<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Fetch进阶指南 | louis blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="fetch async await mode promise progress abort">
<meta property="og:type" content="article">
<meta property="og:title" content="Fetch进阶指南">
<meta property="og:url" content="http://louiszhai.github.io/2016/11/02/fetch/index.html">
<meta property="og:site_name" content="louis blog">
<meta property="og:description" content="fetch async await mode promise progress abort">
<meta property="og:image" content="http://louiszhai.github.io/docImages/ajax07.png">
<meta property="og:image" content="http://louiszhai.github.io/docImages/ajax08.png">
<meta property="og:image" content="http://louiszhai.github.io/docImages/ajax11.png">
<meta property="og:image" content="http://louiszhai.github.io/docImages/ajax09.png">
<meta property="og:image" content="http://louiszhai.github.io/docImages/ajax10.png">
<meta property="og:image" content="http://louiszhai.github.io/docImages/ajax12.png">
<meta property="og:image" content="http://louiszhai.github.io/docImages/ajax13.png">
<meta property="og:image" content="http://louiszhai.github.io/docImages/ajax14.png">
<meta property="og:image" content="http://louiszhai.github.io/docImages/ajax22.png">
<meta property="og:image" content="http://louiszhai.github.io/docImages/ajax15.png">
<meta property="og:image" content="http://louiszhai.github.io/docImages/ajax16.png">
<meta property="og:updated_time" content="2016-11-30T03:15:07.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Fetch进阶指南">
<meta name="twitter:description" content="fetch async await mode promise progress abort">
  
    <link rel="alternative" href="/atom.xml" title="louis blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

<body>
<div id="container">
    <div class="left-col">
        <div class="overlay">
	<!--<input type="text" class="st-default-search-input" style="position:absolute;top: 50px;left: 35px;">-->
</div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="/i.png" class="js-avatar" style="width: 100%;height: 100%;opacity: 1;">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">louis</a></h1>
		</hgroup>

		
		<p class="header-subtitle">程序猿 前端攻城师</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>標籤</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives/">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/Louiszhai" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/xingyez" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/CSS/" style="font-size: 15px;">CSS</a> <a href="/tags/JavaScript/" style="font-size: 20px;">JavaScript</a> <a href="/tags/Web/" style="font-size: 10px;">Web</a> <a href="/tags/XSS/" style="font-size: 10px;">XSS</a> <a href="/tags/css/" style="font-size: 15px;">css</a> <a href="/tags/javascript/" style="font-size: 10px;">javascript</a>
					</div>
				</section>
				
				
				

				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
        <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">louis</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img src="/i.png" class="js-avatar" style="width: 100%;height: 100%;opacity: 1;">
			
			</div>
			<hgroup>
			  <h1 class="header-author">louis</h1>
			</hgroup>
			
			<p class="header-subtitle">程序猿 前端攻城师</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives/">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Louiszhai" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/xingyez" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

        <div class="body-wrap"><article id="post-fetch" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/11/02/fetch/" class="article-date">
  	<time datetime="2016-11-02T04:48:08.000Z" itemprop="datePublished">2016-11-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Fetch进阶指南
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          <span class="toc-arrow"></span>
<div id="toc" class="toc-article">
    <div class="toc-title">目录</div>
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#u5BFC_u8BFB"><span class="toc-text">导读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fetch"><span class="toc-text">Fetch</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#u5C1D_u8BD5_u4E00_u4E2Afetch"><span class="toc-text">尝试一个fetch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Promise_u7279_u6027"><span class="toc-text">Promise特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#response_type"><span class="toc-text">response type</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mode"><span class="toc-text">mode</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#header"><span class="toc-text">header</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#post"><span class="toc-text">post</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#credentials"><span class="toc-text">credentials</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#catch"><span class="toc-text">catch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cache"><span class="toc-text">cache</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#async/await"><span class="toc-text">async/await</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#u4E3A_u4EC0_u4E48_u662Fasync/await"><span class="toc-text">为什么是async/await</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#async/await_u8BED_u6CD5"><span class="toc-text">async/await语法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#u5982_u4F55_u8BD5_u8FD0_u884Casync/await"><span class="toc-text">如何试运行async/await</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u5982_u4F55_u5F25_u8865Fetch_u7684_u4E0D_u8DB3"><span class="toc-text">如何弥补Fetch的不足</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#fetch-jsonp"><span class="toc-text">fetch-jsonp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#abort"><span class="toc-text">abort</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#timeout"><span class="toc-text">timeout</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#progress"><span class="toc-text">progress</span></a></li></ol></li></ol>
</div>
      
        <h3 id="u5BFC_u8BFB"><a href="#u5BFC_u8BFB" class="headerlink" title="导读"></a>导读</h3><p>Fetch 是 web异步通信的未来. 从chrome42, Firefox39, Opera29, EdgeHTML14(并非Edge版本)起, fetch就已经被支持了. 其中chrome42~45版本, fetch对中文支持有问题, 建议从chrome46起使用fetch. 传送门: <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=511289" target="_blank" rel="external">fetch中文乱码</a> .</p>
<a id="more"></a>
<h3 id="Fetch"><a href="#Fetch" class="headerlink" title="Fetch"></a>Fetch</h3><p>先过一遍Fetch原生支持率.</p>
<p><img src="http://louiszhai.github.io/docImages/ajax07.png" alt=""><br><img src="http://louiszhai.github.io/docImages/ajax08.png" alt=""></p>
<p>可见要想在IE8/9/10/11中使用fetch还是有些犯难的,毕竟它连 Promise 都不支持, 更别说fetch了. 别急, 这里有polyfill(垫片). </p>
<ul>
<li>es5 的 polyfill — <a href="https://github.com/es-shims/es5-shim" target="_blank" rel="external"><code>es5-shim, es5-sham</code></a> .</li>
<li>Promise 的 polyfill — <a href="https://github.com/jakearchibald/es6-promise" target="_blank" rel="external"><code>es6-promise</code></a> .</li>
<li>fetch 的 polyfill — <a href="https://github.com/camsong/fetch-ie8" target="_blank" rel="external"><code>fetch-ie8</code></a> .</li>
</ul>
<p>由于IE8基于ES3, IE9支持大部分ES5, IE11支持少量ES5, 其中只有IE10对ES5支持比较完整. 因此IE8+浏览器, 建议依次装载上述垫片.</p>
<h4 id="u5C1D_u8BD5_u4E00_u4E2Afetch"><a href="#u5C1D_u8BD5_u4E00_u4E2Afetch" class="headerlink" title="尝试一个fetch"></a>尝试一个fetch</h4><p>先来看一个简单的fetch.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> word = <span class="string">'123'</span>,</span><br><span class="line">    url = <span class="string">'https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd='</span>+word+<span class="string">'&amp;json=1&amp;p=3'</span>;</span><br><span class="line">fetch(url,&#123;mode: <span class="string">"no-cors"</span>&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> response;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Oops, error"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>fetch执行后返回一个 <code>Promise</code> 对象, 执行成功后, 成功打印出 <code>Response</code> 对象.</p>
<p><img src="http://louiszhai.github.io/docImages/ajax11.png" alt="response headers"></p>
<p>该fetch可以在任何域名的网站直接运行, 且能正常返回百度搜索的建议词条. 以下是常规输入时的是界面截图.</p>
<p><img src="http://louiszhai.github.io/docImages/ajax09.png" alt="response headers"></p>
<p>以下是刚才fetch到的部分数据. 其中key name 为”s”的字段的value就是以上的建议词条.(由于有高亮词条”12306”, 最后一条数据”12366”被顶下去了, 故上面截图上看不到)</p>
<p><img src="http://louiszhai.github.io/docImages/ajax10.png" alt="response headers"></p>
<p>看完栗子过后, 就要动真格了. 下面就来扒下 Fetch.</p>
<h4 id="Promise_u7279_u6027"><a href="#Promise_u7279_u6027" class="headerlink" title="Promise特性"></a>Promise特性</h4><p>fetch方法返回一个Promise对象, 根据 <code>Promise Api</code> 的特性, fetch可以方便地使用then方法将各个处理逻辑串起来, 使用 Promise.resolve() 或 Promise.reject() 方法将分别返会肯定结果的Promise或否定结果的Promise, 从而调用下一个then 或者 catch. 一但then中的语句出现错误, 也将跳到catch中.</p>
<p>Promise若有疑问, 请阅读 <a href="https://www.promisejs.org/" target="_blank" rel="external">Promises</a> .</p>
<p>① 我们不妨在 <a href="https://sp0.baidu.com" target="_blank" rel="external">https://sp0.baidu.com</a> 域名的网页控制台运行以下代码.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> word = <span class="string">'123'</span>,</span><br><span class="line">    url = <span class="string">'https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd='</span>+word+<span class="string">'&amp;json=1&amp;p=3'</span>;</span><br><span class="line">fetch(url).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'第一次进入then...'</span>);</span><br><span class="line">  <span class="keyword">if</span>(response.status&gt;=<span class="number">200</span> &amp;&amp; response.status&lt;<span class="number">300</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Content-Type: '</span> + response.headers.get(<span class="string">'Content-Type'</span>));</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Date: '</span> + response.headers.get(<span class="string">'Date'</span>));</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'status: '</span> + response.status);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'statusText: '</span> + response.statusText);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'type: '</span> + response.type);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'url: '</span> + response.url);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(response);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(response.statusText));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'第二次进入then...'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'抛出的错误如下:'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>运行截图如下:</p>
<p><img src="http://louiszhai.github.io/docImages/ajax12.png" alt="fetch then"></p>
<p>② 我们不妨在非 <a href="https://sp0.baidu.com" target="_blank" rel="external">https://sp0.baidu.com</a> 域名的网页控制台再次运行以上代码.(别忘了给fetch的第二参数传递{mode: “no-cors”})</p>
<p>运行截图如下:</p>
<p><img src="http://louiszhai.github.io/docImages/ajax13.png" alt="fetch catch"></p>
<p>由于第一次进入then分支后, 返回了否定结果的 Promise.reject 对象. 因此代码进入到catch分支, 抛出了错误. 此时, 上述 <code>response.type</code> 为 <code>opaque</code> .</p>
<h4 id="response_type"><a href="#response_type" class="headerlink" title="response type"></a>response type</h4><p>一个fetch请求的响应类型(response.type)为如下三种之一:</p>
<ul>
<li>basic</li>
<li>cors</li>
<li>opaque</li>
</ul>
<p>如上情景①, 同域下, 响应类型为 “basic”.</p>
<p>如上情景②中, 跨域下, 服务器没有返回CORS响应头, 响应类型为 “opaque”. 此时我们几乎不能查看任何有价值的信息, 比如不能查看response, status, url等等等等.</p>
<p><img src="http://louiszhai.github.io/docImages/ajax14.png" alt="fetch type"></p>
<p>同样是跨域下, 如果服务器返回了CORS响应头, 那么响应类型将为 “cors”. 此时响应头中除 <code>Cache-Control</code> , <code>Content-Language</code> , <code>Content-Type</code> , <code>Expores</code> , <code>Last-Modified</code> 和 <code>Progma</code> 之外的字段都不可见.</p>
<p>注意: 无论是同域还是跨域, 以上 fetch 请求都到达了服务器.</p>
<h4 id="mode"><a href="#mode" class="headerlink" title="mode"></a>mode</h4><p>fetch可以设置不同的模式使得请求有效. 模式可在fetch方法的第二个参数对象中定义.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fetch(url, &#123;mode: <span class="string">'cors'</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>可定义的模式如下:</p>
<ul>
<li>same-origin: 表示同域下可请求成功; 反之, 浏览器将拒绝发送本次fetch, 同时抛出错误 “TypeError: Failed to fetch(…)”.</li>
<li>cors: 表示同域和带有CORS响应头的跨域下可请求成功. 其他请求将被拒绝.</li>
<li>cors-with-forced-preflight: 表示在发出请求前, 将执行preflight检查.</li>
<li>no-cors: 常用于跨域请求不带CORS响应头场景, 此时响应类型为 “opaque”.</li>
</ul>
<p>除此之外, 还有两种不太常用的mode类型, 分别是 <code>navigate</code> , <code>websocket</code> , 它们是[HTML标准]9<a href="https://html.spec.whatwg.org/multipage/)中特殊的值" target="_blank" rel="external">https://html.spec.whatwg.org/multipage/)中特殊的值</a>, 这里不做详细介绍.</p>
<h4 id="header"><a href="#header" class="headerlink" title="header"></a>header</h4><p>fetch获取http响应头非常easy. 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fetch(url).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(response.headers.get(<span class="string">'Content-Type'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>设置http请求头也一样简单.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> headers = <span class="keyword">new</span> Headers();</span><br><span class="line">headers.append(<span class="string">"Content-Type"</span>, <span class="string">"text/html"</span>);</span><br><span class="line">fetch(url,&#123;</span><br><span class="line">  headers: headers</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>header的内容也是可以被检索的.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> header = <span class="keyword">new</span> Headers(&#123;</span><br><span class="line">  <span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(header.has(<span class="string">"Content-Type"</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(header.has(<span class="string">"Content-Length"</span>)); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<h4 id="post"><a href="#post" class="headerlink" title="post"></a>post</h4><p>在fetch中发送post请求, 同样可以在fetch方法的第二个参数对象中设置.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> headers = <span class="keyword">new</span> Headers();</span><br><span class="line">headers.append(<span class="string">"Content-Type"</span>, <span class="string">"application/json;charset=UTF-8"</span>);</span><br><span class="line">fetch(url, &#123;</span><br><span class="line">  method: <span class="string">'post'</span>,</span><br><span class="line">  headers: headers,</span><br><span class="line">  body: <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">    date: <span class="string">'2016-10-08'</span>,</span><br><span class="line">    time: <span class="string">'15:16:00'</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="credentials"><a href="#credentials" class="headerlink" title="credentials"></a>credentials</h4><p>跨域请求中需要带有cookie时, 可在fetch方法的第二个参数对象中添加credentials属性, 并将值设置为”include”.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fetch(url,&#123;</span><br><span class="line">  credentials: <span class="string">'include'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>除此之外, credentials 还可以取以下值:</p>
<ul>
<li>omit: 缺省值, 默认为该值.</li>
<li>same-origin: 同源, 表示同域请求才发送cookie.</li>
</ul>
<h4 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h4><p>同 XMLHttpRequest 一样, 无论服务器返回什么样的状态码(chrome中除407之外的其他状态码), 它们都不会进入到错误捕获里. 也就是说, 此时, XMLHttpRequest 实例不会触发 <code>onerror</code> 事件回调, fetch 不会触发 reject. <strong>通常只在网络出现问题时或者ERR_CONNECTION_RESET时, 它们才会进入到相应的错误捕获里.</strong> (其中, 请求返回状态码为407时, chrome浏览器会触发onerror或者reject掉fetch.)</p>
<h4 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h4><p>cache表示如何处理缓存, 遵守http规范, 拥有如下几种值:</p>
<ul>
<li>default: 表示fetch请求之前将检查下http的缓存.</li>
<li>no-store: 表示fetch请求将完全忽略http缓存的存在. 这意味着请求之前将不再检查下http的缓存, 拿到响应后, 它也不会更新http缓存.</li>
<li>no-cache: 如果存在缓存, 那么fetch将发送一个条件查询request和一个正常的request, 拿到响应后, 它会更新http缓存.</li>
<li>reload: 表示fetch请求之前将忽略http缓存的存在, 但是请求拿到响应后, 它将主动更新http缓存.</li>
<li>force-cache: 表示fetch请求不顾一切的依赖缓存, 即使缓存过期了, 它依然从缓存中读取. 除非没有任何缓存, 那么它将发送一个正常的request.</li>
<li>only-if-cached: 表示fetch请求不顾一切的依赖缓存, 即使缓存过期了, 它依然从缓存中读取. 如果没有缓存, 它将抛出网络错误(该设置只在mode为”same-origin”时有效).</li>
</ul>
<p>如果fetch请求的header里包含 <code>If-Modified-Since</code>, <code>If-None-Match</code>, <code>If-Unmodified-Since</code>, <code>If-Match</code>, 或者 <code>If-Range</code> 之一, 且cache的值为 <code>default</code> , 那么fetch将自动把 cache的值设置为 <code>&quot;no-store&quot;</code> .</p>
<h4 id="async/await"><a href="#async/await" class="headerlink" title="async/await"></a>async/await</h4><h5 id="u4E3A_u4EC0_u4E48_u662Fasync/await"><a href="#u4E3A_u4EC0_u4E48_u662Fasync/await" class="headerlink" title="为什么是async/await"></a>为什么是async/await</h5><p>回调深渊一直是jser的一块心病, 虽然ES6提供了 Promise, 将嵌套平铺, 但使用起来依然不便. </p>
<p>要说ES6也提供了generator/yield, 它将一个函数执行暂停, 保存上下文, 再次调用时恢复当时的状态.(学习可参考 <a href="http://www.ruanyifeng.com/blog/2015/04/generator.html" target="_blank" rel="external">Generator 函数的含义与用法 - 阮一峰的网络日志</a>) 无论如何, 总感觉别扭. 如下摘自推库的一张图.</p>
<p><img src="http://louiszhai.github.io/docImages/ajax22.png" alt=""></p>
<p>我们不难看出其中的差距, callback简单粗暴, 层层回调, 回调越深入, 越不容易捋清楚逻辑. Promise 将异步操作规范化.使用then连接, 使用catch捕获错误, 堪称完美, 美中不足的是, then和catch中传递的依然是回调函数, 与心目中的同步代码不是一个套路.</p>
<p>为此, ES7 提供了更标准的解决方案 — async/await. async/await 几乎没有引入新的语法, 表面上看起来, 它就和alert一样易用,  虽然它尚处于ES7的草案中, 不过这并不影响我们提前使用它.</p>
<h5 id="async/await_u8BED_u6CD5"><a href="#async/await_u8BED_u6CD5" class="headerlink" title="async/await语法"></a>async/await语法</h5><p>async 用于声明一个异步函数, 该函数需返回一个 Promise 对象. 而 await 通常后接一个 Promise对象, 需等待该 Promise 对象的 resolve() 方法执行并且返回值后才能继续执行. (如果await后接的是其他对象, 便会立即执行)</p>
<p>因此, async/await 天生可用于处理 fetch请求(毫无违和感). 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> word = <span class="string">'123'</span>,</span><br><span class="line">    url = <span class="string">'https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd='</span>+word+<span class="string">'&amp;json=1&amp;p=3'</span>;</span><br><span class="line">(<span class="keyword">async</span> ()=&gt;&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="keyword">await</span> fetch(url, &#123;mode: <span class="string">'no-cors'</span>&#125;);<span class="comment">//等待fetch被resolve()后才能继续执行</span></span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>自然, async/await 也可处理 Promise 对象.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> wait = <span class="function"><span class="keyword">function</span>(<span class="params">ts</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    setTimeout(resolve,ts,<span class="string">'Copy that!'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="keyword">await</span> wait(<span class="number">1000</span>);<span class="comment">//① 等待1s后返回结果</span></span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">    res = <span class="keyword">await</span> wait(<span class="number">1000</span>);<span class="comment">//② 重复执行一次</span></span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">//"Copy that!"</span></span><br></pre></td></tr></table></figure>
<p>可见使用await后, 可以直接得到返回值, 不必写 <code>.then(callback)</code> , 也不必写 <code>.catch(error)</code> 了, 更可以使用 <code>try catch</code> 标准语法捕获错误.</p>
<p>由于await采用的是同步的写法, 看起来它就和alert函数一样, 可以自动阻塞上下文. 因此它可以重复执行多次, 就像上述代码②一样.</p>
<p>可以看到, await/async 同步阻塞式的写法解决了完全使用 Promise 的一大痛点——不同Promise之间共享数据问题. Promise 需要设置上层变量从而实现数据共享, 而 await/async 就不存在这样的问题, 只需要像写alert一样书写就可以了.</p>
<p>值得注意的是, <strong>await 只能用于 async 声明的函数上下文中</strong>. 如下 forEach 中, 是不能直接使用await的.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">(<span class="keyword">async</span> ()=&gt;&#123;</span><br><span class="line">  array.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">    <span class="keyword">await</span> wait(<span class="number">1000</span>);<span class="comment">//这是错误的写法</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">//因await只能用于 async 声明的函数上下文中, 故不能写在forEach内.下面我们来看正确的写法</span></span><br><span class="line">(<span class="keyword">async</span> ()=&gt;&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>,len=array.length;i&lt;len;i++)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(array[i]);</span><br><span class="line">    <span class="keyword">await</span> wait(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<h5 id="u5982_u4F55_u8BD5_u8FD0_u884Casync/await"><a href="#u5982_u4F55_u8BD5_u8FD0_u884Casync/await" class="headerlink" title="如何试运行async/await"></a>如何试运行async/await</h5><p>鉴于目前只有Edge支持 async/await, 我们可以使用以下方法之一运行我们的代码.</p>
<ol>
<li><p>随着node7.0的发布, node中可以使用如下方式直接运行:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node --harmony-async-await test.js</span><br></pre></td></tr></table></figure>
</li>
<li><p>babel在线编译并运行 <a href="https://babeljs.io/repl/#?babili=false&amp;evaluate=true&amp;lineWrap=false&amp;presets=es2015%2Creact%2Cstage-2&amp;code=" target="_blank" rel="external">Babel · The compiler for writing next generation JavaScript</a> .</p>
</li>
<li><p>本地使用babel编译es6或更高版本es.</p>
<p>1) 安装.</p>
<p>由于Babel5默认自带各种转换插件, 不需要手动安装. 然而从Babel6开始, 插件需要手动下载, 因此以下安装babel后需要再顺便安装两个插件.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm i babel-cli -g	<span class="comment"># babel已更名为babel-cli</span></span><br><span class="line">npm install babel-preset-es2015 --save-dev</span><br><span class="line">npm install babel-preset-stage-<span class="number">0</span> --save-dev</span><br></pre></td></tr></table></figure>
<p>2) 书写.babelrc配置文件.</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "<span class="attribute">presets</span>": <span class="value">[</span><br><span class="line">        <span class="string">"es2015"</span>,</span><br><span class="line">        <span class="string">"stage-0"</span></span><br><span class="line">    ]</span>,</span><br><span class="line">    "<span class="attribute">plugins</span>": <span class="value">[]</span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<p>3) 如果不配置.babelrc. 也可在命令行显式指定插件.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">babel es6.js -o es5.js --presets es2015 stage-<span class="number">0</span> <span class="comment"># 指定使用插件es2015和stage-0编译js</span></span><br></pre></td></tr></table></figure>
<p>4) 编译.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">babel es6.js -o es5.js  <span class="comment"># 编译源文件es6.js,输出为es5.js,编译规则在上述.babelrc中指定</span></span><br><span class="line">babel es6.js --out-file es5.js <span class="comment"># 或者将-o写全为--out-file也行</span></span><br><span class="line">bable es6.js <span class="comment"># 如果不指定输出文件路径,babel会将编译生成的文本标准输出到控制台</span></span><br></pre></td></tr></table></figure>
<p>5) 实时编译</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">babel es6.js -w -o es5.js <span class="comment"># 实时watch es6.js的变化,一旦改变就重新编译</span></span><br><span class="line">babel es6.js -watch -o es5.js <span class="comment"># -w也可写全为--watch</span></span><br></pre></td></tr></table></figure>
<p>6) 编译目录输出到其他目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">babel src <span class="operator">-d</span> build <span class="comment"># 编译src目录下所有js,并输出到build目录</span></span><br><span class="line">babel src --out-dir build <span class="comment"># -d也可写全为--out-dir</span></span><br></pre></td></tr></table></figure>
<p>7) 编译目录输出到单个文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">babel src -o es5.js <span class="comment"># 编译src目录所有js,合并输出为es5.js</span></span><br></pre></td></tr></table></figure>
<p>8) 想要直接运行es6.js, 可使用babel-node.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i babel-node -g <span class="comment"># 全局安装babel-node</span></span><br><span class="line">babel-node es6.js <span class="comment"># 直接运行js文件</span></span><br></pre></td></tr></table></figure>
<p>9) 如需在代码中使用fetch, 且使用babel-node运行, 需引入 <code>node-fetch</code> 模块.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i node-fetch --save-dev</span><br></pre></td></tr></table></figure>
<p>然后在es6.js中require <code>node-fetch</code> 模块.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fetch = <span class="built_in">require</span>(<span class="string">'node-fetch'</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>本地使用traceur编译es6或更高版本es.请参考 <a href="http://www.codesec.net/view/450316.html" target="_blank" rel="external">在项目开发中优雅地使用ES6：Traceur &amp; Babel</a> .</p>
</li>
</ol>
<h3 id="u5982_u4F55_u5F25_u8865Fetch_u7684_u4E0D_u8DB3"><a href="#u5982_u4F55_u5F25_u8865Fetch_u7684_u4E0D_u8DB3" class="headerlink" title="如何弥补Fetch的不足"></a>如何弥补Fetch的不足</h3><p>fetch基于Promise, Promise受限, fetch也难幸免. ES6的Promise基于 <a href="https://promisesaplus.com/" target="_blank" rel="external">Promises/A+</a> 规范 (对规范感兴趣的同学可选读 <a href="http://www.cnblogs.com/fsjohnhuang/p/4135149.html" target="_blank" rel="external">剖析源码理解Promises/A规范</a> ), 它只提供极简的api, 没有 timeout 机制, 没有 progress 提示, 没有 deferred 处理 (这个可以被async/await替代).</p>
<h4 id="fetch-jsonp"><a href="#fetch-jsonp" class="headerlink" title="fetch-jsonp"></a>fetch-jsonp</h4><p>除此之外, fetch还不支持jsonp请求. 不过办法总比问题多, 万能的开源作者提供了 <a href="https://github.com/camsong/fetch-jsonp" target="_blank" rel="external"><code>fetch-jsonp</code></a> 库, 解决了这个问题. </p>
<p><code>fetch-jsonp</code> 使用起来非常简单. 如下是安装:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install fetch-jsonp --save-dev</span><br></pre></td></tr></table></figure>
<p>如下是使用:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fetchJsonp(url, &#123;</span><br><span class="line">  timeout: <span class="number">3000</span>,</span><br><span class="line">  jsonpCallback: <span class="string">'callback'</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(response.json());</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="abort"><a href="#abort" class="headerlink" title="abort"></a>abort</h4><p>由于Promise的限制, fetch 并不支持原生的abort机制, 但这并不妨碍我们使用 Promise.race() 实现一个.</p>
<blockquote>
<p>Promise.race(iterable) 方法返回一个Promise对象, 只要 iterable 中任意一个Promise 被 resolve 或者 reject 后, 外部的Promise 就会以相同的值被 resolve 或者 reject.</p>
</blockquote>
<p>支持性: 从 chrome33, Firefox29, Safari7.1, Opera20, EdgeHTML12(并非Edge版本) 起, Promise就被完整的支持. Promise.race()也随之可用. 下面我们来看下实现.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _fetch = (<span class="function"><span class="keyword">function</span>(<span class="params">fetch</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">url,options</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> abort = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">var</span> abort_promise = <span class="keyword">new</span> <span class="built_in">Promise</span>((resolve, reject)=&gt;&#123;</span><br><span class="line">      abort = () =&gt; &#123;</span><br><span class="line">        reject(<span class="string">'abort.'</span>);</span><br><span class="line">        <span class="built_in">console</span>.info(<span class="string">'abort done.'</span>);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">var</span> promise = <span class="built_in">Promise</span>.race([</span><br><span class="line">      fetch(url,options),</span><br><span class="line">      abort_promise</span><br><span class="line">    ]);</span><br><span class="line">    promise.abort = abort;</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)(fetch);</span><br></pre></td></tr></table></figure>
<p>然后, 使用如下方法测试新的fetch.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = _fetch(<span class="string">'https://www.baidu.com'</span>,&#123;mode:<span class="string">'no-cors'</span>&#125;);</span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'response:'</span>, res);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'error:'</span>, e);</span><br><span class="line">&#125;);</span><br><span class="line">p.abort();</span><br><span class="line"><span class="comment">//"abort done."</span></span><br><span class="line"><span class="comment">//"error: abort."</span></span><br></pre></td></tr></table></figure>
<p>以上, fetch请求后, 立即调用abort方法, 该promise被拒绝, 符合预期. 细心的同学可能已经注意到了, “p.abort();” 该语句我是单独写一行的, 没有链式写在then方法之后. 为什么这么干呢? 这是因为then方法调用后, 返回的是新的promise对象. 该对象不具有abort方法, 因此使用时要注意绕开这个坑.</p>
<h4 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h4><p>同上, 由于Promise的限制, fetch 并不支持原生的timeout机制, 但这并不妨碍我们使用 Promise.race() 实现一个.</p>
<p>下面是一个简易的版本.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params">t</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(resolve=&gt;setTimeout(resolve, t))</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timeout'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = fetch(<span class="string">'https://www.baidu.com'</span>,&#123;mode:<span class="string">'no-cors'</span>&#125;);</span><br><span class="line"><span class="built_in">Promise</span>.race([p, timer(<span class="number">1000</span>)]);</span><br><span class="line"><span class="comment">//"timeout"</span></span><br></pre></td></tr></table></figure>
<p>实际上, 无论超时时间设置为多长, 控制台都将输出log “timeout”. 这是因为, 即使fetch执行成功, 外部的promise执行完毕, 此时 setTimeout 所在的那个promise也不会reject.</p>
<p>下面我们来看一个类似xhr版本的timeout.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _fetch = (<span class="function"><span class="keyword">function</span>(<span class="params">fetch</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">url,options</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> abort = <span class="literal">null</span>,</span><br><span class="line">        timeout = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> abort_promise = <span class="keyword">new</span> <span class="built_in">Promise</span>((resolve, reject)=&gt;&#123;</span><br><span class="line">      abort = () =&gt; &#123;</span><br><span class="line">        reject(<span class="string">'timeout.'</span>);</span><br><span class="line">        <span class="built_in">console</span>.info(<span class="string">'abort done.'</span>);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">var</span> promise = <span class="built_in">Promise</span>.race([</span><br><span class="line">      fetch(url,options),</span><br><span class="line">      abort_promise</span><br><span class="line">    ]);</span><br><span class="line">    promise.abort = abort;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(promise, <span class="string">'timeout'</span>,&#123;</span><br><span class="line">      set: <span class="function"><span class="keyword">function</span>(<span class="params">ts</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((ts=+ts))&#123;</span><br><span class="line">          timeout = ts;</span><br><span class="line">          setTimeout(abort,ts);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> timeout;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)(fetch);</span><br></pre></td></tr></table></figure>
<p>然后, 使用如下方法测试新的fetch.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = _fetch(<span class="string">'https://www.baidu.com'</span>,&#123;mode:<span class="string">'no-cors'</span>&#125;);</span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'response:'</span>, res);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'error:'</span>, e);</span><br><span class="line">&#125;);</span><br><span class="line">p.timeout = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//"abort done."</span></span><br><span class="line"><span class="comment">//"error: timeout."</span></span><br></pre></td></tr></table></figure>
<h4 id="progress"><a href="#progress" class="headerlink" title="progress"></a>progress</h4><p>xhr的 onprogress 让我们可以掌控下载进度, fetch显然没有提供原生api 做类似的事情. 不过 Fetch中的<code>Response.body</code> 中实现了<code>getReader()</code>方法用于读取原始字节流, 该字节流可以循环读取, 直到body下载完成. 因此我们完全可以模拟fetch的progress.</p>
<p>以下是 stackoverflow 上的一段代码, 用于模拟fetch的progress事件. 为了方便测试, 请求url已改为本地服务.(原文请戳 <a href="http://stackoverflow.com/questions/35711724/progress-indicators-for-fetch" target="_blank" rel="external">javascript - Progress indicators for fetch? - Stack Overflow</a>)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">consume</span>(<span class="params">reader</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> total = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>((resolve, reject) =&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">pump</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      reader.read().then((&#123;done, value&#125;) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (done) &#123;</span><br><span class="line">          resolve();</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        total += value.byteLength;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`received <span class="subst">$&#123;value.byteLength&#125;</span> bytes (<span class="subst">$&#123;total&#125;</span> bytes in total)`</span>);</span><br><span class="line">        pump();</span><br><span class="line">      &#125;).catch(reject)</span><br><span class="line">    &#125;</span><br><span class="line">    pump();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">fetch(<span class="string">'http://localhost:10101/notification/'</span>,&#123;mode:<span class="string">'no-cors'</span>&#125;)</span><br><span class="line">  .then(res =&gt; consume(res.body.getReader()))</span><br><span class="line">  .then(() =&gt; <span class="built_in">console</span>.log(<span class="string">"consumed the entire body without keeping the whole thing in memory!"</span>))</span><br><span class="line">  .catch(e =&gt; <span class="built_in">console</span>.log(<span class="string">"something went wrong: "</span> + e));</span><br></pre></td></tr></table></figure>
<p>以下是日志截图:</p>
<p><img src="http://louiszhai.github.io/docImages/ajax15.png" alt=""></p>
<p>刚好github上有个fetch progress的demo, 感兴趣的小伙伴请参看这里: <a href="https://labs.jxck.io/fetch/progress.html" target="_blank" rel="external">Fetch Progress DEMO</a> .</p>
<p>我们不妨来对比下, 使用xhr的onprogress事件回调, 输出如下:</p>
<p><img src="http://louiszhai.github.io/docImages/ajax16.png" alt=""></p>
<p>我试着适当增加响应body的size, 发现xhr的onprogress事件回调依然只执行两次. 通过多次测试发现其执行频率比较低, 远不及fetch progress.</p>
<hr>
<p>本问就讨论这么多内容,大家有什么问题或好的想法欢迎在下方参与<a href="#respond">留言和评论</a>.</p>
<p>本文作者: <a href="https://github.com/Louiszhai" target="_blank" rel="external">louis</a></p>
<p>本文链接: <a href="http://louiszhai.github.io/2016/10/19/fetch/">http://louiszhai.github.io/2016/10/19/fetch/</a></p>
<p>参考文章</p>
<ul>
<li><a href="https://fetch.spec.whatwg.org/#forbidden-header-name" target="_blank" rel="external">Fetch Standard</a></li>
<li><a href="https://segmentfault.com/a/1190000003810652" target="_blank" rel="external">传统 Ajax 已死，Fetch 永生 - 会影 - SegmentFault</a></li>
<li><a href="https://cnodejs.org/topic/5640b80d3a6aa72c5e0030b6" target="_blank" rel="external">体验异步的终极解决方案-ES7的Async/Await - CNode技术社区</a></li>
<li><a href="https://tc39.github.io/ecma262/#sec-promise-constructor" target="_blank" rel="external">ES6-Promise</a></li>
<li><a href="http://www.tuicool.com/articles/QZBJ7zJ" target="_blank" rel="external">译-JavaScript Fetch API - 推酷</a></li>
<li><a href="http://imweb.io/topic/57c6ea35808fd2fb204eef63" target="_blank" rel="external">让fetch也可以timeout - 腾讯Web前端 IMWeb 团队社区 | blog | 团队博客</a></li>
</ul>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/11/02/ajax/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          Ajax知识体系
        
      </div>
    </a>
  
  
    <a href="/2016/07/01/Math/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">全面解读Math对象及位运算</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">Share to: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
    <a class="jiathis_button_twitter"></a>
    <a class="jiathis_button_plus"></a> 
    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>






<div class="duoshuo">
	<div class="ds-thread" data-thread-key="fetch" data-title="Fetch进阶指南" data-url="http://louiszhai.github.io/2016/11/02/fetch/"></div>
	<style>
		#ds-reset .ds-avatar img{width:54px;height:54px;border-radius:27px;-webkit-border-radius:27px;-moz-border-radius:27px;box-shadow:inset 0 -1px 0 #3333sf;-webkit-box-shadow:inset 0 -1px 0 #3333sf;-webkit-transition:0.4s;-webkit-transition:-webkit-transform 0.4s ease-out;transition:transform 0.4s ease-out;-moz-transition:-moz-transform 0.4s ease-out;}
		#ds-reset .ds-avatar img:hover{box-shadow:0 0 10px #fff;rgba(255,255,255,.6),inset 0 0 20px rgba(255,255,255,1);-webkit-box-shadow:0 0 10px #fff;rgba(255,255,255,.6),inset 0 0 20px rgba(255,255,255,1);transform:rotateZ(360deg);-webkit-transform:rotateZ(360deg);-moz-transform:rotateZ(360deg);}
		p.ds-powered-by,#ds-sync-checkbox,.ds-sync label{display:none!important;}
		#ds-reset .ds-rounded-top{-webkit-border-top-right-radius:0px;-webkit-border-top-left-radius:0px;border-top-right-radius:0px;border-top-left-radius:0px;}
		#ds-thread #ds-reset .ds-textarea-wrapper{background:#fff;border:0;margin-bottom:20px;padding-right:0px;}
		#ds-thread #ds-reset .ds-textarea-wrapper textarea{min-height:80px;border:1px solid #ccc;padding:10px;-webkit-appearance:none;border-radius:0;background-color:#FFFFFF;border-color:#cccccc;box-shadow:inset 0 1px 2px rgba(0,0,0,0.1);color:rgba(0,0,0,0.75);-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-transition:border-color 0.15s linear,background 0.15s linear;-moz-transition:border-color 0.15s linear,background 0.15s linear;-ms-transition:border-color 0.15s linear,background 0.15s linear;-o-transition:border-color 0.15s linear,background 0.15s linear;transition:border-color 0.15s linear,background 0.15s linear;}
		/*#ds-thread #ds-reset .ds-textarea-wrapper textarea:focus{border-color:#999999;background:#fafafa;outline:none;}*/
		#ds-thread #ds-reset .ds-post-options{border-bottom-left-radius:0px;-webkit-border-bottom-left-radius:0px;border:none;background:none!important;}
		#ds-reset .ds-textarea-wrapper textarea:focus{border-color:#66afe9;outline:0;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 8px rgba(102,175,233,.6);box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 8px rgba(102,175,233,.6);}
		#ds-thread #ds-reset .ds-post-button:hover,#ds-thread #ds-reset .ds-post-button:focus{
		    background-color: #51a351;
		    background-position: 0 -32px;
		    color:white;
		}
		#ds-thread #ds-reset .ds-post-toolbar,#ds-reset .ds-avatar{box-shadow:none;}
		#ds-thread #ds-reset .ds-textarea-wrapper textarea:focus{
	    	/*background: none repeat scroll 0 0 #F4FAFF;*/
	    	border-color:#9DD4FD;
	    	border-width:1px;
	    	box-shadow:0 1px 1px rgba(0,0,0,0.075) inset, 0 0 8px rgba(82, 168, 236, 0.6);
	    	outline:0 none;
    	}
		#ds-thread #ds-reset .ds-textarea-wrapper textarea:active{
	    	/*background: none repeat scroll 0 0 #F4FAFF;*/
	    	border-width:1px;
	    	border-color:#9DD4FD;
	    	box-shadow:0 1px 1px rgba(0,0,0,0.075) inset, 0 0 8px rgba(82, 168, 236, 0.6);
	    	outline:0 none;
    	}
    	#ds-thread #ds-reset .ds-post-button{
    		box-shadow: 0 1px 0 rgba(255, 255, 255, 0.2) inset, 0 1px 2px rgba(0, 0, 0, 0.05);
		    border-color: rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.25);
		    border-width: 1px;
		    border-style: solid;
		    border-radius: 3px;
		    background: #5bb75b;
		    color:white;
		    text-shadow:none;
		    transition:background-color 300ms ease-out;
    	}
    	#ds-reset .ds-avatar{
    		background-color:initial;
    	}

	</style>
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"true"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
</div>



</div>
        <link rel="stylesheet" href="/css/content.css" type="text/css">
<footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <img src="/img/top_arrow.png" class="top_arrow" id="top_arrow">
    	<div class="footer-left">
    		&copy; 2016 louis

        <span style="position:relative;top:2px" id="cnzz_stat_icon_1256923583"></span>
        <script type="text/javascript">
          var s = document.createElement('script');
          var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");
          s.src = cnzz_protocol + "s11.cnzz.com/z_stat.php?id=1256923583&show=pic";
          document.body.appendChild(s);
        </script>

    	</div>
      	<div class="footer-right">
      		<a href="https://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
<script type="text/javascript">
  //swifty
  /*(function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');
  
  _st('install','4AmBuvmx4Cy-3hvyxeh8','2.0.0');*/
</script>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: false,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="/js/jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>
<script src="/js/content.js" type="text/javascript"></script>







</div>
<script src="/js/screenfull.js" type="text/javascript"></script>
<a href="https://github.com/Louiszhai" style="position: fixed; top: 0; right: 0; border: 0;z-index:9999"><img
            source="https://camo.githubusercontent.com/a6677b08c955af8400f44c6298f40e7d19cc5b2d/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f677261795f3664366436642e706e67"
            src="/img/fork_me_on_github.png" alt="Fork me on GitHub"
            data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_gray_6d6d6d.png"></a>
</body>
</html>