<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>捋一捋JS的数组 | louis blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="JavaScript Array isArray map filter forEach every some push shift unshift sort indexOf">
<meta property="og:type" content="article">
<meta property="og:title" content="捋一捋JS的数组">
<meta property="og:url" content="http://louiszhai.github.io/2015/12/29/array/index.html">
<meta property="og:site_name" content="louis blog">
<meta property="og:description" content="JavaScript Array isArray map filter forEach every some push shift unshift sort indexOf">
<meta property="og:updated_time" content="2016-08-04T01:01:59.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="捋一捋JS的数组">
<meta name="twitter:description" content="JavaScript Array isArray map filter forEach every some push shift unshift sort indexOf">
  
    <link rel="alternative" href="/atom.xml" title="louis blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay">
	<!--<input type="text" class="st-default-search-input" style="position:absolute;top: 50px;left: 35px;">-->
</div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img id="animated" src="/i.png" class="js-avatar" style="width: 100%;height: 100%;opacity: 1;">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">louis</a></h1>
		</hgroup>

		
		<p class="header-subtitle">程序猿 前端攻城师</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>標籤</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives/">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/Louiszhai" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/xingyez" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/CSS/" style="font-size: 15px;">CSS</a> <a href="/tags/JavaScript/" style="font-size: 20px;">JavaScript</a> <a href="/tags/XSS/" style="font-size: 10px;">XSS</a> <a href="/tags/css/" style="font-size: 15px;">css</a>
					</div>
				</section>
				
				
				

				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">louis</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img src="/i.png" class="js-avatar" style="width: 100%;height: 100%;opacity: 1;">
			
			</div>
			<hgroup>
			  <h1 class="header-author">louis</h1>
			</hgroup>
			
			<p class="header-subtitle">程序猿 前端攻城师</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives/">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Louiszhai" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/xingyez" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-array" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/29/array/" class="article-date">
  	<time datetime="2015-12-29T01:00:17.000Z" itemprop="datePublished">2015-12-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      捋一捋JS的数组
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          <span class="toc-arrow"></span>
<div id="toc" class="toc-article">
    <div class="toc-title">目录</div>
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#u5BFC_u8BFB"><span class="toc-text">导读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u539F_u578B"><span class="toc-text">原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u65B9_u6CD5"><span class="toc-text">方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#u6539_u53D8_u81EA_u8EAB_u503C_u7684_u65B9_u6CD5_289_u4E2A_29"><span class="toc-text">改变自身值的方法(9个)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#pop"><span class="toc-text">pop</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#push"><span class="toc-text">push</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#reverse"><span class="toc-text">reverse</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#shift"><span class="toc-text">shift</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sort"><span class="toc-text">sort</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#u4F7F_u7528_u6620_u5C04_u6539_u5584_u6392_u5E8F"><span class="toc-text">使用映射改善排序</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#u5947_u602A_u7684chrome"><span class="toc-text">奇怪的chrome</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#u95EE_u9898_u5206_u6790"><span class="toc-text">问题分析</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#splice"><span class="toc-text">splice</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#unshift"><span class="toc-text">unshift</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#copyWithin"><span class="toc-text">copyWithin</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#fill"><span class="toc-text">fill</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#u4E0D_u4F1A_u6539_u53D8_u81EA_u8EAB_u7684_u65B9_u6CD5_289_u4E2A_29"><span class="toc-text">不会改变自身的方法(9个)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#concat"><span class="toc-text">concat</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#join"><span class="toc-text">join</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#slice"><span class="toc-text">slice</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#toString-NaN"><span class="toc-text">toString</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#toLocaleString-NaN"><span class="toc-text">toLocaleString</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#indexOf"><span class="toc-text">indexOf</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#lastIndexOf"><span class="toc-text">lastIndexOf</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#includes_28ES6_29"><span class="toc-text">includes(ES6)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#startsWith"><span class="toc-text">startsWith</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#endsWith"><span class="toc-text">endsWith</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#toSource"><span class="toc-text">toSource</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#u904D_u5386_u65B9_u6CD5_2812_u4E2A_29"><span class="toc-text">遍历方法(12个)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#forEach"><span class="toc-text">forEach</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#every"><span class="toc-text">every</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#some"><span class="toc-text">some</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#filter"><span class="toc-text">filter</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#map"><span class="toc-text">map</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#reduce"><span class="toc-text">reduce</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#reduceRight"><span class="toc-text">reduceRight</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#entries_28ES6_29"><span class="toc-text">entries(ES6)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#find_26amp_3BfindIndex_28ES6_29"><span class="toc-text">find&findIndex(ES6)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#keys_28ES6_29"><span class="toc-text">keys(ES6)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#values_28ES6_29"><span class="toc-text">values(ES6)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Symbol-iterator_28ES6_29"><span class="toc-text">Symbol.iterator(ES6)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u603B_u7ED3"><span class="toc-text">总结</span></a></li></ol>
</div>
      
        <h3 id="u5BFC_u8BFB"><a href="#u5BFC_u8BFB" class="headerlink" title="导读"></a>导读</h3><p>数组是一种非常重要的数据类型, 它语法简单, 灵活,高效, 在多数编程语言中, 数组都充当着至关重要的角色, 以至于很难想象没有数组的编程语言会是什么样子. 这期我们就来侃侃JavaScript的数组, 趴趴它的那点破事儿. 这篇博客从2015年写到了2016年, 权当是跨年的总结吧, 祝大家新年快乐, 2016更好, 未来更好!</p>
<a id="more"></a>
<p>声明: 以下未特别标明的方法均为ES5已实现的方法.</p>
<h3 id="u539F_u578B"><a href="#u539F_u578B" class="headerlink" title="原型"></a>原型</h3><p>js中所有的数组方法均来自于Array.prototype, 和其他构造函数一样, 你可以通过扩展 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Array" target="_blank" rel="external"><code>Array</code></a> 的 <code>prototype</code> 属性上的方法来给所有数组实例增加方法.</p>
<p>值得一说的是, Array.prototype本身就是一个数组.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.isArray(<span class="built_in">Array</span>.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.length);<span class="comment">//0</span></span><br></pre></td></tr></table></figure>
<p>很明显, 数组的原型是一个空数组, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log([].__proto__.length);<span class="comment">//0</span></span><br><span class="line"><span class="built_in">console</span>.log([].__proto__);<span class="comment">//[Symbol(Symbol.unscopables): Object]</span></span><br></pre></td></tr></table></figure>
<p>有关Symbol(Symbol.unscopables)的知识, 这里不做详述, 具体请移步后续章节.</p>
<h3 id="u65B9_u6CD5"><a href="#u65B9_u6CD5" class="headerlink" title="方法"></a>方法</h3><p>Array.prototype的方法包含三种, 一种是会改变自身值的, 一种是不会改变自身值的, 另外一种是遍历方法.</p>
<p>由于 Array.prototype 的某些属性被设置为[[DontEnum]], 因此不能用一般的方法进行遍历, 我们可以通过如下方式获取 Array.prototype 的所有方法:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(<span class="built_in">Array</span>.prototype);<span class="comment">//["length", "constructor", "toString", "toLocaleString", "join", "pop", "push", "reverse", "shift", "unshift", "slice", "splice", "sort", "filter", "forEach", "some", "every", "map", "indexOf", "lastIndexOf", "reduce", "reduceRight", "copyWithin", "find", "findIndex", "fill", "includes", "entries", "keys", "concat"]</span></span><br></pre></td></tr></table></figure>
<h4 id="u6539_u53D8_u81EA_u8EAB_u503C_u7684_u65B9_u6CD5_289_u4E2A_29"><a href="#u6539_u53D8_u81EA_u8EAB_u503C_u7684_u65B9_u6CD5_289_u4E2A_29" class="headerlink" title="改变自身值的方法(9个)"></a>改变自身值的方法(9个)</h4><p>基于ES6, 改变自身值的方法一共有9个, 分别为pop, push, reverse, shift, sort, splice, unshift, 以及两个ES6新增的方法copyWithin, fill.</p>
<h5 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h5><p>pop() 方法删除一个数组中的最后的一个元素，并且返回这个元素.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">"cat"</span>, <span class="string">"dog"</span>, <span class="string">"cow"</span>, <span class="string">"chicken"</span>, <span class="string">"mouse"</span>];</span><br><span class="line"><span class="keyword">var</span> item = array.pop();</span><br><span class="line"><span class="built_in">console</span>.log(array);<span class="comment">//["cat", "dog", "cow", "chicken"]</span></span><br><span class="line"><span class="built_in">console</span>.log(item);<span class="comment">//mouse</span></span><br></pre></td></tr></table></figure>
<p>由于设计上的巧妙, pop方法可以应用在类数组对象上, 即 <code>鸭式辨型</code>. 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="string">"cat"</span>, <span class="number">1</span>:<span class="string">"dog"</span>, <span class="number">2</span>:<span class="string">"cow"</span>, <span class="number">3</span>:<span class="string">"chicken"</span>, <span class="number">4</span>:<span class="string">"mouse"</span>, length:<span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">var</span> item = <span class="built_in">Array</span>.prototype.pop.call(o);</span><br><span class="line"><span class="built_in">console</span>.log(array);<span class="comment">//Object &#123;0: "cat", 1: "dog", 2: "cow", 3: "chicken", length: 4&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(item);<span class="comment">//mouse</span></span><br></pre></td></tr></table></figure>
<p>但如果类数组对象不具有length属性, 那么该对象将被创建length属性, length值为0, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="string">"cat"</span>, <span class="number">1</span>:<span class="string">"dog"</span>, <span class="number">2</span>:<span class="string">"cow"</span>, <span class="number">3</span>:<span class="string">"chicken"</span>, <span class="number">4</span>:<span class="string">"mouse"</span>&#125;</span><br><span class="line"><span class="keyword">var</span> item = <span class="built_in">Array</span>.prototype.pop.call(o);</span><br><span class="line"><span class="built_in">console</span>.log(array);<span class="comment">//Object &#123;0: "cat", 1: "dog", 2: "cow", 3: "chicken", 4: "mouse", length: 0&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(item);<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<h5 id="push"><a href="#push" class="headerlink" title="push"></a>push</h5><p>push()方法添加一个或者多个元素到数组末尾, 并且返回数组新的长度.</p>
<p>语法: arr.push(element1, …, elementN)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">"football"</span>, <span class="string">"basketball"</span>, <span class="string">"volleyball"</span>, <span class="string">"Table tennis"</span>, <span class="string">"badminton"</span>];</span><br><span class="line"><span class="keyword">var</span> i = array.push(<span class="string">"golfball"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(array);<span class="comment">//["football", "basketball", "volleyball", "Table tennis", "badminton", "golfball"]</span></span><br><span class="line"><span class="built_in">console</span>.log(i);<span class="comment">//6</span></span><br></pre></td></tr></table></figure>
<p>同pop方法一样, push方法也可以应用到类数组对象上, 如果length不能被转成一个数值或者不存在length属性时, 则插入的元素索引为0, 且length属性不存在时, 将会创建它.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="string">"football"</span>, <span class="number">1</span>:<span class="string">"basketball"</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> i = <span class="built_in">Array</span>.prototype.push.call(o, <span class="string">"golfball"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(o);<span class="comment">//Object &#123;0: "golfball", 1: "basketball", length: 1&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(i);<span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<p>实际上, push方法是根据length属性来决定从哪里开始插入给定的值.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="string">"football"</span>, <span class="number">1</span>:<span class="string">"basketball"</span>,length:<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> i = <span class="built_in">Array</span>.prototype.push.call(o,<span class="string">"golfball"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(o);<span class="comment">//Object &#123;0: "football", 1: "golfball", length: 2&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(i);<span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>利用push根据length属性插入元素这个特点, 可以实现数组的合并, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">"football"</span>, <span class="string">"basketball"</span>];</span><br><span class="line"><span class="keyword">var</span> array2 = [<span class="string">"volleyball"</span>, <span class="string">"golfball"</span>];</span><br><span class="line"><span class="keyword">var</span> i = <span class="built_in">Array</span>.prototype.push.apply(array,array2);</span><br><span class="line"><span class="built_in">console</span>.log(array);<span class="comment">//["football", "basketball", "volleyball", "golfball"]</span></span><br><span class="line"><span class="built_in">console</span>.log(i);<span class="comment">//4</span></span><br></pre></td></tr></table></figure>
<h5 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h5><p>reverse()方法颠倒数组中元素的位置, 第一个会成为最后一个, 最后一个会成为第一个, 该方法返回对数组的引用.</p>
<p>语法:arr.reverse()</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> array2 = array.reverse();</span><br><span class="line"><span class="built_in">console</span>.log(array);<span class="comment">//[5,4,3,2,1]</span></span><br><span class="line"><span class="built_in">console</span>.log(array2===array);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>同上, reverse 也是鸭式辨型的受益者, 颠倒元素的范围受length属性制约, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="string">"a"</span>, <span class="number">1</span>:<span class="string">"b"</span>, <span class="number">2</span>:<span class="string">"c"</span>, length:<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="built_in">Array</span>.prototype.reverse.call(o);</span><br><span class="line"><span class="built_in">console</span>.log(o);<span class="comment">//Object &#123;0: "b", 1: "a", 2: "c", length: 2&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(o === o2);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>如果 length 属性小于2 或者 length 属性不为数值, 那么原类数组对象将没有变化. 即使 length 属性不存在, 该对象也不会去创建 length 属性. 特别的是, 当 length 属性较大时, 类数组对象的”索引”会尽可能的向 length 看齐. 如下: </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="string">"a"</span>, <span class="number">1</span>:<span class="string">"b"</span>, <span class="number">2</span>:<span class="string">"c"</span>,length:<span class="number">100</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="built_in">Array</span>.prototype.reverse.call(o);</span><br><span class="line"><span class="built_in">console</span>.log(o);<span class="comment">//Object &#123;97: "c", 98: "b", 99: "a", length: 100&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(o === o2);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<h5 id="shift"><a href="#shift" class="headerlink" title="shift"></a>shift</h5><p>shift()方法删除数组的第一个元素, 并返回这个元素.</p>
<p>语法: arr.shift()</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> item = array.shift();</span><br><span class="line"><span class="built_in">console</span>.log(array);<span class="comment">//[2,3,4,5]</span></span><br><span class="line"><span class="built_in">console</span>.log(item);<span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<p>同样受益于鸭式辨型, 对于类数组对象, shift仍然能够处理, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="string">"a"</span>, <span class="number">1</span>:<span class="string">"b"</span>, <span class="number">2</span>:<span class="string">"c"</span>, length:<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> item = <span class="built_in">Array</span>.prototype.shift.call(o);</span><br><span class="line"><span class="built_in">console</span>.log(o);<span class="comment">//Object &#123;0: "b", 1: "c", length: 2&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(item);<span class="comment">//a</span></span><br></pre></td></tr></table></figure>
<p>如果类数组对象length属性不存在, 将添加length属性, 并初始化为0,如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="string">"a"</span>, <span class="number">1</span>:<span class="string">"b"</span>, <span class="number">2</span>:<span class="string">"c"</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> item = <span class="built_in">Array</span>.prototype.shift.call(o);</span><br><span class="line"><span class="built_in">console</span>.log(o);<span class="comment">//Object &#123;0: "a", 1: "b", 2:"c" length: 0&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(item);<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<h5 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h5><p>sort()方法对数组元素进行排序, 并返回这个数组.</p>
<p>语法: arr.sort([comparefn]), comparefn是可选的, 如果省略, 数组元素将按照各自转换为字符串的Unicode(万国码)位点顺序排序, 例如”boy”将排到”Apple”之前. 当对数字排序的时候, 25将会排到8之前, 因为转换为字符串后, “25”将比”8”靠前. 例如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">"Apple"</span>,<span class="string">"boy"</span>,<span class="string">"Cat"</span>,<span class="string">"dog"</span>];</span><br><span class="line"><span class="keyword">var</span> array2 = array.sort();</span><br><span class="line"><span class="built_in">console</span>.log(array);<span class="comment">//["Apple", "Cat", "boy", "dog"]</span></span><br><span class="line"><span class="built_in">console</span>.log(array2 == array);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">array = [<span class="number">10</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">20</span>];</span><br><span class="line"><span class="keyword">var</span> array3 = array.sort();</span><br><span class="line"><span class="built_in">console</span>.log(array3);<span class="comment">//[1, 10, 20, 3]</span></span><br></pre></td></tr></table></figure>
<p>如果指明了comparefn, 数组将按照调用该函数的返回值来排序. 若 a 和 b 是两个将要比较的元素:</p>
<ul>
<li>若 comparefn(a, b) &lt; 0 , 那么a 将排到 b 前面;</li>
<li>若 comparefn(a, b) = 0 , 那么a 和 b 相对位置不变;</li>
<li>若 comparefn(a, b) &gt; 0 , 那么a , b 将调换位置;</li>
</ul>
<p>如果数组元素为数字, 则排序函数comparefn格式如下所示:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果数组元素为非ASCII字符的字符串(如包含类似 e, é, è, a, ä 或中文字符等非英文字符的字符串), 则需要使用String.localeCompare. 下面这个函数将排到正确的顺序.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">'互'</span>,<span class="string">'联'</span>,<span class="string">'网'</span>,<span class="string">'改'</span>,<span class="string">'变'</span>,<span class="string">'世'</span>,<span class="string">'界'</span>];</span><br><span class="line"><span class="keyword">var</span> array2 = array.sort();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> array = [<span class="string">'互'</span>,<span class="string">'联'</span>,<span class="string">'网'</span>,<span class="string">'改'</span>,<span class="string">'变'</span>,<span class="string">'世'</span>,<span class="string">'界'</span>];<span class="comment">//重新赋值,避免干扰array2</span></span><br><span class="line"><span class="keyword">var</span> array3 = array.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a.localeCompare(b);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(array2);<span class="comment">//["世", "互", "变", "改", "界", "网", "联"]</span></span><br><span class="line"><span class="built_in">console</span>.log(array3);<span class="comment">//["变", "改", "互", "界", "联", "世", "网"]</span></span><br></pre></td></tr></table></figure>
<p>如上, “互联网改变世界” 这个数组, sort函数默认按照数组元素unicode字符串形式进行排序, 然而实际上, 我们期望的是按照拼音先后顺序进行排序, 显然String.localeCompare 帮助我们达到了这个目的.</p>
<p>为什么上面测试中需要重新给array赋值呢, 这是因为sort每次排序时改变的是数组本身, 并且返回数组引用. 如果不这么做, 经过连续两次排序后, array2 和 array3 将指向同一个数组, 最终影响我们测试. array重新赋值后就断开了对原数组的引用.</p>
<p>同上, sort一样受益于鸭式辨型, 比如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="string">'互'</span>,<span class="number">1</span>:<span class="string">'联'</span>,<span class="number">2</span>:<span class="string">'网'</span>,<span class="number">3</span>:<span class="string">'改'</span>,<span class="number">4</span>:<span class="string">'变'</span>,<span class="number">5</span>:<span class="string">'世'</span>,<span class="number">6</span>:<span class="string">'界'</span>,length:<span class="number">7</span>&#125;;</span><br><span class="line"><span class="built_in">Array</span>.prototype.sort.call(o,<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a.localeCompare(b);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(o);<span class="comment">//Object &#123;0: "变", 1: "改", 2: "互", 3: "界", 4: "联", 5: "世", 6: "网", length: 7&#125;, 可见同上述排序结果一致</span></span><br></pre></td></tr></table></figure>
<p>注意: 使用sort的鸭式辨型特性时, 若类数组对象不具有length属性,它并不会进行排序, 也不会为其添加length属性.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="string">'互'</span>,<span class="number">1</span>:<span class="string">'联'</span>,<span class="number">2</span>:<span class="string">'网'</span>,<span class="number">3</span>:<span class="string">'改'</span>,<span class="number">4</span>:<span class="string">'变'</span>,<span class="number">5</span>:<span class="string">'世'</span>,<span class="number">6</span>:<span class="string">'界'</span>&#125;;</span><br><span class="line"><span class="built_in">Array</span>.prototype.sort.call(o,<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a.localeCompare(b);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(o);<span class="comment">//Object &#123;0: "互", 1: "联", 2: "网", 3: "改", 4: "变", 5: "世", 6: "界"&#125;, 可见并未添加length属性</span></span><br></pre></td></tr></table></figure>
<h6 id="u4F7F_u7528_u6620_u5C04_u6539_u5584_u6392_u5E8F"><a href="#u4F7F_u7528_u6620_u5C04_u6539_u5584_u6392_u5E8F" class="headerlink" title="使用映射改善排序"></a>使用映射改善排序</h6><p>comparefn 如果需要对数组元素多次转换以实现排序, 那么使用map辅助排序将是个不错的选择. 基本思想就是将数组中的每个元素实际比较的值取出来, 排序后再将数组恢复.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要被排序的数组</span></span><br><span class="line"><span class="keyword">var</span> array = [<span class="string">'dog'</span>, <span class="string">'Cat'</span>, <span class="string">'Boy'</span>, <span class="string">'apple'</span>];</span><br><span class="line"><span class="comment">// 对需要排序的数字和位置的临时存储</span></span><br><span class="line"><span class="keyword">var</span> mapped = array.map(<span class="function"><span class="keyword">function</span>(<span class="params">el, i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; index: i, value: el.toLowerCase() &#125;;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 按照多个值排序数组</span></span><br><span class="line">mapped.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> +(a.value &gt; b.value) || +(a.value === b.value) - <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 根据索引得到排序的结果</span></span><br><span class="line"><span class="keyword">var</span> result = mapped.map(<span class="function"><span class="keyword">function</span>(<span class="params">el</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> array[el.index];</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(result);<span class="comment">//["apple", "Boy", "Cat", "dog"]</span></span><br></pre></td></tr></table></figure>
<h6 id="u5947_u602A_u7684chrome"><a href="#u5947_u602A_u7684chrome" class="headerlink" title="奇怪的chrome"></a>奇怪的chrome</h6><p>实际上, ECMAscript规范中并未规定具体的sort算法, 这就势必导致各个浏览器不尽相同的sort算法, 请看sort方法在Chrome浏览器下表现:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [&#123; n: <span class="string">"a"</span>, v: <span class="number">1</span> &#125;, &#123; n: <span class="string">"b"</span>, v: <span class="number">1</span> &#125;, &#123; n: <span class="string">"c"</span>, v: <span class="number">1</span> &#125;, &#123; n: <span class="string">"d"</span>, v: <span class="number">1</span> &#125;, &#123; n: <span class="string">"e"</span>, v: <span class="number">1</span> &#125;, &#123; n: <span class="string">"f"</span>, v: <span class="number">1</span> &#125;, &#123; n: <span class="string">"g"</span>, v: <span class="number">1</span> &#125;, &#123; n: <span class="string">"h"</span>, v: <span class="number">1</span> &#125;, &#123; n: <span class="string">"i"</span>, v: <span class="number">1</span> &#125;, &#123; n: <span class="string">"j"</span>, v: <span class="number">1</span> &#125;, &#123; n: <span class="string">"k"</span>, v: <span class="number">1</span> &#125;, ];</span><br><span class="line">array.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.v - b.v;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>,len = array.length; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(array[i].n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//f a c d e b g h i j k</span></span><br></pre></td></tr></table></figure>
<p>由于v值相等, array数组排序前后应该不变, 然而Chrome却表现异常, 而其他浏览器(如IE 或 Firefox) 表现正常.</p>
<p>这是因为v8引擎为了高效排序(采用了不稳定排序). 即数组长度超过10条时, 会调用另一种排序方法(快速排序); 而10条及以下采用的是插入算法,此时结果将是稳定的, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [&#123; n: <span class="string">"a"</span>, v: <span class="number">1</span> &#125;, &#123; n: <span class="string">"b"</span>, v: <span class="number">1</span> &#125;, &#123; n: <span class="string">"c"</span>, v: <span class="number">1</span> &#125;, &#123; n: <span class="string">"d"</span>, v: <span class="number">1</span> &#125;, &#123; n: <span class="string">"e"</span>, v: <span class="number">1</span> &#125;, &#123; n: <span class="string">"f"</span>, v: <span class="number">1</span> &#125;, &#123; n: <span class="string">"g"</span>, v: <span class="number">1</span> &#125;, &#123; n: <span class="string">"h"</span>, v: <span class="number">1</span> &#125;, &#123; n: <span class="string">"i"</span>, v: <span class="number">1</span> &#125;, &#123; n: <span class="string">"j"</span>, v: <span class="number">1</span> &#125;,];</span><br><span class="line">array.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.v - b.v;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>,len = array.length; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(array[i].n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//a b c d e f g h i j</span></span><br></pre></td></tr></table></figure>
<p>从a 到 j 刚好10条数据.</p>
<p>那么我们该如何规避Chrome浏览器的这种”bug”呢? 其实很简单, 只需略动手脚, 改变排序方法的返回值即可, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.v - b.v || array.indexOf(a)-array.indexOf(b);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>使用数组的sort方法需要注意一点: 各浏览器的针对sort方法内部算法实现不尽相同, 排序函数尽量只返回-1, 0, 1三种不同的值, 不要尝试返回true或false等其它数值, 因为可能导致不可靠的排序结果.</p>
<h6 id="u95EE_u9898_u5206_u6790"><a href="#u95EE_u9898_u5206_u6790" class="headerlink" title="问题分析"></a>问题分析</h6><p>sort方法传入的排序函数如果返回布尔值会导致什么样的结果呢?</p>
<p>以下是常见的浏览器以及脚本引擎:</p>
<table>
<thead>
<tr>
<th>Browser Name</th>
<th>ECMAScript Engine</th>
</tr>
</thead>
<tbody>
<tr>
<td>Internet Explorer 6 - 8</td>
<td>JScript</td>
</tr>
<tr>
<td>Internet Explorer 9 - 10</td>
<td>Chakra</td>
</tr>
<tr>
<td>Firefox</td>
<td>IonMonkey(Monkey系列引擎), TraceMonkey, Gecko</td>
</tr>
<tr>
<td>Chrome</td>
<td>V8</td>
</tr>
<tr>
<td>Safair</td>
<td>JavaScriptCore(SquirrelFish Extreme)</td>
</tr>
<tr>
<td>Opera</td>
<td>Carakan</td>
</tr>
</tbody>
</table>
<p>分析以下代码，预期将数组元素进行升序排序：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line"><span class="keyword">var</span> comparefn = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x &gt; y;</span><br><span class="line">&#125;;</span><br><span class="line">array.sort(comparefn);</span><br></pre></td></tr></table></figure>
<p>代码中，comparefn 函数返回值为 bool 类型，并非为规范规定的 -1、0、1 值。那么执行此代码，各 JS 脚本引擎实现情况如何？</p>
<table>
<thead>
<tr>
<th></th>
<th>输出结果</th>
<th>是否符合预期</th>
</tr>
</thead>
<tbody>
<tr>
<td>JScript</td>
<td>[2, 3, 5, 1, 4, 6, 7, 0, 8, 9]</td>
<td>否</td>
</tr>
<tr>
<td>Carakan</td>
<td>[0, 1, 3, 8, 2, 4, 9, 5, 6, 7]</td>
<td>否</td>
</tr>
<tr>
<td>Chakra &amp; JavaScriptCore</td>
<td>[7, 6, 5, 4, 3, 2, 1, 0, 8, 9]</td>
<td>否</td>
</tr>
<tr>
<td>IonMonkey</td>
<td>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</td>
<td>是</td>
</tr>
<tr>
<td>V8</td>
<td>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</td>
<td>是</td>
</tr>
</tbody>
</table>
<p><strong>根据表中数据可见，当数组内元素个数小于等于 10 时:</strong></p>
<ul>
<li>JScript &amp; Carakan 排序结果有误</li>
<li>Chakra &amp; JavaScriptCore 看起来没有进行排序</li>
<li>IonMonkey 返回了预期的正确结果</li>
<li>V8 暂时看起来排序正确</li>
</ul>
<p><strong>将数组元素扩大至 11 位:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>];</span><br><span class="line"><span class="keyword">var</span> comparefn = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x &gt; y;</span><br><span class="line">&#125;;</span><br><span class="line">array.sort(comparefn);</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th></th>
<th>输出结果</th>
<th>是否符合预期</th>
</tr>
</thead>
<tbody>
<tr>
<td>JScript</td>
<td>[2, 3, 5, 1, 4, 6, 7, 0, 8, 9, 10]</td>
<td>否</td>
</tr>
<tr>
<td>Carakan</td>
<td>[0, 1, 3, 8, 2, 4, 9, 5, 10, 6, 7]</td>
<td>否</td>
</tr>
<tr>
<td>Chakra &amp; JavaScriptCore</td>
<td>[7, 6, 5, 4, 3, 2, 1, 0, 10, 8, 9]</td>
<td>否</td>
</tr>
<tr>
<td>IonMonkey</td>
<td>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</td>
<td>是</td>
</tr>
<tr>
<td>V8</td>
<td>[5, 0, 1, 2, 3, 4, 6, 7, 8, 9, 10]</td>
<td>否</td>
</tr>
</tbody>
</table>
<p><strong>根据表中数据可见，当数组内元素个数大于 10 时：</strong></p>
<ul>
<li>JScript &amp; Carakan 排序结果有误</li>
<li>Chakra &amp; JavaScriptCore 看起来没有进行排序</li>
<li>IonMonkey 返回了预期的正确结果</li>
<li>V8 <strong>排序结果由正确转为不正确</strong></li>
</ul>
<h5 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h5><p>splice()方法用新元素替换旧元素的方式来修改数组.</p>
<p>语法: arr.splice(start,deleteCount[, item1[, item2[, …]]])</p>
<p>start 指定从哪一位开始修改内容. 如果超过了数组长度, 则从数组末尾开始添加内容; 如果是负值, 则其指定的索引位置等同于 length+start (length为数组的长度), 表示从数组末尾开始的第 -start 位.</p>
<p>deleteCount 指定要删除的元素个数, 若等于0 ,则不删除. 这种情况下, 至少应该添加一位新元素. 若大于start之后的元素总和, 则start及之后的元素都将被删除.</p>
<p>itemN 指定新增的元素, 如果缺省, 则该方法只删除数组元素.</p>
<p>返回值 由原数组中被删除元素组成的数组,如果没有删除, 则返回一个空数组.</p>
<p>下面来举栗子说明:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">"apple"</span>,<span class="string">"boy"</span>];</span><br><span class="line"><span class="keyword">var</span> splices = array.splice(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(array);<span class="comment">//["apple"]</span></span><br><span class="line"><span class="built_in">console</span>.log(splices);<span class="comment">//["boy"] ,可见是从数组下标为1的元素开始删除,并且删除一个元素,由于itemN缺省,故此时该方法只删除元素</span></span><br><span class="line"></span><br><span class="line">array = [<span class="string">"apple"</span>,<span class="string">"boy"</span>];</span><br><span class="line">splices = array.splice(<span class="number">2</span>,<span class="number">1</span>,<span class="string">"cat"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(array);<span class="comment">//["apple", "boy", "cat"]</span></span><br><span class="line"><span class="built_in">console</span>.log(splices);<span class="comment">//[], 可见由于start超过数组长度,此时从数组末尾开始添加元素,并且原数组不会发生删除行为</span></span><br><span class="line"></span><br><span class="line">array = [<span class="string">"apple"</span>,<span class="string">"boy"</span>];</span><br><span class="line">splices = array.splice(-<span class="number">2</span>,<span class="number">1</span>,<span class="string">"cat"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(array);<span class="comment">//["cat", "boy"]</span></span><br><span class="line"><span class="built_in">console</span>.log(splices);<span class="comment">//["apple"], 可见当start为负值时,是从数组末尾开始的第-start位开始删除,删除一个元素,并且从此处插入了一个元素</span></span><br><span class="line"></span><br><span class="line">array = [<span class="string">"apple"</span>,<span class="string">"boy"</span>];</span><br><span class="line">splices = array.splice(-<span class="number">3</span>,<span class="number">1</span>,<span class="string">"cat"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(array);<span class="comment">//["cat", "boy"]</span></span><br><span class="line"><span class="built_in">console</span>.log(splices);<span class="comment">//["apple"], 可见即使-start超出数组长度,数组默认从首位开始删除</span></span><br><span class="line"></span><br><span class="line">array = [<span class="string">"apple"</span>,<span class="string">"boy"</span>];</span><br><span class="line">splices = array.splice(<span class="number">0</span>,<span class="number">3</span>,<span class="string">"cat"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(array);<span class="comment">//["cat"]</span></span><br><span class="line"><span class="built_in">console</span>.log(splices);<span class="comment">//["apple", "boy"], 可见当deleteCount大于数组start之后的元素总和时,start及之后的元素都将被删除</span></span><br></pre></td></tr></table></figure>
<p>同上, splice一样受益于鸭式辨型, 比如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="string">"apple"</span>,<span class="number">1</span>:<span class="string">"boy"</span>,length:<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> splices = <span class="built_in">Array</span>.prototype.splice.call(o,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(o);<span class="comment">//Object &#123;0: "apple", length: 1&#125;, 可见对象o删除了一个属性,并且length-1</span></span><br><span class="line"><span class="built_in">console</span>.log(splices);<span class="comment">//["boy"]</span></span><br></pre></td></tr></table></figure>
<p>注: 如果类数组对象没有length属性, splice将为该类数组对象添加length属性,并初始化为0. 此处栗子忽略. 如果需要请在<a href="https://github.com/Louiszhai" target="_blank" rel="external">评论</a>里反馈.</p>
<p>如果需要删除数组中一个已存在的元素, 可参考如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>];</span><br><span class="line">array.splice(array.indexOf(<span class="string">'b'</span>),<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h5 id="unshift"><a href="#unshift" class="headerlink" title="unshift"></a>unshift</h5><p>unshift() 方法用于在数组开始处插入一些元素(感觉像栈底插入), 并返回数组新的长度.</p>
<p>语法: arr.unshift(element1, …, elementN)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>];</span><br><span class="line"><span class="keyword">var</span> length = array.unshift(<span class="string">"yellow"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(array);<span class="comment">//["yellow", "red", "green", "blue"]</span></span><br><span class="line"><span class="built_in">console</span>.log(length);<span class="comment">//4</span></span><br></pre></td></tr></table></figure>
<p>如果给unshift方法传入一个数组呢?</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>];</span><br><span class="line"><span class="keyword">var</span> length = array.unshift([<span class="string">"yellow"</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(array);<span class="comment">//[["yellow"], "red", "green", "blue"]</span></span><br><span class="line"><span class="built_in">console</span>.log(length);<span class="comment">//4, 可见数组也能成功插入</span></span><br></pre></td></tr></table></figure>
<p>同上, unshift也受益于鸭式辨型, 呈上栗子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="string">"red"</span>, <span class="number">1</span>:<span class="string">"green"</span>, <span class="number">2</span>:<span class="string">"blue"</span>,length:<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> length = <span class="built_in">Array</span>.prototype.unshift.call(o,<span class="string">"gray"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(o);<span class="comment">//Object &#123;0: "gray", 1: "red", 2: "green", 3: "blue", length: 4&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(length);<span class="comment">//4</span></span><br></pre></td></tr></table></figure>
<p>注: 如果类数组对象不指定length属性, 则返回结果是这样的 Object {0: “gray”, 1: “green”, 2: “blue”, length: 1}, shift会认为数组长度为0, 此时将从对象下标为0的位置开始插入, 相应位置属性将被替换, 此时初始化类数组对象的length属性为插入元素个数.</p>
<h5 id="copyWithin"><a href="#copyWithin" class="headerlink" title="copyWithin"></a>copyWithin</h5><p>copyWithin() 方法用于数组内的元素替换, 即替换元素和被替换元素均是数组内的元素.</p>
<p>语法: arr.copyWithin(target, start[, end = this.length])</p>
<p>taget 指定被替换元素的索引, start 指定替换元素起始的索引, end 可选, 指的是替换元素结束位置的索引.</p>
<p>如果start为负，则其指定的索引位置等同于length+start，length为数组的长度。end也是如此.</p>
<p>注: 目前只有Firefox(版本32及其以上版本)实现了该方法.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]; </span><br><span class="line"><span class="keyword">var</span> array2 = array.copyWithin(<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(array===array2,array2);<span class="comment">// true [4, 5, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]; </span><br><span class="line"><span class="built_in">console</span>.log(array.copyWithin(<span class="number">0</span>,<span class="number">3</span>,<span class="number">4</span>));<span class="comment">// [4, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]; </span><br><span class="line"><span class="built_in">console</span>.log(array.copyWithin(<span class="number">0</span>,-<span class="number">2</span>,-<span class="number">1</span>));<span class="comment">// [4, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>
<p>同上, copyWithin一样受益于鸭式辨型, 例如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="number">1</span>, <span class="number">1</span>:<span class="number">2</span>, <span class="number">2</span>:<span class="number">3</span>, <span class="number">3</span>:<span class="number">4</span>, <span class="number">4</span>:<span class="number">5</span>,length:<span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="built_in">Array</span>.prototype.copyWithin.call(o,<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(o===o2,o2);<span class="comment">//true Object &#123; 0=4,  1=5,  2=3,  更多...&#125;</span></span><br></pre></td></tr></table></figure>
<p>如需在Firefox之外的浏览器使用copyWithin方法,请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin#Polyfill" target="_blank" rel="external">Polyfill</a>.</p>
<h5 id="fill"><a href="#fill" class="headerlink" title="fill"></a>fill</h5><p>fill() 方法同样用于数组元素替换, 它可将数组指定区间内的元素替换为某个值.</p>
<p>语法: <em>arr</em>.fill(value, start[, end = this.length])</p>
<p>value 指定被替换的值, start 指定替换元素起始的索引, end 可选, 指的是替换元素结束位置的索引.</p>
<p>如果start为负，则其指定的索引位置等同于length+start，length为数组的长度。end也是如此.</p>
<p>注: 目前只有Firefox(版本31及其以上版本)实现了该方法.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> array2 = array.fill(<span class="number">10</span>,<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(array===array2,array2);<span class="comment">// true [10, 10, 10, 4, 5], 可见数组区间[0,3]的元素全部替换为10</span></span><br><span class="line"><span class="comment">//其他的举例请参考copyWithin</span></span><br></pre></td></tr></table></figure>
<p>同上, fill 一样受益于鸭式辨型, 例如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="number">1</span>, <span class="number">1</span>:<span class="number">2</span>, <span class="number">2</span>:<span class="number">3</span>, <span class="number">3</span>:<span class="number">4</span>, <span class="number">4</span>:<span class="number">5</span>,length:<span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="built_in">Array</span>.prototype.fill.call(o,<span class="number">10</span>,<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(o===o2,o2); <span class="literal">true</span> <span class="built_in">Object</span> &#123; <span class="number">0</span>=<span class="number">10</span>,  <span class="number">1</span>=<span class="number">10</span>,  <span class="number">2</span>=<span class="number">3</span>,  更多...&#125;</span><br></pre></td></tr></table></figure>
<p>如需在Firefox之外的浏览器使用copyWithin方法,请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/fill#Compatibility" target="_blank" rel="external">Polyfill</a>.</p>
<h4 id="u4E0D_u4F1A_u6539_u53D8_u81EA_u8EAB_u7684_u65B9_u6CD5_289_u4E2A_29"><a href="#u4E0D_u4F1A_u6539_u53D8_u81EA_u8EAB_u7684_u65B9_u6CD5_289_u4E2A_29" class="headerlink" title="不会改变自身的方法(9个)"></a>不会改变自身的方法(9个)</h4><p>基于ES7, 不会改变自身的方法一共有9个, 分别为concat, join, slice, toString, toLocateString, indexOf, lastIndexOf, 未标准的toSource, 以及ES7新增的方法includes.z</p>
<h5 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h5><p>concat() 方法将传入的数组或者元素与原数组合并, 组成一个新的数组并返回.</p>
<p>语法: <em>arr</em>.concat(<em>value1</em>, <em>value2</em>, …, <em>valueN</em>)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> array2 = array.concat(<span class="number">4</span>,[<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(array2);<span class="comment">//[1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"><span class="built_in">console</span>.log(array);<span class="comment">//[1, 2, 3], 可见原数组并未被修改</span></span><br></pre></td></tr></table></figure>
<p>同上, concat 一样受益于鸭式辨型, 但其效果可能达不到我们的期望, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="string">"a"</span>, <span class="number">1</span>:<span class="string">"b"</span>, <span class="number">2</span>:<span class="string">"c"</span>,length:<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="built_in">Array</span>.prototype.concat.call(o,<span class="string">'d'</span>,&#123;<span class="number">3</span>:<span class="string">'e'</span>,<span class="number">4</span>:<span class="string">'f'</span>,length:<span class="number">2</span>&#125;,[<span class="string">'g'</span>,<span class="string">'h'</span>,<span class="string">'i'</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(o2);<span class="comment">//[&#123;0:"a", 1:"b", 2:"c", length:3&#125;, 'd', &#123;3:'e', 4:'f', length:2&#125;, 'g', 'h', 'i']</span></span><br></pre></td></tr></table></figure>
<p>可见, 类数组对象合并后返回的是依然是数组, 并不是我们期望的对象.</p>
<h5 id="join"><a href="#join" class="headerlink" title="join"></a>join</h5><p>join() 方法将数组中的所有元素连接成一个字符串.</p>
<p>语法: str = arr.join([separator = ‘,’]) separator可选, 缺省默认为逗号</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">'We'</span>, <span class="string">'are'</span>, <span class="string">'Chinese'</span>];</span><br><span class="line"><span class="built_in">console</span>.log(array.join());<span class="comment">//We,are,Chinese</span></span><br><span class="line"><span class="built_in">console</span>.log(array.join(<span class="string">'+'</span>));<span class="comment">//We+are+Chinese</span></span><br><span class="line"><span class="built_in">console</span>.log(array.join(<span class="string">''</span>));<span class="comment">//WeareChinese</span></span><br></pre></td></tr></table></figure>
<p>同上, join 一样受益于鸭式辨型, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="string">"We"</span>, <span class="number">1</span>:<span class="string">"are"</span>, <span class="number">2</span>:<span class="string">"Chinese"</span>, length:<span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.join.call(o,<span class="string">'+'</span>));<span class="comment">//We+are+Chinese</span></span><br></pre></td></tr></table></figure>
<h5 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h5><p>slice() 方法将数组中一部分元素浅复制存入新的数组对象, 并且返回这个数组对象.</p>
<p>语法: arr.slice(start[, end])</p>
<p>参数 start 指定复制开始位置的索引, end如果有值则表示复制结束位置的索引(不包括此位置).</p>
<p>如果 start 的值为负数, 假如数组长度为 length, 则表示从 length+start 的位置开始复制, 此时参数 end 如果有值, 只能是比 start 大的负数, 否则将返回空数组.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>,<span class="string">"four"</span>, <span class="string">"five"</span>];</span><br><span class="line"><span class="keyword">var</span> array2 = array.slice(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(array2);<span class="comment">//["three"]</span></span><br></pre></td></tr></table></figure>
<p><em>浅复制</em> 是指当对象的被复制时, 只是复制了对象的引用, 指向的依然是同一个对象. 下面来说明slice为什么是浅复制.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [&#123;color:<span class="string">"yellow"</span>&#125;, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> array2 = array.slice(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(array2);<span class="comment">//[&#123;color:"yellow"&#125;]</span></span><br><span class="line">array[<span class="number">0</span>][<span class="string">"color"</span>] = <span class="string">"blue"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(array2);<span class="comment">//[&#123;color:"bule"&#125;]</span></span><br></pre></td></tr></table></figure>
<p>由于slice是浅复制, 复制到的对象只是一个引用, 改变原数组array的值, array2也随之改变.</p>
<p>同时, 稍微利用下 slice 方法第一个参数为负数时的特性, 我们可以非常方便的拿到数组的最后一项元素, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].slice(-<span class="number">1</span>));<span class="comment">//[3]</span></span><br></pre></td></tr></table></figure>
<p>同上, slice 一样受益于鸭式辨型, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:&#123;<span class="string">"color"</span>:<span class="string">"yellow"</span>&#125;, <span class="number">1</span>:<span class="number">2</span>, <span class="number">2</span>:<span class="number">3</span>, length:<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="built_in">Array</span>.prototype.slice.call(o,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(o2);<span class="comment">//[&#123;color:"yellow"&#125;] ,毫无违和感...</span></span><br></pre></td></tr></table></figure>
<p>鉴于IE9以下版本对于该方法支持性并不是很好, 如需更好的支持低版本IE浏览器, 请参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/slice#更可靠地跨浏览器" target="_blank" rel="external">更可靠地跨浏览器</a></p>
<h5 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h5><p>toString() 方法返回数组的字符串形式, 该字符串由数组中的每个元素的 <code>toString()</code> 返回值经调用 <code>join()</code> 方法连接（由逗号隔开）组成.</p>
<p>语法: <em>arr</em>.toString()</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">'Jan'</span>, <span class="string">'Feb'</span>, <span class="string">'Mar'</span>, <span class="string">'Apr'</span>];</span><br><span class="line"><span class="keyword">var</span> str = array.toString();</span><br><span class="line"><span class="built_in">console</span>.log(str);<span class="comment">//Jan,Feb,Mar,Apr</span></span><br></pre></td></tr></table></figure>
<p>当数组直接和字符串作连接操作时, 将会自动调用其toString() 方法.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = [<span class="string">'Jan'</span>, <span class="string">'Feb'</span>, <span class="string">'Mar'</span>, <span class="string">'Apr'</span>] + <span class="string">',May'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str);<span class="comment">//Jan,Feb,Mar,Apr,May</span></span><br><span class="line"><span class="comment">//下面我们来试试鸭式辨型</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="string">'Jan'</span>, <span class="number">1</span>:<span class="string">'Feb'</span>, <span class="number">2</span>:<span class="string">'Mar'</span>, length:<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="built_in">Array</span>.prototype.toString.call(o);</span><br><span class="line"><span class="built_in">console</span>.log(o2);<span class="comment">//[object Object]</span></span><br><span class="line"><span class="built_in">console</span>.log(o.toString()==o2);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>可见, Array.prototype.toString()方法处理类数组对象时, 跟类数组对象直接调用Object.prototype.toString() 方法结果完全一致, 说好的鸭式辨型呢?</p>
<p>根据ES5语义, toString() 方法是通用的, 可被用于任何对象, 如果对象有一个join() 方法, 将会被调用, 其返回值将被返回, 没有则调用Object.prototype.toString(), 为此, 我们给o对象添加一个join方法, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  <span class="number">0</span>:<span class="string">'Jan'</span>, </span><br><span class="line">  <span class="number">1</span>:<span class="string">'Feb'</span>, </span><br><span class="line">  <span class="number">2</span>:<span class="string">'Mar'</span>, </span><br><span class="line">  length:<span class="number">3</span>, </span><br><span class="line">  join:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.join.call(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.toString.call(o));<span class="comment">//Jan,Feb,Mar</span></span><br></pre></td></tr></table></figure>
<h5 id="toLocaleString-NaN"><a href="#toLocaleString-NaN" class="headerlink" title="toLocaleString"></a>toLocaleString</h5><p>toLocaleString() 类似toString()的变体, 该字符串由数组中的每个元素的 <code>toLocaleString()</code> 返回值经调用 <code>join()</code> 方法连接（由逗号隔开）组成.</p>
<p>语法: <em>arr</em>.toLocaleString()</p>
<p>数组中的元素将调用各自的 toLocaleString 方法:</p>
<ul>
<li><code>Object</code>: <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toLocaleString" target="_blank" rel="external"><code>Object.prototype.toLocaleString()</code></a></li>
<li><code>Number</code>: <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString" target="_blank" rel="external"><code>Number.prototype.toLocaleString()</code></a></li>
<li><code>Date</code>: <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/toLocaleString" target="_blank" rel="external"><code>Date.prototype.toLocaleString()</code></a></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array= [&#123;name:<span class="string">'zz'</span>&#125;, <span class="number">123</span>, <span class="string">"abc"</span>, <span class="keyword">new</span> <span class="built_in">Date</span>()];</span><br><span class="line"><span class="keyword">var</span> str = array.toLocaleString();</span><br><span class="line"><span class="built_in">console</span>.log(str);<span class="comment">//[object Object],123,abc,2016/1/5 下午1:06:23</span></span><br></pre></td></tr></table></figure>
<p>其鸭式辨型的写法也同toString 保持一致, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  <span class="number">0</span>:<span class="number">123</span>, </span><br><span class="line">  <span class="number">1</span>:<span class="string">'abc'</span>, </span><br><span class="line">  <span class="number">2</span>:<span class="keyword">new</span> <span class="built_in">Date</span>(), </span><br><span class="line">  length:<span class="number">3</span>, </span><br><span class="line">  join:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.join.call(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.toLocaleString.call(o));<span class="comment">//123,abc,2016/1/5 下午1:16:50</span></span><br></pre></td></tr></table></figure>
<h5 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h5><p>indexOf() 方法用于查找元素在数组中第一次出现时的索引, 如果没有, 则返回-1.</p>
<p>语法: <em>arr</em>.indexOf(element, fromIndex=0)</p>
<p>element 为需要查找的元素</p>
<p>fromIndex 为开始查找的位置, 缺省默认为0. 如果超出数组长度, 则返回-1. 如果为负值, 假设数组长度为length, 则从数组的第 length + fromIndex项开始往数组末尾查找, 如果length + fromIndex&lt;0 则整个数组都会被查找.</p>
<p>indexOf使用严格相等(即使用 === 去匹配数组中的元素)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">'abc'</span>, <span class="string">'def'</span>, <span class="string">'ghi'</span>,<span class="string">'123'</span>];</span><br><span class="line"><span class="built_in">console</span>.log(array.indexOf(<span class="string">'def'</span>));<span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(array.indexOf(<span class="string">'def'</span>,-<span class="number">1</span>));<span class="comment">//1 此时表示从最后一个元素往后查找,因此查找失败返回-1</span></span><br><span class="line"><span class="built_in">console</span>.log(array.indexOf(<span class="string">'def'</span>,-<span class="number">4</span>));<span class="comment">//1 由于4大于数组长度,此时将查找整个数组,因此返回1</span></span><br><span class="line"><span class="built_in">console</span>.log(array.indexOf(<span class="number">123</span>));<span class="comment">//-1, 由于是严格匹配,因此并不会匹配到字符串'123'</span></span><br></pre></td></tr></table></figure>
<p>得益于鸭式辨型, indexOf 可以处理类数组对象, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="string">'abc'</span>, <span class="number">1</span>:<span class="string">'def'</span>, <span class="number">2</span>:<span class="string">'ghi'</span>, length:<span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.indexOf.call(o,<span class="string">'ghi'</span>,-<span class="number">4</span>));<span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>然而该方法并不支持IE9以下版本, 如需更好的支持低版本IE浏览器(IE6~8), 请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf#Polyfill" target="_blank" rel="external">Polyfill</a>.</p>
<h5 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf"></a>lastIndexOf</h5><p>lastIndexOf() 方法用于查找元素在数组中最后一次出现时的索引, 如果没有, 则返回-1. 并且它是indexOf的逆向查找, 即从数组最后一个往前查找.</p>
<p>语法: <em>arr</em>.lastIndexOf(element, fromIndex=length-1)</p>
<p>element 为需要查找的元素</p>
<p>fromIndex 为开始查找的位置, 缺省默认为数组长度length-1. 如果超出数组长度, 由于是逆向查找, 则查找整个数组. 如果为负值, 则从数组的第 length + fromIndex项开始往数组开头查找, 如果length + fromIndex&lt;0 则数组不会被查找.</p>
<p>同 indexOf 一样, lastIndexOf 也是严格匹配数组元素.</p>
<p>栗子参考 <code>indexOf</code> , 不再详述, 兼容低版本IE浏览器(IE6~8), 请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf#Compatibility" target="_blank" rel="external">Polyfill</a>.</p>
<h5 id="includes_28ES6_29"><a href="#includes_28ES6_29" class="headerlink" title="includes(ES6)"></a>includes(ES6)</h5><p>includes() 方法基于<strong>ECMAScript 2015（ES6）规范</strong>, 它用来判断当前数组是否包含某个指定的值, 如果是, 则返回 true, 否则返回 false.</p>
<p>语法: <em>arr</em>.includes(element, fromIndex=0)</p>
<p>element 为需要查找的元素</p>
<p>fromIndex 表示从该索引位置开始查找 element, 缺省为0, 它是正向查找, 即从索引处往数组末尾查找.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="literal">NaN</span>];</span><br><span class="line"><span class="built_in">console</span>.log(array.includes(<span class="number">1</span>));<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(array.includes(<span class="literal">NaN</span>));<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(array.includes(<span class="number">2</span>,-<span class="number">4</span>));<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>该方法同样受益于鸭式辨型. 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="string">'a'</span>, <span class="number">1</span>:<span class="string">'b'</span>, <span class="number">2</span>:<span class="string">'c'</span>, length:<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> bool = <span class="built_in">Array</span>.prototype.includes.call(o, <span class="string">'a'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(bool);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>该方法只有在Chrome 47, opera 34, Safari 9版本及其更高版本中才予以实现. 如需支持其他浏览器, 请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/includes#Polyfill" target="_blank" rel="external">Polyfill</a>.</p>
<h5 id="startsWith"><a href="#startsWith" class="headerlink" title="startsWith"></a>startsWith</h5><p>startsWith() 方法基于<strong>ECMAScript 2015（ES6）规范</strong>, 它用来判断当前数组是否包含某个指定的值, 如果是, 则返回 true, 否则返回 false.</p>
<p>语法: <em>arr</em>.includes(element, fromIndex=0)</p>
<h5 id="endsWith"><a href="#endsWith" class="headerlink" title="endsWith"></a>endsWith</h5><h5 id="toSource"><a href="#toSource" class="headerlink" title="toSource"></a>toSource</h5><p>toSource() 方法是非标准的, 该方法返回数组的源代码, 目前只有 Firefox 实现了它.</p>
<p>语法: <em>arr</em>.toSource()</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="built_in">console</span>.log(array.toSource());<span class="comment">//["a", "b", "c"]</span></span><br><span class="line"><span class="comment">//测试鸭式辨型</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="string">'a'</span>, <span class="number">1</span>:<span class="string">'b'</span>, <span class="number">2</span>:<span class="string">'c'</span>, length:<span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.toSource.call(o));<span class="comment">//["a","b","c"]</span></span><br></pre></td></tr></table></figure>
<h4 id="u904D_u5386_u65B9_u6CD5_2812_u4E2A_29"><a href="#u904D_u5386_u65B9_u6CD5_2812_u4E2A_29" class="headerlink" title="遍历方法(12个)"></a>遍历方法(12个)</h4><p>基于ES6, 不会改变自身的方法一共有12个, 分别为forEach, every, some, filter, map, reduce, reduceRight, 以及ES6新增的方法entries, find, findIndex, keys, values.</p>
<h5 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h5><p>forEach() 方法指定数组的每项元素都执行一次传入的函数, 返回值为undefined.</p>
<p>语法: <em>arr</em>.forEach(fn, thisArg)</p>
<p>fn 表示在数组每一项上执行的函数, 接受三个参数:</p>
<ul>
<li>value 当前正在被处理的元素的值</li>
<li>index 当前元素的数组索引</li>
<li>array 数组本身</li>
</ul>
<p>thisArg 可选, 用来当做fn函数内的this对象(context 上下文).</p>
<p>forEach 将为数组中每一项执行一次 fn 函数, 那些已删除, 新增或者从未赋值的项将被跳过(但不包括值为 undefined 的项). 遍历过程中, fn会被传入上述三个参数.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> obj = &#123;name:<span class="string">'cc'</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> sReturn = array.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value, index, array</span>)</span>&#123;</span><br><span class="line">  array[index] = value * value;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);<span class="comment">//cc被打印了三次</span></span><br><span class="line">&#125;,obj);</span><br><span class="line"><span class="built_in">console</span>.log(array);<span class="comment">//[1, 9, 25], 可见原数组改变了</span></span><br><span class="line"><span class="built_in">console</span>.log(sReturn);<span class="comment">//undefined, 可见返回值为undefined</span></span><br></pre></td></tr></table></figure>
<p>得益于鸭式辨型, 虽然forEach不能直接遍历对象, 但它可以通过call方式遍历类数组对象. 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="number">1</span>, <span class="number">1</span>:<span class="number">3</span>, <span class="number">2</span>:<span class="number">5</span>, length:<span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">Array</span>.prototype.forEach.call(o,<span class="function"><span class="keyword">function</span>(<span class="params">value, index, obj</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value,index,obj);</span><br><span class="line">  obj[index] = value * value;</span><br><span class="line">&#125;,o);</span><br><span class="line"><span class="comment">//1 0 Object &#123;0: 1, 1: 3, 2: 5, length: 3&#125;</span></span><br><span class="line"><span class="comment">//3 1 Object &#123;0: 1, 1: 3, 2: 5, length: 3&#125;</span></span><br><span class="line"><span class="comment">//5 2 Object &#123;0: 1, 1: 9, 2: 5, length: 3&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(o);<span class="comment">//Object &#123;0: 1, 1: 9, 2: 25, length: 3&#125;</span></span><br></pre></td></tr></table></figure>
<p>参考前面的文章 <a href="http://louiszhai.github.io/2015/12/18/traverse/#forEach"><code>详解JS遍历</code></a> 中 forEach的讲解, 我们知道, forEach无法直接退出循环, 只能使用return 来达到for循环中continue的效果, 并且forEach不能在低版本IE(6~8)中使用, 兼容写法请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach#兼容旧环境（Polyfill）" target="_blank" rel="external">Polyfill</a> .</p>
<h5 id="every"><a href="#every" class="headerlink" title="every"></a>every</h5><p>every() 方法使用传入的函数测试所有元素, 只要其中有一个函数返回值为 false, 那么该方法的结果为 false; 如果全部返回 true, 那么该方法的结果才为 true. 因此 every 方法存在如下规律:</p>
<ul>
<li>若需检测数组中存在元素大于100 (即, one &gt; 100), 那么我们需要在传入的函数中构造 “false” 返回值 (即, 返回 item &lt;= 100), 同时整个方法结果为 false 才表示数组存在元素满足条件; (简单理解为, 若是单项判断, 可用 one false ===&gt; false)</li>
</ul>
<ul>
<li>若需检测数组中是否所有元素都大于100 (即, all &gt; 100),  那么我们需要在传入的函数中构造 “true” 返回值 (即, 返回 item &gt; 100), 同时整个方法结果为 true 才表示数组所有元素均满足条件. (简单理解为, 若是全部判断, 可用 all true ===&gt; true)</li>
</ul>
<p>语法同上述forEach, 具体还可以参考 <a href="http://louiszhai.github.io/2015/12/18/traverse/#every"><code>详解JS遍历</code></a> 中every的讲解.</p>
<p>以下是鸭式辨型的写法:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="number">10</span>, <span class="number">1</span>:<span class="number">8</span>, <span class="number">2</span>:<span class="number">25</span>, length:<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> bool = <span class="built_in">Array</span>.prototype.every.call(o,<span class="function"><span class="keyword">function</span>(<span class="params">value, index, obj</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value &gt;= <span class="number">8</span>;</span><br><span class="line">&#125;,o);</span><br><span class="line"><span class="built_in">console</span>.log(bool);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>every 一样不能在低版本IE(6~8)中使用, 兼容写法请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/every#Compatibility" target="_blank" rel="external">Polyfill</a> .</p>
<h5 id="some"><a href="#some" class="headerlink" title="some"></a>some</h5><p>some() 方法刚好同 every() 方法相反, some 测试数组元素时, 只要有一个函数返回值为 true, 则该方法返回 true, 若全部返回 false, 则该方法返回 false. 因此 some 方法存在如下规律:</p>
<ul>
<li>若需检测数组中存在元素大于100 (即, one &gt; 100), 那么我们需要在传入的函数中构造 “true” 返回值 (即, 返回 item &gt; 100), 同时整个方法结果为 true 才表示数组存在元素满足条件; (简单理解为, 若是单项判断, 可用 one true ===&gt; true)</li>
</ul>
<ul>
<li>若需检测数组中是否所有元素都大于100 (即, all &gt; 100),  那么我们需要在传入的函数中构造 “false” 返回值 (即, 返回 item &lt;= 100), 同时整个方法结果为 false 才表示数组所有元素均满足条件. (简单理解为, 若是全部判断, 可用 all false ===&gt; false)</li>
</ul>
<p>some 的鸭式辨型写法可以参照every,  同样它也不能在低版本IE(6~8)中使用, 兼容写法请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/some#Compatibility" target="_blank" rel="external">Polyfill</a> .</p>
<h5 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h5><p>filter() 方法使用传入的函数测试所有元素, 并返回所有通过测试的元素组成的新数组.</p>
<p>语法: <em>arr</em>.filter(fn, thisArg)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">18</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">35</span>, <span class="number">80</span>];</span><br><span class="line"><span class="keyword">var</span> array2 = array.filter(<span class="function"><span class="keyword">function</span>(<span class="params">value, index, array</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value &gt; <span class="number">20</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(array2);<span class="comment">//[35, 80]</span></span><br></pre></td></tr></table></figure>
<p>filter一样支持鸭式辨型, 具体请参考every方法鸭式辨型写法. 其在低版本IE(6~8) 的兼容写法请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/filter#Compatibility" target="_blank" rel="external">Polyfill</a> .</p>
<h5 id="map"><a href="#map" class="headerlink" title="map"></a>map</h5><p>map() 方法遍历数组, 使用传入函数处理每个元素, 并返回函数的返回值组成的新数组.</p>
<p>语法: <em>arr</em>.map(fn, thisArg)</p>
<p>参数介绍同 forEach 方法的参数介绍.</p>
<p>具体用法请参考 <a href="http://louiszhai.github.io/2015/12/18/traverse/#map"><code>详解JS遍历</code></a> 中 map 的讲解.</p>
<p>map 一样支持鸭式辨型, 具体请参考every方法鸭式辨型写法.</p>
<p>其在低版本IE(6~8) 的兼容写法请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map#Compatibility" target="_blank" rel="external">Polyfill</a> .</p>
<h5 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h5><p>reduce() 方法接收一个方法作为累加器, 数组中的每个值(从左至右) 开始合并, 最终为一个值.</p>
<p>语法: <em>arr</em>.reduce(fn, initialValue)</p>
<p>fn 表示在数组每一项上执行的函数, 接受四个参数:</p>
<ul>
<li>previousValue 上一次调用回调返回的值, 或者是提供的初始值</li>
<li>value 数组中当前被处理元素的值</li>
<li>index 当前元素在数组中的索引</li>
<li>array 数组自身</li>
</ul>
<p>initialValue 指定第一次调用 fn 的第一个参数.</p>
<p>当 fn 第一次执行时, </p>
<ul>
<li>如果 initialValue 在调用 reduce 时被提供, 那么第一个 previousValue 将等于 initialValue, 此时 item 等于数组中的第一个值;</li>
<li>如果 initialValue 未被提供, 那么 previousVaule 等于数组中的第一个值, item 等于数组中的第二个值. 此时如果数组为空, 那么将抛出 TypeError.</li>
<li>如果数组仅有一个元素, 并且没有提供 initialValue, 或提供了 initialValue 但数组为空, 那么fn不会被执行, 数组的唯一值将被返回.</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> s = array.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">previousValue, value, index, array</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> previousValue * value;</span><br><span class="line">&#125;,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s);<span class="comment">//24</span></span><br></pre></td></tr></table></figure>
<p>以上回调被调用4次, 每次的参数和返回见下表:</p>
<table>
<thead>
<tr>
<th style="text-align:center">callback</th>
<th style="text-align:center">previousValue</th>
<th style="text-align:center">currentValue</th>
<th style="text-align:center">index</th>
<th style="text-align:center">array</th>
<th style="text-align:center">return value</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">第1次</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">[1,2,3,4]</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">第2次</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">[1,2,3,4]</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">第3次</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
<td style="text-align:center">[1,2,3,4]</td>
<td style="text-align:center">6</td>
</tr>
<tr>
<td style="text-align:center">第4次</td>
<td style="text-align:center">6</td>
<td style="text-align:center">4</td>
<td style="text-align:center">4</td>
<td style="text-align:center">[1,2,3,4]</td>
<td style="text-align:center">24</td>
</tr>
</tbody>
</table>
<p>reduce 一样支持鸭式辨型, 具体请参考every方法鸭式辨型写法.</p>
<p>其在低版本IE(6~8) 的兼容写法请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#兼容旧环境（Polyfill）" target="_blank" rel="external">Polyfill</a> .</p>
<h5 id="reduceRight"><a href="#reduceRight" class="headerlink" title="reduceRight"></a>reduceRight</h5><p>reduceRight() 方法接收一个方法作为累加器, 数组中的每个值(从右至左) 开始合并, 最终为一个值. 除了与reduce执行方向相反外, 其他完全与其一致, 请参考上述 reduce 方法介绍.</p>
<p>其在低版本IE(6~8) 的兼容写法请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight#.E5.85.BC.E5.AE.B9.E6.80.A7.E6.97.A7.E7.8E.AF.E5.A2.83.EF.BC.88Polyfill.EF.BC.89" target="_blank" rel="external">Polyfill</a> .</p>
<h5 id="entries_28ES6_29"><a href="#entries_28ES6_29" class="headerlink" title="entries(ES6)"></a>entries(ES6)</h5><p>entries() 方法基于<strong>ECMAScript 2015（ES6）规范</strong>, 返回一个数组迭代器对象, 该对象包含数组中每个索引的键值对.</p>
<p>语法: <em>arr</em>.entries()</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>];</span><br><span class="line"><span class="keyword">var</span> iterator = array.entries();</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value);<span class="comment">//[0, "a"]</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value);<span class="comment">//[1, "b"]</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value);<span class="comment">//[2, "c"]</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value);<span class="comment">//undefined, 迭代器处于数组末尾时, 再迭代就会返回undefined</span></span><br></pre></td></tr></table></figure>
<p>很明显, entries 也受益于鸭式辨型, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="string">"a"</span>, <span class="number">1</span>:<span class="string">"b"</span>, <span class="number">2</span>:<span class="string">"c"</span>, length:<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> iterator = <span class="built_in">Array</span>.prototype.entries.call(o);</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value);<span class="comment">//[0, "a"]</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value);<span class="comment">//[1, "b"]</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value);<span class="comment">//[2, "c"]</span></span><br></pre></td></tr></table></figure>
<p>由于该方法基于ES6, 因此目前并不支持所有浏览器, 以下是各浏览器支持版本:</p>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Chrome</th>
<th>Firefox (Gecko)</th>
<th>Internet Explorer</th>
<th>Opera</th>
<th>Safari</th>
</tr>
</thead>
<tbody>
<tr>
<td>Basic support</td>
<td>38</td>
<td><a href="https://developer.mozilla.org/en-US/Firefox/Releases/28" target="_blank" rel="external">28</a> (28)</td>
<td>未实现</td>
<td>25</td>
<td>7.1</td>
</tr>
</tbody>
</table>
<h5 id="find_26amp_3BfindIndex_28ES6_29"><a href="#find_26amp_3BfindIndex_28ES6_29" class="headerlink" title="find&amp;findIndex(ES6)"></a>find&amp;findIndex(ES6)</h5><p>find() 方法基于<strong>ECMAScript 2015（ES6）规范</strong>, 返回数组中第一个满足条件的元素(如果有的话), 如果没有, 则返回undefined.</p>
<p>findIndex() 方法则返回数组中第一个满足条件的元素的索引(如果有的话), 否则返回-1.</p>
<p>语法: <em>arr</em>.find(fn, thisArg), <em>arr</em>.findIndex(fn, thisArg)</p>
<p>我们发现它们的语法与forEach等十分相似, 其实不光语法, find(或findIndex) 在参数及其使用注意事项上, 均与forEach一致. 因此此处将略去 find(或findIndex) 的参数介绍. 下面我们来看个栗子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">value, index, array</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value%<span class="number">2</span>==<span class="number">0</span>;<span class="comment">//返回偶数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params">value, index, array</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value &gt; <span class="number">20</span>;<span class="comment">//返回大于20的数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(array.find(f));<span class="comment">//8</span></span><br><span class="line"><span class="built_in">console</span>.log(array.find(f2));<span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(array.findIndex(f));<span class="comment">//4</span></span><br><span class="line"><span class="built_in">console</span>.log(array.findIndex(f2));<span class="comment">//-1</span></span><br></pre></td></tr></table></figure>
<p>由于其鸭式辨型写法也与forEach方法一致, 故此处略去. </p>
<p>兼容性上我没有详测, 可以知道的是, 最新版的Chrome(47), 以及Firefox的版本25均实现了它们.</p>
<h5 id="keys_28ES6_29"><a href="#keys_28ES6_29" class="headerlink" title="keys(ES6)"></a>keys(ES6)</h5><p>keys() 方法基于<strong>ECMAScript 2015（ES6）规范</strong>,返回一个数组索引的迭代器. (实际实现可能会有调整)</p>
<p>语法: <em>arr</em>.keys()</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">"abc"</span>, <span class="string">"xyz"</span>];</span><br><span class="line"><span class="keyword">var</span> iterator = array.keys();</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());<span class="comment">//Object &#123;value: 0, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());<span class="comment">//Object &#123;value: 1, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());<span class="comment">//Object &#123;value: undefined, done: false&#125;</span></span><br></pre></td></tr></table></figure>
<p>索引迭代器会包含那些没有对应元素的索引, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">"abc"</span>, , <span class="string">"xyz"</span>];</span><br><span class="line"><span class="keyword">var</span> sparseKeys = <span class="built_in">Object</span>.keys(arr);</span><br><span class="line"><span class="keyword">var</span> denseKeys = [...arr.keys()];</span><br><span class="line"><span class="built_in">console</span>.log(sparseKeys); <span class="comment">// ["0", "2"]</span></span><br><span class="line"><span class="built_in">console</span>.log(denseKeys);  <span class="comment">// [0, 1, 2]</span></span><br></pre></td></tr></table></figure>
<p>其鸭式辨型写法请参考上述 entries 方法.</p>
<p>由于该方法基于ES6, 并未完全支持, 以下是各浏览器支持版本:</p>
<table>
<thead>
<tr>
<th style="text-align:center">Feature</th>
<th style="text-align:center">Chrome</th>
<th style="text-align:center">Firefox (Gecko)</th>
<th style="text-align:center">Internet Explorer</th>
<th style="text-align:center">Opera</th>
<th style="text-align:center">Safari</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Basic support</td>
<td style="text-align:center">38</td>
<td style="text-align:center"><a href="https://developer.mozilla.org/en-US/Firefox/Releases/28" target="_blank" rel="external">28</a> (28)</td>
<td style="text-align:center">未实现</td>
<td style="text-align:center">25</td>
<td style="text-align:center">7.1</td>
</tr>
</tbody>
</table>
<h5 id="values_28ES6_29"><a href="#values_28ES6_29" class="headerlink" title="values(ES6)"></a>values(ES6)</h5><p>values() 方法基于<strong>ECMAScript 2015（ES6）规范</strong>, 返回一个数组迭代器对象, 该对象包含数组中每个索引的值. 其用法基本与上述 entries 方法一致.</p>
<p>语法: <em>arr</em>.values()</p>
<p>遗憾的是, 现在没有浏览器实现了该方法, 因此下面将就着看看吧.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">"abc"</span>, <span class="string">"xyz"</span>];</span><br><span class="line"><span class="keyword">var</span> iterator = array.values();</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value);<span class="comment">//abc</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value);<span class="comment">//xyz</span></span><br></pre></td></tr></table></figure>
<h5 id="Symbol-iterator_28ES6_29"><a href="#Symbol-iterator_28ES6_29" class="headerlink" title="Symbol.iterator(ES6)"></a>Symbol.iterator(ES6)</h5><p>该方法基于<strong>ECMAScript 2015（ES6）规范</strong>, 同 values 方法功能相同.</p>
<p>语法: <em>arr</em>[Symbol.iterator]()</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">"abc"</span>, <span class="string">"xyz"</span>];</span><br><span class="line"><span class="keyword">var</span> iterator = array[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value);<span class="comment">//abc</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value);<span class="comment">//xyz</span></span><br></pre></td></tr></table></figure>
<p>其鸭式辨型写法请参考上述 entries 方法.</p>
<p>由于该方法基于ES6, 并未完全支持, 以下是各浏览器支持版本:</p>
<table>
<thead>
<tr>
<th style="text-align:center">Feature</th>
<th style="text-align:center">Chrome</th>
<th style="text-align:center">Firefox (Gecko)</th>
<th style="text-align:center">Internet Explorer</th>
<th style="text-align:center">Opera</th>
<th style="text-align:center">Safari</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Basic support</td>
<td style="text-align:center">38</td>
<td style="text-align:center"><a href="https://developer.mozilla.org/en-US/Firefox/Releases/36" target="_blank" rel="external">36</a> (36) <a href="#respond">1</a></td>
<td style="text-align:center">未实现</td>
<td style="text-align:center">25</td>
<td style="text-align:center">未实现</td>
</tr>
</tbody>
</table>
<h3 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h3><p>以上, Array.prototype 的各方法 基本介绍完毕, 这些方法之间存在很多共性. 比如:</p>
<ul>
<li>所有插入元素的方法, 比如 push, unshift, 一律返回数组新的长度;</li>
<li>所有删除元素的方法, 比如 pop, shift, splice 一律返回删除的元素, 或者返回删除的多个元素组成的数组;</li>
<li><p>部分遍历方法, 比如 forEach, every, some, filter, map, find, findIndex, 它们都接 function(value,index,array){} 和 thisArg 这样两个参数.</p>
<p>Array.prototype 的所有方法均具有鸭式辨型这种神奇的特性. 它们不止可以用来处理数组对象, 还可以处理类数组对象. </p>
</li>
</ul>
<p>例如 javascript 中一个纯天然的类数组对象字符串(String), 像join 方法就完全适用, 可惜的是 Array.prototype 中很多的方法均会去试图修改当前对象的 length 属性, 比如说 pop, push, shift, unshift 方法, 操作 String 对象时, 它就会报错.</p>
<p>还记得么, Array.prototype本身就是一个数组, 并且它的长度为0.</p>
<p>后续章节我们将继续探索Array的一些事情. 感谢您的阅读! </p>
<p>同时, 以下话题将会逐步去探讨, 敬请关注:</p>
<ul>
<li><code>unicode编码表</code></li>
</ul>
<ul>
<li><code>快速排序</code></li>
</ul>
<ul>
<li><code>插入排序</code></li>
</ul>
<hr>
<p>本问就讨论这么多内容,大家有什么问题或好的想法欢迎在下方参与<a href="#respond">留言和评论</a>.</p>
<p>本文作者: <a href="https://github.com/Louiszhai" target="_blank" rel="external">louis</a></p>
<p>本文链接: <a href="http://louiszhai.github.io/2015/12/29/array/">http://louiszhai.github.io/2015/12/29/array/</a></p>
<p>参考文章</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/prototype" target="_blank" rel="external">Array.prototype - JavaScript | MDN</a></li>
<li><a href="http://www.tuicool.com/articles/YjUBNbN" target="_blank" rel="external">Chrome谷歌浏览器中js代码Array.sort排序的bug乱序解决办法 - yzeng - 推酷</a></li>
<li><a href="http://www.w3help.org/zh-cn/causes/SJ9013" target="_blank" rel="external">SJ9013: Array.prototype.sort当使用了 comparefn 后返回值不为 -1、0、1时，各引擎实现排序结果不一致 - W3Help</a></li>
</ul>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/01/10/js.timer/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          setTimeout &amp; setInterval
        
      </div>
    </a>
  
  
    <a href="/2015/12/22/scopeChain/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">详解JS作用域链及闭包</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
    <a class="jiathis_button_twitter"></a>
    <a class="jiathis_button_plus"></a> 
    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>






<div class="duoshuo">
	<div class="ds-thread" data-thread-key="array" data-title="捋一捋JS的数组" data-url="http://louiszhai.github.io/2015/12/29/array/"></div>
	<style>
		#ds-reset .ds-avatar img{width:54px;height:54px;border-radius:27px;-webkit-border-radius:27px;-moz-border-radius:27px;box-shadow:inset 0 -1px 0 #3333sf;-webkit-box-shadow:inset 0 -1px 0 #3333sf;-webkit-transition:0.4s;-webkit-transition:-webkit-transform 0.4s ease-out;transition:transform 0.4s ease-out;-moz-transition:-moz-transform 0.4s ease-out;}
		#ds-reset .ds-avatar img:hover{box-shadow:0 0 10px #fff;rgba(255,255,255,.6),inset 0 0 20px rgba(255,255,255,1);-webkit-box-shadow:0 0 10px #fff;rgba(255,255,255,.6),inset 0 0 20px rgba(255,255,255,1);transform:rotateZ(360deg);-webkit-transform:rotateZ(360deg);-moz-transform:rotateZ(360deg);}
		p.ds-powered-by,#ds-sync-checkbox,.ds-sync label{display:none!important;}
		#ds-reset .ds-rounded-top{-webkit-border-top-right-radius:0px;-webkit-border-top-left-radius:0px;border-top-right-radius:0px;border-top-left-radius:0px;}
		#ds-thread #ds-reset .ds-textarea-wrapper{background:#fff;border:0;margin-bottom:20px;padding-right:0px;}
		#ds-thread #ds-reset .ds-textarea-wrapper textarea{min-height:80px;border:1px solid #ccc;padding:10px;-webkit-appearance:none;border-radius:0;background-color:#FFFFFF;border-color:#cccccc;box-shadow:inset 0 1px 2px rgba(0,0,0,0.1);color:rgba(0,0,0,0.75);-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-transition:border-color 0.15s linear,background 0.15s linear;-moz-transition:border-color 0.15s linear,background 0.15s linear;-ms-transition:border-color 0.15s linear,background 0.15s linear;-o-transition:border-color 0.15s linear,background 0.15s linear;transition:border-color 0.15s linear,background 0.15s linear;}
		/*#ds-thread #ds-reset .ds-textarea-wrapper textarea:focus{border-color:#999999;background:#fafafa;outline:none;}*/
		#ds-thread #ds-reset .ds-post-options{border-bottom-left-radius:0px;-webkit-border-bottom-left-radius:0px;border:none;background:none!important;}
		#ds-reset .ds-textarea-wrapper textarea:focus{border-color:#66afe9;outline:0;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 8px rgba(102,175,233,.6);box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 8px rgba(102,175,233,.6);}
		#ds-thread #ds-reset .ds-post-button:hover,#ds-thread #ds-reset .ds-post-button:focus{
		    background-color: #51a351;
		    background-position: 0 -32px;
		    color:white;
		}
		#ds-thread #ds-reset .ds-post-toolbar,#ds-reset .ds-avatar{box-shadow:none;}
		#ds-thread #ds-reset .ds-textarea-wrapper textarea:focus{
	    	/*background: none repeat scroll 0 0 #F4FAFF;*/
	    	border-color:#9DD4FD;
	    	border-width:1px;
	    	box-shadow:0 1px 1px rgba(0,0,0,0.075) inset, 0 0 8px rgba(82, 168, 236, 0.6);
	    	outline:0 none;
    	}
		#ds-thread #ds-reset .ds-textarea-wrapper textarea:active{
	    	/*background: none repeat scroll 0 0 #F4FAFF;*/
	    	border-width:1px;
	    	border-color:#9DD4FD;
	    	box-shadow:0 1px 1px rgba(0,0,0,0.075) inset, 0 0 8px rgba(82, 168, 236, 0.6);
	    	outline:0 none;
    	}
    	#ds-thread #ds-reset .ds-post-button{
    		box-shadow: 0 1px 0 rgba(255, 255, 255, 0.2) inset, 0 1px 2px rgba(0, 0, 0, 0.05);
		    border-color: rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.25);
		    border-width: 1px;
		    border-style: solid;
		    border-radius: 3px;
		    background: #5bb75b;
		    color:white;
		    text-shadow:none;
		    transition:background-color 300ms ease-out;
    	}
    	#ds-reset .ds-avatar{
    		background-color:initial;
    	}

	</style>
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"true"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
</div>



</div>
      <link rel="stylesheet" href="/css/content.css" type="text/css">
<footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <img src="/img/top_arrow.png" class="top_arrow" id="top_arrow">
    	<div class="footer-left">
    		&copy; 2016 louis

        <script type="text/javascript">if(location.href.indexOf('localhost')<0){var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan style='position:relative;top:2px' id='cnzz_stat_icon_1256923583'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s11.cnzz.com/z_stat.php%3Fid%3D1256923583%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));}</script>

    	</div>
      	<div class="footer-right">
      		<a href="https://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
<script type="text/javascript">
  //swifty
  /*(function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');
  
  _st('install','4AmBuvmx4Cy-3hvyxeh8','2.0.0');*/
</script>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: false,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="/js/jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>
<script src="/js/content.js" type="text/javascript"></script>






  </div>
  <a href="https://github.com/Louiszhai" style="position: fixed; top: 0; right: 0; border: 0;z-index:9999"><img source="https://camo.githubusercontent.com/a6677b08c955af8400f44c6298f40e7d19cc5b2d/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f677261795f3664366436642e706e67" src="/img/fork_me_on_github.png" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_gray_6d6d6d.png"></a>
</body>
</html>