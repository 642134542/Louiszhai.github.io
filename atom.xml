<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>louis blog</title>
  <subtitle>坚持原著, 深度思考, 力求简单通俗叙事</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://louiszhai.github.io/"/>
  <updated>2017-04-19T11:14:17.000Z</updated>
  <id>http://louiszhai.github.io/</id>
  
  <author>
    <name>路易斯</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>webpack与browser-sync热更新原理深度讲解</title>
    <link href="http://louiszhai.github.io/2017/04/19/hmr/"/>
    <id>http://louiszhai.github.io/2017/04/19/hmr/</id>
    <published>2017-04-19T02:10:00.000Z</published>
    <updated>2017-04-19T11:14:17.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文首发于CSDN网站，下面的版本又经过进一步的修订。</strong></p>
<p>开发环境页面热更新早已是主流，我们不光要吃着火锅唱着歌，享受热更新高效率的快感，更要深入下去探求其原理。</p>
<p>要知道，触类则旁通，常见的需求如赛事网页推送比赛结果、网页实时展示投票或点赞数据、在线评论或弹幕、在线聊天室等，都需要借助热更新功能，才能达到实时的端对端的极致体验。</p>
<p>刚好，最近解决<code>webpack-hot-middleware</code>热更新延迟问题的过程中，我深入接触了EventSource技术。遂本文由此开篇，进一步讲解<code>webpack-hot-middleware</code>，<code>browser-sync</code>背后的技术。</p>
<a id="more"></a>
<h3 id="webpack-hot-middleware"><a href="#webpack-hot-middleware" class="headerlink" title="webpack-hot-middleware"></a><strong>webpack-hot-middleware</strong></h3><p><code>webpack-hot-middleware</code>中间件是webpack的一个plugin，通常结合<code>webpack-dev-middleware</code>一起使用。借助它可以实现浏览器的无刷新更新（热更新），即webpack里的HMR（Hot Module Replacement）。如何配置请参考 <a href="https://github.com/glenjamin/webpack-hot-middleware" target="_blank" rel="external">webpack-hot-middleware</a>，如何理解其相关插件请参考 <a href="https://segmentfault.com/a/1190000005614604?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">手把手深入理解 webpack dev middleware 原理與相關 plugins</a>。</p>
<p>webpack加入<code>webpack-hot-middleware</code>后，内存中的页面将包含HMR相关js，加载页面后，Network栏可以看到如下请求：</p>
<p><img src="http://louiszhai.github.io/docImages/hmr11.png" alt="__webpack_hmr"></p>
<p>__webpack_hmr是一个<code>type</code>为EventSource的请求, 从<code>Time</code>栏可以看出：默认情况下，服务器每十秒推送一条信息到浏览器。</p>
<p><img src="http://louiszhai.github.io/docImages/hmr12.png" alt="hmr每10秒推送一条信息"></p>
<p>如果此时关闭开发服务器，浏览器由于重连机制，将持续抛出类似<code>GET http://www.test.com/__webpack_hmr 502 (Bad Gateway)</code> 这样的错误。重新启动开发服务器后，重连将会成功，此时便会刷新页面。</p>
<p>以上这些便是我们使用时感受到的最初的印象。当然，停留在使用层面不是我们的目标，接下来我们将跳出该中间件，讲解其所使用到的<code>EventSource</code>技术。</p>
<h3 id="EventSource"><a href="#EventSource" class="headerlink" title="EventSource"></a><strong>EventSource</strong></h3><p>EventSource 不是一个新鲜的技术，它早就随着H5规范提出了，正式一点应该叫<code>Server-sent events</code>，即<code>SSE</code>。</p>
<p>鉴于传统的通过ajax轮训获取服务器信息的技术方案已经过时，我们迫切需要一个高效的节省资源的方式去获取服务器信息，一旦服务器资源有更新，能够及时地通知到客户端，从而实时地反馈到用户界面上。EventSource就是这样的技术，它本质上还是HTTP，通过response流实时推送服务器信息到客户端。</p>
<p>新建一个EventSource对象非常简单。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> es = <span class="keyword">new</span> EventSource(<span class="string">'/message'</span>);<span class="comment">// /message是服务端支持EventSource的接口</span></div></pre></td></tr></table></figure>
<p>新创建的EventSource对象拥有如下属性：</p>
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">url(只读)</td>
<td style="text-align:center">es对象请求的服务器url</td>
</tr>
<tr>
<td style="text-align:center">readyState(只读)</td>
<td style="text-align:center">es对象的状态，初始为0，包含CONNECTING (0)，OPEN (1)，CLOSED (2)三种状态</td>
</tr>
<tr>
<td style="text-align:center">withCredentials</td>
<td style="text-align:center">是否允许带凭证等，默认为false，即不支持发送cookie</td>
</tr>
</tbody>
</table>
<p>服务端实现<code>/message</code>接口，需要返回类型为 <code>text/event-stream</code>的响应头。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req，res</span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span>(req.url === <span class="string">'/message'</span>)&#123;</div><div class="line">    res.writeHead(<span class="number">200</span>，&#123;</div><div class="line">      <span class="string">'Content-Type'</span>: <span class="string">'text/event-stream'</span>,</div><div class="line">      <span class="string">'Cache-Control'</span>: <span class="string">'no-cache'</span>,</div><div class="line">      <span class="string">'Connection'</span>: <span class="string">'keep-alive'</span></div><div class="line">    &#125;);</div><div class="line">    setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      res.write(<span class="string">'data: '</span> + +<span class="keyword">new</span> <span class="built_in">Date</span>() + <span class="string">'\n\n'</span>);</div><div class="line">    &#125;, <span class="number">1000</span>);</div><div class="line">  &#125;</div><div class="line">&#125;).listen(<span class="number">8888</span>);</div></pre></td></tr></table></figure>
<p>我们注意到，为了避免缓存，Cache-Control 特别设置成了 no-cache，为了能够发送多个response， Connection被设置成了keep-alive.。发送数据时，请务必保证服务器推送的数据以 <code>data:</code>开始，以<code>\n\n</code>结束，否则推送将会失败(原因就不说了，这是约定的)。</p>
<p>以上，服务器每隔1s主动向客户端发送当前时间戳，为了接受这个信息，客户端需要监听服务器。如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">es.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(e.data); <span class="comment">// 打印服务器推送的信息</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如下是消息推送的过程：</p>
<p><img src="http://louiszhai.github.io/docImages/hot-replace01.gif" alt="response size不断增加"></p>
<p><img src="http://louiszhai.github.io/docImages/hot-replace02.gif" alt="接收消息"></p>
<p>你以为es只能监听message事件吗？并不是，message只是缺省的事件类型。实际上，它可以监听任何指定类型的事件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">es.addEventListener(<span class="string">"####"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;<span class="comment">// 事件类型可以随你定义</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'####:'</span>, e.data);</div><div class="line">&#125;，<span class="literal">false</span>);</div></pre></td></tr></table></figure>
<p>服务器发送不同类型的事件时，需要指定event字段。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">res.write(<span class="string">'event: ####\n'</span>);</div><div class="line">res.write(<span class="string">'data: 这是一个自定义的####类型事件\n'</span>);</div><div class="line">res.write(<span class="string">'data: 多个data字段将被解析成一个字段\n\n'</span>);</div></pre></td></tr></table></figure>
<p>如下所示：</p>
<p><img src="http://louiszhai.github.io/docImages/hot-replace04.png" alt="####消息"></p>
<p>可以看到，服务端指定event事件名为”####”后，客户端触发了对应的事件回调，同时服务端设置的多个data字段，客户端使用换行符连接成了一个字符串。</p>
<p>不仅如此，事件流中还可以混合多种事件，请看我们是怎么收到消息的，如下：</p>
<p><img src="http://louiszhai.github.io/docImages/hot-replace03.gif" alt="混合消息"></p>
<p>除此之外，es对象还拥有另外3个方法: <code>onopen()</code>、<code>onerror()</code>、<code>close()</code>，请参考如下实现。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">es.onopen = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="comment">// 链接打开时的回调</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'当前状态readyState:'</span>, es.readyState);<span class="comment">// open时readyState===1</span></div><div class="line">&#125;</div><div class="line">es.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="comment">// 出错时的回调(网络问题,或者服务下线等都有可能导致出错)</span></div><div class="line">  <span class="built_in">console</span>.log(es.readyState);<span class="comment">// 出错时readyState===0</span></div><div class="line">  es.close();<span class="comment">// 出错时，chrome浏览器会每隔3秒向服务器重发原请求,直到成功. 因此出错时，可主动断开原连接.</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用EventSource技术实时更新网页信息十分高效。实际使用中，我们几乎不用担心兼容性问题，主流浏览器都了支持EventSource，当然，除了掉队的IE系。对于不支持的浏览器，其PolyFill方案请参考<a href="https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-Browser-Polyfills#eventsource" target="_blank" rel="external">HTML5 Cross Browser Polyfills</a>。</p>
<h4 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a><strong>CORS</strong></h4><p>另外，如果需要支持跨域调用，请设置响应头<code>Access-Control-Allow-Origin&#39;: &#39;*&#39;</code>。</p>
<p>如需支持发送cookie，请设置响应头<code>Access-Control-Allow-Origin&#39;: req.headers.origin</code> 和 <code>Access-Control-Allow-Credentials:true</code>，并且创建es对象时，需要明确指定是否发送凭证。如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> es = <span class="keyword">new</span> EventSource(<span class="string">'/message'</span>, &#123;</div><div class="line">  <span class="attr">withCredentials</span>: <span class="literal">true</span></div><div class="line">&#125;); <span class="comment">// 创建时指定配置才是有效的</span></div><div class="line">es.withCredentials = <span class="literal">true</span>; <span class="comment">// 与ajax不同，这样设置是无效的</span></div></pre></td></tr></table></figure>
<p>以下是主流浏览器对EventSource的CORS的支持：</p>
<table>
<thead>
<tr>
<th style="text-align:center">Firefox</th>
<th style="text-align:center">Opera</th>
<th style="text-align:center">Chrome</th>
<th style="text-align:center">Safari</th>
<th style="text-align:center">iOS</th>
<th style="text-align:center">Android</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">10+</td>
<td style="text-align:center">12+</td>
<td style="text-align:center">26+</td>
<td style="text-align:center">7.0+</td>
<td style="text-align:center">7.0+</td>
<td style="text-align:center">4.4+</td>
</tr>
</tbody>
</table>
<h4 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置"></a><strong>nginx配置</strong></h4><p>既然说到了EventSource，便有必要谈谈遇到的坑，接下来，就说说我遇到的webpack热更新延迟问题。</p>
<p>如我们所知，webpack借助webpack-hot-middleware插件，实现了网页热更新机制，正常情况下，浏览器打开 <a href="http://localhost:8080" target="_blank" rel="external">http://localhost:8080</a> 这样的网页即可开始调试。然而实际开发中，由于远程服务器需要种cookie登录态到特定的域名上等原因，因此本地往往会用nginx做一层反向代理。即把 <a href="http://www.test.com" target="_blank" rel="external">http://www.test.com</a> 的请求转发到 <a href="http://localhost:8080" target="_blank" rel="external">http://localhost:8080</a> 上(配置过程这里不详述，具体请参考<a href="http://louiszhai.github.io/2016/11/02/ajax/ajax调试技巧">Ajax知识体系大梳理-ajax调试技巧</a>)。转发过后，发现热更新便延迟了。</p>
<p>原因是nginx默认开启的buffer机制缓存了服务器推送的片段信息，缓存达到一定的量才会返回响应内容。只要关闭proxy_buffering即可。配置如下所示：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="section">server</span> &#123;</div><div class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</div><div class="line">    <span class="attribute">server_name</span>  www.test.company.com;</div><div class="line">    <span class="attribute">location</span> / &#123;</div><div class="line">        <span class="attribute">proxy_pass</span> http://localhost:8080;</div><div class="line">        <span class="attribute">proxy_buffering</span> <span class="literal">off</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至此，EventSource部分便告一段落。学习讲究由浅入深，循序渐进。后面我将重点讲解的<code>browser-sync</code>热更新机制，请耐心细读。</p>
<h3 id="browser-sync"><a href="#browser-sync" class="headerlink" title="browser-sync"></a><strong>browser-sync</strong></h3><p>开发中使用<code>browser-sync</code>插件调试，一个网页里的所有交互动作（包括滚动，输入，点击等等），可以实时地同步到其他所有打开该网页的设备，能够节省大量的手工操作时间，从而带来流畅的开发调试体验。目前<code>browser-sync</code>可以结合<code>Gulp</code>或<code>Grunt</code>一起使用，其API请参考：<a href="http://www.browsersync.cn/docs/api/" target="_blank" rel="external">Browsersync API</a>。</p>
<p>通过上面的了解，我们知道<code>EventSouce</code>的使用是比较便捷的，那为什么<code>browser-sync</code>不使用EventSource技术进行代码推送呢？这是因为<code>browser-sync</code>插件共做了两件事：</p>
<ul>
<li>开发更新了一段新的逻辑，服务器实时推送代码改动信息。数据流：服务器 —&gt; 浏览器，使用EventSource技术同样能够实现。</li>
<li>用户操作网页，滚动、输入或点击等，操作信息实时发送给服务器，然后再由服务器将操作同步给其他已打开的网页。数据流：浏览器 —&gt; 服务器 —&gt; 浏览器，该部分功能EventSource技术已无能为力。</li>
</ul>
<p>以上，<code>browser-sync</code>使用WebSocket技术达到实时推送代码改动和用户操作两个目的。至于它是如何计算推送内容，根据不同推送内容采取何种响应策略，不在本次讨论范围之内。下面我们将讲解其核心的WebSocket技术。</p>
<h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a><strong>WebSocket</strong></h3><p>WebSocket是基于TCP的全双工通讯的协议，它与EventSource有着本质上的不同.(前者基于TCP，后者依然基于HTTP) 该协议于2011年被IETF定为标准RFC6455，后被RFC7936补充. WebSocket api也被W3C定为标准。</p>
<p>WebSocket使用和HTTP相同的TCP端口，默认为80， 统一资源标志符为ws，运行在TLS之上时，默认使用443，统一资源标志符为wss。它通过<code>101 switch protocol</code>进行一次TCP握手，即从HTTP协议切换成WebSocket通信协议。</p>
<p>相对于HTTP协议，WebSocket拥有如下优点：</p>
<ul>
<li>全双工，实时性更强。</li>
<li>相对于http携带完整的头部，WebSocket请求头部明显减少。</li>
<li>保持连接状态，不用再验权了。</li>
<li>二进制支持更强，Websocket定义了二进制帧，处理更轻松。</li>
<li>Websocket协议支持扩展，可以自定义的子协议，如 <code>permessage-deflate</code> 扩展。</li>
</ul>
<h4 id="支持性"><a href="#支持性" class="headerlink" title="支持性"></a><strong>支持性</strong></h4><p>优秀技术的落地，调研兼容性是必不可少的环节。所幸的是，现代浏览器对WebSocket的支持比较友好，如下是PC端兼容性：</p>
<table>
<thead>
<tr>
<th style="text-align:center">IE/Edge</th>
<th style="text-align:center">Firefox</th>
<th style="text-align:center">Chrome</th>
<th style="text-align:center">Safari</th>
<th style="text-align:center">Opera</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">10+</td>
<td style="text-align:center">11+</td>
<td style="text-align:center">16+</td>
<td style="text-align:center">7+</td>
<td style="text-align:center">12.1+</td>
</tr>
</tbody>
</table>
<p>如下是mobile端兼容性：</p>
<table>
<thead>
<tr>
<th style="text-align:center">iOS Safari</th>
<th style="text-align:center">Android</th>
<th style="text-align:center">Android Chrome</th>
<th style="text-align:center">Android UC</th>
<th style="text-align:center">QQ Browser</th>
<th style="text-align:center">Opera Mini</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">7.1+</td>
<td style="text-align:center">4.4+</td>
<td style="text-align:center">57+</td>
<td style="text-align:center">11.4+</td>
<td style="text-align:center">1.2+</td>
<td style="text-align:center">-</td>
</tr>
</tbody>
</table>
<h4 id="Frame"><a href="#Frame" class="headerlink" title="Frame"></a><strong>Frame</strong></h4><p>根据RFC6455文档，WebSocket协议基于Frame而非Stream（EventSource是基于Stream的）。因此其传输的数据都是Frame（帧）。想要了解数据的往返，弄懂协议处理过程，Frame的解读是必不可少。如下便是Frame的结构：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"> 0                   1                   2                   3</div><div class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</div><div class="line">+-+-+-+-+-------+-+-------------+-------------------------------+</div><div class="line">|<span class="string">F</span>|<span class="string">R</span>|<span class="string">R</span>|<span class="string">R</span>|<span class="string"> opcode</span>|<span class="string">M</span>|<span class="string"> Payload len </span>|<span class="string">    Extended payload length    </span>|</div><div class="line">|<span class="string">I</span>|<span class="string">S</span>|<span class="string">S</span>|<span class="string">S</span>|<span class="string">  (4)  </span>|<span class="string">A</span>|<span class="string">     (7)     </span>|<span class="string">             (16/64)           </span>|</div><div class="line">|<span class="string">N</span>|<span class="string">V</span>|<span class="string">V</span>|<span class="string">V</span>|<span class="string">       </span>|<span class="string">S</span>|<span class="string">             </span>|<span class="string">   (if payload len==126/127)   </span>|</div><div class="line">|<span class="string"> </span>|<span class="string">1</span>|<span class="string">2</span>|<span class="string">3</span>|<span class="string">       </span>|<span class="string">K</span>|<span class="string">             </span>|<span class="string">                               </span>|</div><div class="line">+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +</div><div class="line">|<span class="string">     Extended payload length continued，if payload len == 127  </span>|</div><div class="line">+ - - - - - - - - - - - - - - - +-------------------------------+</div><div class="line">|<span class="string">                               </span>|<span class="string">Masking-key，if MASK set to 1  </span>|</div><div class="line">+-------------------------------+-------------------------------+</div><div class="line">|<span class="string"> Masking-key (continued)       </span>|<span class="string">          Payload Data         </span>|</div><div class="line">+-------------------------------- - - - - - - - - - - - - - - - +</div><div class="line">:                     Payload Data continued ...                :</div><div class="line">+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +</div><div class="line">|<span class="string">                     Payload Data continued ...                </span>|</div><div class="line">+---------------------------------------------------------------+</div></pre></td></tr></table></figure>
<p>第一个字节包含FIN、RSV、Opcode。</p>
<ul>
<li><p>FIN：size为1bit，标示是否最后一帧。<code>%x0</code>表示还有后续帧，<code>%x1</code>表示这是最后一帧。</p>
</li>
<li><p>RSV1、2、3，每个size都是1bit，默认值都是0，如果没有定义非零值的含义，却出现了非零值，则WebSocket链接将失败。</p>
</li>
<li><p>Opcode，size为4bits，表示『payload data』的类型。如果收到未知的opcode，连接将会断开。已定义的opcode值如下：</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">%<span class="selector-tag">x0</span></span>:	代表连续的帧</div><div class="line"><span class="tag">%<span class="selector-tag">x1</span></span>:	文本帧</div><div class="line"><span class="tag">%<span class="selector-tag">x2</span></span>:	二进制帧</div><div class="line"><span class="tag">%<span class="selector-tag">x3</span></span>~7:	预留的非控制帧</div><div class="line"><span class="tag">%<span class="selector-tag">x8</span></span>:	关闭握手帧</div><div class="line"><span class="tag">%<span class="selector-tag">x9</span></span>:	ping帧，后续心跳连接会讲到</div><div class="line"><span class="tag">%<span class="selector-tag">xA</span></span>:	pong帧，后续心跳连接会讲到</div><div class="line"><span class="tag">%<span class="selector-tag">xB</span></span>~F:	预留的非控制帧</div></pre></td></tr></table></figure>
</li>
</ul>
<p>第二个字节包含Mask、Payload len。</p>
<ul>
<li><p>Mask：size为1bit，标示『payload data』是否添加掩码。所有从客户端发送到服务端的帧都会被置为1，如果置1，<code>Masking-key</code>便会赋值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//若server是一个WebSocket服务端实例</span></div><div class="line"><span class="comment">//监听客户端消息</span></div><div class="line">server.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">msg, flags</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'client say: %s'</span>, msg);</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'mask value:'</span>, flags.masked);<span class="comment">// true，进一步佐证了客户端发送到服务端的Mask帧都会被置为1</span></div><div class="line">&#125;);</div><div class="line"><span class="comment">//监听客户端pong帧响应</span></div><div class="line">server.on(<span class="string">'pong'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">msg, flags</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'pong data: %s'</span>, msg);</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'mask value:'</span>, flags.masked);<span class="comment">// true，进一步佐证了客户端发送到服务端的Mask帧都会被置为1</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>Payload len：size为7bits，即使是当做无符号整型也只能表示0~127的值，所以它不能表示更大的值，因此规定”Payload data”长度小于或等于125的时候才用来描述数据长度。如果<code>Payload len==126</code>，则使用随后的2bytes（16bits）来存储数据长度。如果<code>Payload len==127</code>，则使用随后的8bytes（64bits）来存储数据长度。</p>
</li>
</ul>
<p>以上，扩展的Payload len可能占据第三至第四个或第三至第十个字节。紧随其后的是”Mask-key”。</p>
<ul>
<li>Mask-key：size为0或4bytes（32bits），默认为0，与前面Mask呼应，从客户端发送到服务端的帧都包含4bytes（32bits）的掩码，一旦掩码被设置，所有接收到的”payload data”都必须与该值以一种算法做异或运算来获取真实值。</li>
<li>Payload data：size为”Extension data” 和 “Application data” 的总和，一般”Extension data”数据为空。</li>
<li>Extension data：默认为0，如果扩展被定义，扩展必须指定”Extension data”的长度。</li>
<li>Application data：占据”Extension data”之后剩余帧的空间。</li>
</ul>
<p>关于Frame的更多理论介绍不妨读读 <a href="https://github.com/abbshr/abbshr.github.io/issues/22" target="_blank" rel="external">学习WebSocket协议—从顶层到底层的实现原理（修订版）</a>。</p>
<p>关于Frame的数据帧解析不妨读读 <a href="https://www.web-tinker.com/article/20306.html" target="_blank" rel="external">WebSocket(贰) 解析数据帧</a> 及其后续文章。</p>
<h4 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a><strong>建立连接</strong></h4><p>了解了Frame的数据结构后，我们来实际练习下。浏览器上，新建一个ws对象十分简单。如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">'ws://127.0.0.1:10103/'</span>);<span class="comment">// 本地使用10103端口进行测试</span></div></pre></td></tr></table></figure>
<p>新建的WebSocket对象如下所示：</p>
<p><img src="http://louiszhai.github.io/docImages/hot-replace09.png" alt="Websocket对象"></p>
<p>这中间包含了一次Websocket握手的过程，我们分两步来理解。</p>
<p>第一步，客户端请求。</p>
<p><img src="http://louiszhai.github.io/docImages/hot-replace05.png" alt="Websocket Request"></p>
<p>这是一个GET请求，主要字段如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Connection: Upgrade</div><div class="line">Upgrade: websocket</div><div class="line">Sec-WebSocket-Key:61x6lFN92sJHgzXzCHfBJQ==</div><div class="line">Sec-WebSocket-Version:13</div></pre></td></tr></table></figure>
<p>Connection字段指定为Upgrade，表示客户端希望连接升级。</p>
<p>Upgrade字段设置为websocket，表示希望升级至Websocket协议。</p>
<p>Sec-WebSocket-Key字段是随机字符串，服务器根据它来构造一个SHA-1的信息摘要。</p>
<p>Sec-WebSocket-Version表示支持的Websocket版本。RFC6455要求使用的版本是13。</p>
<p>甚至我们可以从请求截图里看出，Origin是<code>file://</code>，而Host是<code>127.0.0.1:10103</code>，明显不是同一个域下，但依然可以请求成功，说明Websocket协议是不受同源策略限制的(同源策略限制的是http协议)。</p>
<p>第二步，服务端响应。</p>
<p><img src="http://louiszhai.github.io/docImages/hot-replace07.png" alt="Websocket Response"></p>
<p>Status Code: 101 Switching Protocols 表示Websocket协议通过101状态码进行握手。</p>
<p>Sec-WebSocket-Accept字段是由Sec-WebSocket-Key字段加上特定字符串”258EAFA5-E914-47DA-95CA-C5AB0DC85B11”，计算SHA-1摘要，然后再base64编码之后生成的. 该操作可避免普通http请求，被误认为Websocket协议。</p>
<p>Sec-WebSocket-Extensions字段表示服务端对Websocket协议的扩展。</p>
<p>以上，WebSocket构造器不止可以传入url，还能传入一个可选的协议名称字符串或数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ws = <span class="keyword">new</span> WebSocket(<span class="string">'ws://127.0.0.1:10103/'</span>, [<span class="string">'abc'</span>,<span class="string">'son_protocols'</span>]);</div></pre></td></tr></table></figure>
<h4 id="服务端实现"><a href="#服务端实现" class="headerlink" title="服务端实现"></a><strong>服务端实现</strong></h4><p>等等，我们慢一点，上面好像漏掉了一步，似乎没有提到服务端是怎么实现的。请继续往下看：</p>
<p>先做一些准备。ws是一个nodejs版的WebSocketServer实现。使用 <code>npm install ws</code> 即可安装。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> WebSocketServer = <span class="built_in">require</span>(<span class="string">'ws'</span>).Server，</div><div class="line">    server = <span class="keyword">new</span> WebSocketServer(&#123;<span class="attr">port</span>: <span class="number">10103</span>&#125;);</div><div class="line">server.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</div><div class="line">  s.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123; <span class="comment">//监听客户端消息</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'client say: %s'</span>, msg);</div><div class="line">  &#125;);</div><div class="line">  s.send(<span class="string">'server ready!'</span>);<span class="comment">// 连接建立好后，向客户端发送一条消息</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>以上，<code>new WebSocketServer()</code>创建服务器时如需权限验证，请指定<code>verifyClient</code>为验权的函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">server = <span class="keyword">new</span> WebSocketServer(&#123;</div><div class="line">  <span class="attr">port</span>: <span class="number">10103</span>,</div><div class="line">  <span class="attr">verifyClient</span>: verify</div><div class="line">&#125;);</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">verify</span>(<span class="params">info</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(info));<span class="comment">// [ 'origin', 'secure', 'req' ]</span></div><div class="line">  <span class="built_in">console</span>.log(info.orgin);<span class="comment">// "file://"</span></div><div class="line">  <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">// 返回true时表示验权通过，否则客户端将抛出"HTTP Authentication failed"错误</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上，<code>verifyClient</code>指定的函数只有一个形参，若为它显式指定两个形参，那么第一个参数同上info，第二个参数将是一个<code>cb</code>回调函数。该函数用于显式指定拒绝时的HTTP状态码等，它默认拥有3个形参，依次为：</p>
<ul>
<li>result，布尔值类型，表示是否通过权限验证。</li>
<li>code，数值类型，若result值为false时，表示HTTP的错误状态码。</li>
<li>name，字符串类型，若result值为false时，表示HTTP状态码的错误信息。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 若verify定义如下</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">verify</span>(<span class="params">info, cb</span>)</span>&#123;</div><div class="line">  <span class="comment">//一旦拥有第二个形参，如果不调用，默认将通过验权</span></div><div class="line">  cb(<span class="literal">false</span>, <span class="number">401</span>, <span class="string">'权限不够'</span>);<span class="comment">// 此时表示验权失败，HTTP状态码为401，错误信息为"权限不够"</span></div><div class="line">  <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">// 一旦拥有第二个形参，响应就被cb接管了，返回什么值都不会影响前面的处理结果</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除了<code>port</code> 和 <code>verifyClient</code>设置外，其它设置项及更多API，请参考文档 <a href="https://github.com/websockets/ws/blob/master/doc/ws.md" target="_blank" rel="external">ws-doc</a>。</p>
<h4 id="发送和监听消息"><a href="#发送和监听消息" class="headerlink" title="发送和监听消息"></a><strong>发送和监听消息</strong></h4><p>接下来，我们来实现消息收发。如下是客户端发送消息。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ws.onopen = function(e)&#123;</div><div class="line">  // 可发送字符串，ArrayBuffer 或者 Blob数据</div><div class="line">  ws.send('client ready!);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>客户端监听信息。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'server say:'</span>, e.data);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>如下是浏览器的运行截图。</p>
<p><img src="http://louiszhai.github.io/docImages/hot-replace06.png" alt="message"></p>
<p>消息的内容都在Frames栏，第一条彩色背景的信息是客户端发送的，第二条是服务端发送的。两条消息的长度都是13。</p>
<p>如下是Timing栏，不止是WebSocket，包括EventSource，都有这样的黄色高亮警告。</p>
<p><img src="http://louiszhai.github.io/docImages/hot-replace08.png" alt="Websocket Request"></p>
<p>该警告说明：请求还没完成。实际上，直到一方连接close掉，请求才会完成。</p>
<h4 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a><strong>关闭连接</strong></h4><p>说到close，ws的close方法比es的略复杂。</p>
<p>语法：<em>close(short code，string reason);</em></p>
<p>close默认可传入两个参数。code是数字，表示关闭连接的状态号，默认是1000，即正常关闭。（code取值范围从0到4999，其中有些是保留状态号，正常关闭时只能指定为1000或者3000~4999之间的值，具体请参考<a href="https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes" target="_blank" rel="external">CloseEvent - Web APIs</a>）。reason是UTF-8文本，表示关闭的原因（文本长度需小于或等于123字节）。</p>
<p>由于code 和 reason都有限制，因此该方法可能抛出异常，建议catch下.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">  ws.close(<span class="number">1001</span>, <span class="string">'CLOSE_GOING_AWAY'</span>);</div><div class="line">&#125;<span class="keyword">catch</span>(e)&#123;</div><div class="line">  <span class="built_in">console</span>.log(e);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ws对象还拥有onclose和onerror监听器，分别监听关闭和错误事件。（注：EventSource没有onclose监听）</p>
<h4 id="拥有的属性"><a href="#拥有的属性" class="headerlink" title="拥有的属性"></a><strong>拥有的属性</strong></h4><p>ws的readyState属性拥有4个值，比es的readyState的多一个CLOSING的状态。</p>
<table>
<thead>
<tr>
<th style="text-align:center">常量</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">EventSource(值)</th>
<th style="text-align:center">WebSocket(值)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">CONNECTING</td>
<td style="text-align:center">连接未初始化</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">OPEN</td>
<td style="text-align:center">连接已就绪</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">CLOSING</td>
<td style="text-align:center">连接正在关闭</td>
<td style="text-align:center">-</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">CLOSED</td>
<td style="text-align:center">连接已关闭</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
</tr>
</tbody>
</table>
<p>另外，除了两种都有的url属性外，WebSocket对象还拥有更多的属性。</p>
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">binaryType</td>
<td style="text-align:center">被传输二进制内容的类型，有blob，arraybuffer两种</td>
</tr>
<tr>
<td style="text-align:center">bufferedAmount</td>
<td style="text-align:center">待传输的数据的长度</td>
</tr>
<tr>
<td style="text-align:center">extensions</td>
<td style="text-align:center">表示服务器选用的扩展</td>
</tr>
<tr>
<td style="text-align:center">protocol</td>
<td style="text-align:center">指的是构造器第二个参数传入的子协议名称</td>
</tr>
</tbody>
</table>
<h4 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a><strong>文件上传</strong></h4><p>以前一直是使用ajax做文件上传，实际上，Websocket上传文件也是一把好刀. 其send方法可以发送String，ArrayBuffer，Blob共三种数据类型，发送二进制文件完全不在话下。</p>
<p>由于各个浏览器对Websocket单次发送的数据有限制，所以我们需要将待上传文件切成片段去发送。如下是实现。</p>
<p>1) html。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">id</span>=<span class="string">"file"</span>/&gt;</span></div></pre></td></tr></table></figure>
<p>2) js。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">'ws://127.0.0.1:10103/'</span>);<span class="comment">// 连接服务器</span></div><div class="line"><span class="keyword">const</span> fileSelect = <span class="built_in">document</span>.getElementById(<span class="string">'file'</span>);</div><div class="line"><span class="keyword">const</span> size = <span class="number">1024</span> * <span class="number">128</span>;<span class="comment">// 分段发送的文件大小(字节)</span></div><div class="line"><span class="keyword">let</span> curSize, total, file, fileReader;</div><div class="line"></div><div class="line">fileSelect.onchange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  file = <span class="keyword">this</span>.files[<span class="number">0</span>];<span class="comment">// 选中的待上传文件</span></div><div class="line">  curSize = <span class="number">0</span>;<span class="comment">// 当前已发送的文件大小</span></div><div class="line">  total = file.size;<span class="comment">// 文件大小</span></div><div class="line">  ws.send(file.name);<span class="comment">// 先发送待上传文件的名称</span></div><div class="line">  fileReader = <span class="keyword">new</span> FileReader();<span class="comment">// 准备读取文件</span></div><div class="line">  fileReader.onload = loadAndSend;</div><div class="line">  readFragment();<span class="comment">// 读取文件片段</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadAndSend</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span>(ws.bufferedAmount &gt; size * <span class="number">5</span>)&#123;<span class="comment">// 若发送队列中的数据太多,先等一等</span></div><div class="line">    setTimeout(loadAndSend，<span class="number">4</span>);</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  ws.send(fileReader.result);<span class="comment">// 发送本次读取的片段内容</span></div><div class="line">  curSize += size;<span class="comment">// 更新已发送文件大小</span></div><div class="line">  curSize &lt; total ? readFragment() : <span class="built_in">console</span>.log(<span class="string">'upload successed!'</span>);<span class="comment">// 下一步操作</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFragment</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">const</span> blob = file.slice(curSize, curSize + size);<span class="comment">// 获取文件指定片段</span></div><div class="line">  fileReader.readAsArrayBuffer(blob);<span class="comment">// 读取文件为ArrayBuffer对象</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>3) server(node)。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> WebSocketServer = <span class="built_in">require</span>(<span class="string">'ws'</span>).Server,</div><div class="line">    server = <span class="keyword">new</span> WebSocketServer(&#123;<span class="attr">port</span>: <span class="number">10103</span>&#125;),<span class="comment">// 启动服务器</span></div><div class="line">    fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line">server.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">wsServer</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> fileName, i = <span class="number">0</span>;<span class="comment">// 变量定义不可放在全局,因每个连接都不一样,这里才是私有作用域</span></div><div class="line">  server.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data, flags</span>)</span>&#123;<span class="comment">// 监听客户端消息</span></div><div class="line">    <span class="keyword">if</span>(flags.binary)&#123;<span class="comment">// 判断是否二进制数据</span></div><div class="line">      <span class="keyword">var</span> method = i++ ? <span class="string">'appendFileSync'</span> : <span class="string">'writeFileSync'</span>;</div><div class="line">      <span class="comment">// 当前目录下写入或者追加写入文件(建议加上try语句捕获可能的错误)</span></div><div class="line">      fs[method](<span class="string">'./'</span> + fileName, data，<span class="string">'utf-8'</span>);</div><div class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">// 非二进制数据则认为是文件名称</span></div><div class="line">      fileName = data;</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">  wsServer.send(<span class="string">'server ready!'</span>);<span class="comment">// 告知客户端服务器已就绪</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>运行效果如下：</p>
<p><img src="http://louiszhai.github.io/docImages/hot-replace10.png" alt="Websocket upload"></p>
<p>上述测试代码中没有过多涉及服务器的存储过程。通常，服务器也会有缓存区上限，如果客户端单次发送的数据量超过服务端缓存区上限，那么服务端也需要多次读取。</p>
<h4 id="心跳连接"><a href="#心跳连接" class="headerlink" title="心跳连接"></a><strong>心跳连接</strong></h4><p>生产环境下上传一个文件远比本地测试来得复杂。实际上，从客户端到服务端，中间存在着大量的网络链路，如路由器，防火墙等等。一份文件的上传要经过中间的层层路由转发，过滤。这些中间链路可能会认为一段时间没有数据发送，就自发切断两端的连接。这个时候，由于TCP并不定时检测连接是否中断，而通信的双方又相互没有数据发送，客户端和服务端依然会一厢情愿的信任之前的连接，长此以往，将使得大量的服务端资源被WebSocket连接占用。</p>
<p>正常情况下，TCP的四次挥手完全可以通知两端去释放连接。但是上述这种普遍存在的异常场景，将使得连接的释放成为梦幻。</p>
<p>为此，早在websocket协议实现时，设计者们便提供了一种 Ping/Pong Frame的心跳机制。一端发送Ping Frame，另一端以 Pong Frame响应。这种Frame是一种特殊的数据包，它只包含一些元数据，能够在不影响原通信的情况下维持住连接。</p>
<p>根据规范<a href="https://tools.ietf.org/html/rfc6455#section-5.5.2" target="_blank" rel="external">RFC 6455</a>，Ping Frame包含一个值为9的opcode，它可能携带数据。收到Ping Frame后，Pong Frame必须被作为响应发出。Pong Frame包含一个值为10的opcode，它将包含与Ping Frame中相同的数据。</p>
<p>借助ws包，服务端可以这么来发送Ping Frame。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wsServer.ping();</div></pre></td></tr></table></figure>
<p>同时，需要监听客户端响应的pong Frame.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">wsServer.on(<span class="string">'pong'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data, flags</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(data);<span class="comment">// ""</span></div><div class="line">  <span class="built_in">console</span>.log(flags);<span class="comment">// &#123; masked: true，binary: true &#125;</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>以上，由于Ping Frame 不带数据，因此作为响应的Pong Frame的data值为空串。遗憾的是，目前浏览器只能被动发送Pong Frame作为响应（<a href="http://stackoverflow.com/questions/10585355/sending-websocket-ping-pong-frame-from-browser" target="_blank" rel="external">Sending websocket ping/pong frame from browser</a>），无法通过JS API主动向服务端发送Ping Frame。因此对于web服务，可以采取服务端主动ping的方式，来保持住链接。实际应用中，服务端还需要设置心跳的周期，以保证心跳连接可以一直持续。同时，还应该有重发机制，若连续几次没有收到心跳连接的回复，则认为连接已经断开，此时便可以关闭Websocket连接了。</p>
<h4 id="Socket-IO"><a href="#Socket-IO" class="headerlink" title="Socket.IO"></a><strong>Socket.IO</strong></h4><p>WebSocket出世已久，很多优秀的大神基于此开发出了各式各样的库。其中<a href="http://Socket.IO" target="_blank" rel="external">Socket.IO</a>是一个非常不错的开源WebSocke库，旨在抹平浏览器之间的兼容性问题。它基于Node.js，支持以下方式优雅降级：</p>
<ul>
<li>Websocket</li>
<li>Adobe® Flash® Socket</li>
<li>AJAX long polling</li>
<li>AJAX multipart streaming</li>
<li>Forever Iframe</li>
<li>JSONP Polling</li>
</ul>
<p>如何在项目中使用Socket.IO，请参考<a href="https://github.com/nswbmw/N-chat/wiki/%E7%AC%AC%E4%B8%80%E7%AB%A0-socket.io-%E7%AE%80%E4%BB%8B%E5%8F%8A%E4%BD%BF%E7%94%A8" target="_blank" rel="external">第一章 socket.io 简介及使用</a>。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h3><p>EventSource，本质依然是HTTP，它仅提供服务端到客户端的单向文本数据传输，不需要心跳连接，连接断开会持续触发重连。</p>
<p>WebSocket协议，基于TCP协议，它提供双向数据传输，支持二进制，需要心跳连接，连接断开不会重连。</p>
<p>EventSource更轻量和简单，WebSocket支持性更好（因其支持IE10+）。通常来说，使用EventSource能够完成的功能，使用WebSocket一样能够做到，反之却不行，使用时若遇到连接断开或抛错，请及时调用各自的<code>close</code>方法主动释放资源。</p>
<hr>
<p>本问就讨论这么多内容,大家有什么问题或好的想法欢迎在下方参与<a href="#respond">留言和评论</a>。</p>
<p>本文作者： <a href="https://github.com/Louiszhai" target="_blank" rel="external">louis</a></p>
<p>本文链接： <a href="http://louiszhai.github.io/2017/04/19/hmr/">http://louiszhai.github.io/2017/04/19/hmr/</a></p>
<p>参考文章</p>
<ul>
<li><a href="https://tools.ietf.org/html/rfc6455#section-5.5.2" target="_blank" rel="external">RFC 6455 - The WebSocket Protocol</a></li>
<li><a href="https://cnodejs.org/topic/5463840472f405c829029f62" target="_blank" rel="external">用node.js实现HTML5原生的comet(长连接) </a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Server-sent_events/Using_server-sent_events" target="_blank" rel="external">使用服务器发送事件 - Server-sent events</a></li>
<li><a href="http://www.cnblogs.com/tianma3798/p/5852475.html" target="_blank" rel="external">HTML5 文件域+FileReader 分段读取文件并上传(七)-WebSocket</a></li>
<li><a href="http://www.cnblogs.com/axes/p/4514199.html?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">nodejs实现Websocket的数据接收发送</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      EventSource 热更新 webpack热更新延迟 websocket 心跳连接 Frame Socket.IO browser-sync webpack-hot-middleware
    
    </summary>
    
    
      <category term="Web" scheme="http://louiszhai.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>浏览器缓存机制剖析</title>
    <link href="http://louiszhai.github.io/2017/04/07/http-cache/"/>
    <id>http://louiszhai.github.io/2017/04/07/http-cache/</id>
    <published>2017-04-07T00:00:00.000Z</published>
    <updated>2017-04-25T10:26:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>缓存一直是前端优化的主战场, 利用好缓存就成功了一半. 本篇从http请求和响应的头域入手, 让你对浏览器缓存有个整体的概念. 最终你会发现强缓存, 协商缓存 和 启发式缓存是如此的简单.</p>
<h3 id="导读"><a href="#导读" class="headerlink" title="导读"></a><strong>导读</strong></h3><p>我不知道拖延症是有多严重, 反正去年3月开的题, 直到今年4月才开始写.(请尽情吐槽吧)</p>
<a id="more"></a>
<p>浏览器对于请求资源, 拥有一系列成熟的缓存策略. 按照发生的时间顺序分别为<strong>存储策略</strong>, <strong>过期策略</strong>, <strong>协商策略</strong>, 其中<strong>存储策略</strong>在收到响应后应用, <strong>过期策略</strong>, <strong>协商策略</strong>在发送请求前应用. 流程图如下所示.</p>
<div id="flowchart-0" class="flow-chart"></div>

<p>废话不多说, 我们先来看两张表格.</p>
<p>1.http header中与缓存有关的key.</p>
<table>
<thead>
<tr>
<th style="text-align:center">key</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">存储策略</th>
<th style="text-align:center">过期策略</th>
<th style="text-align:center">协商策略</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>Cache-Control</strong></td>
<td style="text-align:center">指定缓存机制,覆盖其它设置</td>
<td style="text-align:center">✔️</td>
<td style="text-align:center">✔️</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><strong>Pragma</strong></td>
<td style="text-align:center">http1.0字段,指定缓存机制</td>
<td style="text-align:center">✔️</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><strong>Expires</strong></td>
<td style="text-align:center">http1.0字段,指定缓存的过期时间</td>
<td style="text-align:center"></td>
<td style="text-align:center">✔️</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><strong>Last-Modified</strong></td>
<td style="text-align:center">资源最后一次的修改时间</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">✔️</td>
</tr>
<tr>
<td style="text-align:center"><strong>ETag</strong></td>
<td style="text-align:center">唯一标识请求资源的字符串</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">✔️</td>
</tr>
</tbody>
</table>
<p>2.缓存协商策略用于重新验证缓存资源是否有效, 有关的key如下.</p>
<table>
<thead>
<tr>
<th style="text-align:center">key</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>If-Modified-Since</strong></td>
<td style="text-align:center">缓存校验字段, 值为资源最后一次的修改时间, 即上次收到的Last-Modified值</td>
</tr>
<tr>
<td style="text-align:center"><strong>If-Unmodified-Since</strong></td>
<td style="text-align:center">同上, 处理方式与之相反</td>
</tr>
<tr>
<td style="text-align:center"><strong>If-Match</strong></td>
<td style="text-align:center">缓存校验字段, 值为唯一标识请求资源的字符串, 即上次收到的ETag值</td>
</tr>
<tr>
<td style="text-align:center"><strong>If-None-Match</strong></td>
<td style="text-align:center">同上, 处理方式与之相反</td>
</tr>
</tbody>
</table>
<p>下面我们来看下各个头域(key)的作用.</p>
<h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a><strong>Cache-Control</strong></h3><p>浏览器缓存里, Cache-Control是金字塔顶尖的规则, 它藐视一切其他设置, 只要其他设置与其抵触, 一律覆盖之.</p>
<p>不仅如此, 它还是一个复合规则, 包含多种值, 横跨 <strong>存储策略</strong>, <strong>过期策略</strong> 两种, 同时在请求头和响应头都可设置.</p>
<p>语法为: <em>“Cache-Control : cache-directive”</em>.</p>
<p>Cache-directive共有如下12种(其中请求中指令7种, 响应中指令9种):</p>
<table>
<thead>
<tr>
<th style="text-align:center">Cache-directive</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">存储策略</th>
<th style="text-align:center">过期策略</th>
<th>请求字段</th>
<th>响应字段</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>public</strong></td>
<td style="text-align:center">资源将被客户端和代理服务器缓存</td>
<td style="text-align:center">✔️</td>
<td style="text-align:center"></td>
<td></td>
<td>✔️</td>
</tr>
<tr>
<td style="text-align:center"><strong>private</strong></td>
<td style="text-align:center">资源仅被客户端缓存, 代理服务器不缓存</td>
<td style="text-align:center">✔️</td>
<td style="text-align:center"></td>
<td></td>
<td>✔️</td>
</tr>
<tr>
<td style="text-align:center"><strong>no-store</strong></td>
<td style="text-align:center">请求和响应都不缓存</td>
<td style="text-align:center">✔️</td>
<td style="text-align:center"></td>
<td>✔️</td>
<td>✔️</td>
</tr>
<tr>
<td style="text-align:center"><strong>no-cache</strong></td>
<td style="text-align:center">相当于<code>max-age:0,must-revalidate</code>即资源被缓存, 但是缓存立刻过期, 同时下次访问时强制验证资源有效性</td>
<td style="text-align:center">✔️</td>
<td style="text-align:center">✔️</td>
<td>✔️</td>
<td>✔️</td>
</tr>
<tr>
<td style="text-align:center"><strong>max-age</strong></td>
<td style="text-align:center">缓存资源, 但是在指定时间(单位为秒)后缓存过期</td>
<td style="text-align:center">✔️</td>
<td style="text-align:center">✔️</td>
<td>✔️</td>
<td>✔️</td>
</tr>
<tr>
<td style="text-align:center"><strong>s-maxage</strong></td>
<td style="text-align:center">同上, 依赖public设置, 覆盖max-age, 且只在代理服务器上有效.</td>
<td style="text-align:center">✔️</td>
<td style="text-align:center">✔️</td>
<td></td>
<td>✔️</td>
</tr>
<tr>
<td style="text-align:center"><strong>max-stale</strong></td>
<td style="text-align:center">指定时间内, 即使缓存过时, 资源依然有效</td>
<td style="text-align:center"></td>
<td style="text-align:center">✔️</td>
<td>✔️</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"><strong>min-fresh</strong></td>
<td style="text-align:center">缓存的资源至少要保持指定时间的新鲜期</td>
<td style="text-align:center"></td>
<td style="text-align:center">✔️</td>
<td>✔️</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"><strong>must-revalidation</strong> / <strong>proxy-revalidation</strong></td>
<td style="text-align:center">如果缓存失效, 强制重新向服务器(或代理)发起验证(因为max-stale等字段可能改变缓存的失效时间)</td>
<td style="text-align:center"></td>
<td style="text-align:center">✔️</td>
<td></td>
<td>✔️</td>
</tr>
<tr>
<td style="text-align:center"><strong>only-if-cached</strong></td>
<td style="text-align:center">仅仅返回已经缓存的资源, 不访问网络, 若无缓存则返回504</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td>✔️</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"><strong>no-transform</strong></td>
<td style="text-align:center">强制要求代理服务器不要对资源进行转换, 禁止代理服务器对 <code>Content-Encoding</code>, <code>Content-Range</code>, <code>Content-Type</code>字段的修改(因此代理的gzip压缩将不被允许)</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td>✔️</td>
<td>✔️</td>
</tr>
</tbody>
</table>
<p>假设所请求资源于4月5日缓存, 且在4月12日过期.</p>
<p>当max-age 与 max-stale 和 min-fresh 同时使用时, 它们的设置相互之间独立生效, 最为保守的缓存策略总是有效. 这意味着, 如果max-age=10 days, max-stale=2 days, min-fresh=3 days, 那么:</p>
<ul>
<li>根据max-age的设置, 覆盖原缓存周期,  缓存资源将在4月15日失效(5+10=15);</li>
<li>根据max-stale的设置, 缓存过期后两天依然有效, 此时响应将返回110(Response is stale)状态码, 缓存资源将在4月14日失效(12+2=14);</li>
<li>根据min-fresh的设置, 至少要留有3天的新鲜期, 缓存资源将在4月9日失效(12-3=9);</li>
</ul>
<p>由于客户端总是采用最保守的缓存策略, 因此, 4月9日后, 对于该资源的请求将重新向服务器发起验证.</p>
<h3 id="Pragma"><a href="#Pragma" class="headerlink" title="Pragma"></a><strong>Pragma</strong></h3><p>http1.0字段, 通常设置为<code>Pragma:no-cache</code>, 作用同<code>Cache-Control:no-cache</code>. 当一个no-cache请求发送给一个不遵循HTTP/1.1的服务器时, 客户端应该包含pragma指令. 为此, 勾选☑️ 上disable cache时, 浏览器自动带上了pragma字段. 如下:</p>
<p><img src="http://louiszhai.github.io/docImages/http-cache03.png" alt="Pragma:no-cache"></p>
<h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a><strong>Expires</strong></h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Expires:Wed, 05 Apr 2017 00:55:35 GMT</div></pre></td></tr></table></figure>
<p>即到期时间, 以服务器时间为参考系, 其优先级比 <code>Cache-Control:max-age</code> 低, 两者同时出现在响应头时, <code>Expires</code>将被后者覆盖. 如果<code>Expires</code>, <code>Cache-Control: max-age</code>, 或 <code>Cache-Control:s-maxage</code> 都没有在响应头中出现, 并且也没有其它缓存的设置, 那么浏览器默认会采用一个启发式的算法, 通常会取响应头的<code>Date_value - Last-Modified_value</code>值的10%作为缓存时间.</p>
<p>如下资源便采取了启发式缓存算法.</p>
<p><img src="http://louiszhai.github.io/docImages/http-cache06.png" alt="启发式缓存生效"></p>
<p>其缓存时间为 <code>(Date_value - Last-Modified_value) * 10%</code>, 计算如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> Date_value = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'Thu, 06 Apr 2017 01:30:56 GMT'</span>).getTime();</div><div class="line"><span class="keyword">const</span> LastModified_value = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'Thu, 01 Dec 2016 06:23:23 GMT'</span>).getTime();</div><div class="line"><span class="keyword">const</span> cacheTime = (Date_value - LastModified_value) / <span class="number">10</span>;</div><div class="line"><span class="keyword">const</span> Expires_timestamp = Date_value + cacheTime;</div><div class="line"><span class="keyword">const</span> Expires_value = <span class="keyword">new</span> <span class="built_in">Date</span>(Expires_timestamp);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Expires:'</span>, Expires_value); <span class="comment">// Expires: Tue Apr 18 2017 23:25:41 GMT+0800 (CST)</span></div></pre></td></tr></table></figure>
<p>可见该资源将于2017年4月18日23点25分41秒过期, 尝试以下两步进行验证:</p>
<p>1) 试着把本地时间修改为2017年4月18日23点25分40秒, 迅速刷新页面, 发现强缓存依然有效(依旧是<code>200 OK (from disk cache)</code>).</p>
<p>2) 然后又修改本地时间为2017年4月18日23点26分40秒(即往后拨1分钟), 刷新页面, 发现缓存已过期, 此时浏览器重新向服务器发起了验证, 且命中了304协商缓存, 如下所示.</p>
<p><img src="http://louiszhai.github.io/docImages/http-cache07.png" alt="缓存过期, 重新发起验证, 命中304协商缓存"></p>
<p>3) 将本地时间恢复正常(即 2017-04-06 09:54:19). 刷新页面, 发现Date依然是4月18日, 如下所示.</p>
<p><img src="http://louiszhai.github.io/docImages/http-cache08.png" alt="本地时间恢复正常, 缓存依然有效"></p>
<p>从<code>⚠️ Provisional headers are shown</code> 和Date字段可以看出来, 浏览器并未发出请求, 缓存依然有效, 只不过此时Status Code显示为200 OK. (甚至我还专门打开了charles, 也没有发现该资源的任何请求, 可见这个200 OK多少有些误导人的意味)</p>
<p>可见, 启发式缓存算法采用的缓存时间可长可短, 因此对于常规资源, 建议明确设置缓存时间(如指定max-age 或 expires).</p>
<h3 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a><strong>ETag</strong></h3><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">ETag:"fcb82312d92970bdf0d18a4eca08ebc7efede4fe"</span></div></pre></td></tr></table></figure>
<p>实体标签, 服务器资源的唯一标识符, 浏览器可以根据ETag值缓存数据, 节省带宽. 如果资源已经改变, etag可以帮助防止同步更新资源的相互覆盖. ETag 优先级比 Last-Modified 高.</p>
<h3 id="If-Match"><a href="#If-Match" class="headerlink" title="If-Match"></a><strong>If-Match</strong></h3><p>语法: <em>If-Match: ETag_value</em> 或者 <em>If-Match: ETag_value, ETag_value, …</em></p>
<p>缓存校验字段, 其值为上次收到的一个或多个<code>etag</code> 值. 常用于判断条件是否满足, 如下两种场景:</p>
<ul>
<li>对于 GET 或 HEAD 请求, 结合 Range 头字段, 它可以保证新范围的请求和前一个来自相同的源, 如果不匹配, 服务器将返回一个416(Range Not Satisfiable)状态码的响应.</li>
<li>对于 PUT 或者其他不安全的请求, <code>If-Match</code> 可用于阻止错误的更新操作, 如果不匹配, 服务器将返回一个412(Precondition Failed)状态码的响应.</li>
</ul>
<h3 id="If-None-Match"><a href="#If-None-Match" class="headerlink" title="If-None-Match"></a><strong>If-None-Match</strong></h3><p>语法: <em>If-None-Match: ETag_value</em> 或者 <em>If-None-Match: ETag_value, ETag_value, …</em></p>
<p>缓存校验字段, 结合ETag字段, 常用于判断缓存资源是否有效, 优先级比<code>If-Modified-Since</code>高.</p>
<ul>
<li>对于 GET 或 HEAD 请求, 如果其etags列表均不匹配, 服务器将返回200状态码的响应, 反之, 将返回304(Not Modified)状态码的响应. 无论是200还是304响应, 都至少返回 <code>Cache-Control</code>, <code>Content-Location</code>, <code>Date</code>, <code>ETag</code>, <code>Expires</code>, and <code>Vary</code> 中之一的字段.</li>
<li>对于其他更新服务器资源的请求, 如果其etags列表匹配, 服务器将执行更新, 反之, 将返回412(Precondition Failed)状态码的响应.</li>
</ul>
<h3 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a><strong>Last-Modified</strong></h3><p>语法: <em>Last-Modified: 星期,日期 月份 年份 时:分:秒 GMT</em></p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Last-Modified</span>: Tue, 04 Apr 2017 10:01:15 GMT</div></pre></td></tr></table></figure>
<p>用于标记请求资源的最后一次修改时间, 格式为GMT(格林尼治标准时间). 如可用 <code>new Date().toGMTString()</code>获取当前GMT时间. Last-Modified 是 ETag 的fallback机制, 优先级比 ETag 低, 且只能精确到秒, 因此不太适合短时间内频繁改动的资源. 不仅如此, 服务器端的静态资源, 通常需要编译打包, 可能出现资源内容没有改变, 而Last-Modified却改变的情况.</p>
<h3 id="If-Modified-Since"><a href="#If-Modified-Since" class="headerlink" title="If-Modified-Since"></a><strong>If-Modified-Since</strong></h3><p>语法同上, 如:</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">If-Modified-Since</span>: Tue, 04 Apr 2017 10:12:27 GMT</div></pre></td></tr></table></figure>
<p>缓存校验字段, 其值为上次响应头的Last-Modified值, 若与请求资源当前的Last-Modified值相同, 那么将返回304状态码的响应, 反之, 将返回200状态码响应.</p>
<h3 id="If-Unmodified-Since"><a href="#If-Unmodified-Since" class="headerlink" title="If-Unmodified-Since"></a><strong>If-Unmodified-Since</strong></h3><p>缓存校验字段, 语法同上. 表示资源未修改则正常执行更新, 否则返回412(Precondition Failed)状态码的响应. 常用于如下两种场景:</p>
<ul>
<li>不安全的请求, 比如说使用post请求更新wiki文档, 文档未修改时才执行更新.</li>
<li>与 If-Range 字段同时使用时, 可以用来保证新的片段请求来自一个未修改的文档.</li>
</ul>
<h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a><strong>强缓存</strong></h3><p>一旦资源命中强缓存, 浏览器便不会向服务器发送请求, 而是直接读取缓存. Chrome下的现象是 <code>200 OK (from disk cache)</code> 或者 <code>200 OK (from memory cache)</code>. 如下:</p>
<p><img src="http://louiszhai.github.io/docImages/http-cache01.png" alt="200 OK (from disk cache)"></p>
<p><img src="http://louiszhai.github.io/docImages/http-cache02.png" alt="200 OK (from memory cache)"></p>
<p>对于常规请求, 只要存在该资源的缓存, 且Cache-Control:max-age 或者expires没有过期, 那么就能命中强缓存.</p>
<h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a><strong>协商缓存</strong></h3><p>缓存过期后, 继续请求该资源, 对于现代浏览器, 拥有如下两种做法:</p>
<ul>
<li>根据上次响应中的ETag_value, 自动往request header中添加<code>If-None-Match</code>字段. 服务器收到请求后, 拿<code>If-None-Match</code>字段的值与资源的<code>ETag</code>值进行比较, 若相同, 则命中协商缓存, 返回304响应.</li>
<li>根据上次响应中的Last-Modified_value, 自动往request header中添加<code>If-Modified-Since</code>字段. 服务器收到请求后, 拿<code>If-Modified-Since</code>字段的值与资源的<code>Last-Modified</code>值进行比较, 若相同, 则命中协商缓存, 返回304响应.</li>
</ul>
<p>以上, ETag优先级比Last-Modified高, 同时存在时, 前者覆盖后者. 下面通过实例来理解下强缓存和协商缓存.</p>
<p>如下忽略首次访问, 第二次通过 <code>If-Modified-Since</code> 命中了304协商缓存.</p>
<p><img src="http://louiszhai.github.io/docImages/http-cache04.png" alt="304"></p>
<p>协商缓存的响应结果, 不仅验证了资源的有效性, 同时还更新了浏览器缓存. 主要更新内容如下:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Age:0</div><div class="line">Cache-Control:max-age=600</div><div class="line">Date: Wed, 05 Apr 2017 13:09:36 GMT</div><div class="line">Expires:Wed, 05 Apr 2017 00:55:35 GMT</div></pre></td></tr></table></figure>
<p><code>Age:0</code> 表示命中了代理服务器的缓存, age值为0表示代理服务器刚刚刷新了一次缓存.</p>
<p><code>Cache-Control:max-age=600</code> 覆盖 <code>Expires</code> 字段, 表示从Date_value, 即 <code>Wed, 05 Apr 2017 13:09:36 GMT</code> 起, 10分钟之后缓存过期. 因此10分钟之内访问, 将会命中强缓存, 如下所示:</p>
<p><img src="http://louiszhai.github.io/docImages/http-cache05.png" alt="200 from cache"></p>
<p>当然, 除了上述与缓存直接相关的字段外, http header中还包括如下间接相关的字段.</p>
<h3 id="Age"><a href="#Age" class="headerlink" title="Age"></a><strong>Age</strong></h3><p>出现此字段, 表示命中代理服务器的缓存. 它指的是代理服务器对于请求资源的已缓存时间, 单位为秒. 如下:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Age:2383321</div><div class="line">Date:Wed, 08 Mar 2017 16:12:42 GMT</div></pre></td></tr></table></figure>
<p>以上指的是, 代理服务器在2017年3月8日16:12:42时向源服务器发起了对该资源的请求, 目前已缓存了该资源2383321秒.</p>
<h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a><strong>Date</strong></h3><p>指的是响应生成的时间. 请求经过代理服务器时, 返回的Date未必是最新的, 通常这个时候, 代理服务器将增加一个Age字段告知该资源已缓存了多久.</p>
<h3 id="Vary"><a href="#Vary" class="headerlink" title="Vary"></a><strong>Vary</strong></h3><p>对于服务器而言, 资源文件可能不止一个版本, 比如说压缩和未压缩, 针对不同的客户端, 通常需要返回不同的资源版本. 比如说老式的浏览器可能不支持解压缩, 这个时候, 就需要返回一个未压缩的版本; 对于新的浏览器, 支持压缩, 返回一个压缩的版本, 有利于节省带宽, 提升体验. 那么怎么区分这个版本呢, 这个时候就需要Vary了.</p>
<p>服务器通过指定<code>Vary: Accept-Encoding</code>, 告知代理服务器, 对于这个资源, 需要缓存两个版本: 压缩和未压缩. 这样老式浏览器和新的浏览器, 通过代理, 就分别拿到了未压缩和压缩版本的资源, 避免了都拿同一个资源的尴尬.</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Vary:Accept-Encoding,User-Agent</span></div></pre></td></tr></table></figure>
<p>如上设置, 代理服务器将针对是否压缩和浏览器类型两个维度去缓存资源. 如此一来, 同一个url, 就能针对PC和Mobile返回不同的缓存内容.</p>
<h3 id="怎么让浏览器不缓存静态资源"><a href="#怎么让浏览器不缓存静态资源" class="headerlink" title="怎么让浏览器不缓存静态资源"></a><strong>怎么让浏览器不缓存静态资源</strong></h3><p>实际上, 工作中很多场景都需要避免浏览器缓存, 除了浏览器隐私模式, 请求时想要禁用缓存, 还可以设置请求头: <code>Cache-Control: no-cache, no-store, must-revalidate</code> .</p>
<p>当然, 还有一种常用做法: 即给请求的资源增加一个版本号, 如下:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"../css/style.css?version=1.8.9"</span>/&gt;</span></div></pre></td></tr></table></figure>
<p>这样做的好处就是你可以自由控制什么时候加载最新的资源.</p>
<p>不仅如此, HTML也可以禁用缓存, 即在页面的\<head\>节点中加入\<meta\>标签, 代码如下:</meta\></head\></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Cache-Control"</span> <span class="attr">content</span>=<span class="string">"no-cache, no-store, must-revalidate"</span>/&gt;</span></div></pre></td></tr></table></figure>
<p>上述虽能禁用缓存, 但只有部分浏览器支持, 而且由于代理不解析HTML文档, 故代理服务器也不支持这种方式.</p>
<h3 id="IE8的异常表现"><a href="#IE8的异常表现" class="headerlink" title="IE8的异常表现"></a><strong>IE8的异常表现</strong></h3><p>实际上, 上述缓存有关的规律, 并非所有浏览器都完全遵循. 比如说IE8.</p>
<p>资源缓存是否有效相关.</p>
<table>
<thead>
<tr>
<th style="text-align:center">浏览器</th>
<th style="text-align:center">前提</th>
<th style="text-align:center">操作</th>
<th style="text-align:center">表现</th>
<th style="text-align:center">正常表现</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">IE8</td>
<td style="text-align:center">资源缓存有效</td>
<td style="text-align:center">新开一个窗口加载网页</td>
<td style="text-align:center">重新发送请求(返回200)</td>
<td style="text-align:center">展示缓存的页面</td>
</tr>
<tr>
<td style="text-align:center">IE8</td>
<td style="text-align:center">资源缓存失效</td>
<td style="text-align:center">原浏览器窗口中单击 Enter 按钮</td>
<td style="text-align:center">展示缓存的页面</td>
<td style="text-align:center">重新发送请求(返回200)</td>
</tr>
</tbody>
</table>
<p>Last-Modified / E-Tag 相关.</p>
<table>
<thead>
<tr>
<th style="text-align:center">浏览器</th>
<th style="text-align:center">前提</th>
<th style="text-align:center">操作</th>
<th style="text-align:center">表现</th>
<th style="text-align:center">正常表现</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">IE8</td>
<td style="text-align:center">资源内容没有修改</td>
<td style="text-align:center">新开一个窗口加载网页</td>
<td style="text-align:center">浏览器重新发送请求(返回200)</td>
<td style="text-align:center">重新发送请求(返回304)</td>
</tr>
<tr>
<td style="text-align:center">IE8</td>
<td style="text-align:center">资源内容已修改</td>
<td style="text-align:center">原浏览器窗口中单击 Enter 按钮</td>
<td style="text-align:center">浏览器展示缓存的页面</td>
<td style="text-align:center">重新发送请求(返回200)</td>
</tr>
</tbody>
</table>
<hr>
<p>本问就讨论这么多内容,大家有什么问题或好的想法欢迎在下方参与<a href="#respond">留言和评论</a>.</p>
<p>本文作者: <a href="https://github.com/Louiszhai" target="_blank" rel="external">louis</a></p>
<p>本文链接: <a href="http://louiszhai.github.io/2017/04/07/http-cache/">http://louiszhai.github.io/2017/04/07/http-cache/</a></p>
<p>参考文章</p>
<ul>
<li><a href="https://msdn.microsoft.com/en-us/library/27w3sx5e(v=vs.110).aspx" target="_blank" rel="external">Cache Policy Interaction—Maximum Age and Maximum Staleness</a></li>
<li><a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html" target="_blank" rel="external">HTTP/1.1: Header Field Definitions</a></li>
<li><a href="http://stackoverflow.com/questions/1046966/whats-the-difference-between-cache-control-max-age-0-and-no-cache" target="_blank" rel="external">http - What’s the difference between Cache-Control: max-age=0 and no-cache? - Stack Overflow</a></li>
<li><a href="http://www.baitouwei.com/2016/04/20/App-%E7%BC%93%E5%AD%98%E6%96%B9%E6%A1%88%EF%BC%9AHttp-%E7%BC%93%E5%AD%98/" target="_blank" rel="external">App 缓存方案：Http 缓存 · baitouwei</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control" target="_blank" rel="external">Cache-Control - HTTP | MDN</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzA3NTYzODYzMg==&amp;mid=2653578381&amp;idx=1&amp;sn=3f676e2b2e08bcff831c69d31cf51c51&amp;key=dde62796d24517c892043e67f2520e046c13fc0558822ef7ba7fbe8003ddde05e22230fb4ccb2c31133df2a507940c5d4561c7b4f4570969a47cf1388ff57e4bfea70a3810f3fc805e2a5d9aa3192439&amp;ascene=0&amp;uin=MTM4MjU5NzA0MA%3D%3D&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.11.6+build(15G1212)&amp;version=12010110&amp;nettype=WIFI&amp;fontScale=100&amp;pass_ticket=n3plsW%2FV7Vb6O9hKzPNig5MYpXUoJo3tNUNxhJ5Jh6e9AS%2BRXmvJPbIzUeUmL3S2" target="_blank" rel="external">彻底弄懂 Http 缓存机制 - 基于缓存策略三要素分解法</a></li>
</ul>
<script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: 发起请求
e=>end: 载入资源
c1=>condition: 是否已缓存?
c2=>condition: [过期策略]-
缓存是否过期?
c3=>condition: 验证是否通过?
op1=>operation: [协商策略]-
重新向服务器发起验证
op2=>operation: 向服务器请求资源
op3=>operation: 304响应
io1=>inputoutput: [存储策略]-
响应内容存入缓存
io2=>inputoutput: [存储策略]-
根据响应头更新缓存

st->c1
c1(yes,right)->c2
c1(no)->op2
c2(yes, right)->op1(right)->c3
c2(no)->e
c3(yes, right)->op3->io2->e
c3(no)->op2->io1->e</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":1,"line-length":50,"text-margin":10,"font-size":12,"maxWidth":3,"symbols":{"start":{"fill":"#B5CA92","element-color":"green"},"condition":{"fill":"#58C4A3","yes-text":"是","no-text":"否"},"operation":{"fill":"#F1D5A6"},"inputoutput":{"fill":"#C59E63"},"end":{"fill":"#92A8CD"}}}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(document.getElementById("flowchart-0-options").value);  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script>]]></content>
    
    <summary type="html">
    
      http-cache 浏览器缓存策略 浏览器缓存机制 304协商缓存 强缓存 Age Date Vary Cache-Control Expires ETag Last-Modified Pragma If-Modified-Since If-Unmodified-Since If-Match If-None-Match no-cache max-age max-stale min-fresh must-revalidation
    
    </summary>
    
    
      <category term="Web" scheme="http://louiszhai.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>Promise使用手册</title>
    <link href="http://louiszhai.github.io/2017/03/12/promise/"/>
    <id>http://louiszhai.github.io/2017/03/12/promise/</id>
    <published>2017-03-12T13:28:23.000Z</published>
    <updated>2017-04-17T02:55:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>开始写本篇文字时, 我一直不是很明白任务队列的机制, 故想写篇文章弄懂它. 于是我尝试以Promise为核心, 逐步展开, 最终分析process.nextTick , promise.then , setTimeout , setImmediate 它们的异步机制.</p>
<h3 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h3><p>Promise问世已久, 其科普类文章亦不计其数. 遂本篇初衷不为科普, 只为能够温故而知新.</p>
<p>比如说, catch能捕获所有的错误吗? 为什么有些时候会抛出”Uncaught (in promise) …”? <code>Promise.resolve</code> 和 <code>Promise.reject</code> 处理Promise对象时又有什么不一样的地方?</p>
<a id="more"></a>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><h4 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h4><p>阅读此篇之前, 我们先体验一下如下代码:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>)</div><div class="line">&#125;, <span class="number">0</span>);</div><div class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</div><div class="line">    i == <span class="number">9999</span> &amp;&amp; resolve()</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="number">5</span>)</div><div class="line">&#125;);</div><div class="line"><span class="built_in">console</span>.log(<span class="number">3</span>);</div></pre></td></tr></table></figure>
<p>这里先卖个关子, 后续将给出答案并提供详细分析.</p>
<p>和往常文章一样, 我喜欢从api入手, 先具象地了解一个概念, 然后再抽象或扩展这个概念, 接着再谈谈概念的具体应用场景, 通常末尾还会有一个简短的小结. 这样, 查询api的读者可以选择性地阅读上文, 希望深入的读者可以继续剖析概念, 当然我更希望你能耐心地读到应用场景处, 这样便能升华对这个概念或技术的运用, 也能避免踩坑.</p>
<h4 id="new-Promise"><a href="#new-Promise" class="headerlink" title="new Promise"></a>new Promise</h4><p>Promise的设计初衷是避免异步回调地狱. 它提供更简洁的api, 同时展平回调为链式调用, 使得代码更加清爽, 易读.</p>
<p>如下, 即创建一个Promise对象:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Create a new Promise.'</span>);</div><div class="line">&#125;);</div><div class="line"><span class="built_in">console</span>.log(p);</div></pre></td></tr></table></figure>
<p><img src="http://louiszhai.github.io/docImages/promise01.png" alt="new Promise"></p>
<p>创建Promise时, 浏览器同步执行传入的第一个方法, 从而输出log. 新创建的promise实例对象, 初始状态为等待(pending), 除此之外, Promise还有另外两个状态:</p>
<ul>
<li>fulfilled, 表示操作完成, 实现了. 只在resolve方法执行时才进入该状态.</li>
<li>rejected, 表示操作失败, 拒绝了. 只在reject方法执行时或抛出错误的情况下才进入该状态.</li>
</ul>
<p>如下图展示了Promise的状态变化过程(图片来自<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="external">MDN</a>):</p>
<p><img src="http://louiszhai.github.io/docImages/promise03.png" alt="Promise state"></p>
<p>从初始状态(pending)到实现(fulfilled)或拒绝(rejected)状态的转换, 这是两个分支, 实现或拒绝即最终状态, 一旦到达其中之一的状态, promise的状态便稳定了. (因此, 不要尝试实现或拒绝状态的互转, 它们都是最终状态, 没法转换)</p>
<p>以上, 创建Promise对象时, 传入的回调函数<code>function(resolve, reject){}</code>默认拥有两个参数, 分别为:</p>
<ul>
<li>resolve, 用于改变该Promise本身的状态为实现, 执行后, 将触发then的onFulfilled回调, 并把resolve的参数传递给onFulfilled回调.</li>
<li>reject, 用于改变该Promise本身的状态为拒绝, 执行后, 将触发 then | catch的onRejected回调, 并把reject的参数传递给onRejected回调.</li>
</ul>
<p>Promise的原型仅有两个自身方法, 分别为 <code>Promise.prototype.then</code> , <code>Promise.prototype.catch</code> . 而它自身仅有四个方法, 分别为  <code>Promise.reject</code> , <code>Promise.resolve</code> , <code>Promise.all</code> , <code>Promise.race</code> .</p>
<h4 id="then"><a href="#then" class="headerlink" title="then"></a>then</h4><p>语法: <em>Promise.prototype.then(onFulfilled, onRejected)</em></p>
<p>用于绑定后续操作. 使用十分简单:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'此处执行后续操作'</span>);</div><div class="line">&#125;);</div><div class="line"><span class="comment">// 当然, then的最大便利之处便是可以链式调用</span></div><div class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'先做一件事'</span>);</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'再做一件事'</span>);</div><div class="line">&#125;);</div><div class="line"><span class="comment">// then还可以同时接两个回调,分别处理成功和失败状态</span></div><div class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">SuccessRes</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'处理成功的操作'</span>);</div><div class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">failRes</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'处理失败的操作'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>不仅如此, Promise的then中还可返回一个新的Promise对象, 后续的then将接着继续处理这个新的Promise对象.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'这里是一个新的Promise对象'</span>);</div><div class="line">    resolve(<span class="string">'New Promise resolve.'</span>);</div><div class="line">  &#125;);</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(res);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>那么, 如果没有指定返回值, 会怎么样?</p>
<p>根据Promise规范, <strong>then或catch即使未显式指定返回值, 它们也总是默认返回一个新的fulfilled状态的promise对象</strong>.</p>
<h4 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h4><p>语法: <em>Promise.prototype.catch(onRejected)</em></p>
<p>用于捕获并处理异常. 无论是程序抛出的异常, 还是主动reject掉Promise自身, 都会被catch捕获到.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">  reject(<span class="string">'该prormise已被拒绝'</span>);</div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'catch:'</span>, reason);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>同then语句一样, catch也是可以链式调用的.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">  reject(<span class="string">'该prormise已被拒绝'</span>);</div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">reason</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'catch:'</span>, reason);</div><div class="line">  <span class="built_in">console</span>.log(a);</div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">reason</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(reason);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>以上, 将依次输出两次log, 第一次输出promise被拒绝, 第二次输出”ReferenceError a is not defined”的堆栈信息.</p>
<h5 id="catch能捕获哪些错误"><a href="#catch能捕获哪些错误" class="headerlink" title="catch能捕获哪些错误"></a>catch能捕获哪些错误</h5><p>那是不是catch可以捕获所有错误呢? 可以, 怎么不可以, 我以前也这么天真的认为. 直到有一天我执行了如下的语句, 我就学乖了.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">  <span class="built_in">Promise</span>.reject(<span class="string">'返回一个拒绝状态的Promise'</span>);</div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">reason</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'catch:'</span>, reason);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>执行结果如下:</p>
<p><img src="http://louiszhai.github.io/docImages/promise02.png" alt=""></p>
<p>为什么catch没有捕获到该错误呢? 这个问题, 待下一节我们了解了Promise.reject语法后再做分析.</p>
<h4 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject"></a>Promise.reject</h4><p>语法: <em>Promise.reject(value)</em></p>
<p>该方法返回一个拒绝状态的Promise对象, 同时传入的参数作为PromiseValue.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//params: String</span></div><div class="line"><span class="built_in">Promise</span>.reject(<span class="string">'该prormise已被拒绝'</span>);</div><div class="line">.catch(<span class="function"><span class="keyword">function</span>(<span class="params">reason</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'catch:'</span>, reason);</div><div class="line">&#125;);</div><div class="line"><span class="comment">//params: Error</span></div><div class="line"><span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'这是一个error'</span>)).then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'fulfilled:'</span>, res);</div><div class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'rejected:'</span>, reason); <span class="comment">// rejected: Error: 这是一个error...</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>即使参数为Promise对象, 它也一样会把Promise当作拒绝的理由, 在外部再包装一个拒绝状态的Promise对象予以返回.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//params: Promise</span></div><div class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'This is a promise'</span>);</div><div class="line">&#125;);</div><div class="line"><span class="built_in">Promise</span>.reject(p).catch(<span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'rejected:'</span>, reason);</div><div class="line">  <span class="built_in">console</span>.log(p == reason);</div><div class="line">&#125;);</div><div class="line"><span class="comment">// "This is a promise"</span></div><div class="line"><span class="comment">// rejected: Promise &#123;[[PromiseStatus]]: "pending", [[PromiseValue]]: undefined&#125;</span></div><div class="line"><span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>以上代码片段, <code>Promise.reject(p)</code> 进入到了catch语句中, 说明其返回了一个拒绝状态的Promise, 同时拒绝的理由就是传入的参数p.</p>
<h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>我们都知道, Promise.reject返回了一个拒绝状态的Promise对象. 对于这样的Promise对象, 如果其后续then | catch中都没有声明onRejected回调, 它将会抛出一个 “Uncaught (in promise) …”的错误. 如上图所示, 原语句是 “Promise.reject(‘返回一个拒绝状态的Promise’);” 其后续并没有跟随任何then | catch语句, 因此它将抛出错误, 且该错外部的Promise无法捕获.</p>
<p>不仅如此, Promise之间泾渭分明, 内部Promise抛出的任何错误, 外部Promise对象都无法感知并捕获. 同时, 由于promise是异步的, try catch语句也无法捕获其错误.</p>
<p>因此养成良好习惯, promise记得写上catch.</p>
<p>除了catch, nodejs下Promise抛出的错误, 还会被进程的<code>unhandledRejection</code> 和 <code>rejectionHandled</code>事件捕获.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">  <span class="comment">//console.log(a);</span></div><div class="line">  reject(<span class="string">'rejected'</span>);</div><div class="line">&#125;);</div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  p.catch(<span class="function"><span class="keyword">function</span>(<span class="params">reason</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.info(<span class="string">'promise catch:'</span>, reason);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div><div class="line">process.on(<span class="string">'uncaughtException'</span>, (e) =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.error(<span class="string">'uncaughtException'</span>, e);</div><div class="line">&#125;);</div><div class="line">process.on(<span class="string">'unhandledRejection'</span>, (e) =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.info(<span class="string">'unhandledRejection:'</span>, e);</div><div class="line">&#125;);</div><div class="line">process.on(<span class="string">'rejectionHandled'</span>, (e) =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.info(<span class="string">'rejectionHandled'</span>, e);</div><div class="line">&#125;);</div><div class="line"><span class="comment">//unhandledRejection: rejected</span></div><div class="line"><span class="comment">//rejectionHandled Promise &#123; &lt;rejected&gt; 'rejected' &#125;</span></div><div class="line"><span class="comment">//promise catch: rejected</span></div></pre></td></tr></table></figure>
<p>即使去掉以上代码中的注释, 输出依然一致. 可见, Promise内部抛出的错误, 都不会被<code>uncaughtException</code>事件捕获.</p>
<h5 id="链式写法的好处"><a href="#链式写法的好处" class="headerlink" title="链式写法的好处"></a>链式写法的好处</h5><p>请看如下代码:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">  resolve(<span class="string">'New Promise resolve.'</span>);</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</div><div class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"oops..."</span>);</div><div class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'then catch:'</span>, error);</div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'catch:'</span>, reason);</div><div class="line">&#125;);</div><div class="line"><span class="comment">//catch: Error: oops...</span></div></pre></td></tr></table></figure>
<p>可见, then语句的onRejected回调并不能捕获onFulfilled回调内抛出的错误, 尾随其后的catch语句却可以, 因此推荐链式写法.</p>
<h4 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve"></a>Promise.resolve</h4><p>语法: <em>Promise.resolve(value | promise | thenable)</em></p>
<p>thenable 表示一个定义了 <code>then</code> 方法的对象或函数.</p>
<p>参数为promise时, 返回promise本身.</p>
<p>参数为thenable的对象或函数时, 将其then属性作为new promise时的回调, 返回一个包装的promise对象.(注意: 这里与Promise.reject直接包装一个拒绝状态的Promise不同)</p>
<p>其他情况下, 返回一个实现状态的Promise对象, 同时传入的参数作为PromiseValue.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//params: String</span></div><div class="line"><span class="comment">//return: fulfilled Promise</span></div><div class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'返回一个fulfilled状态的promise'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(res); <span class="comment">// "返回一个fulfilled状态的promise"</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">//params: Array</span></div><div class="line"><span class="comment">//return: fulfilled Promise</span></div><div class="line"><span class="built_in">Promise</span>.resolve([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]).then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(res); <span class="comment">// ["a", "b", "c"]</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">//params: Promise</span></div><div class="line"><span class="comment">//return: Promise self</span></div><div class="line"><span class="keyword">let</span> resolveFn;</div><div class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</div><div class="line">  resolveFn = resolve;</div><div class="line">&#125;);</div><div class="line"><span class="keyword">const</span> r2 = <span class="built_in">Promise</span>.resolve(p2);</div><div class="line">r2.then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(res);</div><div class="line">&#125;);</div><div class="line">resolveFn(<span class="string">'xyz'</span>); <span class="comment">// "xyz"</span></div><div class="line"><span class="built_in">console</span>.log(r2 === p2); <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="comment">//params: thenable Object</span></div><div class="line"><span class="comment">//return: 根据thenable的最终状态返回不同的promise</span></div><div class="line"><span class="keyword">const</span> thenable = &#123;</div><div class="line">  <span class="attr">then</span>: <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123; <span class="comment">//作为new promise时的回调函数</span></div><div class="line">    reject(<span class="string">'promise rejected!'</span>);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"><span class="built_in">Promise</span>.resolve(thenable).then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'res:'</span>, res);</div><div class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'reason:'</span>, reason);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>可见, Promise.resolve并非返回实现状态的Promise这么简单, 我们还需基于传入的参数动态判断.</p>
<p>至此, 我们基本上不用期望使用Promise全局方法中去改变其某个实例的状态.</p>
<ul>
<li>对于Promise.reject(promise), 它只是简单地包了一个拒绝状态的promise壳, 参数promise什么都没变.</li>
<li>对于Promise.resolve(promise), 仅仅返回参数promise本身.</li>
</ul>
<h4 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h4><p>语法: <em>Promise.all(iterable)</em></p>
<p>该方法接一个迭代器(如数组等), 返回一个新的Promise对象. 如果迭代器中所有的Promise对象都被实现, 那么, 返回的Promise对象状态为”fulfilled”, 反之则为”rejected”. 概念上类似Array.prototype.every.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//params: all fulfilled promise</span></div><div class="line"><span class="comment">//return: fulfilled promise</span></div><div class="line"><span class="built_in">Promise</span>.all([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]).then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'promise fulfilled:'</span>, res); <span class="comment">// promise fulfilled: [1, 2, 3]</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">//params: has rejected promise</span></div><div class="line"><span class="comment">//return: rejected promise</span></div><div class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">  reject(<span class="string">'rejected'</span>);</div><div class="line">&#125;);</div><div class="line"><span class="built_in">Promise</span>.all([<span class="number">1</span>, <span class="number">2</span>, p]).then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'promise fulfilled:'</span>, res);</div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">reason</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'promise reject:'</span>, reason); <span class="comment">// promise reject: rejected</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>Promise.all特别适用于处理依赖多个异步请求的结果的场景.</p>
<h4 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h4><p>该方法接一个迭代器(如数组等), 返回一个新的Promise对象. 只要迭代器中有一个Promise对象状态改变(被实现或被拒绝), 那么返回的Promise将以相同的值被实现或拒绝, 然后它将忽略迭代器中其他Promise的状态变化.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Promise</span>.race([<span class="number">1</span>, <span class="built_in">Promise</span>.reject(<span class="number">2</span>)]).then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'promise fulfilled:'</span>, res);</div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">reason</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'promise reject:'</span>, reason);</div><div class="line">&#125;);</div><div class="line"><span class="comment">// promise fulfilled: 1</span></div></pre></td></tr></table></figure>
<p>如果调换以上参数的顺序, 结果将输出 “promise reject: 2”. 可见对于状态稳定的Promise(fulfilled 或 rejected状态), 哪个排第一, 将返回哪个.</p>
<p>Promise.race适用于多者中取其一的场景, 比如同时发送多个请求, 只要有一个请求成功, 那么就以该Promise的状态作为最终的状态, 该Promise的值作为最终的值, 包装成一个新的Promise对象予以返回.</p>
<p>在 <a href="http://louiszhai.github.io/2016/11/02/fetch/#abort">Fetch进阶指南</a> 一文中, 我曾利用Promise.race模拟了Promise的abort和timeout机制.</p>
<h3 id="Promises-A-规范的要点"><a href="#Promises-A-规范的要点" class="headerlink" title="Promises/A+规范的要点"></a>Promises/A+规范的要点</h3><p>promise.then(onFulfilled, onRejected)中, 参数都是可选的, 如果onFulfilled或onRejected不是函数, 那么将忽略它们.</p>
<p>catch只是then的语法糖, 相当于promise.then(null, onRejected).</p>
<h3 id="任务队列之谜"><a href="#任务队列之谜" class="headerlink" title="任务队列之谜"></a>任务队列之谜</h3><p>终于, 我们要一起来看看文章起始的一道题目.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>)</div><div class="line">&#125;, <span class="number">0</span>);</div><div class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</div><div class="line">    i == <span class="number">9999</span> &amp;&amp; resolve()</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="number">5</span>)</div><div class="line">&#125;);</div><div class="line"><span class="built_in">console</span>.log(<span class="number">3</span>);</div></pre></td></tr></table></figure>
<p>这道题目来自知乎(机智的你可能早已看穿, 但千万别戳破😂), 可以戳此链接 <a href="https://www.zhihu.com/question/36972010" target="_blank" rel="external">Promise的队列与setTimeout的队列有何关联</a> 围观点赞.</p>
<p>围观完了, 别忘了继续读下去, 这里请允许我站在诸位知乎大神的肩膀上, 继续深入分析.</p>
<p>以上代码, 最终运行结果是1,2,3,5,4. 并不是1,2,3,4,5.</p>
<ol>
<li>首先前面有提到, new Promise第一个回调函数内的语句同步执行, 因此控制台将顺序输出1,2, 此处应无异议.</li>
<li><code>console.log(3)</code>, 这里是同步执行, 因此接着将输出3, 此处应无异议.</li>
<li>剩下便是setTimeout 和 Promise的then的博弈了, 同为异步事件, 为什么then后注册却先于setTimeout执行?</li>
</ol>
<p>之前, 我们在 <a href="http://louiszhai.github.io/2016/11/02/ajax/#ajax有没有破坏js单线程机制">Ajax知识体系</a> 一文中有提到:</p>
<blockquote>
<p>浏览器中, js引擎线程会循环从 <code>任务队列</code> 中读取事件并且执行, 这种运行机制称作 <code>Event Loop</code> (事件循环).</p>
</blockquote>
<p>不仅如此, event loop至少拥有如下两种队列:</p>
<ul>
<li>task queue, 也叫macrotask queue, 指的是宏任务队列, 包括rendering, script(页面脚本), 鼠标, 键盘, 网络请求等事件触发, setTimeout, setInterval, setImmediate(node)等等.</li>
</ul>
<ul>
<li>microtask queue, 指的是微任务队列, 用于在浏览器重新渲染前执行, 包含Promise, process.nextTick(node), Object.observe, MutationObserver回调等.</li>
</ul>
<p>如下是HTML规范原文:</p>
<blockquote>
<p>An <a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loop" target="_blank" rel="external">event loop</a> has one or more task queues. A <a href="https://html.spec.whatwg.org/multipage/webappapis.html#task-queue" target="_blank" rel="external">task queue</a> is an ordered list of tasks, which are algorithms that are responsible for such work as: events, parsing, callbacks, using a resource, reacting to DOM manipulation…</p>
<p>Each <a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loop" target="_blank" rel="external">event loop</a> has a microtask queue. A microtask is a <a href="https://html.spec.whatwg.org/multipage/webappapis.html#concept-task" target="_blank" rel="external">task</a> that is originally to be queued on the <a href="https://html.spec.whatwg.org/multipage/webappapis.html#microtask-queue" target="_blank" rel="external">microtask queue</a> rather than a <a href="https://html.spec.whatwg.org/multipage/webappapis.html#task-queue" target="_blank" rel="external">task queue</a>.</p>
</blockquote>
<p>浏览器(或宿主环境) 遵循队列先进先出原则, 依次遍历macrotask queue中的每一个task, 不过每执行一个macrotask, 并不是立即就执行下一个, 而是执行一遍microtask queue中的任务, 然后切换GUI线程重新渲染或垃圾回收等.</p>
<p>上述代码块可以看做是一个macrotask, 对于其执行过程, 不妨作如下简化:</p>
<ol>
<li>首先执行当前macrotask, 将setTimeout回调以一个新的task形式, 加入到macrotask queue末尾.</li>
<li>当前macrotask继续执行, 创建一个新的Promise, 同步执行其回调函数, 输出1; for循环1w次, 然后执行resolve方法, 将该Promise回调加入到microtask queue末尾, 循环结束, 接着输出2.</li>
<li>当前macrotask继续执行, 输出3. 至此, 当前macrotask执行完毕.</li>
<li>开始顺序执行microtask queue中的所有任务, 也包括刚刚加入到队列末尾 Promise回调, 故输出5. 至此, microtask queue任务全部执行完毕, microtask queue清空.</li>
<li>浏览器挂起js引擎, 可能切换至GUI线程或者执行垃圾回收等.</li>
<li>切换回js引擎, 继续从macrotask queue取出下一个macrotask, 执行之, 然后再取出microtask queue, 执行之, 后续所有的macrotask均如此重复. 自然, 也包括刚刚加入到队列末尾的setTimeout回调, 故输出4.</li>
</ol>
<p>这里直接给出事件回调优先级:</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">process</span>.nextTick &gt; promise.then &gt; <span class="built_in">setTimeout</span> ? setImmediate</div></pre></td></tr></table></figure>
<p>nodejs中每一次event loop称作tick. _tickCallback在macrotask queue中每个task执行完成后触发. 实际上, _tickCallback内部共干了两件事:</p>
<ol>
<li>执行nextTick queue中的所有任务, 包括process.nextTick注册的回调.</li>
<li>第一步完成后执行 _runMicrotasks函数, 即执行microtask queue中的所有任务, 包括promise.then注册的回调.</li>
</ol>
<p>因此, process.nextTick优先级比promise.then高.</p>
<p>那么setTimeout与setImmediate到底哪个更快呢? 回答是并不确定. 请看如下代码:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">setImmediate(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="number">1</span>);</div><div class="line">&#125;);</div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="number">0</span>);</div><div class="line">&#125;, <span class="number">0</span>);</div></pre></td></tr></table></figure>
<p>前后两次的执行结果如下:</p>
<p><img src="http://louiszhai.github.io/docImages/promise04.png" alt=""></p>
<p>测试时, 我本地node版本是v5.7.0.</p>
<hr>
<p>本问就讨论这么多内容,大家有什么问题或好的想法欢迎在下方参与<a href="#respond">留言和评论</a>.</p>
<p>本文作者: <a href="https://github.com/Louiszhai" target="_blank" rel="external">louis</a></p>
<p>本文链接: <a href="http://louiszhai.github.io/2017/02/25/promise/">http://louiszhai.github.io/2017/02/25/promise/</a></p>
<p>参考文章</p>
<ul>
<li><a href="http://www.th7.cn/web/js/201511/134740.shtml" target="_blank" rel="external">完全理解Promise_JavaScript_第七城市</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="external">Promise - JavaScript | MDN</a></li>
<li><a href="https://www.zhihu.com/question/36972010" target="_blank" rel="external">Promise的队列与setTimeout的队列的有何关联 -知乎</a></li>
<li><a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loop" target="_blank" rel="external">HTML Standard event loop</a></li>
<li><a href="https://promisesaplus.com/#point-11" target="_blank" rel="external">Promises/A+</a></li>
<li><a href="http://jphpsf.github.io/setImmediate-shim-demo/" target="_blank" rel="external">setImmediate API demo</a></li>
<li><a href="https://www.zhihu.com/question/23028843" target="_blank" rel="external">Process.nextTick 和 setImmediate 的区别？ - 知乎</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      promise promise.race promise.all Promise.reject Promise.resolve then catch Promises/A+ process.nextTick setImmediate
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://louiszhai.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>为什么Web App的返回逻辑如此复杂</title>
    <link href="http://louiszhai.github.io/2017/02/24/back/"/>
    <id>http://louiszhai.github.io/2017/02/24/back/</id>
    <published>2017-02-24T07:59:01.000Z</published>
    <updated>2017-04-17T02:54:08.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h3><p>最近我在梳理公司web app新产品线的返回逻辑, 推演了N种方案, 竟然没有一种完全通用的. 这让我迷惑不已. 仔细体验了公司的各种H5页面, 发现返回逻辑还真是五花八门. 那么, 问题来了, 为什么Web App的返回逻辑如此难以设计?</p>
<a id="more"></a>
<h3 id="可供尝试的api"><a href="#可供尝试的api" class="headerlink" title="可供尝试的api"></a>可供尝试的api</h3><p>相对于较复杂的返回场景, 可用的api少得可怜. webview的history对象中, 仅 back 和 go 方法可用. 它们遵循如下规律:</p>
<ul>
<li>调用<code>history.back</code> 如果存在历史的话, 只能回到前一个页面, 否则将静默失败.</li>
<li>调用<code>history.go(-n)</code> 如果存在历史的话, 可以回到前n个页面, 否则将静默失败.</li>
</ul>
<p>从这里看起来, 似乎想回到哪就回到哪. 自然不是, 不然就不会有这篇文章了.</p>
<p>不得不说的是, H5中有个堪称坑爹的设定, 就是<code>history.length</code>属性, 该属性无论何时, 都是当前webview历史栈的总长度. 也就是说, 无论你的网页是第一个打开的, 还是中间打开的, 还是最后一个打开的, 只要返回到你的网页, 你获取到的<code>history.length</code>都是相同的值. 无论如何你都不能直接拿到你的网页在webview历史栈中的位置(或者序号), 这将导致你不知道要往前跳几步(假设要跳过若干个历史), 因此你不能随心所欲的调用<code>history.go</code>方法.</p>
<p>通常情况下,若web app自带返回按钮, 如果其中一个网页A是通过重定向模拟返回到它之前的某个网页B, 用户在新的网页B点击返回按钮, 将返回到网页A, 此时再点击网页A的返回按钮, 那么又将进入到新的网页B2中. 如下:</p>
<p>①—&gt;A —②重定向—&gt; B —③返回—&gt; A —④重定向—&gt; B2 —⑤返回—&gt; A</p>
<p>我们来看看webview历史栈发生了什么, 假设历史栈已经存储了n项历史:</p>
<ul>
<li>①栈顶压入A页面, 此时当前页面指针后移1位, 指向A页面, 且A页面位于栈顶, 此时历史栈长度为n+1;</li>
<li>②栈顶压入B页面, 此时当前页面指针后移1位, 指向B页面, 且B页面位于栈顶, 此时历史栈长度为n+2;</li>
<li>③当前页面指针前移1位, 指向A页面, 此时B页面位于栈顶, 历史栈长度依然为n+2;</li>
<li>④当前页面指针后的栈被清空, 历史栈长度为n+1, 栈顶压入B2页面, 当前页面指针后移1位, 指向B2页面, 且B2页面位于栈顶, 此时历史栈长度为n+2;</li>
<li>⑤当前页面指针前移1位, 指向A页面, 此时B2页面位于栈顶, 历史栈长度依然为n+2;</li>
</ul>
<p>B和B2其实是同一个网页, 除了历史栈中的位置不同, 他们没有任何不同. 如此逻辑将使得我们将陷入返回的死循环中. 为避免这种体验上的缺陷, 请尽量不要在返回逻辑中重定向到某个之前的页面.</p>
<blockquote>
<p>webview中通过location.href方式跳转链接, 可起到清理浏览历史项的作用, 如此时webview中共存在100个历史项, 我们一路返回至第90个页面(该页面的history.length依然是100), 然后在该页面通过location.href跳转至另一个页面, 那么新的页面将处于历史项的第91项, 原来的第91~100项历史将被清空. 于是新的页面中获取的history.length将准确地标示了该页面处于历史项的第几项.</p>
</blockquote>
<h3 id="重定向过后怎么返回"><a href="#重定向过后怎么返回" class="headerlink" title="重定向过后怎么返回"></a>重定向过后怎么返回</h3><p>愿望是美好的, 现实是残酷的. 纯H5下想要在返回逻辑中不重定向, 先砍了这些需求再说:</p>
<ul>
<li>从网页A跳走, 中间经过n个其他域名的网页, 最终不希望用户按步返回, 希望能够直接返回网页A的场景.</li>
<li>从详情页B跳走, 中间需要经过各种支付中间页, 然后进入web版收银台, 弹出支付宝或者微信支付弹框, 支付成功后进入到成功页, 从成功页返回时希望直接回到详情页B的场景.</li>
</ul>
<p>从产品上看, 这些需求都是合理的. 那么如何从最后一个页面, 成功地返回到初始的A或B页面, 这里我想到了一个解决方案. 思路如下:</p>
<p><code>history.go</code>方法是可用的. 只要get到了网页处于历史栈的位置, 就可以正常的返回n步. 虽然通常情况下从初始页面A跳出时, <code>history.length</code>并不可靠, 但是从A页面跳到(通过location.href跳转)的第一个页面X中, <code>history.length</code>却是可靠的, 此时该值准确地记录了页面X在历史栈中的位置.(不懂的可以去看上述第④步解析) 只要在页面X中执行如下语句, 便可记录页面A的位置.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//假定原页面A中跳转时执行如下语句</span></div><div class="line"><span class="keyword">let</span> linkA = <span class="string">"http://www.a.com/a?params=abc"</span>;</div><div class="line">linkA = <span class="built_in">window</span>.encodeURIComponent(linkA);</div><div class="line"><span class="keyword">const</span> targetLink = <span class="string">`http://www.x.com/x?from=<span class="subst">$&#123;linkA&#125;</span>#test`</span>;</div><div class="line">location.href = targetLink;</div><div class="line"></div><div class="line"><span class="comment">//在页面X执行如下语句</span></div><div class="line"><span class="keyword">const</span> cursor = history.length - <span class="number">1</span>;</div><div class="line"><span class="keyword">let</span> params = location.search.match(<span class="regexp">/from=([^&amp;]*)/</span>),</div><div class="line">    <span class="keyword">from</span>;</div><div class="line"><span class="keyword">if</span> (params <span class="keyword">instanceof</span> <span class="built_in">Array</span> &amp;&amp; params.length === <span class="number">2</span>) &#123;</div><div class="line">  <span class="comment">// 获取原页面A的链接</span></div><div class="line">  <span class="keyword">from</span> = <span class="built_in">window</span>.decodeURIComponent(params[<span class="number">1</span>]);</div><div class="line">  <span class="keyword">const</span> a = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>);</div><div class="line">  a.href = <span class="keyword">from</span>;</div><div class="line">  <span class="keyword">const</span> paramStr = <span class="string">`historyCursor=<span class="subst">$&#123;history.length - <span class="number">1</span>&#125;</span>`</span>;</div><div class="line">  <span class="comment">// 追加historyCursor=history.length参数</span></div><div class="line">  <span class="keyword">const</span> searchStr = a.search ? <span class="string">`<span class="subst">$&#123;a.search&#125;</span>&amp;<span class="subst">$&#123;paramStr&#125;</span>`</span> : <span class="string">`?<span class="subst">$&#123;paramStr&#125;</span>`</span>;</div><div class="line">  <span class="keyword">from</span> = a.origin + a.pathname + searchStr + a.hash;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>页面X经过n次跳转, 其中可能经过了各种支付中间页, 最终又重定向回到页面X’(与页面x链接相同, 但是新的页面), 在页面X’上点击返回按钮时, 此时可以直接重定向回到原页面A’(与页面A链接相似, 仅仅多了参数historyCursor, 是新的页面).</p>
<p>待用户回到了页面A’后, 此时点击返回按钮时, 走的并不是通常的<code>history.back</code> , 而应该是回到页面A的前一个页面, 换句话说 , 此时用户将往回跳n个页面. 这里的主要判断逻辑如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">goBack</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> start, current, step;</div><div class="line">  <span class="keyword">const</span> params = location.search.match(<span class="regexp">/historyCursor=(\d+)/</span>);</div><div class="line">  <span class="keyword">if</span>(params <span class="keyword">instanceof</span> <span class="built_in">Array</span> &amp;&amp; params.length === <span class="number">2</span>) &#123;</div><div class="line">    <span class="comment">// 如参数中带有historyCursor, 返回时将回跳n步</span></div><div class="line">    start = +params[<span class="number">1</span>];</div><div class="line">    current = history.length;</div><div class="line">    step = current - start + <span class="number">1</span>;</div><div class="line">    location.go(-step);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// 默认将返回上一个页面</span></div><div class="line">    history.back();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上, 由多个页面传递historyCursor的值, 基本将需求中的返回逻辑落地了. 美中不足的是, 页面A的返回逻辑依赖了页面X的代码(页面X中需要设置对的historyCursor值), 存在耦合. 这样开发页面A的同学将通知开发页面X的同学, 返回时你要给我加一个historyCursor的参数, 巴拉巴拉. 开发页面X的同学也很纠结, 因为他始终要确认是不是从页面A跳过来的, 如果是, 那他就要加一个historyCursor参数, 并且重定向到页面A. 同时Android系统自带的返回键也会让这套方案更加雪上加霜.</p>
<p>有鉴于此, 以上纯H5的解决方案便不太完美.</p>
<h3 id="H5是否可以打开新的网页窗口"><a href="#H5是否可以打开新的网页窗口" class="headerlink" title="H5是否可以打开新的网页窗口"></a>H5是否可以打开新的网页窗口</h3><p>对于非嵌入app的H5应用, 那么使用场景就是各家的浏览器, 应用中对于有可能打乱历史记录的网页, 直接新开窗口就行.</p>
<p>对于嵌入app内的H5应用, 通常来说, H5本身不具备新开webview的能力. 这里需要native辅助. 接下来我们将主要关注嵌入app内的H5的应用.</p>
<h3 id="native提供jsBridge"><a href="#native提供jsBridge" class="headerlink" title="native提供jsBridge"></a>native提供jsBridge</h3><p>app内嵌的H5应用, 可借助native的jsBridge新开webview, 从而避免历史记录混乱. 为此, native客户端(包括Android和IOS以及其他)将提供接口以便js打开或关闭webview. 值得考虑的是, 这里面可能带来一个负面影响, js有可能多次申请新开webview, 从而大量消耗内存和电量. 因此, native有必要对webview的个数予以限制.</p>
<h3 id="native维护H5的历史记录"><a href="#native维护H5的历史记录" class="headerlink" title="native维护H5的历史记录"></a>native维护H5的历史记录</h3><p>既然开多个webview开销会增大, 基于此, 我突发奇想, 有没有可能由native客户端来维护单个webview的历史记录, 从而所有的页面跳转将由native接管?</p>
<p>我认为这是有可能的. 首先native可以保留每次加载的页面链接, 同时, 页面跳转时可提前设置下一个页面的返回逻辑. 既然历史记录和返回逻辑都在native中注册, 剩下的问题就是, js怎么通知native返回了? 这个也很简单, native不止可以loadUrl, 还可以load页面上的方法. 又页面上用于返回的两个js方法: <code>history.go</code> 和 <code>history.back</code> 都是可以重写的. 因此, native可在页面DOMContentLoaded事件回调中重写go和back方法, 改为调用jsBridge接口(此前, 为了解决第三方OAuth2.0登录后返回到空白页的问题, 我写了部分native逻辑, 用于重写js原生go和back方法已在生产环境下使用).</p>
<p>思路如下:</p>
<ol>
<li><p><strong>记录历史栈</strong>: native存储webview中加载的每一个页面, 形成一个历史记录栈. 并且标记当前页面处于该历史记录栈的位置.</p>
</li>
<li><p><strong>重写返回方法</strong>: webview中每个页面加载完成后, 重写<code>history.go</code> 和 <code>history.back</code>方法, 改为调用jsBridge接口, 方便native感知网页的后退. (下面将详细说明重写的时机)</p>
</li>
<li><p><strong>设置下一个页面的返回逻辑</strong>: 页面跳转之前, 可调用jsBridge强制设置下一个页面的返回url(如从a跳转至b页面, 设置后, 无论b处于历史记录栈的哪一项, 从b返回都将回到a页面)</p>
</li>
<li><p><strong>回退时检查当前页面的返回逻辑</strong>: 一旦H5中调用<code>history.go</code> 和 <code>history.back</code>方法返回之前的页面, native自动检查该页面之前是否设置过返回url, 如有则从历史记录栈中捞出该url的位置, 继续调用js原生的<code>history.go</code>方法进行跳转, 同时忽略本次历史; 如无则直接通过原方法跳转页面, 同时忽略本次历史.</p>
</li>
<li><p>重写Android自带的物理返回键.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//改写物理返回键的逻辑</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onKeyDown</span><span class="params">(<span class="keyword">int</span> keyCode, KeyEvent event)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span>(keyCode==KeyEvent.KEYCODE_BACK)&#123;</div><div class="line">    <span class="comment">//参照第4步策略实现</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><strong>激进策略—拦截页面主动发起的重定向(选用)</strong>: 每次加载url前, 都将检查该url是否在当前页面之前的历史记录栈中出现过, 如有则直接调用js原生的<code>history.go</code>方法, 回退到该url原来的页面.</p>
</li>
</ol>
<p>注: 虽然返回时shouldOverrideUrlLoading事件不会触发, 但onPageStarted和onPageFinished会依次触发一次. 因此上述第4步返回时需要忽略本次历史.</p>
<p>那么如何记录webview历史栈, 并且重写js方法呢? </p>
<p>嫌我啰嗦, 你可能会说 “Talk is cheap, show me the code.” 那么, 请看如下Android代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">History</span> </span>&#123;</div><div class="line">  <span class="keyword">public</span> url;</div><div class="line">  <span class="keyword">public</span> backItem;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">History</span><span class="params">(String url)</span></span>&#123;</div><div class="line">    <span class="keyword">this</span>.url = url;</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">History</span><span class="params">(String url, History backItem)</span></span>&#123;</div><div class="line">    <span class="keyword">this</span>.url = url;</div><div class="line">    <span class="keyword">this</span>.backItem = backItem;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*-----------华丽丽的class分界线------------*/</span></div><div class="line"></div><div class="line">ArrayList&lt;History&gt; historyList = <span class="keyword">new</span> ArrayList&lt;History&gt;;</div><div class="line"></div><div class="line"><span class="comment">/*-----------华丽丽的class分界线------------*/</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebViewManager</span> </span>&#123;</div><div class="line">  <span class="comment">//此处略去webView元素的获取</span></div><div class="line">  webView.setWebViewClient(<span class="keyword">new</span> WebViewClient() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPageStarted</span><span class="params">(WebView view, String url, Bitmap favicon)</span> </span>&#123;</div><div class="line">      <span class="comment">// 存储当前页面URL</span></div><div class="line">      History history = <span class="keyword">new</span> History(url);</div><div class="line">      historyList.append(history);</div><div class="line">      <span class="comment">// 重写js返回方法</span></div><div class="line">      String fnString = <span class="string">"(function()&#123;/*在这里重写history.go和history.back方法*/&#125;)()"</span>;</div><div class="line">      webView.loadUrl(<span class="string">"javascript:"</span> + fnString);</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面只是Simple的体验, 实际请求中, 一定会有url重定向场景. 接下来我们将着重讨论这种场景.</p>
<h3 id="如何在webview中判断页面是否加载完成"><a href="#如何在webview中判断页面是否加载完成" class="headerlink" title="如何在webview中判断页面是否加载完成"></a>如何在webview中判断页面是否加载完成</h3><p>首先, 加载页面有两种方式:</p>
<ol>
<li>webview主动loadUrl.</li>
<li>页面上触发的url加载行为.</li>
</ol>
<p>我们先来模拟一个<strong>两次</strong>重定向的场景, 通常情况下, 直接访问 <a href="http://www.baidu.com" target="_blank" rel="external">http://www.baidu.com</a> 将发生一次重定向. 在此之前用一个短链接重定向到 <a href="http://www.baidu.com" target="_blank" rel="external">http://www.baidu.com</a> 这样便多了一次重定向. 下面将基于这个场景进行两次测试.</p>
<p>那么第一种方式, 将依次触发webview的以下事件回调:</p>
<p><img src="http://louiszhai.github.io/docImages/back01.png" alt="webview主动loadUrl"></p>
<p>整理如下:</p>
<ol>
<li>onPageStarted</li>
<li>onPageStarted</li>
<li>shouldOverrideUrlLoading</li>
<li>onPageFinished</li>
<li>onPageStarted</li>
<li>onPageStarted</li>
<li>shouldOverrideUrlLoading</li>
<li>onPageFinished</li>
<li>onPageStarted</li>
<li>onPageFinished</li>
</ol>
<p>第二种方式, 将依次触发webview的以下事件回调:</p>
<p><img src="http://louiszhai.github.io/docImages/back02.png" alt="页面上触发的url加载行为"></p>
<p>整理如下:</p>
<ol>
<li>shouldOverrideUrlLoading</li>
<li>onPageStarted</li>
<li>onPageStarted</li>
<li>shouldOverrideUrlLoading</li>
<li>onPageFinished</li>
<li>onPageStarted</li>
<li>onPageStarted</li>
<li>shouldOverrideUrlLoading</li>
<li>onPageFinished</li>
<li>onPageStarted</li>
<li>onPageFinished</li>
</ol>
<p>可见, 除了最后一次onPageFinished事件, 其他的onPageFinished事件都紧跟shouldOverrideUrlLoading事件之后触发.</p>
<p>基于上述现象, 可以设置全局状态位(flag), onPageStarted触发时设置为<code>true</code>, shouldOverrideUrlLoading触发时设置为<code>false</code>, onPageFinished触发时, 判断flag是否为true, 如果为true则意味着页面加载完成, 此时便可放心的记录页面url以及重写js原生返回方法.</p>
<h3 id="基于hash跳转产生的历史项如何记录"><a href="#基于hash跳转产生的历史项如何记录" class="headerlink" title="基于hash跳转产生的历史项如何记录"></a>基于hash跳转产生的历史项如何记录</h3><p>上述方法真的可以记录webview所有的历史项吗?</p>
<p>其实还不能. 实际上, webview的网页上进行hash跳转时, onPageStarted 和 shouldOverrideUrlLoading 都不会触发. 所幸的是 onPageFinished 能够感知到hash值的变化. 我们可以在该方法内继续维护历史记录栈.</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>至此, 我想, 基于native的这套返回方案应该是可行. 但有native的同学告知: 有些页面native无法记录页面url? 这是为什么呢? 至少到目前为止, 我还没有发现这样的场景. 欢迎阅读本文的你留下个脚印, 一起讨论和完善web app返回方案.</p>
<hr>
<p>本问就讨论这么多内容,大家有什么问题或好的想法欢迎在下方参与<a href="#respond">留言和评论</a>.</p>
<p>本文作者: <a href="https://github.com/Louiszhai" target="_blank" rel="external">louis</a></p>
<p>本文链接: <a href="http://louiszhai.github.io/2017/02/20/back/">http://louiszhai.github.io/2017/02/20/back/</a></p>
<p>参考文章</p>
<ul>
<li><a href="http://chuansong.me/n/361100051028" target="_blank" rel="external">浅谈WebView的页面跳转_郭霖_传送门</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      web返回 HybirdApp返回 H5返回 app返回
    
    </summary>
    
    
      <category term="Web" scheme="http://louiszhai.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>box-shadow属性探秘</title>
    <link href="http://louiszhai.github.io/2017/02/19/box-shadow/"/>
    <id>http://louiszhai.github.io/2017/02/19/box-shadow/</id>
    <published>2017-02-19T08:23:34.000Z</published>
    <updated>2017-04-17T02:54:08.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h3><p>我总是记不住css3的box-shadow属性拥有几个值, 它们的顺序究竟如何? 对我来说, 这是一个大难题. 我们都知道, 使用一个属性, 总是可以不停地在开发者工具上测试UI表现, 直到表现令人满意. 好吧, 有些时候它是奏效的; 而其它时候呢, 我们会消耗时间, 积攒疲劳值, 以及成就感下降等. 一旦短时记忆失效, 我们完全有可能重复一遍之前不愉快地尝试. 因此我选择多花些时间, 用力一次记住它. 如果你恰好也有同样的疑惑, 请读下去.</p>
<a id="more"></a>
<h3 id="box-shadow"><a href="#box-shadow" class="headerlink" title="box-shadow"></a>box-shadow</h3><p>box-shadow用于创建阴影, 使得元素更有立体感, 它的值由以下六个部分组成:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">box-shadow</span>: <span class="selector-tag">offsetX</span> <span class="selector-tag">offsetY</span> <span class="selector-tag">blur</span> <span class="selector-tag">spread</span> <span class="selector-tag">color</span> <span class="selector-tag">position</span>;</div></pre></td></tr></table></figure>
<p>它们分别为: x轴偏移 y轴偏移 模糊半径 大小 颜色 位置.</p>
<p>xy轴偏移, 参照css中的坐标系, 水平向右(→)为X轴正方向, 垂直向下(↓)为Y轴正方向.</p>
<h4 id="offsetX"><a href="#offsetX" class="headerlink" title="offsetX"></a>offsetX</h4><p>即水平偏移, 值取正数时, 阴影位于元素右边, 值取负数时, 阴影位于元素左边.</p>
<p>为了便于观察到效果, 我将模糊半径默认设置成10px.</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">box-shadow</span>: 20<span class="selector-tag">px</span> 0 10<span class="selector-tag">px</span> 0 <span class="selector-tag">lightblue</span>; <span class="comment">/*阴影向右偏移20px*/</span></div></pre></td></tr></table></figure>
<p><img src="http://louiszhai.github.io/docImages/box-shadow01.png" alt="offsetX为正值"></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">box-shadow</span>: <span class="selector-tag">-20px</span> 0 10<span class="selector-tag">px</span> 0 <span class="selector-tag">lightblue</span>; <span class="comment">/*阴影向左偏移20px*/</span></div></pre></td></tr></table></figure>
<p><img src="http://louiszhai.github.io/docImages/box-shadow02.png" alt="offsetX为负值"></p>
<h4 id="offsetY"><a href="#offsetY" class="headerlink" title="offsetY"></a>offsetY</h4><p>即垂直偏移, 值取正数时, 阴影位于元素下方, 值取负数时, 阴影位于元素上方.</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">box-shadow</span>: 0 10<span class="selector-tag">px</span> 10<span class="selector-tag">px</span> 0 <span class="selector-tag">lightblue</span>; <span class="comment">/*阴影向下偏移10px*/</span></div></pre></td></tr></table></figure>
<p><img src="http://louiszhai.github.io/docImages/box-shadow03.png" alt="offsetY为正值"></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">box-shadow</span>: 0 <span class="selector-tag">-10px</span> 10<span class="selector-tag">px</span> 0 <span class="selector-tag">lightblue</span>; <span class="comment">/*阴影向上偏移10px*/</span></div></pre></td></tr></table></figure>
<p><img src="http://louiszhai.github.io/docImages/box-shadow04.png" alt="offsetY为负值"></p>
<h4 id="blur"><a href="#blur" class="headerlink" title="blur"></a>blur</h4><p>设置阴影的模糊半径, 值越大时, 阴影就越模糊, 值为0时则完全不模糊, 值小于0时则按照0处理.</p>
<p>我试着加大模糊半径, 取值为50px, 可以看到阴影变得非常模糊.</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">box-shadow</span>: 20<span class="selector-tag">px</span> 0 50<span class="selector-tag">px</span> 0 <span class="selector-tag">lightblue</span>; <span class="comment">/*阴影向右偏移20px, 模糊半径由10px放大至50px*/</span></div></pre></td></tr></table></figure>
<p><img src="http://louiszhai.github.io/docImages/box-shadow05.png" alt="offsetX+blur"></p>
<p>同时, 上下边界也有模糊阴影, 理论上讲, 模糊半径在上下左右各个方向应该都有效果, 下面我们来验证之:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">box-shadow</span>: 0 0 50<span class="selector-tag">px</span> 0 <span class="selector-tag">lightblue</span>; <span class="comment">/*模糊半径设置为50px, 无偏移*/</span></div></pre></td></tr></table></figure>
<p><img src="http://louiszhai.github.io/docImages/box-shadow06.png" alt="blur"></p>
<p>如上图, 同猜想一致, 模糊阴影在上下左右4个方向分别发散. 此时, 对角线方向上阴影是最淡的, 要想模糊阴影均匀分布在元素周围, 只需将元素设置为圆形即可.</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">box-shadow</span>: 0 0 50<span class="selector-tag">px</span> 0 <span class="selector-tag">lightblue</span>; <span class="comment">/*模糊半径设置为50px, 无偏移*/</span></div><div class="line"><span class="selector-tag">border-radius</span>: 100%; <span class="comment">/*元素设置为圆形*/</span></div></pre></td></tr></table></figure>
<p><img src="http://louiszhai.github.io/docImages/box-shadow07.png" alt="blur-circle"></p>
<h4 id="spread"><a href="#spread" class="headerlink" title="spread"></a>spread</h4><p>设置阴影大小. 当blur值为0时, spread就像是元素背后的一块幕布, spread值越大, 阴影越宽, 当其取负值时, 阴影大小为元素高宽分别减去spread值, 此时, blur设置的模糊阴影则会向内靠拢.</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">box-shadow</span>: 0 0 0 10<span class="selector-tag">px</span> <span class="selector-tag">lightblue</span>; <span class="comment">/*阴影大小设置为+10px*/</span></div></pre></td></tr></table></figure>
<p><img src="http://louiszhai.github.io/docImages/box-shadow08.png" alt="spread"></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">box-shadow</span>: 0 0 10<span class="selector-tag">px</span> 10<span class="selector-tag">px</span> <span class="selector-tag">lightblue</span>; <span class="comment">/*模糊半径设置为10px, 阴影大下为+10px*/</span></div></pre></td></tr></table></figure>
<p><img src="http://louiszhai.github.io/docImages/box-shadow09.png" alt="spread"></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">box-shadow</span>: 0 0 10<span class="selector-tag">px</span> <span class="selector-tag">-1px</span> <span class="selector-tag">lightblue</span>; <span class="comment">/*模糊半径设置为10px, 阴影大下为-1px, 由于模糊阴影部分向内靠拢, 阴影变得非常薄*/</span></div></pre></td></tr></table></figure>
<p><img src="http://louiszhai.github.io/docImages/box-shadow10.png" alt="spread+blur"></p>
<p>不知道你有没有注意到 ,对于阴影大小, 我使用的是+10px 或者 -1px这样的单位, 这是为什么呢? 这里卖个关子先, 请看如下效果.</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">box-shadow</span>: 150<span class="selector-tag">px</span> 0 0 0<span class="selector-tag">px</span> <span class="selector-tag">lightblue</span>;</div></pre></td></tr></table></figure>
<p><img src="http://louiszhai.github.io/docImages/box-shadow19.png" alt="offsetX+spread"></p>
<p>仅仅将阴影水平向右移动一段距离, 可见, 阴影是有默认大小的, 并且默认与元素是一般大小. 而这几乎打破了我一度的认知, 说好的阴影呢, 不是环绕吗!</p>
<p>前面提到了圆形阴影, 实际上, 就是<code>border-radius:100%</code>的特例, 那么如果border-radius是一个具体的值呢, 此时阴影又该当如何呈现? 请耐心往下看, 我将在多重阴影的节点给出分析.</p>
<h4 id="color"><a href="#color" class="headerlink" title="color"></a>color</h4><p>设置阴影的颜色. 支持常用色值, HEX(16进制), RGB, RGBA, HSL, HSLA等颜色单位. 以下颜色全部都是浅蓝色.</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">box-shadow</span>: 0 0 10<span class="selector-tag">px</span> 0 <span class="selector-tag">lightblue</span>;</div><div class="line"><span class="selector-tag">box-shadow</span>: 0 0 10<span class="selector-tag">px</span> 0 <span class="selector-id">#add8e6</span>;</div><div class="line"><span class="selector-tag">box-shadow</span>: 0 0 10<span class="selector-tag">px</span> 0 <span class="selector-tag">rgba</span>(173, 216, 230, 1);</div><div class="line"><span class="selector-tag">box-shadow</span>: 0 0 10<span class="selector-tag">px</span> 0 <span class="selector-tag">hsla</span>(195, 53%, 79%, 1);</div></pre></td></tr></table></figure>
<h4 id="position"><a href="#position" class="headerlink" title="position"></a>position</h4><p>设置阴影的位置, 默认为外部阴影, 可通过inset值来设置内部阴影.</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">box-shadow</span>: 0 0 20<span class="selector-tag">px</span> 10<span class="selector-tag">px</span> <span class="selector-tag">lightblue</span>; <span class="comment">/*默认为外部阴影*/</span></div><div class="line"><span class="selector-tag">box-shadow</span>: 0 0 20<span class="selector-tag">px</span> 10<span class="selector-tag">px</span> <span class="selector-tag">lightblue</span> <span class="selector-tag">inset</span>; <span class="comment">/*设置为inset时, 为内部阴影*/</span></div></pre></td></tr></table></figure>
<p><img src="http://louiszhai.github.io/docImages/box-shadow11.png" alt="inset"></p>
<h3 id="多重阴影"><a href="#多重阴影" class="headerlink" title="多重阴影"></a>多重阴影</h3><p>box-shadow同background属性一样, 它们都支持多重效果的设置, 且多重值以逗号分隔.</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">box-shadow</span>: 0 0 20<span class="selector-tag">px</span> 10<span class="selector-tag">px</span> <span class="selector-tag">lightblue</span>,</div><div class="line">            0 0 20<span class="selector-tag">px</span> 10<span class="selector-tag">px</span> <span class="selector-tag">lightblue</span> <span class="selector-tag">inset</span>; <span class="comment">/*同时设置内外阴影*/</span></div></pre></td></tr></table></figure>
<p><img src="http://louiszhai.github.io/docImages/box-shadow12.png" alt="内外阴影"></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">box-shadow</span>: 10<span class="selector-tag">px</span> 10<span class="selector-tag">px</span> 0<span class="selector-tag">px</span> 10<span class="selector-tag">px</span> <span class="selector-id">#d0268c</span>,</div><div class="line">            <span class="selector-tag">-10px</span> <span class="selector-tag">-10px</span> 0<span class="selector-tag">px</span> 10<span class="selector-tag">px</span> <span class="selector-tag">rgba</span>(95, 167, 44, 0<span class="selector-class">.56</span>),</div><div class="line">            0<span class="selector-tag">px</span> 0<span class="selector-tag">px</span> 0<span class="selector-tag">px</span> 20<span class="selector-tag">px</span> <span class="selector-tag">lightgrey</span>; <span class="comment">/*多重阴影效果*/</span></div></pre></td></tr></table></figure>
<p><img src="http://louiszhai.github.io/docImages/box-shadow13.png" alt="多重阴影"></p>
<p>上面留下了一个问题, 答案就在下面的样式中.</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">border-radius</span>: 10<span class="selector-tag">px</span>;</div><div class="line"><span class="selector-tag">box-shadow</span>: 110<span class="selector-tag">px</span> 0 0 <span class="selector-tag">-10px</span> <span class="selector-id">#ccc</span>, 220<span class="selector-tag">px</span> 0 0 0 <span class="selector-id">#808080</span>, 360<span class="selector-tag">px</span> 0 0 10<span class="selector-tag">px</span> <span class="selector-tag">grey</span>;</div></pre></td></tr></table></figure>
<p>直接上效果.</p>
<p><img src="http://louiszhai.github.io/docImages/box-shadow20.png" alt="border-radius影响spread的效果"></p>
<p>从第一个阴影开始(上图左二), 随着阴影spread值的变化, 阴影经历了边框直角, 边框圆角, 边框更圆角(词穷)的过程.</p>
<p>这两个属性的关系如下: </p>
<ul>
<li>spread值越大, border-radius的值就越大, 当spread&lt;0时, border-radius会变小, 最小为0.</li>
</ul>
<h3 id="有趣的效果"><a href="#有趣的效果" class="headerlink" title="有趣的效果"></a>有趣的效果</h3><h4 id="纸张投影效果"><a href="#纸张投影效果" class="headerlink" title="纸张投影效果"></a>纸张投影效果</h4><p>先来看以下纸张投影效果是个什么样.</p>
<p><img src="http://louiszhai.github.io/docImages/box-shadow14.png" alt="paper-shadow"></p>
<p>不就是在纸张底部加个投影吗, 是的, 你没看错. 这样的投影, 实现起来灰常简单, 只需要元素底部左右各加一个box-shadow, 然后佐以transform变换, 稍微改变个角度就大功告成了. 下面我们来用三步实现它.</p>
<h5 id="准备元素"><a href="#准备元素" class="headerlink" title="准备元素"></a>准备元素</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></div><div class="line">  <span class="selector-class">.drop-shadow</span> &#123;</div><div class="line">    <span class="attribute">position</span>: relative;</div><div class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</div><div class="line">    <span class="attribute">background</span>: <span class="number">#CCC</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="selector-class">.vertical-line</span>&#123;</div><div class="line">    <span class="attribute">position</span>: relative;</div><div class="line">    <span class="attribute">height</span>: <span class="number">96%</span>;</div><div class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">top</span>: <span class="number">2%</span>;</div><div class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</div><div class="line">    <span class="attribute">border</span>: <span class="number">1px</span> dashed <span class="number">#808080</span>;</div><div class="line">  &#125;</div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"shadow"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"vertical-line"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>阶段性效果如下:</p>
<p><img src="http://louiszhai.github.io/docImages/box-shadow15.png" alt="paper-shadow-part01"></p>
<h5 id="添加阴影样式"><a href="#添加阴影样式" class="headerlink" title="添加阴影样式"></a>添加阴影样式</h5><p>先在元素底部左右两边各生成一个阴影, 阴影应该是垂直向下的, 和模糊的, 那么属性如下设置.</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.shadow</span><span class="selector-pseudo">::before</span>, <span class="selector-class">.shadow</span><span class="selector-pseudo">::after</span> &#123;</div><div class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</div><div class="line">    <span class="attribute">position</span>: absolute;</div><div class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">width</span>: <span class="number">50%</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">10%</span>;</div><div class="line">    <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">15px</span> <span class="number">20px</span> <span class="built_in">rgba</span>(125, 125, 125, 0.9);</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.drop-shadow</span><span class="selector-pseudo">::after</span>&#123;</div><div class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">left</span>: auto;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>阶段性效果如下:</p>
<p><img src="http://louiszhai.github.io/docImages/box-shadow16.png" alt="paper-shadow-part02"></p>
<p>这个时候, 阴影基本上呈现了, 但有两点不太完美:</p>
<ul>
<li>左右阴影应该是倾斜的;</li>
<li>底部阴影有些太厚, 且边缘部分应该淡化.</li>
</ul>
<p>倾斜可使用 <code>transform: rotate(5deg)</code> 实现. 阴影太厚或边缘淡化只需将阴影往内收一些就行, 如 <code>bottom: 20px; left:10px</code> 等.</p>
<h5 id="给阴影加个角度并收缩一些"><a href="#给阴影加个角度并收缩一些" class="headerlink" title="给阴影加个角度并收缩一些"></a>给阴影加个角度并收缩一些</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.shadow</span><span class="selector-pseudo">::before</span>, <span class="selector-class">.shadow</span><span class="selector-pseudo">::after</span> &#123;</div><div class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</div><div class="line">    <span class="attribute">position</span>: absolute;</div><div class="line">    <span class="attribute">bottom</span>: <span class="number">20px</span>;</div><div class="line">    <span class="attribute">left</span>: <span class="number">10px</span>;</div><div class="line">    <span class="attribute">width</span>: <span class="number">50%</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">10%</span>;</div><div class="line">    <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">20px</span> <span class="number">30px</span> <span class="built_in">rgba</span>(125, 125, 125, 0.9);</div><div class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(-5deg);</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.drop-shadow</span><span class="selector-pseudo">::after</span>&#123;</div><div class="line">  <span class="attribute">right</span>: <span class="number">10px</span>;</div><div class="line">  <span class="attribute">left</span>: auto;</div><div class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(5deg);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>阶段性效果如下:</p>
<p><img src="http://louiszhai.github.io/docImages/box-shadow17.png" alt="paper-shadow-part03"></p>
<p>可以看到, 阴影出现在元素之上. 可设置<code>z-index</code> 为-1, 将阴影层级降低一些, 这样就实现了上述所说的纸张阴影效果.</p>
<p><img src="http://louiszhai.github.io/docImages/box-shadow14.png" alt="paper-shadow"></p>
<h4 id="升起效果"><a href="#升起效果" class="headerlink" title="升起效果"></a>升起效果</h4><p>同样, 我们先来看下升起效果长什么样. 如下:</p>
<p><img src="http://louiszhai.github.io/docImages/box-shadow18.gif" alt="paper-shadow-part02"></p>
<p>这是一个简单的动画, 鼠标移入, 元素上移, 同时阴影缩小, 鼠标移出则反之. 这里, 我们分两步来实现它.</p>
<h5 id="准备元素和阴影"><a href="#准备元素和阴影" class="headerlink" title="准备元素和阴影"></a>准备元素和阴影</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></div><div class="line">  <span class="selector-class">.rose</span> &#123;</div><div class="line">    <span class="attribute">position</span>: relative;</div><div class="line">    <span class="attribute">width</span>: <span class="number">80px</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">120px</span>;</div><div class="line">    <span class="attribute">background</span>: <span class="built_in">rgba</span>(0,0,0,0.2);</div><div class="line">    <span class="attribute">transition</span>: transform <span class="number">1s</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="selector-class">.rose</span><span class="selector-pseudo">::after</span> &#123;</div><div class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</div><div class="line">    <span class="attribute">position</span>: absolute;</div><div class="line">    <span class="attribute">bottom</span>: -<span class="number">30px</span>;</div><div class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">8px</span>;</div><div class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</div><div class="line">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</div><div class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(0,0,0,0.2);</div><div class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-50%, 0);</div><div class="line">    <span class="attribute">transition</span>: transform <span class="number">1s</span>;</div><div class="line">    <span class="attribute">box-shadow</span>: <span class="number">0px</span> <span class="number">0px</span> <span class="number">15px</span> <span class="number">0px</span> <span class="built_in">rgba</span>(0,0,0,0.2);</div><div class="line">  &#125;</div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"rose"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<h5 id="添加动画"><a href="#添加动画" class="headerlink" title="添加动画"></a>添加动画</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.rose</span><span class="selector-pseudo">:hover</span> &#123;</div><div class="line">    <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-40px);</div><div class="line">    <span class="attribute">transition</span>: transform <span class="number">1s</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.rose</span><span class="selector-pseudo">:hover</span><span class="selector-pseudo">::after</span> &#123;</div><div class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-50%, 40px) <span class="built_in">scale</span>(0.75);</div><div class="line">  <span class="attribute">transition</span>: transform <span class="number">1s</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="box-decoration-break"><a href="#box-decoration-break" class="headerlink" title="box-decoration-break"></a>box-decoration-break</h3><p>欲了解这个属性, 我们先读一则规范.</p>
<p>2016年1月14日, W3C发布了CSS片段模块(<a href="https://www.w3.org/TR/2016/CR-css-break-3-20160114/" target="_blank" rel="external">CSS Fragmentation Module Level 3</a>)的候选推荐标准, 明确定义了在盒间、盒内、行间、页间进行断行的属性和规则.</p>
<p>简言之, 对于一个盒子模型, 如果它被分裂成多个长度不等的小碎片, 那么它将遵循以下规则来调整布局:</p>
<ul>
<li>布局将在每个碎片中生效, 并在断点处衔接起来. 但是重新计算大小和位置.</li>
<li>后续碎片必须遵循定位规则, 并且不能高于前面碎片的边缘. 如果想延续碎片开始时的边缘, 需指定 <code>box-decoration-break</code> 为 <code>clone</code>, 那么padding 和 border 将包裹后续碎片的边缘.</li>
</ul>
<p>也就是说, 当行内元素换行后, border, background将会出现截断现象, box-shadow也会如此. 如下:</p>
<p><img src="http://louiszhai.github.io/docImages/box-shadow21.png" alt="box-decoration-break:slice"></p>
<p>实际上, 这种效果并非不可改变, 设置 <code>box-decoration-break:clone</code> , 以上各个css效果将每行重新渲染, 彼此相互独立.</p>
<p><img src="http://louiszhai.github.io/docImages/box-shadow22.png" alt="box-decoration-break:clone"></p>
<p>box-decoration-break属性用于描述盒子碎片(如跨行的inline元素的各个部分)如何渲染上述border, background, box-shadow等css效果. 该属性拥有两个值, slice 和 clone, 默认值为slice, 如上图一效果. 以下是官方原文.</p>
<blockquote>
<p>For <a href="https://www.w3.org/TR/css-break-3/#propdef-box-decoration-break" target="_blank" rel="external">box-decoration-break: slice</a>, backgrounds (and <a href="https://www.w3.org/TR/css3-background/#border-image" target="_blank" rel="external">border-image</a>) are drawn as if applied to a composite box consisting of all of the box’s fragments reassembled in visual order. This theoretical assembly occurs after the element has been laid out (including any justification, bidi reordering, page breaks, etc.). To assemble the composite box…</p>
</blockquote>
<p>从box-decoration-break属性的支持性来看, 目前firefox遥遥领先, 它从v32版本开始就已经全部支持. 以下浏览器均需要 -webkit-前缀, 并且不支持跨列和跨页的截断效果, 其他浏览器目前还不支持.</p>
<table>
<thead>
<tr>
<th style="text-align:center">Chrome</th>
<th style="text-align:center">Safari</th>
<th style="text-align:center">Opera</th>
<th style="text-align:center">ios Safari</th>
<th style="text-align:center">Opera mini</th>
<th style="text-align:center">Android</th>
<th style="text-align:center">Chrome Android</th>
<th style="text-align:center">QQ</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">22+</td>
<td style="text-align:center">6.1+</td>
<td style="text-align:center">15+</td>
<td style="text-align:center">7.1+</td>
<td style="text-align:center">all</td>
<td style="text-align:center">4.4+</td>
<td style="text-align:center">55+</td>
<td style="text-align:center">1.2+</td>
</tr>
</tbody>
</table>
<p>注: 不支持box-decoration-break的浏览器默认按照<code>box-decoration-break:slice</code> 效果来渲染盒子碎片.</p>
<hr>
<p>本问就讨论这么多内容,大家有什么问题或好的想法欢迎在下方参与<a href="#respond">留言和评论</a>.</p>
<p>本文作者: <a href="https://github.com/Louiszhai" target="_blank" rel="external">louis</a></p>
<p>本文链接: <a href="http://louiszhai.github.io/2017/02/12/box-shadow/">http://louiszhai.github.io/2017/02/12/box-shadow/</a></p>
<p>参考文章</p>
<ul>
<li><a href="https://gold.xitu.io/entry/574664ba5bbb5000578cd2a0" target="_blank" rel="external">[译] box-shadow 属性 - 掘金</a></li>
<li><a href="https://segmentfault.com/a/1190000002793308" target="_blank" rel="external">CSS3实现Drop-shadow - MockingBird 博客 - SegmentFault</a></li>
<li><a href="https://www.w3.org/TR/css-break-3/#breaking-boxes" target="_blank" rel="external">CSS Fragmentation Module Level 3</a></li>
<li><a href="http://www.chinaw3c.org/archives/1236/" target="_blank" rel="external">W3C发布CSS片段模块（CSS Fragmentation Module Level 3）候选推荐标准 征集参考实现 - W3C中国</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      box-shadow 阴影 多重阴影 纸张投影 升起效果 box-decoration-break
    
    </summary>
    
    
      <category term="CSS" scheme="http://louiszhai.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>弹性盒模型Flex指南</title>
    <link href="http://louiszhai.github.io/2017/01/13/flex/"/>
    <id>http://louiszhai.github.io/2017/01/13/flex/</id>
    <published>2017-01-13T00:42:01.000Z</published>
    <updated>2017-04-25T05:46:11.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h3><p>Web layout 是Web UI中的基础架构, 重要性不言而喻. 传统的盒模型, 借助display, position, float 属性应对普通布局游刃有余, 但针对复杂的或自适应布局, 常常捉襟见肘. 比如垂直居中, 就是一个老大难的问题, 借助flex弹性盒模型, 两行代码就可以优雅的实现之. (该方法曾在 <a href="http://louiszhai.github.io/2016/03/12/css-center/">16种方法实现水平居中垂直居中</a> 一文中提到). 当然, 本次我们不会只讨论垂直居中的问题, 我将努力尽可能的还原flex的应用场景.</p>
<a id="more"></a>
<h3 id="Flex"><a href="#Flex" class="headerlink" title="Flex"></a>Flex</h3><p>Flex即弹性盒模型, 该布局方案由W3C于2009年提出. 此后, Flex方案便历经v2009, v2011, v2012, v2014, v2015, v2016等版本, 最近方案是2016年5月26日起草的 <a href="http://www.w3.org/TR/2016/CR-css-flexbox-1-20160526/" target="_blank" rel="external">CSS Flexible Box Layout Module Level 1</a>.</p>
<h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><p>首先, 我们来回顾下如今PC端的兼容性(以下为完全兼容版本).</p>
<table>
<thead>
<tr>
<th style="text-align:center">IE</th>
<th style="text-align:center">Edge</th>
<th style="text-align:center">Firefox</th>
<th style="text-align:center">Chrome</th>
<th style="text-align:center">Safari</th>
<th style="text-align:center">Opera</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">-</td>
<td style="text-align:center">12+</td>
<td style="text-align:center">28+</td>
<td style="text-align:center">21+</td>
<td style="text-align:center">6.1+</td>
<td style="text-align:center">12.1+</td>
</tr>
</tbody>
</table>
<p>以上, IE10+仅支持2012版W3C的flex语法, 且存在较多已知的bug, 此时使用flex布局需谨慎.</p>
<p>Chrome浏览器v21~v28版本需要添加 “-webkit-“ 前缀.</p>
<p>Safari浏览器v6.1~v8版本需要添加 “-webkit-“ 前缀.</p>
<p>Opera浏览器v15~v16版本需要添加 “-webkit-“ 前缀.</p>
<p>因此, 看到一些sass编译后的css文件中带有 “-webkit-“ 前缀无需惊慌.</p>
<p>平时开发时最为担心的便是移动端兼容性, 请看:</p>
<table>
<thead>
<tr>
<th style="text-align:center">IOS Safari</th>
<th style="text-align:center">Opera mini</th>
<th style="text-align:center">Android</th>
<th style="text-align:center">Android Chrome</th>
<th style="text-align:center">UC</th>
<th style="text-align:center">微信</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">7.1+</td>
<td style="text-align:center">√</td>
<td style="text-align:center">4.4+</td>
<td style="text-align:center">55</td>
<td style="text-align:center">-</td>
<td style="text-align:center">当前支持</td>
</tr>
</tbody>
</table>
<p>微信当前版本已支持flex.</p>
<p>UC不对外提供webview内核, 除去一些H5app的应用, 各种分享页基本(常在微信下打开)基本不需要担心对其兼容性, 实在需要实现, UC还是支持老版本的弹性盒子的, 可以优雅降级. 可见, Android4.4以上基本可以安心使用flex.</p>
<h3 id="Autoprefixer"><a href="#Autoprefixer" class="headerlink" title="Autoprefixer"></a>Autoprefixer</h3><p>强记各种浏览器的前缀是没有必要的, 因为autoprefixer该做的, 都帮我们做了. 因此建议尝试下以下三个插件之一.</p>
<ul>
<li><a href="https://github.com/nDmitry/grunt-autoprefixer" target="_blank" rel="external">grunt-autoprefixer</a></li>
<li><a href="https://www.npmjs.com/package/gulp-autoprefixer" target="_blank" rel="external">gulp-autoprefixer</a></li>
<li><a href="https://github.com/postcss/autoprefixer" target="_blank" rel="external">PostCSS-autoprefixer</a></li>
</ul>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>Flex布局使得子项目能够”弹性”的改变其高宽, 自由填充容器剩余空间, 以适应容器变大, 或者压缩子项目自身, 以适应容器变小; 同时还可以方便的调节子项目方向和顺序. flex常用于高宽需要自适应, 或子项目大小成比例, 或水平垂直对齐等场景.</p>
<h3 id="概念铺垫"><a href="#概念铺垫" class="headerlink" title="概念铺垫"></a>概念铺垫</h3><p>Flex弹性盒模型里, 有容器和项目之分. 设置<code>display:flex</code>的为容器, 容器内的元素称作它的子项目, 容器有容器的一套属性, 子项目有子项目的另一套属性. (可以这么理解: father作为弹性盒子, 制定行为规范, son享受盒子的便利, 按照规范划分各自的”辖区”).</p>
<p>以下图片摘自大漠的<a href="6">一个完整的Flexbox指南</a>文中.</p>
<p><img src="http://louiszhai.github.io/docImages/flex01.jpeg" alt="flexbox"></p>
<p>father制定的规范, 基于两个方向 — 水平和垂直. </p>
<ul>
<li>水平方向的称之为主轴(main axis), 垂直方向的称之为交叉轴(cross axis). </li>
<li>主轴起始位置, 叫做<code>main start</code>, 末尾位置叫做<code>main end</code>; </li>
<li>交叉轴起始位置, 叫做<code>cross start</code>, 末尾位置叫做<code>cross end</code>.</li>
<li>子项目在主轴上所占的宽(高)度, 叫做<code>main size</code>, 在交叉轴上所占的高(宽)度, 叫做<code>cross size</code>.</li>
</ul>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>display: flex | inline-flex;(元素将升级为弹性盒子). 前者容器升级为块级盒子, 后者容器将升级为行内盒子. 元素采用flex布局以后, 子元素的float, clear, vertical-align属性都将失效.</p>
<h4 id="容器属性"><a href="#容器属性" class="headerlink" title="容器属性"></a>容器属性</h4><p>容器具有以下6个属性.</p>
<ul>
<li>flex-direction 指定主轴的方向.</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">flex-direction的值</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>row</strong>(默认)</td>
<td style="text-align:center">指定主轴水平, 子项目从左至右排列➜</td>
</tr>
<tr>
<td style="text-align:center"><strong>row-reverse</strong></td>
<td style="text-align:center">指定主轴水平, 子项目从右至左排列⬅︎</td>
</tr>
<tr>
<td style="text-align:center"><strong>column</strong></td>
<td style="text-align:center">指定主轴垂直, 子项目从上至下排列⬇︎</td>
</tr>
<tr>
<td style="text-align:center"><strong>column-reverse</strong></td>
<td style="text-align:center">指定主轴垂直, 子项目从下至上排列⬆︎</td>
</tr>
</tbody>
</table>
<ul>
<li>flex-wrap 指定如何换行.</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">flex-wrap的值</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>nowrap</strong>(默认)</td>
<td style="text-align:center">默认不换行</td>
</tr>
<tr>
<td style="text-align:center"><strong>wrap</strong></td>
<td style="text-align:center">正常换行</td>
</tr>
<tr>
<td style="text-align:center"><strong>wrap-reverse</strong></td>
<td style="text-align:center">换行, 且前面的行在底部</td>
</tr>
</tbody>
</table>
<ul>
<li>flex-flow 它是flex-direction 和 flex-wrap的简写形式, 默认值为<code>row nowrap</code>.</li>
<li>justify-content 指定主轴上子项目的对齐方式.(通常为水平方向对齐方式)</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">justify-content的值</th>
<th style="text-align:center">描述(子项目–主轴方向)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>flex-start</strong>(默认)</td>
<td style="text-align:center">子项目起始位置与<code>main start</code>位置对齐</td>
</tr>
<tr>
<td style="text-align:center"><strong>flex-end</strong></td>
<td style="text-align:center">子项目末尾位置与<code>main end</code>位置对齐</td>
</tr>
<tr>
<td style="text-align:center"><strong>center</strong></td>
<td style="text-align:center">在主轴方向居中于容器</td>
</tr>
<tr>
<td style="text-align:center"><strong>space-between</strong></td>
<td style="text-align:center">与交叉轴两端对齐, 子项目之间的间隔全部相等</td>
</tr>
<tr>
<td style="text-align:center"><strong>space-around</strong></td>
<td style="text-align:center">子项目两侧的距离相等, 它们之间的距离两倍于它们与主轴起始或末尾位置的距离.</td>
</tr>
</tbody>
</table>
<ul>
<li>align-items 指定交叉轴上子项目的对齐方式.(通常为垂直方向对齐方式)</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">align-items的值</th>
<th style="text-align:center">描述(子项目—交叉轴方向)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>flex-start</strong></td>
<td style="text-align:center">子项目起始位置与<code>cross start</code>位置对齐</td>
</tr>
<tr>
<td style="text-align:center"><strong>flex-end</strong></td>
<td style="text-align:center">子项目末尾位置与<code>cross end</code>位置对齐</td>
</tr>
<tr>
<td style="text-align:center"><strong>center</strong></td>
<td style="text-align:center">在交叉轴方向居中于容器</td>
</tr>
<tr>
<td style="text-align:center"><strong>baseline</strong></td>
<td style="text-align:center">第一行文字的基线对齐</td>
</tr>
<tr>
<td style="text-align:center"><strong>stretch</strong>(默认)</td>
<td style="text-align:center">高度未定(或auto)时, 将占满容器的高度</td>
</tr>
</tbody>
</table>
<ul>
<li>align-content 指定多根主轴的对齐方式. 若只有一根主轴, 则无效.</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">align-content的值</th>
<th style="text-align:center">描述(子项目)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>flex-start</strong></td>
<td style="text-align:center">顶部与<code>cross start</code>位置对齐</td>
</tr>
<tr>
<td style="text-align:center"><strong>flex-end</strong></td>
<td style="text-align:center">底部与<code>cross end</code>位置对齐</td>
</tr>
<tr>
<td style="text-align:center"><strong>center</strong></td>
<td style="text-align:center">在交叉轴方向居中于容器</td>
</tr>
<tr>
<td style="text-align:center"><strong>space-between</strong></td>
<td style="text-align:center">与交叉轴两端对齐, 间隔全部相等</td>
</tr>
<tr>
<td style="text-align:center"><strong>space-around</strong></td>
<td style="text-align:center">子项目两侧的距离相等, 它们之间的距离两倍于它们与主轴起始或末尾位置的距离.</td>
</tr>
<tr>
<td style="text-align:center"><strong>stretch</strong>(默认)</td>
<td style="text-align:center">多根主轴上的子项目充满交叉轴</td>
</tr>
</tbody>
</table>
<h4 id="子项目属性"><a href="#子项目属性" class="headerlink" title="子项目属性"></a>子项目属性</h4><p>子项目具有以下6个属性.</p>
<ul>
<li><p><strong>flex-grow</strong> 指定子项目的放大比例, 默认为0(即不放大). 该属性可取值为任何正整数. 假设各个子项目的放大比例之和为n, 那么容器内剩余的空间将分配n份, 每个子项目各自分到x/n份. (x为该子项目的放大比例)</p>
</li>
<li><p><strong>flex-shrink</strong> 指定子项目的缩小比例, 默认为<code>1</code>. 设置为0时, 空间不足该子项目将不缩小. 我们知道, <code>容器的缩小总宽度=子项目所需要的总宽度-容器实际宽度</code>, 假设容器需要缩小的宽度为W, 某子项目的默认宽度为L, 其缩小比例为p, 那么该子项目实际的宽度为<code>L-p*W</code>. </p>
<ul>
<li><p>上面轻描淡写的给出了子项目的缩小比例, 可能会给你一种错觉— “缩小比例很容易计算”, 实际上, <strong>我们在计算元素需要缩小比例时, 总是要考虑到元素自身默认的大小</strong>.</p>
</li>
<li><p>假设上述子项目其flex-shrink值为x1, 另一个子项目的默认宽度为R, flex-shrink值为x2, 考虑到元素自身大小. 最终第一个子项目的缩小比例是加权了自身默认大小后的结果, 即<code>rate = L*x1/(L*x1 + R*x2)</code>.</p>
<p><img src="http://louiszhai.github.io/docImages/flex03.png" alt=""></p>
</li>
<li><p>为什么计算会如此复杂, 如此不直观??? 这是因为, 子项目的大小各不一致, 假如一个子项目是另一个子项目主轴宽度的9倍, 前者的flex-shrink值为1, 后者为9, 而容器实际上只有他们默认总宽度的一半. 这意味着, 这两个子项目共计要压缩为默认的一半. 如果仅仅按照flex-shrink值来决定比例, 那么第二个子项目需要压缩其默认的9/10, 而我们知道, 它默认是如此的小, 即使全部压缩了, 也无济于事; 而第一个元素仅需要压缩其默认的1/10, 简直就是九牛一毛, 根本达不到默认总宽度压缩一半的效果. 很明显, 这种压缩比例的分配方式是不合理的. 因此最终的压缩比例加入了默认宽度值(即flex-basis值), 表达式的分子为 <code>flex-shrink * flex-basis</code>, 分母为各子项目  <code>flex-shrink * flex-basis</code> 之和.</p>
</li>
</ul>
</li>
<li><p><strong>flex-basis</strong> 指定子项目分配的默认空间, 默认为<code>auto</code>. 即该子项目的原本大小.</p>
</li>
<li><p><strong>flex</strong> 是 flex-grow, flex-shrink, flex-basis 3个属性的缩写. 默认为<code>0 1 auto</code>. 该属性取值为auto时等同于设置为<code>1 1 auto</code>, 取值为none时等同于设置为<code>0 0 auto</code>.</p>
</li>
<li><p><strong>align-self</strong> 指定单个子项目独立的对齐方式. 默认为<code>auto</code>, 表示继承父元素的align-items属性, 如无父元素, 则等同于<code>stretch</code>. 该属性共有6种值, 其他值与上述align-items属性保持一致.</p>
</li>
<li><p><strong>order</strong> 指定子项目的顺序, 数值越小, 顺序越靠前, 默认为<code>0</code>.</p>
</li>
</ul>
<h3 id="flex属性的优先级"><a href="#flex属性的优先级" class="headerlink" title="flex属性的优先级"></a>flex属性的优先级</h3><p>我们可以给input设置<code>flex:1</code>, 使其充满一行, 并且随着父元素大小变化而变化. 也可以给div设置<code>flex:1</code>使其充满剩余高度.</p>
<p>使用flex布局这些都不是难事, 需要注意的是, 这其中有坑. 为了避免踩坑, 我们先来看下flex属性的优先级:</p>
<p><strong>width|height &gt; 自适应文本内容的宽度或高度 &gt; flex:数值</strong></p>
<p>这意味着, 首先是元素宽高的值优先, 其次是内容的宽高, 再次是flex数值. 现在我们来看看坑是什么.</p>
<ol>
<li>给input元素设置<code>flex:1</code>时需要注意, 通常input拥有一个默认宽度(用于展示默认数量的字符), 在chrome v55下, 这个宽度默认为126px(同时还包含2px的border). 因此想要实现input宽度自适应, 可以设置其width为0.</li>
<li>给div元素设置<code>flex:1</code>时, 因div的高度会受子级元素影响, 为了使得该div占满其父元素剩余的高度, 且不超出, 建议将该div的<code>height</code>属性设置为0.</li>
</ol>
<h3 id="场景回顾"><a href="#场景回顾" class="headerlink" title="场景回顾"></a>场景回顾</h3><ol>
<li><p>想要实现垂直居中的效果, 只需要设置父元素为<code>display:flex;justify-content:center</code> 即可. (当然, 父元素样式采用:<code>display:table;</code>, 子元素样式采用:<code>display:table-cell;vertical-align:middle</code> 也是可以实现的), 如下图.</p>
<p><img src="http://louiszhai.github.io/docImages/flex02.png" alt=""></p>
</li>
<li><p>想要实现左右两个元素等高(父元素高度由子元素撑开), 并且各占一半的宽度. 如上图.</p>
<ul>
<li>早期的实现方案, 需要借助负margin. 父元素样式设置为<code>overflow:hidden</code>, 子元素样式设置为<code>margin-bottom:-10000px;padding-bottom:10000px;</code>, 这样, 每个子元素便能借助padding撑开, 同时, 借助负margin和overflow合理裁剪.</li>
<li>第二种方案就是借助IE8都支持的<code>display:table</code>属性, 父元素样式设置为<code>display:table</code> , 子元素设置为<code>display:table-cell</code>. 利用表格的行高一致性, 轻松实现行高一致.</li>
<li>最终, 我们发现, 还是flex弹性盒模型来得方便快捷, 它只需要父级元素样式设置为<code>display:flex</code>.</li>
</ul>
</li>
<li><p>iphone低版本下，flex与inline-block有兼容性问题，这将导致inline-block的元素脱离flex布局（就好像其父元素没有设置为flex布局一样）。目前没有什么比较好的解决方案，建议在flex布局下慎用inline-block元素。</p>
</li>
</ol>
<p>有关flex的旧语法, 请戳这篇回顾  <a href="https://segmentfault.com/a/1190000003978624" target="_blank" rel="external">Flex布局新旧混合写法详解（兼容微信）</a> .</p>
<p>有关移动端的最佳实践, 请戳这篇围观 <a href="https://isux.tencent.com/flexbox.html" target="_blank" rel="external">移动端全兼容的flexbox速成班</a> .</p>
<p>当然, 这里还有一个 <a href="https://github.com/philipwalton/flexbugs" target="_blank" rel="external">Flexbugs</a> 列表, github上已有近6k的star, 感兴趣可以前去看看.</p>
<hr>
<p>本问就讨论这么多内容,大家有什么问题或好的想法欢迎在下方参与<a href="#respond">留言和评论</a>.</p>
<p>本文作者: <a href="https://github.com/Louiszhai" target="_blank" rel="external">louis</a></p>
<p>本文链接: <a href="http://louiszhai.github.io/2017/01/13/flex/">http://louiszhai.github.io/2017/01/13/flex/</a></p>
<p>参考文章</p>
<ul>
<li><a href="https://www.w3.org/TR/css-flexbox-1/" target="_blank" rel="external">CSS Flexible Box Layout Module Level 1</a></li>
<li><a href="https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/" target="_blank" rel="external">2012 CSS Flexible Box Layout Module</a></li>
<li><a href="https://www.w3.org/TR/2009/WD-css3-flexbox-20090723/" target="_blank" rel="external">2009 CSS Flexible Box Layout Module</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="external">Flex 布局教程：语法篇 - 阮一峰的网络日志</a></li>
<li><a href="https://zm10.sm-tc.cn/?src=l4uLj8XQ0IiIiNGIzJyPk4qM0ZyQktCcjIzM0J7SmIqWm5rSi5DSmZOah52Qh9GXi5KT&amp;from=derive&amp;depth=2&amp;v=1&amp;link_type=12&amp;uid=5f61658d8b9f95c8d0141e9c09fa6e85&amp;hid=f2ad43235a237619a455bdb39512d4c1&amp;restype=1&amp;uc_param_str=dnntnwvepffrgibijbprsvdsei&amp;query=%E5%A4%A7%E6%BC%A0+flex" target="_blank" rel="external">一个完整的Flexbox指南–大漠</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      弹性盒模型 flex flex-grow flex-shrink flex-basis align-items align-content order flex-flow flex-direction flex-wrap align-self
    
    </summary>
    
    
      <category term="CSS" scheme="http://louiszhai.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>JS中可能用得到的全部的排序算法</title>
    <link href="http://louiszhai.github.io/2016/12/23/sort/"/>
    <id>http://louiszhai.github.io/2016/12/23/sort/</id>
    <published>2016-12-23T03:55:14.000Z</published>
    <updated>2017-04-17T02:54:08.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h3><p>排序算法可以称得上是我的盲点, 曾几何时当我知道Chrome的Array.prototype.sort使用了快速排序时, 我的内心是奔溃的(啥是快排, 我只知道冒泡啊?!), 要知道学习一门技术最好的时间是三年前, 但愿我现在补习还来得及(捂脸).</p>
<p>因此本篇重拾了出镜概率比较高的十来种排序算法, 逐一分析其排序思想, 并批注注意事项. 欢迎对算法提出改进和<a href="#respond">讨论</a>.</p>
<a id="more"></a>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p><img src="http://louiszhai.github.io/docImages/sort02.gif" alt="冒泡"></p>
<p>冒泡排序需要两个嵌套的循环. 其中, <code>外层循环</code>移动游标; <code>内层循环</code>遍历游标及之后(或之前)的元素, 通过两两交换的方式, 每次只确保该内循环结束位置排序正确, 然后<code>内层循环</code>周期结束, 交由<code>外层循环</code>往后(或前)移动游标, 随即开始下一轮<code>内层循环</code>, 以此类推, 直至循环结束.</p>
<p><strong><em>Tips</em></strong>: 由于冒泡排序只在相邻元素大小不符合要求时才调换他们的位置, 它并不改变相同元素之间的相对顺序, 因此它是稳定的排序算法.</p>
<p>由于有两层循环, 因此可以有四种实现方式.</p>
<table>
<thead>
<tr>
<th style="text-align:center">方案</th>
<th style="text-align:center">外层循环</th>
<th style="text-align:center">内层循环</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">正序</td>
<td style="text-align:center">正序</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">正序</td>
<td style="text-align:center">逆序</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">逆序</td>
<td style="text-align:center">正序</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">逆序</td>
<td style="text-align:center">逆序</td>
</tr>
</tbody>
</table>
<p>四种不同循环方向, 实现方式略有差异.</p>
<p>如下是动图效果(对应于方案1: 内/外层循环均是正序遍历.</p>
<p><img src="http://louiszhai.github.io/docImages/sort05.gif" alt="冒泡排序"></p>
<p>如下是上图的算法实现(对应<strong>方案一</strong>: 内/外层循环均是正序遍历).</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//先将交换元素部分抽象出来</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">i,j,array</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> temp = array[j];</div><div class="line">  array[j] = array[i];</div><div class="line">  array[i] = temp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">array</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> length = array.length, isSwap;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;			<span class="comment">//正序</span></div><div class="line">    isSwap = <span class="literal">false</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; length - <span class="number">1</span> - i; j++) &#123;	 <span class="comment">//正序</span></div><div class="line">      array[j] &gt; array[j+<span class="number">1</span>] &amp;&amp; (isSwap = <span class="literal">true</span>) &amp;&amp; swap(j,j+<span class="number">1</span>,array);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(!isSwap)</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> array;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上, 排序的特点就是: 靠后的元素位置先确定.</p>
<p><strong>方案二</strong>: 外循环正序遍历, 内循环逆序遍历, 代码如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">array</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> length = array.length, isSwap;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;			<span class="comment">//正序</span></div><div class="line">    isSwap = <span class="literal">false</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = length - <span class="number">1</span>; j &gt;= i+<span class="number">1</span>; j--) &#123;	 <span class="comment">//逆序</span></div><div class="line">      array[j] &lt; array[j<span class="number">-1</span>] &amp;&amp; (isSwap = <span class="literal">true</span>) &amp;&amp; swap(j,j<span class="number">-1</span>,array);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(!isSwap)</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> array;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上, 靠前的元素位置先确定.</p>
<p><strong>方案三</strong>: 外循环逆序遍历, 内循环正序遍历, 代码如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">array</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> length = array.length, isSwap;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;	 <span class="comment">//逆序</span></div><div class="line">    isSwap = <span class="literal">false</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;			<span class="comment">//正序</span></div><div class="line">      array[j] &gt; array[j+<span class="number">1</span>] &amp;&amp; (isSwap = <span class="literal">true</span>) &amp;&amp; swap(j,j+<span class="number">1</span>,array);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(!isSwap)</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> array;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上, 由于内循环是正序遍历, 因此靠后的元素位置先确定.</p>
<p><strong>方案四</strong>: 外循环逆序遍历, 内循环逆序遍历, 代码如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">array</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> length = array.length, isSwap;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;				<span class="comment">//逆序</span></div><div class="line">    isSwap = <span class="literal">false</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = length - <span class="number">1</span>; j &gt;= length - <span class="number">1</span> - i; j--) &#123; <span class="comment">//逆序</span></div><div class="line">      array[j] &lt; array[j<span class="number">-1</span>] &amp;&amp; (isSwap = <span class="literal">true</span>) &amp;&amp; swap(j,j<span class="number">-1</span>,array);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(!isSwap)</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> array;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上, 由于内循环是逆序遍历, 因此靠前的元素位置先确定.</p>
<p>以下是其算法复杂度:</p>
<table>
<thead>
<tr>
<th style="text-align:center">平均时间复杂度</th>
<th style="text-align:center">最好情况</th>
<th style="text-align:center">最坏情况</th>
<th style="text-align:center">空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">O(n²)</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">O(n²)</td>
<td style="text-align:center">O(1)</td>
</tr>
</tbody>
</table>
<p>冒泡排序是最容易实现的排序, 最坏的情况是每次都需要交换, 共需遍历并交换将近n²/2次, 时间复杂度为O(n²). 最佳的情况是内循环遍历一次后发现排序是对的, 因此退出循环, 时间复杂度为O(n). 平均来讲, 时间复杂度为O(n²). 由于冒泡排序中只有缓存的temp变量需要内存空间, 因此空间复杂度为常量O(1).</p>
<h3 id="双向冒泡排序"><a href="#双向冒泡排序" class="headerlink" title="双向冒泡排序"></a>双向冒泡排序</h3><p>双向冒泡排序是冒泡排序的一个简易升级版, 又称鸡尾酒排序. 冒泡排序是从低到高(或者从高到低)单向排序, 双向冒泡排序顾名思义就是从两个方向分别排序(通常, 先从低到高, 然后从高到低). 因此它比冒泡排序性能稍好一些.</p>
<p>如下是算法实现:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bothwayBubbleSort</span>(<span class="params">array</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> tail = array.length<span class="number">-1</span>, i, isSwap = <span class="literal">false</span>;</div><div class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; tail; tail--)&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> j = tail; j &gt; i; j--)&#123;	<span class="comment">//第一轮, 先将最小的数据冒泡到前面</span></div><div class="line">      array[j<span class="number">-1</span>] &gt; array[j] &amp;&amp; (isSwap = <span class="literal">true</span>) &amp;&amp; swap(j,j<span class="number">-1</span>,array);</div><div class="line">    &#125;</div><div class="line">    i++;</div><div class="line">    <span class="keyword">for</span>(j = i; j &lt; tail; j++)&#123;		<span class="comment">//第二轮, 将最大的数据冒泡到后面</span></div><div class="line">      array[j] &gt; array[j+<span class="number">1</span>] &amp;&amp; (isSwap = <span class="literal">true</span>) &amp;&amp; swap(j,j+<span class="number">1</span>,array);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> array;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>从算法逻辑上看, 选择排序是一种简单且直观的排序算法. 它也是两层循环. <code>内层循环</code>就像工人一样, 它是真正做事情的, <code>内层循环</code>每执行一遍, 将选出本次待排序的元素中最小(或最大)的一个, 存放在数组的起始位置. 而 <code>外层循环</code>则像老板一样, 它告诉<code>内层循环</code>你需要不停的工作, 直到工作完成(也就是全部的元素排序完成).</p>
<p><strong><em>Tips</em></strong>: 选择排序每次交换的元素都有可能不是相邻的, 因此它有可能打破原来值为相同的元素之间的顺序. 比如数组[2,2,1,3], 正向排序时, 第一个数字2将与数字1交换, 那么两个数字2之间的顺序将和原来的顺序不一致, <strong>虽然它们的值相同, 但它们相对的顺序却发生了变化</strong>. 我们将这种现象称作 <code>不稳定性</code> .</p>
<p>如下是动图效果:</p>
<p><img src="http://louiszhai.github.io/docImages/sort06.gif" alt="选择排序"></p>
<p>如下是上图的算法实现:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectSort</span>(<span class="params">array</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> length = array.length, min;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</div><div class="line">    min = i;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; length; j++) &#123;</div><div class="line">      array[j] &lt; array[min] &amp;&amp; (min = j); <span class="comment">//记住最小数的下标</span></div><div class="line">    &#125;</div><div class="line">    min!=i &amp;&amp; swap(i,min,array);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> array;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以下是其算法复杂度:</p>
<table>
<thead>
<tr>
<th style="text-align:center">平均时间复杂度</th>
<th style="text-align:center">最好情况</th>
<th style="text-align:center">最坏情况</th>
<th style="text-align:center">空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">O(n²)</td>
<td style="text-align:center">O(n²)</td>
<td style="text-align:center">O(n²)</td>
<td style="text-align:center">O(1)</td>
</tr>
</tbody>
</table>
<p>选择排序的简单和直观名副其实, 这也造就了它”出了名的慢性子”, 无论是哪种情况, 哪怕原数组已排序完成, 它也将花费将近n²/2次遍历来确认一遍. 即便是这样, 它的排序结果也还是不稳定的. 唯一值得高兴的是, 它并不耗费额外的内存空间.</p>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>插入排序的设计初衷是往有序的数组中快速插入一个新的元素. 它的算法思想是: 把要排序的数组分为了两个部分, 一部分是数组的全部元素(除去待插入的元素), 另一部分是待插入的元素; 先将第一部分排序完成, 然后再插入这个元素. 其中第一部分的排序也是通过再次拆分为两部分来进行的.</p>
<p>插入排序由于操作不尽相同, 可分为 <code>直接插入排序</code> , <code>折半插入排序</code>(又称二分插入排序), <code>链表插入排序</code> , <code>希尔排序</code> .</p>
<h4 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h4><p>它的基本思想是: 将待排序的元素按照大小顺序, 依次插入到一个已经排好序的数组之中, 直到所有的元素都插入进去.</p>
<p>如下是动图效果:</p>
<p><img src="http://louiszhai.github.io/docImages/sort07.gif" alt="直接插入排序"></p>
<p>如下是上图的算法实现:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">directInsertionSort</span>(<span class="params">array</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> length = array.length, index, current;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</div><div class="line">    index = i - <span class="number">1</span>;		 <span class="comment">//待比较元素的下标</span></div><div class="line">    current = array[i];	 <span class="comment">//当前元素</span></div><div class="line">    <span class="keyword">while</span>(index &gt;= <span class="number">0</span> &amp;&amp; array[index] &gt; current) &#123; <span class="comment">//前置条件之一:待比较元素比当前元素大</span></div><div class="line">      array[index+<span class="number">1</span>] = array[index];	<span class="comment">//将待比较元素后移一位</span></div><div class="line">      index--;					       <span class="comment">//游标前移一位</span></div><div class="line">      <span class="comment">//console.log(array);</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(index+<span class="number">1</span> != i)&#123;				   <span class="comment">//避免同一个元素赋值给自身</span></div><div class="line">      array[index+<span class="number">1</span>] = current;		    <span class="comment">//将当前元素插入预留空位</span></div><div class="line">      <span class="comment">//console.log(array);</span></div><div class="line">    &#125;		</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> array;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为了更好的观察到直接插入排序的实现过程, 我们不妨将上述代码中的注释部分加入. 以数组 [5,4,3,2,1] 为例, 如下便是原数组的演化过程.</p>
<p><img src="http://louiszhai.github.io/docImages/sort01.png" alt=""></p>
<p>可见, 数组的各个元素, 从后往前, 只要比前面的元素小, 都依次插入到了合理的位置.</p>
<p><strong><em>Tips</em></strong>: 由于直接插入排序每次只移动一个元素的位置, 并不会改变值相同的元素之间的排序, 因此它是一种稳定排序.</p>
<h4 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h4><p>折半插入排序是直接插入排序的升级版. 鉴于插入排序第一部分为已排好序的数组, 我们不必按顺序依次寻找插入点, 只需比较它们的中间值与待插入元素的大小即可.</p>
<p><strong><em>Tips</em></strong>: 同直接插入排序类似, 折半插入排序每次交换的是相邻的且值为不同的元素, 它并不会改变值相同的元素之间的顺序. 因此它是稳定的.</p>
<p>算法基本思想是: </p>
<ol>
<li>取0 ~ i-1的中间点( <code>m = (i-1)&gt;&gt;1</code> ), array[i] 与 array[m] 进行比较, 若array[i] &lt; array[m] , 则说明待插入的元素array[i] 应该处于数组的 0 ~ m 索引之间; 反之, 则说明它应该处于数组的 m ~ i-1 索引之间.</li>
<li>重复步骤1, 每次缩小一半的查找范围, 直至找到插入的位置.</li>
<li>将数组中插入位置之后的元素全部后移一位.</li>
<li>在指定位置插入第 i 个元素.</li>
</ol>
<blockquote>
<p>注: <code>x&gt;&gt;1</code> 是位运算中的右移运算, 表示右移一位, 等同于x除以2再取整, 即 <code>x&gt;&gt;1 == Math.floor(x/2)</code> .</p>
</blockquote>
<p>如下是算法实现:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">binaryInsertionSort</span>(<span class="params">array</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> current, i, j, low, high, m;</div><div class="line">  <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; array.length; i++)&#123;</div><div class="line">    low = <span class="number">0</span>;</div><div class="line">    high = i - <span class="number">1</span>;</div><div class="line">    current = array[i];</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(low &lt;= high)&#123;			<span class="comment">//步骤1&amp;2:折半查找</span></div><div class="line">      m = (low + high)&gt;&gt;<span class="number">1</span>;</div><div class="line">      <span class="keyword">if</span>(array[i] &gt;= array[m])&#123;<span class="comment">//值相同时, 切换到高半区，保证稳定性</span></div><div class="line">        low = m + <span class="number">1</span>;		<span class="comment">//插入点在高半区</span></div><div class="line">      &#125;<span class="keyword">else</span>&#123;</div><div class="line">        high = m - <span class="number">1</span>;		<span class="comment">//插入点在低半区</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(j = i; j &gt; low; j--)&#123;	 <span class="comment">//步骤3:插入位置之后的元素全部后移一位</span></div><div class="line">      array[j] = array[j<span class="number">-1</span>];</div><div class="line">    &#125;</div><div class="line">    array[low] = current;		 <span class="comment">//步骤4:插入该元素</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> array;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为了便于对比, 同样以数组 [5,4,3,2,1] 举例🌰. 原数组的演化过程如下(与上述一样):</p>
<p><img src="http://louiszhai.github.io/docImages/sort.png" alt="折半插入排序"></p>
<p>虽然折半插入排序明显减少了查询的次数, 但是数组元素移动的次数却没有改变. 它们的时间复杂度都是O(n²).</p>
<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><p>希尔排序也称缩小增量排序, 它是直接插入排序的另外一个升级版, 实质就是分组插入排序. 希尔排序以其设计者希尔(Donald Shell)的名字命名, 并于1959年公布.</p>
<p>算法的基本思想: </p>
<ol>
<li>将数组拆分为若干个子分组, 每个分组由相距一定”增量”的元素组成. 比方说将[0,1,2,3,4,5,6,7,8,9,10]的数组拆分为”增量”为5的分组, 那么子分组分别为 [0,5], [1,6], [2,7], [3,8], [4,9] 和 [5,10].</li>
<li>然后对每个子分组应用直接插入排序.</li>
<li>逐步减小”增量”, 重复步骤1,2.</li>
<li>直至”增量”为1, 这是最后一个排序, 此时的排序, 也就是对全数组进行直接插入排序.</li>
</ol>
<p>如下是排序的示意图:</p>
<p><img src="http://louiszhai.github.io/docImages/sort04.png" alt="希尔排序示意图"></p>
<p>可见, 希尔排序实际上就是不断的进行直接插入排序, 分组是为了先将局部元素有序化. 因为直接插入排序在元素基本有序的状态下, 效率非常高. 而希尔排序呢, 通过先分组后排序的方式, 制造了直接插入排序高效运行的场景. 因此希尔排序效率更高.</p>
<p>我们试着抽象出共同点, 便不难发现上述希尔排序的第四步就是一次直接插入排序, 而希尔排序原本就是从”增量”为n开始, 直至”增量”为1, 循环应用直接插入排序的一种封装. 因此直接插入排序就可以看做是步长为1的希尔排序. 为此我们先来封装下直接插入排序.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//形参增加步数gap(实际上就相当于gap替换了原来的数字1)</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">directInsertionSort</span>(<span class="params">array, gap</span>) </span>&#123;</div><div class="line">  gap = (gap == <span class="literal">undefined</span>) ? <span class="number">1</span> : gap;       <span class="comment">//默认从下标为1的元素开始遍历</span></div><div class="line">  <span class="keyword">var</span> length = array.length, index, current;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = gap; i &lt; length; i++) &#123;</div><div class="line">    index = i - gap;	<span class="comment">//待比较元素的下标</span></div><div class="line">    current = array[i];	<span class="comment">//当前元素</span></div><div class="line">    <span class="keyword">while</span>(index &gt;= <span class="number">0</span> &amp;&amp; array[index] &gt; current) &#123; <span class="comment">//前置条件之一:待比较元素比当前元素大</span></div><div class="line">      array[index + gap] = array[index];	<span class="comment">//将待比较元素后移gap位</span></div><div class="line">      index -= gap;					       <span class="comment">//游标前移gap位</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(index + gap != i)&#123;				   <span class="comment">//避免同一个元素赋值给自身</span></div><div class="line">      array[index + gap] = current;		    <span class="comment">//将当前元素插入预留空位</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> array;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么希尔排序的算法实现如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">shellSort</span>(<span class="params">array</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> length = array.length, gap = length&gt;&gt;<span class="number">1</span>, current, i, j;</div><div class="line">  <span class="keyword">while</span>(gap &gt; <span class="number">0</span>)&#123;</div><div class="line">    directInsertionSort(array, gap); <span class="comment">//按指定步长进行直接插入排序</span></div><div class="line">    gap = gap&gt;&gt;<span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> array;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同样以数组[5,4,3,2,1] 举例🌰. 原数组的演化过程如下:</p>
<p><img src="http://louiszhai.github.io/docImages/sort03.png" alt="希尔排序"></p>
<p>对比上述直接插入排序和折半插入排序, 数组元素的移动次数由14次减少为7次. 通过拆分原数组为粒度更小的子数组, 希尔排序进一步提高了排序的效率.</p>
<p>不仅如此, 以上步长设置为了 {N/2, (N/2)/2, …, 1}. 该序列即<a href="http://baike.baidu.com/view/10729635.htm" target="_blank" rel="external">希尔增量</a>, 其它的增量序列 还有Hibbard：{1, 3, …, 2^k-1}. 通过合理调节步长, 还能进一步提升排序效率. 实际上已知的最好步长序列是由Sedgewick提出的(1, 5, 19, 41, 109,…). 该序列中的项或者是9*4^i - 9*2^i + 1或者是4^i - 3*2^i + 1. 具体请戳 <a href="https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F#步长序列" target="_blank" rel="external">希尔排序-维基百科</a> .</p>
<p><strong><em>Tips</em></strong>: 我们知道, 单次直接插入排序是稳定的, 它不会改变相同元素之间的相对顺序, 但在多次不同的插入排序过程中, 相同的元素可能在各自的插入排序中移动, 可能导致相同元素相对顺序发生变化. 因此, 希尔排序并不稳定.</p>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序建立在归并操作之上, 它采取分而治之的思想, 将数组拆分为两个子数组, 分别排序, 最后才将两个子数组合并; 拆分的两个子数组, 再继续递归拆分为更小的子数组, 进而分别排序, 直到数组长度为1, 直接返回该数组为止.</p>
<p><strong><em>Tips</em></strong>: 归并排序严格按照从左往右(或从右往左)的顺序去合并子数组, 它并不会改变相同元素之间的相对顺序, 因此它也是一种稳定的排序算法.</p>
<p>如下是动图效果:</p>
<p><img src="http://louiszhai.github.io/docImages/sort08.gif" alt="归并排序"></p>
<p>归并排序可通过两种方式实现:</p>
<ol>
<li>自上而下的递归</li>
<li>自下而上的迭代</li>
</ol>
<p>如下是算法实现(方式1:递归):</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">array</span>) </span>&#123;  <span class="comment">//采用自上而下的递归方法</span></div><div class="line">  <span class="keyword">var</span> length = array.length;</div><div class="line">  <span class="keyword">if</span>(length &lt; <span class="number">2</span>) &#123;</div><div class="line">    <span class="keyword">return</span> array;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">var</span> m = (length &gt;&gt; <span class="number">1</span>),</div><div class="line">      left = array.slice(<span class="number">0</span>, m),</div><div class="line">      right = array.slice(m); <span class="comment">//拆分为两个子数组</span></div><div class="line">  <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right));<span class="comment">//子数组继续递归拆分,然后再合并</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">left, right</span>)</span>&#123; <span class="comment">//合并两个子数组</span></div><div class="line">  <span class="keyword">var</span> result = [];</div><div class="line">  <span class="keyword">while</span> (left.length &amp;&amp; right.length) &#123;</div><div class="line">    <span class="keyword">var</span> item = left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>] ? left.shift() : right.shift();<span class="comment">//注意:判断的条件是小于或等于,如果只是小于,那么排序将不稳定.</span></div><div class="line">    result.push(item);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> result.concat(left.length ? left : right);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由上, 长度为n的数组, 最终会调用mergeSort函数2n-1次. 通过自上而下的递归实现的归并排序, 将存在堆栈溢出的风险. 亲测各浏览器的堆栈溢出所需的递归调用次数大致为:</p>
<ul>
<li>Chrome v55: 15670</li>
<li>Firefox v50: 44488</li>
<li>Safari v9.1.2: 50755</li>
</ul>
<p>以下是测试代码:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">computeMaxCallStackSize</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span> + computeMaxCallStackSize();</div><div class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">    <span class="comment">// Call stack overflow</span></div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> time = computeMaxCallStackSize();</div><div class="line"><span class="built_in">console</span>.log(time);</div></pre></td></tr></table></figure>
<p>为此, ES6规范中提出了尾调优化的思想: 如果一个函数的最后一步也是一个函数调用, 那么该函数所需要的栈空间将被释放, 它将直接进入到下次调用中, 最终调用栈里只保留最后一次的调用记录.</p>
<p>虽然ES6规范如此诱人, 然而目前并没有浏览器支持尾调优化, 相信在不久的将来, 尾调优化就会得到主流浏览器的支持.</p>
<p>以下是其算法复杂度:</p>
<table>
<thead>
<tr>
<th style="text-align:center">平均时间复杂度</th>
<th style="text-align:center">最好情况</th>
<th style="text-align:center">最坏情况</th>
<th style="text-align:center">空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">O(nlog₂n)</td>
<td style="text-align:center">O(nlog₂n)</td>
<td style="text-align:center">O(nlog₂n)</td>
<td style="text-align:center">O(n)</td>
</tr>
</tbody>
</table>
<p>从效率上看, 归并排序可算是排序算法中的”佼佼者”. 假设数组长度为n, 那么拆分数组共需logn步, 又每步都是一个普通的合并子数组的过程, 时间复杂度为O(n), 故其综合时间复杂度为O(nlogn). 另一方面, 归并排序多次递归过程中拆分的子数组需要保存在内存空间, 其空间复杂度为O(n).</p>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序借用了分治的思想, 并且基于冒泡排序做了改进. 它由C. A. R. Hoare在1962年提出. 它将数组拆分为两个子数组, 其中一个子数组的所有元素都比另一个子数组的元素小, 然后对这两个子数组再重复进行上述操作, 直到数组不可拆分, 排序完成.</p>
<p>如下是动图效果:</p>
<p><img src="http://louiszhai.github.io/docImages/sort09.gif" alt="快速排序"></p>
<p>如下是算法实现:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">array, left, right</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> partitionIndex,</div><div class="line">      left = <span class="keyword">typeof</span> left == <span class="string">'number'</span> ? left : <span class="number">0</span>,</div><div class="line">      right = <span class="keyword">typeof</span> right == <span class="string">'number'</span> ? right : array.length<span class="number">-1</span>;</div><div class="line">  <span class="keyword">if</span> (left &lt; right) &#123;</div><div class="line">    partitionIndex = partition(array, left, right);<span class="comment">//切分的基准值</span></div><div class="line">    quickSort(array, left, partitionIndex<span class="number">-1</span>);</div><div class="line">    quickSort(array, partitionIndex+<span class="number">1</span>, right);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> array;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">partition</span>(<span class="params">array, left ,right</span>) </span>&#123;   <span class="comment">//分区操作</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = left+<span class="number">1</span>, j = left; i &lt;= right; i++) &#123;<span class="comment">//j是较小值存储位置的游标</span></div><div class="line">    array[i] &lt; array[left] &amp;&amp; swap(i, ++j, array);<span class="comment">//以第一个元素为基准</span></div><div class="line">  &#125;</div><div class="line">  swap(left, j, array);			<span class="comment">//将第一个元素移至中间</span></div><div class="line">  <span class="keyword">return</span> j;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以下是其算法复杂度:</p>
<table>
<thead>
<tr>
<th style="text-align:center">平均时间复杂度</th>
<th style="text-align:center">最好情况</th>
<th style="text-align:center">最坏情况</th>
<th style="text-align:center">空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">O(nlog₂n)</td>
<td style="text-align:center">O(nlog₂n)</td>
<td style="text-align:center">O(n²)</td>
<td style="text-align:center">O(nlog₂n)</td>
</tr>
</tbody>
</table>
<p>快速排序排序效率非常高. 虽然它运行最糟糕时将达到O(n²)的时间复杂度, 但通常, 平均来看, 它的时间复杂为O(nlogn), 比同样为O(nlogn)时间复杂度的归并排序还要快. 快速排序似乎更偏爱乱序的数列, 越是乱序的数列, 它相比其他排序而言, 相对效率更高. 之前在 <a href="http://louiszhai.github.io/2015/12/29/array/#">捋一捋JS的数组</a> 一文中就提到: <strong>Chrome的v8引擎为了高效排序, 在排序数据超过了10条时, 便会采用快速排序. 对于10条及以下的数据采用的便是插入排序.</strong></p>
<p><strong><em>Tips</em></strong>: 同选择排序相似, 快速排序每次交换的元素都有可能不是相邻的, 因此它有可能打破原来值为相同的元素之间的顺序. 因此, 快速排序并不稳定.</p>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><blockquote>
<p>1991年的计算机先驱奖获得者、斯坦福大学计算机科学系教授罗伯特·弗洛伊德(Robert W．Floyd) 和威廉姆斯(J．Williams) 在1964年共同发明了著名的堆排序算法(Heap Sort).</p>
</blockquote>
<p>堆排序是利用堆这种数据结构所设计的一种排序算法. 它是选择排序的一种. 堆分为大根堆和小根堆. 大根堆要求每个子节点的值都不大于其父节点的值, 即array[childIndex] &lt;= array[parentIndex], 最大的值一定在堆顶. 小根堆与之相反, 即每个子节点的值都不小于其父节点的值, 最小的值一定在堆顶. 因此我们可使用大根堆进行升序排序, 使用小根堆进行降序排序.</p>
<p>并非所有的序列都是堆, 对于序列k1, k2,…kn, 需要满足如下条件才行:</p>
<ul>
<li>ki &lt;= k(2i) 且 ki&lt;=k(2i+1)(1≤i≤ n/2), 即为小根堆, 将&lt;=换成&gt;=, 那么则是大根堆. 我们可以将这里的堆看作完全二叉树, k(i) 相当于是二叉树的非叶子节点, k(2i) 则是左子节点, k(2i+1)是右子节点.</li>
</ul>
<p>算法的基本思想(以大根堆为例): </p>
<ol>
<li>先将初始序列K[1..n]建成一个大根堆, 此堆为初始的无序区.</li>
<li>再将关键字最大的记录K<a href="#respond">1</a> (即堆顶)和无序区的最后一个记录K[n]交换, 由此得到新的无序区K[1..n-1]和有序区K[n], 且满足K[1..n-1].keys≤K[n].key</li>
<li>交换K<a href="#respond">1</a> 和 K[n] 后, 堆顶可能违反堆性质, 因此需将K[1..n-1]调整为堆. 然后重复步骤2, 直到无序区只有一个元素时停止.</li>
</ol>
<p>如下是动图效果:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1867034-bf2472770e2258a9.gif?imageMogr2/auto-orient/strip" alt="桶排序示意图"></p>
<p>如下是算法实现:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapAdjust</span>(<span class="params">array, i, length</span>) </span>&#123;<span class="comment">//堆调整</span></div><div class="line">  <span class="keyword">var</span> left = <span class="number">2</span> * i + <span class="number">1</span>,</div><div class="line">      right = <span class="number">2</span> * i + <span class="number">2</span>,</div><div class="line">      largest = i;</div><div class="line">  <span class="keyword">if</span> (left &lt; length &amp;&amp; array[largest] &lt; array[left]) &#123;</div><div class="line">    largest = left;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (right &lt; length &amp;&amp; array[largest] &lt; array[right]) &#123;</div><div class="line">    largest = right;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (largest != i) &#123;</div><div class="line">    swap(i, largest, array);</div><div class="line">    heapAdjust(array, largest, length);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapSort</span>(<span class="params">array</span>) </span>&#123;</div><div class="line">  <span class="comment">//建立大顶堆</span></div><div class="line">  length = array.length;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = length&gt;&gt;<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">    heapAdjust(array, i, length);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//调换第一个与最后一个元素,重新调整为大顶堆</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</div><div class="line">    swap(<span class="number">0</span>, i, array);</div><div class="line">    heapAdjust(array, <span class="number">0</span>, --length);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> array;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上, ①建立堆的过程, 从length/2 一直处理到0, 时间复杂度为O(n);</p>
<p>②调整堆的过程是沿着堆的父子节点进行调整, 执行次数为堆的深度, 时间复杂度为O(lgn);</p>
<p>③堆排序的过程由n次第②步完成, 时间复杂度为O(nlgn).</p>
<p><strong><em>Tips</em></strong>: 由于堆排序中初始化堆的过程比较次数较多, 因此它不太适用于小序列. 同时由于多次任意下标相互交换位置, 相同元素之间原本相对的顺序被破坏了, 因此, 它是不稳定的排序.</p>
<h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p>计数排序几乎是唯一一个不基于比较的排序算法, 该算法于1954年由 Harold H. Seward 提出. 使用它处理一定范围内的整数排序时, 时间复杂度为O(n+k), 其中k是整数的范围, 它几乎比任何基于比较的排序算法都要快( 只有当O(k)&gt;O(n*log(n))的时候其效率反而不如基于比较的排序, 如归并排序和堆排序).</p>
<p>使用计数排序需要满足如下条件:</p>
<ul>
<li>待排序的序列全部为整数</li>
<li>排序需要额外的存储空间</li>
</ul>
<p>算法的基本思想: </p>
<blockquote>
<p>计数排序利用了一个特性, 对于数组的某个元素, 一旦知道了有多少个其它元素比它小(假设为m个), 那么就可以确定出该元素的正确位置(第m+1位)</p>
</blockquote>
<ol>
<li>初始化游标i为0, 并准备一个缓存数组B, 长度为待排序数组A的最大值+1, 循环一遍待排序数组A, 在缓存数组B中存储A的各个元素出现的次数.</li>
<li>①将B中的当前元素item与0比较, 若大于0, 则往待排序数组A中写入一项A[i] = item; 然后i++, item—; 然后重复步骤①, 直到item==0, 则进入到B的下一个元素中.</li>
<li>遍历缓存数组B, 即循环执行步骤2. 最终所有有效元素都将依次写回待排序数组A的第1,2,…n项.</li>
</ol>
<p>如下是动图效果:</p>
<p><img src="http://louiszhai.github.io/docImages/sort10.gif" alt="计数排序"></p>
<p>如下是算法实现:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">countSort</span>(<span class="params">array, max</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> tempLength = max + <span class="number">1</span>,</div><div class="line">        temp = <span class="keyword">new</span> <span class="built_in">Array</span>(tempLength),</div><div class="line">        index = <span class="number">0</span>,</div><div class="line">        length = array.length;   </div><div class="line">    <span class="comment">//初始化缓存数组各项的值</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (!temp[array[i]]) &#123;</div><div class="line">            temp[array[i]] = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        temp[array[i]]++;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//依次取出缓存数组的值,并写入原数组</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; tempLength; j++) &#123;</div><div class="line">        <span class="keyword">while</span>(temp[j] &gt; <span class="number">0</span>) &#123;</div><div class="line">            array[index++] = j;</div><div class="line">            temp[j]--;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> array;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>Tips</em></strong>: 计数排序不改变相同元素之间原本相对的顺序, 因此它是稳定的排序算法.</p>
<h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p>桶排序即所谓的箱排序, 它是将数组分配到有限数量的桶子里. 每个桶里再各自排序(因此有可能使用别的排序算法或以递归方式继续桶排序). 当每个桶里的元素个数趋于一致时, 桶排序只需花费O(n)的时间. 桶排序通过空间换时间的方式提高了效率, 因此它需要额外的存储空间(即桶的空间).</p>
<p>算法的基本思想:</p>
<p>桶排序的核心就在于怎么把元素平均分配到每个桶里, 合理的分配将大大提高排序的效率.</p>
<p>如下是算法实现:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bucketSort</span>(<span class="params">array, bucketSize</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (array.length === <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">return</span> array;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> i = <span class="number">1</span>,</div><div class="line">      min = array[<span class="number">0</span>],</div><div class="line">      max = min;</div><div class="line">  <span class="keyword">while</span> (i++ <span class="xml"><span class="tag">&lt; <span class="attr">array.length</span>) &#123;</span></span></div><div class="line">    <span class="attr">if</span> (<span class="attr">array</span>[<span class="attr">i</span>] &lt; <span class="attr">min</span>) &#123;</div><div class="line">      <span class="attr">min</span> = <span class="string">array[i];</span>                //输入数据的最小值</div><div class="line">    &#125; <span class="attr">else</span> <span class="attr">if</span> (<span class="attr">array</span>[<span class="attr">i</span>] &gt; max) &#123;</div><div class="line">      max = array[i];                //输入数据的最大值</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  //桶的初始化</div><div class="line">  bucketSize = bucketSize || 5; //设置桶的默认大小为5</div><div class="line">  var bucketCount = ~~((max - min) / bucketSize) + 1, //桶的个数</div><div class="line">      buckets = new Array(bucketCount); //创建桶</div><div class="line">  for (i = 0; i <span class="tag">&lt; <span class="attr">buckets.length</span>; <span class="attr">i</span>++) &#123;</span></div><div class="line">    <span class="attr">buckets</span>[<span class="attr">i</span>] = <span class="string">[];</span> //初始化桶</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  //将数据分配到各个桶中,这里直接按照数据值的分布来分配,一定范围内均匀分布的数据效率最为高效</div><div class="line">  <span class="attr">for</span> (<span class="attr">i</span> = <span class="string">0;</span> <span class="attr">i</span> &lt; <span class="attr">array.length</span>; <span class="attr">i</span>++) &#123;</div><div class="line">    <span class="attr">buckets</span>[~~((<span class="attr">array</span>[<span class="attr">i</span>] <span class="attr">-</span> <span class="attr">min</span>) / <span class="attr">bucketSize</span>)]<span class="attr">.push</span>(<span class="attr">array</span>[<span class="attr">i</span>]);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="attr">array.length</span> = <span class="string">0;</span></div><div class="line">  <span class="attr">for</span> (<span class="attr">i</span> = <span class="string">0;</span> <span class="attr">i</span> &lt; <span class="attr">buckets.length</span>; <span class="attr">i</span>++) &#123;</div><div class="line">    <span class="attr">quickSort</span>(<span class="attr">buckets</span>[<span class="attr">i</span>]); //对每个桶进行排序，这里使用了快速排序</div><div class="line">    <span class="attr">for</span> (<span class="attr">var</span> <span class="attr">j</span> = <span class="string">0;</span> <span class="attr">j</span> &lt; <span class="attr">buckets</span>[<span class="attr">i</span>]<span class="attr">.length</span>; <span class="attr">j</span>++) &#123;</div><div class="line">      <span class="attr">array.push</span>(<span class="attr">buckets</span>[<span class="attr">i</span>][<span class="attr">j</span>]); //将已排序的数据写回数组中</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="attr">return</span> <span class="attr">array</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>Tips</em></strong>: 桶排序本身是稳定的排序, 因此它的稳定性与桶内排序的稳定性保持一致.</p>
<p>实际上, 桶也只是一个抽象的概念, 它的思想与归并排序,快速排序等类似, 都是通过将大量数据分配到N个不同的容器中, 分别排序, 最后再合并数据. 这种方式大大减少了排序时整体的遍历次数, 提高了算法效率.</p>
<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>基数排序源于老式穿孔机, 排序器每次只能看到一个列. 它是基于元素值的每个位上的字符来排序的. 对于数字而言就是分别基于个位, 十位, 百位 或千位等等数字来排序. (不明白不要紧, 我也不懂, 请接着往下读)</p>
<p>按照优先从高位或低位来排序有两种实现方案:</p>
<ul>
<li>MSD: 由高位为基底, 先按k1排序分组, 同一组中记录, 关键码k1相等, 再对各组按k2排序分成子组, 之后, 对后面的关键码继续这样的排序分组, 直到按最次位关键码kd对各子组排序后. 再将各组连接起来, 便得到一个有序序列. MSD方式适用于位数多的序列.</li>
<li>LSD: 由低位为基底, 先从kd开始排序，再对kd-1进行排序，依次重复，直到对k1排序后便得到一个有序序列. LSD方式适用于位数少的序列.</li>
</ul>
<p>如下是LSD的动图效果:</p>
<p><img src="http://louiszhai.github.io//docImages/sort11.gif" alt="基数排序">)</p>
<p>如下是算法实现:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">radixSort</span>(<span class="params">array, max</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> buckets = [],</div><div class="line">        unit = <span class="number">10</span>,</div><div class="line">        base = <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; max; i++, base *= <span class="number">10</span>, unit *= <span class="number">10</span>) &#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; array.length; j++) &#123;</div><div class="line">            <span class="keyword">var</span> index = ~~((array[j] % unit) / base);<span class="comment">//依次过滤出个位,十位等等数字</span></div><div class="line">            <span class="keyword">if</span>(buckets[index] == <span class="literal">null</span>) &#123;</div><div class="line">                buckets[index] = []; <span class="comment">//初始化桶</span></div><div class="line">            &#125;</div><div class="line">            buckets[index].push(array[j]);<span class="comment">//往不同桶里添加数据</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">var</span> pos = <span class="number">0</span>,</div><div class="line">            value;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>, length = buckets.length; j &lt; length; j++) &#123;</div><div class="line">            <span class="keyword">if</span>(buckets[j] != <span class="literal">null</span>) &#123;</div><div class="line">                <span class="keyword">while</span> ((value = buckets[j].shift()) != <span class="literal">null</span>) &#123;</div><div class="line">                      array[pos++] = value; <span class="comment">//将不同桶里数据挨个捞出来,为下一轮高位排序做准备,由于靠近桶底的元素排名靠前,因此从桶底先捞</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> array;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上算法, 如果用来比较时间, 先按日排序, 再按月排序, 最后按年排序, 仅需排序三次.</p>
<p>基数排序更适合用于对时间, 字符串等这些整体权值未知的数据进行排序.</p>
<p><strong><em>Tips</em></strong>: 基数排序不改变相同元素之间的相对顺序, 因此它是稳定的排序算法.</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>各种排序性能对比如下:</p>
<table>
<thead>
<tr>
<th style="text-align:center">排序类型</th>
<th style="text-align:center">平均情况</th>
<th style="text-align:center">最好情况</th>
<th style="text-align:center">最坏情况</th>
<th style="text-align:center">辅助空间</th>
<th style="text-align:center">稳定性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">冒泡排序</td>
<td style="text-align:center">O(n²)</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">O(n²)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">选择排序</td>
<td style="text-align:center">O(n²)</td>
<td style="text-align:center">O(n²)</td>
<td style="text-align:center">O(n²)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:center">直接插入排序</td>
<td style="text-align:center">O(n²)</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">O(n²)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">折半插入排序</td>
<td style="text-align:center">O(n²)</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">O(n²)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">希尔排序</td>
<td style="text-align:center">O(n^1.3)</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">O(n²)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:center">归并排序</td>
<td style="text-align:center">O(nlog₂n)</td>
<td style="text-align:center">O(nlog₂n)</td>
<td style="text-align:center">O(nlog₂n)</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">快速排序</td>
<td style="text-align:center">O(nlog₂n)</td>
<td style="text-align:center">O(nlog₂n)</td>
<td style="text-align:center">O(n²)</td>
<td style="text-align:center">O(nlog₂n)</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:center">堆排序</td>
<td style="text-align:center">O(nlog₂n)</td>
<td style="text-align:center">O(nlog₂n)</td>
<td style="text-align:center">O(nlog₂n)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:center">计数排序</td>
<td style="text-align:center">O(n+k)</td>
<td style="text-align:center">O(n+k)</td>
<td style="text-align:center">O(n+k)</td>
<td style="text-align:center">O(k)</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">桶排序</td>
<td style="text-align:center">O(n+k)</td>
<td style="text-align:center">O(n+k)</td>
<td style="text-align:center">O(n²)</td>
<td style="text-align:center">O(n+k)</td>
<td style="text-align:center">(不)稳定</td>
</tr>
<tr>
<td style="text-align:center">基数排序</td>
<td style="text-align:center">O(d(n+k))</td>
<td style="text-align:center">O(d(n+k))</td>
<td style="text-align:center">O(d(n+kd))</td>
<td style="text-align:center">O(n+kd)</td>
<td style="text-align:center">稳定</td>
</tr>
</tbody>
</table>
<p>注: 桶排序的稳定性取决于桶内排序的稳定性, 因此其稳定性不确定. 基数排序中, k代表关键字的基数, d代表长度, n代表关键字的个数.</p>
<p>愿以此文怀念下我那远去的算法课程.</p>
<p>未完待续…</p>
<p>感谢 <a href="http://visualgo.net/" target="_blank" rel="external">http://visualgo.net/</a> 提供图片支持. 特别感谢 <a href="http://www.jianshu.com/users/6c53fb7d1bce" target="_blank" rel="external">不是小羊的肖恩</a> 在简书上发布的 <a href="http://www.jianshu.com/p/1b4068ccd505" target="_blank" rel="external">JS家的排序算法</a> 提供的讲解.</p>
<hr>
<p>本问就讨论这么多内容,大家有什么问题或好的想法欢迎在下方参与<a href="#respond">留言和评论</a>.</p>
<p>本文作者: <a href="https://github.com/Louiszhai" target="_blank" rel="external">louis</a></p>
<p>本文链接: <a href="http://louiszhai.github.io/2016/12/23/sort/">http://louiszhai.github.io/2016/12/23/sort/</a></p>
<p>参考文章</p>
<ul>
<li><a href="http://www.jianshu.com/p/1b4068ccd505" target="_blank" rel="external">JS家的排序算法 - 简书</a></li>
<li><a href="http://blog.csdn.net/morewindows/article/details/6668714" target="_blank" rel="external">白话经典算法系列之三 希尔排序的实现 - MoreWindows Blog - 博客频道 - CSDN.NET</a></li>
<li><a href="http://www.cnblogs.com/ludashi/p/6031379.html" target="_blank" rel="external">算法与数据结构(十三) 冒泡排序、插入排序、希尔排序、选择排序（Swift3.0版） - 青玉伏案 - 博客园</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      算法 冒泡排序 双向冒泡排序 选择排序 插入排序 直接插入排序 折半插入排序 希尔排序 归并排序 快速排序 堆排序 计数排序 桶排序 基数排序
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://louiszhai.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>聊一聊H5应用缓存-Manifest</title>
    <link href="http://louiszhai.github.io/2016/11/25/manifest/"/>
    <id>http://louiszhai.github.io/2016/11/25/manifest/</id>
    <published>2016-11-25T00:08:21.000Z</published>
    <updated>2017-04-17T02:55:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h3><p>Manifest 是 H5提供的一种应用缓存机制, 基于它web应用可以实现离线访问(offline cache). 为此, 浏览器还提供了应用缓存的api–applicationCache. 虽然manifest的技术已被web标准废弃, 但这不影响我们尝试去了解它. 也正是因为manifest的应用缓存机制如此诱人, 饿了么 和 office 365邮箱等都还在使用着它!</p>
<a id="more"></a>
<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>对manifest熟悉的同学可以跳过此节.</p>
<p>鉴于manifest应用缓存的技术, 我们可以做到:</p>
<ul>
<li>离线访问: 即使服务器挂了, 或者没有网络, 用户依然可以正常浏览网页内容.</li>
<li>访问更快: 数据存在于本地, 省去了浏览器发起http请求的时间, 因此访问更快, 移动端效果更为明显.</li>
<li>降低负载: 浏览器只在manifest文件改动时才去服务器下载需要缓存的资源, 大大降低了服务器负载.</li>
</ul>
<p>manifest缓存的过程如下(来自网络):</p>
<p><img src="http://ww2.sinaimg.cn/large/006y8lVagw1fa479nwxhmj30pm08hdgj.jpg" alt="manifest"></p>
<h3 id="支持性"><a href="#支持性" class="headerlink" title="支持性"></a>支持性</h3><p>主流浏览器都支持manifest应用缓存技术. 如下表格:</p>
<table>
<thead>
<tr>
<th style="text-align:center">IE</th>
<th style="text-align:center">Edge</th>
<th style="text-align:center">Firefox</th>
<th style="text-align:center">Chrome</th>
<th style="text-align:center">Safari</th>
<th style="text-align:center">Opera</th>
<th style="text-align:center">ios</th>
<th style="text-align:center">Android</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">10+</td>
<td style="text-align:center">12+</td>
<td style="text-align:center">3.5+</td>
<td style="text-align:center">4+</td>
<td style="text-align:center">4+</td>
<td style="text-align:center">11.5+</td>
<td style="text-align:center">7.1+</td>
<td style="text-align:center">2.3+</td>
</tr>
</tbody>
</table>
<p>H5标准中, <a href="https://html.spec.whatwg.org/#offline" target="_blank" rel="external">Offline Web applications</a> 部分有如下描述:</p>
<blockquote>
<p>This feature is in the process of being removed from the Web platform. (This is a long process that takes many years.) Using any of the offline Web application features at this time is highly discouraged. Use service workers instead. <a href="https://html.spec.whatwg.org/#refsSW" target="_blank" rel="external">[SW]</a></p>
</blockquote>
<p>因此后续我将在其他文章中继续介绍 service workers, 本篇继续关注manifest.</p>
<h3 id="如何开启应用缓存"><a href="#如何开启应用缓存" class="headerlink" title="如何开启应用缓存"></a>如何开启应用缓存</h3><p>manifest使用缓存清单进行管理, 缓存清单需要与html标签进行关联. 如下:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">manifest</span>=<span class="string">"test.appcache"</span>&gt;</span></div><div class="line">  ...</div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>在html标签中指定manifest文件, 便表示该网页使用manifest进行离线缓存. 该网页内需要缓存的文件列表需要在 test.appcache 文本文件中指定.</p>
<h3 id="manifest缓存清单"><a href="#manifest缓存清单" class="headerlink" title="manifest缓存清单"></a>manifest缓存清单</h3><p>就像写作文一样, manifest采用经典的三段式. 分别为: <code>CACHE</code>, <code>NETWORK</code> 和 <code>FALLBACK</code>. 如下, 先看一个栗子🌰:</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">CACHE MANIFEST</div><div class="line"><span class="meta"># v1.0.0</span></div><div class="line">content.css</div><div class="line"></div><div class="line"><span class="symbol">NETWORK:</span></div><div class="line">app.js</div><div class="line"></div><div class="line"><span class="symbol">FALLBACK:</span></div><div class="line">/other <span class="number">404.</span>html</div></pre></td></tr></table></figure>
<p>其中第一行必须以 <code>CACHE MANIFEST</code> 开头, 后可跟若干字符注释, 注释从#号开始. 跟在  <code>CACHE MANIFEST</code>  行后的文件, 每行列出一个, 这些文件是需要缓存的文件. 因此 content.css 会被缓存, 不需要访问网络.</p>
<p>第二段内容以 <code>NETWORK:</code> 开始, 跟在该行后的文件表示需要访问网络. 如: app.js 将直接从网络上下载, 并不走manifest cache, 如果除了第一段中缓存的文件以外, 其他文件都从网络上获取, 那么此时可将 app.js 改为 * (通配符).</p>
<p>第三段内容以 <code>FALLBACK:</code> 开始, 跟在该行后的文件表示会有一个替代方案. 如: 当访问 /other 路径时, 如果访问失败, 那么将自动加载 404.html 作为替代.</p>
<h3 id="manifest缓存状态"><a href="#manifest缓存状态" class="headerlink" title="manifest缓存状态"></a>manifest缓存状态</h3><p>每个manifest缓存都有一个状态, 标示着缓存的情况. 一份缓存清单只有一个缓存状态, 即使它被多个页面引用. 以下是各个缓存状态:</p>
<ul>
<li><em>UNCACHED</em>(未缓存): 表明应用缓存对象还没有初始化完成.</li>
<li><em>IDLE</em>(空闲): 应用缓存并未处于更新状态.</li>
<li><em>CHECKING</em>(检查): 正在检查是否存在更新.</li>
<li><em>DOWNLOADING</em>(下载): 清单更新后, 重新下载全部资源到临时缓存中.</li>
<li><em>UPDATEREADY</em>(更新就绪): 新版本的缓存下载完成, 全部就绪, 随即触发事件 updateready.</li>
<li><em>OBSOLETE</em>(废弃): 应用缓存已被废弃.</li>
</ul>
<p>上述缓存状态常量依次取值0, 1, 2, 3, 4, 5.</p>
<h3 id="applicationCache"><a href="#applicationCache" class="headerlink" title="applicationCache"></a>applicationCache</h3><p>applicationCache是操作应用缓存的瑞士军刀, 也是唯一的一把刀.</p>
<p>首先我们来获取该对象.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//webview下</span></div><div class="line"><span class="keyword">var</span> cache = <span class="built_in">window</span>.applicationCache;</div><div class="line"><span class="comment">//shared worker中</span></div><div class="line"><span class="keyword">var</span> cache = self.applicationCache;</div></pre></td></tr></table></figure>
<p>以下是其属性和方法介绍(大神请绕过):</p>
<ul>
<li><p>status: 返回当前页面的应用缓存的状态, 通常开启应用缓存的页面可能返回1, 其他页面则返回0.</p>
</li>
<li><p>update(): 手动触发应用缓存的更新. </p>
<p>(1) 若有更新, 则依次触发①检查事件(Checking event), ②下载事件(Downloading event), ③下载进度事件(Progress event), ④更新完成事件(UpdateReady event);</p>
<p>(2) 若无更新, 则依次触发①检查事件(Checking event), ②无更新事件(NoUpdate event);</p>
<p>(3) 在未开启应用缓存的页面调用将抛出<code>Uncaught DOMException</code> 错误.</p>
<p>update() 方法通常在长时间不关闭的页面使用, 比如说邮箱应用, 用于定期检测可能的更新.</p>
</li>
<li><p>abort(): 取消应用缓存的更新. 可用于节省有限的网络带宽.</p>
</li>
<li><p>swapCache(): 如果存在一个更新版本的应用缓存, 那么它将切换过去, 否则将抛出 <code>Uncaught DOMException</code> 错误. 通常, 我们会在updateready事件触发之后手动调用swapCache()方法, swapCache的切换只对后续加载的缓存文件有效, 已经加载成功的资源并不会重新加载.</p>
</li>
</ul>
<p>那么如何利用好上述api更新一个页面的应用缓存呢? 别急, <a href="http://www.html5rocks.com/en/tutorials/appcache/beginner/" target="_blank" rel="external">Beginner’s Guide to Using the Application Cache</a> 一文中提供了如下的样板方法:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Check if a new cache is available on page load.</span></div><div class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">  <span class="built_in">window</span>.applicationCache.addEventListener(<span class="string">'updateready'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.applicationCache.status == <span class="built_in">window</span>.applicationCache.UPDATEREADY) &#123;</div><div class="line">      <span class="comment">// Browser downloaded a new app cache.</span></div><div class="line">      <span class="comment">// Swap it in and reload the page to get the new hotness.</span></div><div class="line">      <span class="built_in">window</span>.applicationCache.swapCache();</div><div class="line">      <span class="keyword">if</span> (confirm(<span class="string">'A new version of this site is available. Load it?'</span>)) &#123;</div><div class="line">        <span class="built_in">window</span>.location.reload();</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">// Manifest didn't changed. Nothing new to server.</span></div><div class="line">    &#125;</div><div class="line">  &#125;, <span class="literal">false</span>);</div><div class="line">&#125;, <span class="literal">false</span>);</div></pre></td></tr></table></figure>
<h3 id="manifest缓存独立性"><a href="#manifest缓存独立性" class="headerlink" title="manifest缓存独立性"></a>manifest缓存独立性</h3><ol>
<li>manifest的缓存和浏览器默认的缓存是两套机制, 相互独立, 并且不受浏览器缓存大小限制(Chrome下测试结果).</li>
<li>各个manifest文件的缓存相互独立, 各自在独立的区域进行缓存. 即使是缓存同一个文件, 也可能由于缓存的版本不一致, 而造成各个页面资源不一致.</li>
</ol>
<h3 id="manifest缓存规则"><a href="#manifest缓存规则" class="headerlink" title="manifest缓存规则"></a>manifest缓存规则</h3><ol>
<li>遵循全量缓存的规律. 即: manifest文件改动后, 将重新缓存一遍所有的文件(包括html本身和动态添加的需要缓存的文件,即使缓存列表中没有该html). 第一次缓存过程中如果出现缓存失败的文件, 那么, 第二访问, 又将重新缓存一遍所有的文件. 以此类推.</li>
<li>manifest文件本身不能写进缓存清单, 否则连同html和资源在其缓存失效之前, 将永远不能获得更新.</li>
<li>即使manifest文件丢失, 缓存依然有效. 不过从此以后, 引入该manifest的html, 将永远不能获得更新.</li>
</ol>
<h3 id="webview的缓存现象"><a href="#webview的缓存现象" class="headerlink" title="webview的缓存现象"></a>webview的缓存现象</h3><p>通常, webview的缓存有如下三种现象:</p>
<ol>
<li>普通网页(无manifest文件), 不受manifest缓存影响, 缓存只走 http cache.</li>
<li>包含manifest文件的网页, 缓存文件只受manifest缓存影响(只有manifest文件改变时才会更新缓存资源), 缓存资源完全与 http cache 无关, 但是 <code>NETWORK</code> 段落后需要访问网络的文件, 将继续走 http cache.</li>
<li>webview直接加载manifest缓存过的文件时, 优先加载第一个manifest缓存的该文件, 如果没有找到manifest缓存, 那么它将自动寻找 http cache 或者 在线加载.</li>
</ol>
<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><ol>
<li>通常只使用一个manifest文件, 并保证缓存的文件尽可能的少, 以减小manifest每次更新清单中文件所耗费的时间和流量.</li>
<li>如果一定要使用两个及以上manifest文件, 缓存文件请尽量不要相同.</li>
<li>如果以上两条都不能保证, 那么, 请保证尽可能在manifest缓存的状态更新时, 主动去刷新网页.(此时并不能保证不同网页之间同一个缓存文件版本一致)</li>
</ol>
<h3 id="具体落地步骤"><a href="#具体落地步骤" class="headerlink" title="具体落地步骤"></a>具体落地步骤</h3><ol>
<li><p>如果缓存的文件需要加参数运行, 建议将参数内容加到hash中, 如:cached-page.html#parameterName=value</p>
</li>
<li><p>manifest 的引入可以使用绝对路径或者相对路径, 如果你使用的是绝对路径, 那么你的manifest文件必须和你的站点处于同一个域名下.</p>
</li>
<li><p>manifest文件你可以保存为任意的扩展名, 但是响应头中以下字段须取以下定值, 以保证manifest文件正确被解析, 并且它没有http缓存.</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Content-Type</span>: text/cache-manifest</div><div class="line"><span class="attribute">Cache-Control</span>: max-age=0</div><div class="line"><span class="attribute">Expires</span>: [CURRENT TIME]</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="如何更新缓存"><a href="#如何更新缓存" class="headerlink" title="如何更新缓存"></a>如何更新缓存</h3><ol>
<li>更新manifest文件后, webview将自动更新缓存.</li>
<li>js更新缓存(手动触发manifest更新): window.applicationCache.update();</li>
</ol>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>chrome浏览器下通过访问 <a href="chrome://appcache-internals/" target="_blank" rel="external">chrome://appcache-internals/</a> 可以查看缓存在本地的资源文件.</p>
<p>另外, 除了本文参考的一篇 MDN 的文章以及 HTML5 Rocks的 <a href="http://www.html5rocks.com/en/tutorials/appcache/beginner/" target="_blank" rel="external">Beginner’s Guide to Using the Application Cache</a> 一文, 还有如下三个链接可供您比较阅读, 谢谢.</p>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Cache_manifest_in_HTML5" target="_blank" rel="external">Cache manifest in HTML5</a> on Wikipedia</li>
<li><a href="http://www.w3.org/TR/offline-webapps/" target="_blank" rel="external">Offline Web Applications</a> W3C Working Group Note</li>
<li><a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/offline.html" target="_blank" rel="external">Offline Web applications</a> at WHATWG</li>
</ul>
<hr>
<p>本问就讨论这么多内容,大家有什么问题或好的想法欢迎在下方参与<a href="#respond">留言和评论</a>.</p>
<p>本文作者: <a href="https://github.com/Louiszhai" target="_blank" rel="external">louis</a></p>
<p>本文链接: <a href="http://louiszhai.github.io/2016/11/25/manifest/">http://louiszhai.github.io/2016/11/25/manifest/</a></p>
<p>参考文章</p>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/HTML/Using_the_application_cache" target="_blank" rel="external">Using the application cache | MDN</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      manifest offline cache applicationCache
    
    </summary>
    
    
      <category term="Web" scheme="http://louiszhai.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>Ajax知识体系大梳理</title>
    <link href="http://louiszhai.github.io/2016/11/02/ajax/"/>
    <id>http://louiszhai.github.io/2016/11/02/ajax/</id>
    <published>2016-11-02T04:48:27.000Z</published>
    <updated>2017-04-17T02:54:08.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h3><p>Ajax 全称 Asynchronous JavaScript and XML, 即异步JS与XML. 它最早在IE5中被使用, 然后由Mozilla, Apple, Google推广开来. 典型的代表应用有 Outlook Web Access, 以及 GMail. 现代网页中几乎无ajax不欢. 前后端分离也正是建立在ajax异步通信的基础之上.</p>
<a id="more"></a>
<h3 id="浏览器为ajax做了什么"><a href="#浏览器为ajax做了什么" class="headerlink" title="浏览器为ajax做了什么"></a>浏览器为ajax做了什么</h3><p>现代浏览器中, 虽然几乎全部支持ajax, 但它们的技术方案却分为两种:</p>
<p>① 标准浏览器通过 <code>XMLHttpRequest</code> 对象实现了ajax的功能. 只需要通过一行语句便可创建一个用于发送ajax请求的对象.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</div></pre></td></tr></table></figure>
<p>② IE浏览器通过 <code>XMLHttpRequest</code> 或者 <code>ActiveXObject</code> 对象同样实现了ajax的功能.</p>
<h4 id="MSXML"><a href="#MSXML" class="headerlink" title="MSXML"></a>MSXML</h4><p>鉴于IE系列各种 “神级” 表现,  我们先来看看IE浏览器风骚的走位.</p>
<p>IE下的使用环境略显复杂, IE7及更高版本浏览器可以直接使用BOM的 XMLHttpRequest 对象. MSDN传送门: <a href="https://blogs.msdn.microsoft.com/ie/2006/01/23/native-xmlhttprequest-object/" target="_blank" rel="external">Native XMLHTTPRequest object</a>. IE6及更低版本浏览器只能使用 <code>ActiveXObject</code> 对象来创建 XMLHttpRequest 对象实例. 创建时需要指明一个类似”Microsoft.XMLHTTP”这样的ProgID. 而实际呢, windows系统环境下, 以下ProgID都应该可以创建XMLHTTP对象:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">Microsoft</span><span class="selector-class">.XMLHTTP</span></div><div class="line"><span class="selector-tag">Microsoft</span><span class="selector-class">.XMLHTTP</span><span class="selector-class">.1</span><span class="selector-class">.0</span></div><div class="line"><span class="selector-tag">Msxml2</span><span class="selector-class">.ServerXMLHTTP</span></div><div class="line"><span class="selector-tag">Msxml2</span><span class="selector-class">.ServerXMLHTTP</span><span class="selector-class">.3</span><span class="selector-class">.0</span></div><div class="line"><span class="selector-tag">Msxml2</span><span class="selector-class">.ServerXMLHTTP</span><span class="selector-class">.4</span><span class="selector-class">.0</span></div><div class="line"><span class="selector-tag">Msxml2</span><span class="selector-class">.ServerXMLHTTP</span><span class="selector-class">.5</span><span class="selector-class">.0</span></div><div class="line"><span class="selector-tag">Msxml2</span><span class="selector-class">.ServerXMLHTTP</span><span class="selector-class">.6</span><span class="selector-class">.0</span></div><div class="line"><span class="selector-tag">Msxml2</span><span class="selector-class">.XMLHTTP</span></div><div class="line"><span class="selector-tag">Msxml2</span><span class="selector-class">.XMLHTTP</span><span class="selector-class">.3</span><span class="selector-class">.0</span></div><div class="line"><span class="selector-tag">Msxml2</span><span class="selector-class">.XMLHTTP</span><span class="selector-class">.4</span><span class="selector-class">.0</span></div><div class="line"><span class="selector-tag">Msxml2</span><span class="selector-class">.XMLHTTP</span><span class="selector-class">.5</span><span class="selector-class">.0</span></div><div class="line"><span class="selector-tag">Msxml2</span><span class="selector-class">.XMLHTTP</span><span class="selector-class">.6</span><span class="selector-class">.0</span></div></pre></td></tr></table></figure>
<p>简言之, Microsoft.XMLHTTP 已经非常老了, 主要用于提供对历史遗留版本的支持, 不建议使用.对于 MSXML4, 它已被 MSXML6 替代; 而 MSXML5 又是专门针对office办公场景, 在没有安装 Microsoft Office 2003 及更高版本办公软件的情况下, MSXML5 未必可用. 相比之下, MSXML6 具有比 MSXML3 更稳定, 更高性能, 更安全的优势, 同时它也提供了一些 MSXML3 中没有的功能, 比如说 XSD schema. 唯一遗憾的是, MSXML6 只在 vista 系统及以上才是默认支持的; 而 MSXML3 在 Win2k SP4及以上系统就是可用的. 因此一般情况下, MSXML3 可以作为 MSXML6 的优雅降级方案, 我们通过指定 PorgID 为 Msxml2.XMLHTTP 即可自动映射到 Msxml2.XMLHTTP.3.0. 如下所示:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> ActiveXObject(<span class="string">"Msxml2.XMLHTTP"</span>);<span class="comment">// 即MSXML3,等同于如下语句</span></div><div class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> ActiveXObject(<span class="string">"MSXML2.XMLHTTP.3.0"</span>);</div></pre></td></tr></table></figure>
<p>MSDN有篇文章专门讲解了各个版本的MSXML. 传送门: <a href="https://blogs.msdn.microsoft.com/xmlteam/2006/10/23/using-the-right-version-of-msxml-in-internet-explorer/" target="_blank" rel="external">Using the right version of MSXML in Internet Explorer</a>.</p>
<p>亲测了 IE5, IE5.5, IE6, IE7, IE8, IE9, IE10, IE edge等浏览器, IE5及之后的浏览器均可以通过如下语句获取xhr对象:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> ActiveXObject(<span class="string">"Msxml2.XMLHTTP"</span>);<span class="comment">// 即MSXML3</span></div><div class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);<span class="comment">// 很老的api,虽然浏览器支持,功能可能不完善,故不建议使用</span></div></pre></td></tr></table></figure>
<p>以上, 思路已经很清晰了, 下面给出个全兼容的方法.</p>
<h4 id="全平台兼容的XMLHttpRequest对象"><a href="#全平台兼容的XMLHttpRequest对象" class="headerlink" title="全平台兼容的XMLHttpRequest对象"></a>全平台兼容的XMLHttpRequest对象</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getXHR</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> xhr = <span class="literal">null</span>;</div><div class="line">  <span class="keyword">if</span>(<span class="built_in">window</span>.XMLHttpRequest) &#123;</div><div class="line">    xhr = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">window</span>.ActiveXObject) &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      xhr = <span class="keyword">new</span> ActiveXObject(<span class="string">"Msxml2.XMLHTTP"</span>);</div><div class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        xhr = <span class="keyword">new</span> ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</div><div class="line">      &#125; <span class="keyword">catch</span> (e) &#123; </div><div class="line">        alert(<span class="string">"您的浏览器暂不支持Ajax!"</span>);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> xhr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="ajax有没有破坏js单线程机制"><a href="#ajax有没有破坏js单线程机制" class="headerlink" title="ajax有没有破坏js单线程机制"></a>ajax有没有破坏js单线程机制</h3><p>对于这个问题, 我们先看下浏览器线程机制. 一般情况下, 浏览器有如下四种线程:</p>
<ul>
<li>GUI渲染线程</li>
<li>javascript引擎线程</li>
<li>浏览器事件触发线程</li>
<li>HTTP请求线程</li>
</ul>
<p>那么这么多线程, 它们究竟是怎么同js引擎线程交互的呢?</p>
<p>通常, 它们的线程间交互以事件的方式发生, 通过事件回调的方式予以通知. 而事件回调, 又是以先进先出的方式添加到<code>任务队列</code> 的末尾 , 等到js引擎空闲时, <code>任务队列</code> 中排队的任务将会依次被执行. 这些事件回调包括 setTimeout, setInterval, click, ajax异步请求等回调.</p>
<p><strong>浏览器中, js引擎线程会循环从 <code>任务队列</code> 中读取事件并且执行, 这种运行机制称作 <code>Event Loop</code> (事件循环).</strong></p>
<p>对于一个ajax请求, js引擎首先生成 <code>XMLHttpRequest</code> 实例对象, open过后再调用send方法. 至此, 所有的语句都是同步执行. 但从send方法内部开始, 浏览器为将要发生的网络请求创建了新的http请求线程, 这个线程独立于js引擎线程, 于是网络请求异步被发送出去了. 另一方面, js引擎并不会等待 ajax 发起的http请求收到结果, 而是直接顺序往下执行.</p>
<p>当ajax请求被服务器响应并且收到response后, 浏览器事件触发线程捕获到了ajax的回调事件 <code>onreadystatechange</code> (当然也可能触发onload, 或者 onerror等等) . 该回调事件并没有被立即执行, 而是被添加到 <code>任务队列</code> 的末尾. 直到js引擎空闲了, <code>任务队列</code> 的任务才被捞出来, 按照添加顺序, 挨个执行, 当然也包括刚刚append到队列末尾的 <code>onreadystatechange</code> 事件.</p>
<p>在 <code>onreadystatechange</code> 事件内部, 有可能对dom进行操作. 此时浏览器便会挂起js引擎线程, 转而执行GUI渲染线程, 进行UI重绘(repaint)或者回流(reflow). 当js引擎重新执行时, GUI渲染线程又会被挂起, GUI更新将被保存起来, 等到js引擎空闲时立即被执行.</p>
<p>以上整个ajax请求过程中, 有涉及到浏览器的4种线程. 其中除了 <code>GUI渲染线程</code> 和 <code>js引擎线程</code> 是互斥的. 其他线程相互之间, 都是可以并行执行的. 通过这样的一种方式, ajax并没有破坏js的单线程机制.</p>
<h3 id="ajax与setTimeout排队问题"><a href="#ajax与setTimeout排队问题" class="headerlink" title="ajax与setTimeout排队问题"></a>ajax与setTimeout排队问题</h3><p>通常, ajax 和 setTimeout 的事件回调都被同等的对待, 按照顺序自动的被添加到 <code>任务队列</code> 的末尾, 等待js引擎空闲时执行. 但请注意, 并非xhr的所有回调执行都滞后于setTImeout的回调. 请看如下代码:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">url, method</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> xhr = getXHR();</div><div class="line">  xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  	<span class="built_in">console</span>.log(<span class="string">'xhr.readyState:'</span> + <span class="keyword">this</span>.readyState);</div><div class="line">  &#125;</div><div class="line">  xhr.onloadstart = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  	<span class="built_in">console</span>.log(<span class="string">'onloadStart'</span>);</div><div class="line">  &#125;</div><div class="line">  xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  	<span class="built_in">console</span>.log(<span class="string">'onload'</span>);</div><div class="line">  &#125;</div><div class="line">  xhr.open(method, url, <span class="literal">true</span>);</div><div class="line">  xhr.setRequestHeader(<span class="string">'Cache-Control'</span>,<span class="number">3600</span>);</div><div class="line">  xhr.send();</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</div><div class="line">&#125;,<span class="number">0</span>);</div><div class="line">ajax(<span class="string">'http://louiszhai.github.io/docImages/ajax01.png'</span>,<span class="string">'GET'</span>);</div><div class="line"><span class="built_in">console</span>.warn(<span class="string">'这里的log并不是最先打印出来的.'</span>);</div></pre></td></tr></table></figure>
<p>上述代码执行结果如下图:</p>
<p><img src="http://louiszhai.github.io/docImages/ajax27.png" alt="setTimeout &amp; ajax &amp; 同步"></p>
<p>由于ajax异步, setTimeout回调本应该最先被执行, 然而实际上, 一次ajax请求, 并非所有的部分都是异步的, 至少”readyState==1”的 <code>onreadystatechange</code> 回调以及 <code>onloadstart</code> 回调就是同步执行的. 因此它们的输出排在最前面.</p>
<h3 id="XMLHttpRequest-属性解读"><a href="#XMLHttpRequest-属性解读" class="headerlink" title="XMLHttpRequest 属性解读"></a>XMLHttpRequest 属性解读</h3><p>首先在Chrome console下创建一个 XMLHttpRequest 实例对象xhr. 如下所示:</p>
<p><img src="http://louiszhai.github.io/docImages/ajax01.png" alt="XMLHttpRequest"></p>
<h4 id="inherit"><a href="#inherit" class="headerlink" title="inherit"></a>inherit</h4><p>试运行以下代码.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest(),</div><div class="line">    i=<span class="number">0</span>;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> xhr)&#123;</div><div class="line">    <span class="keyword">if</span>(xhr.hasOwnProperty(key))&#123;</div><div class="line">       i++;</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(i);<span class="comment">//0</span></div><div class="line"><span class="built_in">console</span>.log(XMLHttpRequest.prototype.hasOwnProperty(<span class="string">'timeout'</span>));<span class="comment">//true</span></div></pre></td></tr></table></figure>
<p>可见,  XMLHttpRequest 实例对象没有自有属性. 实际上, 它的所有属性均来自于 <code>XMLHttpRequest.prototype</code> .</p>
<p>追根溯源, XMLHttpRequest 实例对象具有如下的继承关系. (下面以a&lt;&lt;b表示a继承b)</p>
<p><code>xhr</code> &lt;&lt; <code>XMLHttpRequest.prototype</code> &lt;&lt; <code>XMLHttpRequestEventTarget.prototype</code> &lt;&lt; <code>EventTarget.prototype</code> &lt;&lt; <code>Object.prototype</code></p>
<p>由上, xhr也具有Object等原型中的所有方法. 如toString方法.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xhr.toString();<span class="comment">//"[object XMLHttpRequest]"</span></div></pre></td></tr></table></figure>
<p>通常, 一个xhr实例对象拥有10个普通属性+9个方法.</p>
<h4 id="readyState"><a href="#readyState" class="headerlink" title="readyState"></a>readyState</h4><p>只读属性, readyState属性记录了ajax调用过程中所有可能的状态. 它的取值简单明了, 如下:</p>
<table>
<thead>
<tr>
<th>readyState</th>
<th>对应常量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>0 (未初始化)</td>
<td>xhr.UNSENT</td>
<td>请求已建立, 但未初始化(此时未调用open方法)</td>
</tr>
<tr>
<td>1 (初始化)</td>
<td>xhr.OPENED</td>
<td>请求已建立, 但未发送 (已调用open方法, 但未调用send方法)</td>
</tr>
<tr>
<td>2 (发送数据)</td>
<td>xhr.HEADERS_RECEIVED</td>
<td>请求已发送 (send方法已调用, 已收到响应头)</td>
</tr>
<tr>
<td>3 (数据传送中)</td>
<td>xhr.LOADING</td>
<td>请求处理中, 因响应内容不全, 这时通过responseBody和responseText获取可能会出现错误</td>
</tr>
<tr>
<td>4 (完成)</td>
<td>xhr.DONE</td>
<td>数据接收完毕, 此时可以通过通过responseBody和responseText获取完整的响应数据</td>
</tr>
</tbody>
</table>
<p>注意, readyState 是一个只读属性, 想要改变它的值是不可行的.</p>
<h4 id="onreadystatechange"><a href="#onreadystatechange" class="headerlink" title="onreadystatechange"></a>onreadystatechange</h4><p>onreadystatechange事件回调方法在readystate状态改变时触发, 在一个收到响应的ajax请求周期中, onreadystatechange 方法会被触发4次. 因此可以在 onreadystatechange 方法中绑定一些事件回调, 比如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span>(xhr.readystate==<span class="number">4</span>)&#123;</div><div class="line">    <span class="keyword">var</span> s = xhr.status;</div><div class="line">    <span class="keyword">if</span>((s &gt;= <span class="number">200</span> &amp;&amp; s &lt; <span class="number">300</span>) || s == <span class="number">304</span>)&#123;</div><div class="line">      <span class="keyword">var</span> resp = xhr.responseText;</div><div class="line">      <span class="comment">//TODO ...</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意: onreadystatechange回调中默认会传入Event实例, 如下:</p>
<p><img src="http://louiszhai.github.io/docImages/ajax02.png" alt="Event"></p>
<h4 id="status"><a href="#status" class="headerlink" title="status"></a>status</h4><p>只读属性, status表示http请求的状态, 初始值为0. 如果服务器没有显式地指定状态码, 那么status将被设置为默认值, 即200.</p>
<h4 id="statusText"><a href="#statusText" class="headerlink" title="statusText"></a>statusText</h4><p>只读属性, statusText表示服务器的响应状态信息, 它是一个 UTF-16 的字符串, 请求成功且status==20X时, 返回大写的 <code>OK</code> . 请求失败时返回空字符串. 其他情况下返回相应的状态描述. 比如: 301的 <code>Moved Permanently</code> , 302的 <code>Found</code> , 303的 <code>See Other</code> , 307 的 <code>Temporary Redirect</code> , 400的 <code>Bad Request</code> , 401的 <code>Unauthorized</code> 等等.</p>
<h4 id="onloadstart"><a href="#onloadstart" class="headerlink" title="onloadstart"></a>onloadstart</h4><p>onloadstart事件回调方法在ajax请求发送之前触发, 触发时机在 <code>readyState==1</code> 状态之后, <code>readyState==2</code> 状态之前.</p>
<p>onloadstart方法中默认将传入一个ProgressEvent事件进度对象. 如下:</p>
<p><img src="http://louiszhai.github.io/docImages/ajax03.png" alt="ProgressEvent"> </p>
<p>ProgressEvent对象具有三个重要的Read only属性.</p>
<ul>
<li>lengthComputable 表示长度是否可计算, 它是一个布尔值, 初始值为false.</li>
<li>loaded 表示已加载资源的大小, 如果使用http下载资源, 它仅仅表示已下载内容的大小, 而不包括http headers等. 它是一个无符号长整型, 初始值为0.</li>
<li>total 表示资源总大小, 如果使用http下载资源, 它仅仅表示内容的总大小, 而不包括http headers等, 它同样是一个无符号长整型, 初始值为0.</li>
</ul>
<h4 id="onprogress"><a href="#onprogress" class="headerlink" title="onprogress"></a>onprogress</h4><p>onprogress事件回调方法在 <code>readyState==3</code> 状态时开始触发, 默认传入 ProgressEvent 对象, 可通过 <code>e.loaded/e.total</code> 来计算加载资源的进度, 该方法用于获取资源的下载进度.</p>
<p>注意: 该方法适用于 IE10+ 及其他现代浏览器.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">xhr.onprogress = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'progress:'</span>, e.loaded/e.total);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="onload"><a href="#onload" class="headerlink" title="onload"></a>onload</h4><p>onload事件回调方法在ajax请求成功后触发, 触发时机在 <code>readyState==4</code> 状态之后.</p>
<p>想要捕捉到一个ajax异步请求的成功状态, 并且执行回调, 一般下面的语句就足够了:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> s = xhr.status;</div><div class="line">  <span class="keyword">if</span>((s &gt;= <span class="number">200</span> &amp;&amp; s &lt; <span class="number">300</span>) || s == <span class="number">304</span>)&#123;</div><div class="line">    <span class="keyword">var</span> resp = xhr.responseText;</div><div class="line">    <span class="comment">//TODO ...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="onloadend"><a href="#onloadend" class="headerlink" title="onloadend"></a>onloadend</h4><p>onloadend事件回调方法在ajax请求完成后触发, 触发时机在 <code>readyState==4</code> 状态之后(收到响应时) 或者  <code>readyState==2</code> 状态之后(未收到响应时).</p>
<p>onloadend方法中默认将传入一个ProgressEvent事件进度对象.</p>
<h4 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h4><p>timeout属性用于指定ajax的超时时长. 通过它可以灵活地控制ajax请求时间的上限. timeout的值满足如下规则:</p>
<ul>
<li>通常设置为0时不生效.</li>
<li>设置为字符串时, 如果字符串中全部为数字, 它会自动将字符串转化为数字, 反之该设置不生效.</li>
<li>设置为对象时, 如果该对象能够转化为数字, 那么将设置为转化后的数字.</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">xhr.timeout = <span class="number">0</span>; <span class="comment">//不生效</span></div><div class="line">xhr.timeout = <span class="string">'123'</span>; <span class="comment">//生效, 值为123</span></div><div class="line">xhr.timeout = <span class="string">'123s'</span>; <span class="comment">//不生效</span></div><div class="line">xhr.timeout = [<span class="string">'123'</span>]; <span class="comment">//生效, 值为123</span></div><div class="line">xhr.timeout = &#123;<span class="attr">a</span>:<span class="number">123</span>&#125;; <span class="comment">//不生效</span></div></pre></td></tr></table></figure>
<h4 id="ontimeout"><a href="#ontimeout" class="headerlink" title="ontimeout"></a>ontimeout</h4><p>ontimeout方法在ajax请求超时时触发, 通过它可以在ajax请求超时时做一些后续处理.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">xhr.ontimeout = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.error(<span class="string">"请求超时!!!"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="response-responseText"><a href="#response-responseText" class="headerlink" title="response responseText"></a>response responseText</h4><p>均为只读属性, response表示服务器的响应内容, 相应的, responseText表示服务器响应内容的文本形式.</p>
<h4 id="responseXML"><a href="#responseXML" class="headerlink" title="responseXML"></a>responseXML</h4><p>只读属性, responseXML表示xml形式的响应数据, 缺省为null, 若数据不是有效的xml, 则会报错.</p>
<h4 id="responseType"><a href="#responseType" class="headerlink" title="responseType"></a>responseType</h4><p>responseType表示响应的类型, 缺省为空字符串, 可取 <code>&quot;arraybuffer&quot;</code> , <code>&quot;blob&quot;</code> , <code>&quot;document&quot;</code> , <code>&quot;json&quot;</code> , and <code>&quot;text&quot;</code> 共五种类型.</p>
<h4 id="responseURL"><a href="#responseURL" class="headerlink" title="responseURL"></a>responseURL</h4><p>responseURL返回ajax请求最终的URL, 如果请求中存在重定向, 那么responseURL表示重定向之后的URL.</p>
<h4 id="withCredentials"><a href="#withCredentials" class="headerlink" title="withCredentials"></a>withCredentials</h4><p>withCredentials是一个布尔值, 默认为false, 表示跨域请求中不发送cookies等信息. 当它设置为true时, <code>cookies</code> , <code>authorization headers</code> 或者<code>TLS客户端证书</code> 都可以正常发送和接收. 显然它的值对同域请求没有影响.</p>
<p>注意: 该属性适用于 IE10+, opera12+及其他现代浏览器.</p>
<h4 id="abort"><a href="#abort" class="headerlink" title="abort"></a>abort</h4><p>abort方法用于取消ajax请求, 取消后, readyState 状态将被设置为 <code>0</code> (<code>UNSENT</code>). 如下, 调用abort 方法后, 请求将被取消.</p>
<p><img src="http://louiszhai.github.io/docImages/ajax04.png" alt="Event"></p>
<h4 id="getResponseHeader"><a href="#getResponseHeader" class="headerlink" title="getResponseHeader"></a>getResponseHeader</h4><p>getResponseHeader方法用于获取ajax响应头中指定name的值. 如果response headers中存在相同的name, 那么它们的值将自动以字符串的形式连接在一起.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(xhr.getResponseHeader(<span class="string">'Content-Type'</span>));<span class="comment">//"text/html"</span></div></pre></td></tr></table></figure>
<h4 id="getAllResponseHeaders"><a href="#getAllResponseHeaders" class="headerlink" title="getAllResponseHeaders"></a>getAllResponseHeaders</h4><p>getAllResponseHeaders方法用于获取所有安全的ajax响应头, 响应头以字符串形式返回. 每个HTTP报头名称和值用冒号分隔, 如key:value, 并以\r\n结束.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>.readyState == <span class="keyword">this</span>.HEADERS_RECEIVED) &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.getAllResponseHeaders());</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//Content-Type: text/html"</span></div></pre></td></tr></table></figure>
<p>以上,  <code>readyState === 2</code> 状态时, 就意味着响应头已接受完整. 此时便可以打印出完整的 response headers.</p>
<h4 id="setRequestHeader"><a href="#setRequestHeader" class="headerlink" title="setRequestHeader"></a>setRequestHeader</h4><p>既然可以获取响应头, 那么自然也可以设置请求头, setRequestHeader就是干这个的. 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//指定请求的type为json格式</span></div><div class="line">xhr.setRequestHeader(<span class="string">"Content-type"</span>, <span class="string">"application/json"</span>);</div><div class="line"><span class="comment">//除此之外, 还可以设置其他的请求头</span></div><div class="line">xhr.setRequestHeader(<span class="string">'x-requested-with'</span>, <span class="string">'123456'</span>);</div></pre></td></tr></table></figure>
<h4 id="onerror"><a href="#onerror" class="headerlink" title="onerror"></a>onerror</h4><p>onerror方法用于在ajax请求出错后执行. 通常只在网络出现问题时或者ERR_CONNECTION_RESET时触发(如果请求返回的是407状态码, chrome下也会触发onerror).</p>
<h4 id="upload"><a href="#upload" class="headerlink" title="upload"></a>upload</h4><p>upload属性默认返回一个 <code>XMLHttpRequestUpload</code> 对象, 用于上传资源. 该对象具有如下方法:</p>
<ul>
<li>onloadstart</li>
<li>onprogress</li>
<li>onabort</li>
<li>onerror</li>
<li>onload</li>
<li>ontimeout</li>
<li>onloadend</li>
</ul>
<p>上述方法功能同 xhr 对象中同名方法一致. 其中, onprogress 事件回调方法可用于跟踪资源上传的进度.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">xhr.upload.onprogress = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> percent = <span class="number">100</span> * e.loaded / e.total |<span class="number">0</span>;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'upload: '</span> + precent + <span class="string">'%'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="overrideMimeType"><a href="#overrideMimeType" class="headerlink" title="overrideMimeType"></a>overrideMimeType</h4><p>overrideMimeType方法用于强制指定response 的 MIME 类型, 即强制修改response的 <code>Content-Type</code> . 如下, 服务器返回的response的 MIME 类型为 <code>text/plain</code> .</p>
<p><img src="http://louiszhai.github.io/docImages/ajax05.png" alt="response headers"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">xhr.getResponseHeader(<span class="string">'Content-Type'</span>);<span class="comment">//"text/plain"</span></div><div class="line">xhr.responseXML;<span class="comment">//null</span></div></pre></td></tr></table></figure>
<p>通过overrideMimeType方法将response的MIME类型设置为 <code>text/xml;charset=utf-8</code> , 如下所示:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">xhr.overrideMimeType(<span class="string">"text/xml; charset = utf-8"</span>);</div><div class="line">xhr.send();</div></pre></td></tr></table></figure>
<p>此时虽然 response headers 如上图, 没有变化, 但 <code>Content-Type</code> 已替换为新值.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xhr.getResponseHeader(<span class="string">'Content-Type'</span>);<span class="comment">//"text/xml; charset = utf-8"</span></div></pre></td></tr></table></figure>
<p>此时, <code>xhr.responseXML</code> 也将返回DOM对象, 如下图.</p>
<p><img src="http://louiszhai.github.io/docImages/ajax06.png" alt="response headers"></p>
<h3 id="XHR一级"><a href="#XHR一级" class="headerlink" title="XHR一级"></a>XHR一级</h3><p>XHR1 即 XMLHttpRequest Level 1. XHR1时, xhr对象具有如下缺点:</p>
<ul>
<li>仅支持文本数据传输, 无法传输二进制数据.</li>
<li>传输数据时, 没有进度信息提示, 只能提示是否完成.</li>
<li>受浏览器 <code>同源策略</code> 限制, 只能请求同域资源.</li>
<li>没有超时机制, 不方便掌控ajax请求节奏.</li>
</ul>
<h3 id="XHR二级"><a href="#XHR二级" class="headerlink" title="XHR二级"></a>XHR二级</h3><p>XHR2 即 XMLHttpRequest Level 2. XHR2针对XHR1的上述缺点做了如下改进:</p>
<ul>
<li>支持二进制数据, 可以上传文件, 可以使用FormData对象管理表单.</li>
<li>提供进度提示, 可通过 <code>xhr.upload.onprogress</code> 事件回调方法获取传输进度.</li>
<li>依然受 <code>同源策略</code> 限制, 这个安全机制不会变. XHR2新提供 <code>Access-Control-Allow-Origin</code> 等headers, 设置为 <code>*</code> 时表示允许任何域名请求, 从而实现跨域CORS访问(有关CORS详细介绍请耐心往下读).</li>
<li>可以设置timeout 及 ontimeout, 方便设置超时时长和超时后续处理.</li>
</ul>
<p>这里就H5新增的FormData对象举个例.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//可直接创建FormData实例</span></div><div class="line"><span class="keyword">var</span> data = <span class="keyword">new</span> FormData();</div><div class="line">data.append(<span class="string">"name"</span>, <span class="string">"louis"</span>);</div><div class="line">xhr.send(data);</div><div class="line"><span class="comment">//还可以通过传入表单DOM对象来创建FormData实例</span></div><div class="line"><span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">'form'</span>);</div><div class="line"><span class="keyword">var</span> data = <span class="keyword">new</span> FormData(form);</div><div class="line">data.append(<span class="string">"password"</span>, <span class="string">"123456"</span>);</div><div class="line">xhr.send(data);</div></pre></td></tr></table></figure>
<p>目前, 主流浏览器基本上都支持XHR2, 除了IE系列需要IE10及更高版本. 因此IE10以下是不支持XHR2的.</p>
<p>那么问题来了, IE7, 8,9的用户怎么办? 很遗憾, 这些用户是比较尴尬的. 对于IE8,9而言, 只有一个阉割版的 <code>XDomainRequest</code> 可用,IE7则没有. 估计IE7用户只能哭晕在厕所了.</p>
<h3 id="XDomainRequest"><a href="#XDomainRequest" class="headerlink" title="XDomainRequest"></a>XDomainRequest</h3><p>XDomainRequest 对象是IE8,9折腾出来的, 用于支持CORS请求非成熟的解决方案. 以至于IE10中直接移除了它, 并重新回到了 XMLHttpRequest 的怀抱.</p>
<p>XDomainRequest 仅可用于发送 <code>GET</code>和 <code>POST</code> 请求. 如下即创建过程.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> xdr = <span class="keyword">new</span> XDomainRequest();</div></pre></td></tr></table></figure>
<p>xdr具有如下属性:</p>
<ul>
<li>timeout</li>
<li>responseText</li>
</ul>
<p>如下方法:</p>
<ul>
<li>open: 只能接收Method,和url两个参数. 只能发送异步请求.</li>
<li>send</li>
<li>abort</li>
</ul>
<p>如下事件回调:</p>
<ul>
<li>onprogress</li>
<li>ontimeout</li>
<li>onerror</li>
<li>onload</li>
</ul>
<p>除了缺少一些方法外, XDomainRequest 基本上就和 XMLHttpRequest 的使用方式保持一致. </p>
<p>必须要明确的是:</p>
<ul>
<li>XDomainRequest 不支持跨域传输cookie.</li>
<li>只能设置请求头的Content-Type字段, 且不能访问响应头信息.</li>
</ul>
<h3 id="ajax"><a href="#ajax" class="headerlink" title="$.ajax"></a>$.ajax</h3><p>$.ajax是jquery对原生ajax的一次封装. 通过封装ajax, jquery抹平了不同版本浏览器异步http的差异性, 取而代之的是高度统一的api. jquery作为js类库时代的先驱, 对前端发展有着深远的影响. 了解并熟悉其ajax方法, 不可谓不重要.</p>
<h4 id="参数列表"><a href="#参数列表" class="headerlink" title="参数列表"></a>参数列表</h4><p>$.ajax() 只有一个参数, 该参数为key-value设置对象. 实际上, jq发送的所有ajax请求, 都是通过调用该ajax方法实现的. 它的详细参数如下表:</p>
<table>
<thead>
<tr>
<th style="text-align:center">序号</th>
<th style="text-align:center">参数</th>
<th style="text-align:center">类型</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center"><strong><em>accepts</em></strong></td>
<td style="text-align:center"><em>PlainObject</em></td>
<td style="text-align:left">用于通知服务器该请求需要接收何种类型的返回结果. 如有必要, 推荐在 <code>$.ajaxSetup()</code> 方法中设置一次.</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center"><strong><em>async</em></strong></td>
<td style="text-align:center"><em>Boolean</em></td>
<td style="text-align:left">默认为true, 即异步.</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center"><strong><em>beforeSend</em></strong></td>
<td style="text-align:center"><em>Function</em></td>
<td style="text-align:left">请求发送前的回调, 默认传入参数jqXHR和settings. 函数内显式返回false将取消本次请求.</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center"><strong><em>cache</em></strong></td>
<td style="text-align:center"><em>Boolean</em></td>
<td style="text-align:left">请求是否开启缓存, 默认为true, 如不需要缓存请设置为false. 不过, dataType为”script”和”jsonp”时默认为false.</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center"><strong><em>complete</em></strong></td>
<td style="text-align:center"><em>Function</em></td>
<td style="text-align:left">请求完成后的回调(请求<code>success</code> 和 <code>error</code>之后均调用), 默认传入参数jqXHR和textStatus(请求状态, 取值为 “success”,”notmodified”,”error”,”timeout”,”abort”,”parsererror”之一). 从jq1.5开始, complete可以设置为一个包含函数的数组. 如此每个函数将依次被调用.</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center"><strong><em>contents</em></strong></td>
<td style="text-align:center"><em>PlainObject</em></td>
<td style="text-align:left">一个以”{字符串/正则表达式}”配对的对象, 根据给定的内容类型, 解析请求的返回结果.</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center"><strong><em>contentType</em></strong></td>
<td style="text-align:center"><em>String</em></td>
<td style="text-align:left">编码类型, 相对应于http请求头域的”Content-Type”字段. 默认值为”application/x-www-form-urlencoded; charset=UTF-8”.</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center"><strong><em>context</em></strong></td>
<td style="text-align:center"><em>Object</em></td>
<td style="text-align:left">设置ajax回调函数的上下文. 默认上下文为ajax请求传入的参数设置对象. 如设置为document.body, 那么所有ajax回调函数中将以body为上下文.</td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center"><strong><em>converters</em></strong></td>
<td style="text-align:center"><em>PlainObject</em></td>
<td style="text-align:left">一个数据类型到数据类型转换器的对象. 默认为 <code>{&quot;* text&quot;: window.String, &quot;text html&quot;: true, &quot;text json&quot;: jQuery.parseJSON, &quot;text xml&quot;: jQuery.parseXML}</code> . 如设置<code>converters:{&quot;json jsonp&quot;: function(msg){}}</code></td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center"><strong><em>crossDomain</em></strong></td>
<td style="text-align:center"><em>Boolean</em></td>
<td style="text-align:left">默认同域请求为false, 跨域请求为true.</td>
</tr>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:center"><strong><em>data</em></strong></td>
<td style="text-align:center"><em>Object, Array</em></td>
<td style="text-align:left">发送到服务器的数据, 默认data为键值对格式对象, 若data为数组则按照<code>traditional</code>参数的值, 自动转化为一个同名的多值查询字符串. 如{a:1,b:2}将转换为”&amp;a=1&amp;b=2”.</td>
</tr>
<tr>
<td style="text-align:center">12</td>
<td style="text-align:center"><strong><em>dataFilter</em></strong></td>
<td style="text-align:center"><em>Function</em></td>
<td style="text-align:left">处理XMLHttpRequest原始响应数据的回调, 默认传入data和type参数, data是Ajax返回的原始数据, type是调用$.ajax时提供的dataType参数</td>
</tr>
<tr>
<td style="text-align:center">13</td>
<td style="text-align:center"><strong><em>dataType</em></strong></td>
<td style="text-align:center"><em>String</em></td>
<td style="text-align:left">预期服务器返回的数据类型, 可设置为”xml”,”html”,”script”,”json”,”jsonp”,”text”之一, 其中设置为”xml”或”text”类型时, 数据不会经过处理.</td>
</tr>
<tr>
<td style="text-align:center">14</td>
<td style="text-align:center"><strong><em>error</em></strong></td>
<td style="text-align:center"><em>Function</em></td>
<td style="text-align:left">请求失败时的回调函数, 默认传入jqXHR(jq1.4以前为原生xhr对象),textStatus(请求状态,取值为null,”timeout”,”error”,”abort” 或 “parsererror”),errorString(错误内容), 当一个HTTP错误发生时, <code>errorThrown</code> 接收HTTP状态的文本部分,比如”Not Found”等. 从jq1.5开始, error可以设置为一个包含函数的数组. 如此每个函数将依次被调用.注意: 跨域脚本和JSONP请求时error不被调用.</td>
</tr>
<tr>
<td style="text-align:center">15</td>
<td style="text-align:center"><strong><em>global</em></strong></td>
<td style="text-align:center"><em>Boolean</em></td>
<td style="text-align:left">表示是否触发全局ajax事件, 默认为true. 设为false将不再触发ajaxStart,ajaxStop,ajaxSend,ajaxError等. 跨站脚本和jsonp请求, 该值自动设置为false.</td>
</tr>
<tr>
<td style="text-align:center">16</td>
<td style="text-align:center"><strong><em>headers</em></strong></td>
<td style="text-align:center"><em>PlainObject</em></td>
<td style="text-align:left">设置请求头, 格式为k-v键值对对象. 由于该设置会在beforeSend函数被调用之前生效, 因此可在beforeSend函数内覆盖该对象.</td>
</tr>
<tr>
<td style="text-align:center">17</td>
<td style="text-align:center"><strong><em>ifModified</em></strong></td>
<td style="text-align:center"><em>Boolean</em></td>
<td style="text-align:left">只有上次请求响应改变时, 才允许请求成功. 它使用HTTP包的Last-Modified 头信息判断, 默认为false. 若设置为true, 且数据自从上次请求后没有更改过就会报错.</td>
</tr>
<tr>
<td style="text-align:center">18</td>
<td style="text-align:center"><strong><em>isLocal</em></strong></td>
<td style="text-align:center"><em>Boolean</em></td>
<td style="text-align:left">运行当前环境设置为”本地”,默认为false, 若设置为true, 将影响请求发送时的协议.</td>
</tr>
<tr>
<td style="text-align:center">19</td>
<td style="text-align:center"><strong><em>jsonp</em></strong></td>
<td style="text-align:center"><em>String</em></td>
<td style="text-align:left">显式指定jsonp请求中的回调函数的名称. 如jsonp:cb, jq会将cb代替callback, 以 “cb=?”传给服务器. 从jq1.5开始, 若设置jsonp:false, 那么需要明确设置jsonpCallback:”callbackName”.</td>
</tr>
<tr>
<td style="text-align:center">20</td>
<td style="text-align:center"><strong><em>jsonpCallback</em></strong></td>
<td style="text-align:center"><em>String,Function</em></td>
<td style="text-align:left">为jsonp请求指定一个回调函数名, 以取代jq自动生成的随机函数名. 从jq1.5开始, 可以将该属性设置为一个函数, 函数的返回值就是jsonpCallback的结果.</td>
</tr>
<tr>
<td style="text-align:center">21</td>
<td style="text-align:center"><strong><em>mimeType</em></strong></td>
<td style="text-align:center"><em>String</em></td>
<td style="text-align:left">设置一个MIME类型, 以覆盖xhr的MIM类型(jq1.5新增)</td>
</tr>
<tr>
<td style="text-align:center">22</td>
<td style="text-align:center"><strong><em>password</em></strong></td>
<td style="text-align:center"><em>String</em></td>
<td style="text-align:left">设置认证请求中的密码</td>
</tr>
<tr>
<td style="text-align:center">23</td>
<td style="text-align:center"><strong><em>processData</em></strong></td>
<td style="text-align:center"><em>Boolean</em></td>
<td style="text-align:left">jq的ajax方法默认会将传入的data隐式转换为查询字符串(如”&amp;a=1&amp;b=2”), 以配合 默认内容类型 “application/x-www-form-urlencoded”, 如果不希望转换请设置为false. angular中想要禁用默认转换, 需要重写transformRequest方法.</td>
</tr>
<tr>
<td style="text-align:center">24</td>
<td style="text-align:center"><strong><em>scriptCharset</em></strong></td>
<td style="text-align:center"><em>String</em></td>
<td style="text-align:left">仅在”script”请求中使用(如跨域jsonp, dataType为”script”类型). 显式指定时, 请求中将在script标签上设置<code>charset</code>属性, 可在发现本地和远程编码不一致时使用.</td>
</tr>
<tr>
<td style="text-align:center">25</td>
<td style="text-align:center"><strong><em>statusCode</em></strong></td>
<td style="text-align:center"><em>PlainObject</em></td>
<td style="text-align:left">一组http状态码和回调函数对应的键值对对象. 该对象以 {404:function(){}} 这种形式表示. 可用于根据不同的http状态码, 执行不同的回调.(jq1.5新增)</td>
</tr>
<tr>
<td style="text-align:center">26</td>
<td style="text-align:center"><strong><em>timeout</em></strong></td>
<td style="text-align:center"><em>Number</em></td>
<td style="text-align:left">设置超时时间.</td>
</tr>
<tr>
<td style="text-align:center">27</td>
<td style="text-align:center"><strong><em>traditional</em></strong></td>
<td style="text-align:center"><em>Boolean</em></td>
<td style="text-align:left">是否按照默认方式序列化data对象, 默认值为false.</td>
</tr>
<tr>
<td style="text-align:center">28</td>
<td style="text-align:center"><strong><em>type</em></strong></td>
<td style="text-align:center"><em>String</em></td>
<td style="text-align:left">可以设置为8种http method之一, jq中不区分大小写.</td>
</tr>
<tr>
<td style="text-align:center">29</td>
<td style="text-align:center"><strong><em>url</em></strong></td>
<td style="text-align:center"><em>String</em></td>
<td style="text-align:left">请求的uri地址.</td>
</tr>
<tr>
<td style="text-align:center">30</td>
<td style="text-align:center"><strong><em>username</em></strong></td>
<td style="text-align:center"><em>String</em></td>
<td style="text-align:left">设置认证请求中的用户名</td>
</tr>
<tr>
<td style="text-align:center">31</td>
<td style="text-align:center"><strong><em>xhr</em></strong></td>
<td style="text-align:center"><em>Function</em></td>
<td style="text-align:left">在回调内创建并返回xhr对象</td>
</tr>
<tr>
<td style="text-align:center">32</td>
<td style="text-align:center"><strong><em>xhrFields</em></strong></td>
<td style="text-align:center"><em>PlainObject</em></td>
<td style="text-align:left">键值对对象, 用于设置原生的xhr对象, 如可用来设置withCredentials:true(jq1.5.1新增)</td>
</tr>
</tbody>
</table>
<h4 id="支持promise"><a href="#支持promise" class="headerlink" title="支持promise"></a>支持promise</h4><p>$.ajax() 方法返回jqXHR对象(jq1.5起), 如果使用的不是XMLHttpRequest对象时, 如jsonp请求, 返回的jqXHR对象将尽可能模拟原生的xhr. 从jq1.5起, 返回的jqXHR对象实现了promise接口, 具有如下新方法.</p>
<table>
<thead>
<tr>
<th style="text-align:center">新方法</th>
<th style="text-align:center">被替代的老方法(jq1.8起弃用)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">done(function(data, textStatus, jqXHR) {})</td>
<td style="text-align:center"><del>success</del></td>
</tr>
<tr>
<td style="text-align:center">fail(function(jqXHR, textStatus, errorThrown) {})</td>
<td style="text-align:center"><del>error</del></td>
</tr>
<tr>
<td style="text-align:center">always(function(data or jqXHR, textStatus, jqXHR or errorThrown) {})</td>
<td style="text-align:center"><del>complete</del></td>
</tr>
</tbody>
</table>
<p>从jq1.6开始, done, fail, always按照FIFO队列可以分配多个回调.</p>
<h4 id="使用转换器"><a href="#使用转换器" class="headerlink" title="使用转换器"></a>使用转换器</h4><p>$.ajax() 的转换器可以将支持的数据类型映射到其它数据类型. 如果需要将自定义数据类型映射到已知的类型. 需要使用 <code>contents</code> 选项在响应的 “Content-Type” 和实际数据类型之间添加一个转换函数.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$.ajaxSetup(&#123;</div><div class="line">  <span class="attr">contents</span>: &#123;</div><div class="line">    <span class="attr">myContentType</span>: <span class="regexp">/myContentType/</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">converters</span>: &#123;</div><div class="line">    <span class="string">"myContentType json"</span>: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">      <span class="comment">//TODO something</span></div><div class="line">      <span class="keyword">return</span> newData;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>转换一个支持的类型为自定义类型, 然后再返回. 如 text—&gt;myContentType—&gt;json.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$.ajaxSetup(&#123;</div><div class="line">  <span class="attr">contents</span>: &#123;</div><div class="line">    <span class="attr">myContentType</span>: <span class="regexp">/myContentType/</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">converters</span>: &#123;</div><div class="line">    <span class="string">"text myContentType"</span>: <span class="literal">true</span>,</div><div class="line">    <span class="string">"myContentType json"</span>: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">      <span class="comment">//TODO something</span></div><div class="line">      <span class="keyword">return</span> newData;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="事件触发顺序"><a href="#事件触发顺序" class="headerlink" title="事件触发顺序"></a>事件触发顺序</h4><p>$.ajax()方法触发的事件纷繁复杂, 有将近20个之多. 为了囊括最多的事件, 这里以一次成功的上传请求为例, 以下是它们的调用顺序(请求出现错误时的顺序, 请自行对应).</p>
<table>
<thead>
<tr>
<th style="text-align:center">序号</th>
<th style="text-align:center">事件名称</th>
<th style="text-align:center">是否全局事件</th>
<th style="text-align:center">是否能关闭</th>
<th style="text-align:center">默认形参</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">$.ajaxPrefilter</td>
<td style="text-align:center">✔️</td>
<td style="text-align:center">❌</td>
<td style="text-align:center">function(options, originalOptions, jqXHR){}</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">$(document).ajaxStar</td>
<td style="text-align:center">✔️</td>
<td style="text-align:center">✔️</td>
<td style="text-align:center">function(){}(只在当前无激活ajax时触发)</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">beforeSend</td>
<td style="text-align:center">❌</td>
<td style="text-align:center">-</td>
<td style="text-align:center">function(jqXHR, settings){}</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">$(document).ajaxSend</td>
<td style="text-align:center">✔️</td>
<td style="text-align:center">✔️</td>
<td style="text-align:center">function(){}</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">xhr.onloadstart</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">ProgressEvent</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">xhr.upload.onloadstart</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">ProgressEvent</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">xhr.upload.onprogress</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">ProgressEvent</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">xhr.upload.onload</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">ProgressEvent</td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">xhr.upload.onloadend</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">ProgressEvent</td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">xhr.onprogress</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">ProgressEvent</td>
</tr>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:center">xhr.onload</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">ProgressEvent</td>
</tr>
<tr>
<td style="text-align:center">12</td>
<td style="text-align:center"><del>success</del>(弃用)</td>
<td style="text-align:center">❌</td>
<td style="text-align:center">-</td>
<td style="text-align:center">function(data, textStatus, jqXHR){}</td>
</tr>
<tr>
<td style="text-align:center">13</td>
<td style="text-align:center">$(document).ajaxSuccess</td>
<td style="text-align:center">✔️</td>
<td style="text-align:center">✔️</td>
<td style="text-align:center">function(event, jqXHR, options){}</td>
</tr>
<tr>
<td style="text-align:center">14</td>
<td style="text-align:center"><del>complete</del>(弃用)</td>
<td style="text-align:center">❌</td>
<td style="text-align:center">-</td>
<td style="text-align:center">function(jqXHR, textStatus){}</td>
</tr>
<tr>
<td style="text-align:center">15</td>
<td style="text-align:center">$(document).ajaxComplete</td>
<td style="text-align:center">✔️</td>
<td style="text-align:center">✔️</td>
<td style="text-align:center">function(event, jqXHR, textStatus)</td>
</tr>
<tr>
<td style="text-align:center">16</td>
<td style="text-align:center">$(document).ajaxStop</td>
<td style="text-align:center">✔️</td>
<td style="text-align:center">✔️</td>
<td style="text-align:center">function(){}</td>
</tr>
<tr>
<td style="text-align:center">17</td>
<td style="text-align:center">xhr.onloadend</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">ProgressEvent</td>
</tr>
</tbody>
</table>
<p>从jq1.8起, 对于函数 <code>ajaxStart</code>, <code>ajaxSend</code>, <code>ajaxSuccess</code>, <code>ajaxComplete</code>, <code>ajaxStop</code> , 只能为<code>document</code>对象绑定事件处理函数, 为其他元素绑定的事件处理函数不会起作用.</p>
<h3 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h3><p>实际上, 如果你仅仅只是想要一个不错的http库, 相比于庞大臃肿的jquery, 短小精悍的Axios可能更加适合你. 原因如下:</p>
<ul>
<li>Axios支持node, jquery并不支持.</li>
<li>Axios基于promise语法, jq3.0才开始全面支持.</li>
<li>Axios短小精悍, 更加适合http场景, jquery大而全, 加载较慢.</li>
<li>vue作者尤大放弃推荐vue-resource, 转向推荐Axios. 以下为尤大原话.</li>
</ul>
<blockquote>
<p>“最近团队讨论了一下, Ajax 本身跟 Vue 并没有什么需要特别整合的地方, 使用 fetch polyfill 或是 axios、superagent 等等都可以起到同等的效果, vue-resource 提供的价值和其维护成本相比并不划算, 所以决定在不久以后取消对 vue-resource 的官方推荐.”</p>
</blockquote>
<p>Axios大小仅12k, 目前最新版本号为: <a href="https://www.npmjs.org/package/axios" target="_blank" rel="external"><img src="https://camo.githubusercontent.com/9f600e10007ac86da6a8b90c16ca1e9504901730/68747470733a2f2f696d672e736869656c64732e696f2f6e706d2f762f6178696f732e7376673f7374796c653d666c61742d737175617265" alt="npm version"></a></p>
<p>语法上Axios基本就和promise一样, 在then方法中处理回调, 在catch方法中处理异常. 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">axios.get(<span class="string">"https://api.github.com/users/louiszhai"</span>)</div><div class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(response);</div><div class="line">  &#125;)</div><div class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(error);</div><div class="line">  &#125;);</div></pre></td></tr></table></figure>
<p>除了get, 它还支持post, delete, head, put, patch, request请求. 具体使用攻略, 请戳这里: <a href="http://www.bootcdn.cn/axios/readme/" target="_blank" rel="external">axios</a> .</p>
<p>如需在网页上引入 Axios, 可以链接CDN <a href="http://www.bootcdn.cn/axios/" target="_blank" rel="external">axios | Bootstrap中文网开源项目免费 CDN 服务</a> 或者将其下载到本地.</p>
<h3 id="Fetch"><a href="#Fetch" class="headerlink" title="Fetch"></a>Fetch</h3><p>说到ajax, 就不得不提及fetch, 由于篇幅较长, fetch已从本文中独立出来, 请戳 <a href="http://louiszhai.github.io/2016/11/02/fetch/">Fetch进阶指南</a> .</p>
<h3 id="ajax跨域请求"><a href="#ajax跨域请求" class="headerlink" title="ajax跨域请求"></a>ajax跨域请求</h3><h4 id="什么是CORS"><a href="#什么是CORS" class="headerlink" title="什么是CORS"></a>什么是CORS</h4><p>CORS是一个W3C(World Wide Web)标准, 全称是跨域资源共享(Cross-origin resource sharing).它允许浏览器向跨域服务器, 发出异步http请求, 从而克服了ajax受同源策略的限制. 实际上, 浏览器不会拦截不合法的跨域请求, 而是拦截了他们的响应, 因此即使请求不合法, 很多时候, 服务器依然收到了请求.(Chrome和Firefox下https网站不允许发送http异步请求除外)</p>
<p>通常, 一次跨域访问拥有如下流程:</p>
<p><img src="http://louiszhai.github.io/docImages/cross-domain02.jpg" alt=""></p>
<h4 id="移动端CORS兼容性"><a href="#移动端CORS兼容性" class="headerlink" title="移动端CORS兼容性"></a>移动端CORS兼容性</h4><p>当前几乎所有的桌面浏览器(Internet Explorer 8+, Firefox 3.5+, Safari 4+和 Chrome 3+)都可通过名为跨域资源共享的协议支持ajax跨域调用.</p>
<p>那么移动端兼容性又如何呢? 请看下图:</p>
<p><img src="http://louiszhai.github.io/docImages/ajax25.png" alt="cors-mobile"></p>
<p>可见, CORS的技术在IOS Safari7.1及Android webview2.3中就早已支持, 即使低版本下webview的canvas在使用跨域的video或图片时会有问题, 也丝毫不影响CORS的在移动端的使用. 至此, 我们就可以放心大胆的去应用CORS了.</p>
<h4 id="CORS有关的headers"><a href="#CORS有关的headers" class="headerlink" title="CORS有关的headers"></a>CORS有关的headers</h4><p>1) HTTP Response Header(服务器提供):</p>
<ul>
<li><p>Access-Control-Allow-Origin: 指定允许哪些源的网页发送请求.</p>
</li>
<li><p>Access-Control-Allow-Credentials: 指定是否允许cookie发送.</p>
</li>
<li><p>Access-Control-Allow-Methods: 指定允许哪些请求方法.</p>
</li>
<li><p>Access-Control-Allow-Headers: 指定允许哪些常规的头域字段, 比如说 Content-Type.</p>
</li>
<li><p>Access-Control-Expose-Headers: 指定允许哪些额外的头域字段, 比如说 X-Custom-Header.</p>
<p>该字段可省略. CORS请求时, xhr.getResponseHeader() 方法默认只能获取6个基本字段: <code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code> . 如果需要获取其他字段, 就需要在Access-Control-Expose-Headers 中指定. 如上, 这样xhr.getResponseHeader(‘X-Custom-Header’) 才能返回X-Custom-Header字段的值.(该部分摘自阮一峰老师博客)</p>
</li>
<li><p>Access-Control-Max-Age: 指定preflight OPTIONS请求的有效期, 单位为秒.</p>
</li>
</ul>
<p>2) HTTP Request Header(浏览器OPTIONS请求默认自带):</p>
<ul>
<li>Access-Control-Request-Method: 告知服务器,浏览器将发送哪种请求, 比如说POST.</li>
<li>Access-Control-Request-Headers: 告知服务器, 浏览器将包含哪些额外的头域字段.</li>
</ul>
<p>3) 以下所有的header name 是被拒绝的:</p>
<ul>
<li>Accept-Charset</li>
<li>Accept-Encoding</li>
<li>Access-Control-Request-Headers</li>
<li>Access-Control-Request-Method</li>
<li>Connection</li>
<li>Content-Length</li>
<li>Cookie</li>
<li>Cookie2</li>
<li>Date</li>
<li>DNT</li>
<li>Expect</li>
<li>Host</li>
<li>Keep-Alive</li>
<li>Origin</li>
<li>Referer</li>
<li>TE</li>
<li>Trailer</li>
<li>Transfer-Encoding</li>
<li>Upgrade</li>
<li>Via</li>
<li>包含以<code>Proxy-</code> 或 <code>Sec-</code> 开头的header name</li>
</ul>
<h4 id="CORS请求"><a href="#CORS请求" class="headerlink" title="CORS请求"></a>CORS请求</h4><p>CORS请求分为两种, ① 简单请求; ② 非简单请求.</p>
<p>满足如下两个条件便是简单请求, 反之则为非简单请求.(CORS请求部分摘自阮一峰老师博客)</p>
<p>1) 请求是以下三种之一:</p>
<ul>
<li>HEAD</li>
<li>GET</li>
<li>POST</li>
</ul>
<p>2) http头域不超出以下几种字段:</p>
<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Last-Event-ID</li>
<li>Content-Type字段限三个值 <code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code></li>
</ul>
<p>对于简单请求, 浏览器将发送一次http请求, 同时在Request头域中增加 <code>Origin</code> 字段, 用来标示请求发起的源, 服务器根据这个源采取不同的响应策略. 若服务器认为该请求合法, 那么需要往返回的 HTTP Response 中添加 <code>Access-Control-*</code> 等字段.( <code>Access-Control-*</code> 相关字段解析请阅读我之前写的<a href="http://louiszhai.github.io/2016/01/11/cross-domain/#CORS__u8DE8_u57DF_u8BBF_u95EE]">CORS 跨域访问</a> )</p>
<p>对于非简单请求, 比如Method为<code>POST</code>且Content-Type值为 <code>application/json</code> 的请求或者Method为 <code>PUT</code> 或 <code>DELETE</code> 的请求, 浏览器将发送两次http请求. 第一次为preflight预检(Method: OPTIONS),主要验证来源是否合法. 值得注意的是:OPTION请求响应头同样需要包含 <code>Access-Control-*</code> 字段等. 第二次才是真正的HTTP请求. 所以服务器必须处理OPTIONS应答(通常需要返回20X的状态码, 否则xhr.onerror事件将被触发).</p>
<p>以上请求流程图为:</p>
<p><img src="http://louiszhai.github.io/docImages/cross-domain01.jpg" alt=""></p>
<h4 id="HTML启用CORS"><a href="#HTML启用CORS" class="headerlink" title="HTML启用CORS"></a>HTML启用CORS</h4><p>http-equiv 相当于http的响应头, 它回应给浏览器一些有用的信息,以帮助正确和精确地显示网页内容. 如下html将允许任意域名下的网页跨域访问.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Access-Control-Allow-Origin"</span> <span class="attr">content</span>=<span class="string">"*"</span>&gt;</span></div></pre></td></tr></table></figure>
<h4 id="图片启用CORS"><a href="#图片启用CORS" class="headerlink" title="图片启用CORS"></a>图片启用CORS</h4><p>通常, 图片允许跨域访问, 也可以在canvas中使用跨域的图片, 但这样做会污染画布, 一旦画布受污染, 将无法读取其数据. 比如无法调用 toBlob(), toDataURL() 或 getImageData()方法. 浏览器的这种安全机制规避了未经许可的远程服务器图片被滥用的风险.(该部分内容摘自 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/CORS_enabled_image" target="_blank" rel="external">启用了 CORS 的图片 - HTML（超文本标记语言） | MDN</a>)</p>
<p>因此如需在canvas中使用跨域的图片资源, 请参考如下apache配置片段(来自<a href="https://github.com/h5bp/server-configs-apache/blob/fc379c45f52a09dd41279dbf4e60ae281110a5b0/src/.htaccess#L36-L53" target="_blank" rel="external">HTML5 Boilerplate Apache server configs</a>).</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="section">&lt;IfModule mod_setenvif.c&gt;</span></div><div class="line">    <span class="section">&lt;IfModule mod_headers.c&gt;</span></div><div class="line">        <span class="section">&lt;FilesMatch "\.(cur|gif|ico|jpe?g|png|svgz?|webp)$"&gt;</span></div><div class="line">            <span class="attribute">SetEnvIf</span> Origin <span class="string">":"</span> IS_CORS</div><div class="line">            <span class="attribute"><span class="nomarkup">Header</span></span> set Access-Control-Allow-Origin <span class="string">"*"</span> env=IS_CORS</div><div class="line">        <span class="section">&lt;/FilesMatch&gt;</span></div><div class="line">    <span class="section">&lt;/IfModule&gt;</span></div><div class="line"><span class="section">&lt;/IfModule&gt;</span></div></pre></td></tr></table></figure>
<h3 id="ajax文件上传"><a href="#ajax文件上传" class="headerlink" title="ajax文件上传"></a>ajax文件上传</h3><p>ajax实现文件上传非常简单, 这里我选取原生js, jq, angular 分别来比较下, 并顺便聊聊使用它们时的注意事项.(ajax文件上传的代码已上传至github, 请戳这里预览效果: <a href="http://louiszhai.github.io/res/ajaxUpload.html">ajax 文件上传 demo | louis</a>)</p>
<p>1) 为了上传文件, 我们得先选中一个文件. 一个type为file的input框就够了.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"input"</span> <span class="attr">type</span>=<span class="string">"file"</span>&gt;</span></div></pre></td></tr></table></figure>
<p>2) 然后用FormData对象包裹📦选中的文件.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> input = <span class="built_in">document</span>.getElementById(<span class="string">"input"</span>),</div><div class="line">    formData = <span class="keyword">new</span> FormData();</div><div class="line">formData.append(<span class="string">"file"</span>,input.files[<span class="number">0</span>]);<span class="comment">//key可以随意定义,只要后台能理解就行</span></div></pre></td></tr></table></figure>
<p>3) 定义上传的URL, 以及方法. github上我搭建了一个 <a href="https://github.com/Louiszhai/node-webserver" target="_blank" rel="external">node-webserver</a>, 根据需要可以自行克隆下来npm start后便可调试本篇代码.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> url = <span class="string">"http://localhost:10108/test"</span>,</div><div class="line">    method = <span class="string">"POST"</span>;</div></pre></td></tr></table></figure>
<h4 id="js文件上传"><a href="#js文件上传" class="headerlink" title="js文件上传"></a>js文件上传</h4><p>4.1) 封装一个用于发送ajax请求的方法.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">url, method, data</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> xhr = <span class="literal">null</span>;</div><div class="line">  <span class="keyword">if</span>(<span class="built_in">window</span>.XMLHttpRequest) &#123;</div><div class="line">    xhr = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">window</span>.ActiveXObject) &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      xhr = <span class="keyword">new</span> ActiveXObject(<span class="string">"Msxml2.XMLHTTP"</span>);</div><div class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        xhr = <span class="keyword">new</span> ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</div><div class="line">      &#125; <span class="keyword">catch</span> (e) &#123; </div><div class="line">        alert(<span class="string">"您的浏览器暂不支持Ajax!"</span>);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  xhr.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(e);</div><div class="line">  &#125;</div><div class="line">  xhr.open(method, url);</div><div class="line">  <span class="keyword">try</span>&#123;</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      xhr.send(data);</div><div class="line">    &#125;);</div><div class="line">  &#125;<span class="keyword">catch</span>(e)&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'error:'</span>,e);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> xhr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>4.2) 上传文件并绑定事件.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> xhr = ajax(url, method, formData);</div><div class="line">xhr.upload.onprogress = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"upload progress:"</span>, e.loaded/e.total*<span class="number">100</span> + <span class="string">"%"</span>);</div><div class="line">&#125;;</div><div class="line">xhr.upload.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"upload onload."</span>);</div><div class="line">&#125;;</div><div class="line">xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"onload."</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上传结果如下所示:</p>
<p><img src="http://louiszhai.github.io/docImages/ajax17.png" alt="js file upload"></p>
<h4 id="fetch上传"><a href="#fetch上传" class="headerlink" title="fetch上传"></a>fetch上传</h4><p>5) fetch只要发送一个post请求, 并且body属性设置为formData即可. 遗憾的是, fetch无法跟踪上传的进度信息.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">fetch(url, &#123;</div><div class="line">  <span class="attr">method</span>: method,</div><div class="line">  <span class="attr">body</span>: formData</div><div class="line">  &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(res);</div><div class="line">  &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(e);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="jquery文件上传"><a href="#jquery文件上传" class="headerlink" title="jquery文件上传"></a>jquery文件上传</h4><p>jq提供了各式各样的上传插件, 其原理都是利用jq自身的ajax方法.</p>
<p>6) jq的ajax提供了xhr属性用于自定义各种事件.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">$.ajax(&#123;</div><div class="line">  <span class="attr">type</span>: method,</div><div class="line">  <span class="attr">url</span>: url,</div><div class="line">  <span class="attr">data</span>: formData,</div><div class="line">  <span class="attr">processData</span> : <span class="literal">false</span>,</div><div class="line">  <span class="attr">contentType</span> : <span class="literal">false</span> ,<span class="comment">//必须false才会自动加上正确的Content-Type</span></div><div class="line">  xhr: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> xhr = $.ajaxSettings.xhr();<span class="comment">//实际上就是return new window.XMLHttpRequest()对象</span></div><div class="line">    <span class="keyword">if</span>(xhr.upload) &#123;</div><div class="line">      xhr.upload.addEventListener(<span class="string">"progress"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"jq upload progress:"</span>, e.loaded/e.total*<span class="number">100</span> + <span class="string">"%"</span>);</div><div class="line">      &#125;, <span class="literal">false</span>);</div><div class="line">      xhr.upload.addEventListener(<span class="string">"load"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"jq upload onload."</span>);</div><div class="line">      &#125;);</div><div class="line">      xhr.addEventListener(<span class="string">"load"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"jq onload."</span>);</div><div class="line">      &#125;);</div><div class="line">      <span class="keyword">return</span> xhr;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>jq上传结果如下所示:</p>
<p><img src="http://louiszhai.github.io/docImages/ajax18.png" alt="jq file upload"></p>
<p>有关jq ajax更多的api, 请参考中文文档 <a href="http://www.jquery123.com/jQuery.ajax/" target="_blank" rel="external">jQuery.ajax() | jQuery API 中文文档</a> .</p>
<h4 id="angular文件上传"><a href="#angular文件上传" class="headerlink" title="angular文件上传"></a>angular文件上传</h4><p>7.1) angular提供了$http方法用于发送http请求, 该方法返回一个promise对象.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$http(&#123;</div><div class="line">  <span class="attr">method</span>: method,</div><div class="line">  <span class="attr">url</span>: url,</div><div class="line">  <span class="attr">data</span>: formData,</div><div class="line">&#125;).success(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(res);</div><div class="line">&#125;).error(<span class="function"><span class="keyword">function</span>(<span class="params">err, status</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(err);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>angular文件上传的代码已上传至github, 请戳这里预览效果: <a href="http://louiszhai.github.io/res/angularUpload.html">angular 文件上传 demo | louis</a>.</p>
<p>低版本angular中文件上传的功能并不完整,  直到angular1.5.5才在$http中加入了eventHandler和uploadEventHandlers等方法, 使得它支持上传进度信息. 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">$http(&#123;</div><div class="line">  <span class="attr">method</span>: method,</div><div class="line">  <span class="attr">url</span>: url,</div><div class="line">  <span class="attr">eventHandlers</span>: &#123;</div><div class="line">    <span class="attr">progress</span>: <span class="function"><span class="keyword">function</span>(<span class="params">c</span>) </span>&#123;<span class="comment">//下载进度</span></div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'Progress -&gt; '</span> + c);</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">uploadEventHandlers</span>: &#123;</div><div class="line">    <span class="attr">progress</span>: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;<span class="comment">//上传进度</span></div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'UploadProgress -&gt; '</span> + e);</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">data</span>: formData,</div><div class="line">&#125;).success(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(res);</div><div class="line">&#125;).error(<span class="function"><span class="keyword">function</span>(<span class="params">err, status</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(err);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>angular1.5.5以下低版本中, 请参考成熟的实现方案 <a href="https://github.com/nervgh/angular-file-upload" target="_blank" rel="external">angular-file-upload</a> 以及它提供的demo <a href="http://nervgh.github.io/pages/angular-file-upload/examples/simple/" target="_blank" rel="external">Simple example</a> .</p>
<h3 id="ajax请求二进制文件"><a href="#ajax请求二进制文件" class="headerlink" title="ajax请求二进制文件"></a>ajax请求二进制文件</h3><h4 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h4><p>处理二进制文件主要使用的是H5的FileReader.</p>
<p>PC支持性如下:</p>
<table>
<thead>
<tr>
<th style="text-align:center">IE</th>
<th style="text-align:center">Edge</th>
<th style="text-align:center">Firefox</th>
<th style="text-align:center">Chrome</th>
<th style="text-align:center">Safari</th>
<th style="text-align:center">Opera</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">12</td>
<td style="text-align:center">3.6</td>
<td style="text-align:center">6</td>
<td style="text-align:center">6</td>
<td style="text-align:center">11.5</td>
</tr>
</tbody>
</table>
<p>Mobile支持性如下:</p>
<table>
<thead>
<tr>
<th style="text-align:center">IOS Safari</th>
<th style="text-align:center">Opera Mini</th>
<th style="text-align:center">Android Browser</th>
<th style="text-align:center">Chrome/Android</th>
<th style="text-align:center">UC/Android</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">7.1</td>
<td style="text-align:center">-</td>
<td style="text-align:center">4</td>
<td style="text-align:center">53</td>
<td style="text-align:center">11</td>
</tr>
</tbody>
</table>
<p>以下是其API:</p>
<table>
<thead>
<tr>
<th style="text-align:center">属性/方法名称</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong><em>error</em></strong></td>
<td style="text-align:left">表示读取文件期间发生的错误.</td>
</tr>
<tr>
<td style="text-align:center"><strong><em>readyState</em></strong></td>
<td style="text-align:left">表示读取文件的状态.默认有三个值:0表示文件还没有加载;1表示文件正在读取;2表示文件读取完成.</td>
</tr>
<tr>
<td style="text-align:center"><strong><em>result</em></strong></td>
<td style="text-align:left">读取的文件内容.</td>
</tr>
<tr>
<td style="text-align:center"><strong><em>abort()</em></strong></td>
<td style="text-align:left">取消文件读取操作, 此时<code>readyState</code>属性将置为2.</td>
</tr>
<tr>
<td style="text-align:center"><strong><em>readAsArrayBuffer()</em></strong></td>
<td style="text-align:left">读取文件(或blob对象)为类型化数组(<a href="http://blog.csdn.net/lichwei1983/article/details/43893025" target="_blank" rel="external">ArrayBuffer</a>),  类型化数组允许开发者以数组下标的方式, 直接操作内存, 由于数据以二进制形式传递, 效率非常高.</td>
</tr>
<tr>
<td style="text-align:center"><em><del>readAsBinaryString()</del></em></td>
<td style="text-align:left">读取文件(或blob对象)为二进制字符串, 该方法已移出标准api, 请谨慎使用.</td>
</tr>
<tr>
<td style="text-align:center"><strong><em>readAsDataURL()</em></strong></td>
<td style="text-align:left">读取文件(或blob对象)为base64编码的URL字符串, 与window.URL.createObjectURL方法效果类似.</td>
</tr>
<tr>
<td style="text-align:center"><strong><em>readAsText()</em></strong></td>
<td style="text-align:left">读取文件(或blob对象)为文本字符串.</td>
</tr>
<tr>
<td style="text-align:center"><strong><em>onload()</em></strong></td>
<td style="text-align:left">文件读取完成时的事件回调, 默认传入event事件对象. 该回调内, 可通过this.result 或 event.target.result获取读取的文件内容.</td>
</tr>
</tbody>
</table>
<h4 id="ajax请求二进制图片并预览"><a href="#ajax请求二进制图片并预览" class="headerlink" title="ajax请求二进制图片并预览"></a>ajax请求二进制图片并预览</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest(),</div><div class="line">    url = <span class="string">"http://louiszhai.github.io/docImages/ajax01.png"</span>;</div><div class="line">xhr.open(<span class="string">"GET"</span>, url);</div><div class="line">xhr.responseType = <span class="string">"blob"</span>;</div><div class="line">xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>.status == <span class="number">200</span>)&#123;</div><div class="line">    <span class="keyword">var</span> blob = <span class="keyword">this</span>.response;</div><div class="line">    <span class="keyword">var</span> img = <span class="built_in">document</span>.createElement(<span class="string">"img"</span>);</div><div class="line">    <span class="comment">//方案一</span></div><div class="line">    img.src = <span class="built_in">window</span>.URL.createObjectURL(blob);<span class="comment">//这里blob依然占据着内存</span></div><div class="line">    img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="built_in">window</span>.URL.revokeObjectURL(img.src);<span class="comment">//释放内存</span></div><div class="line">    &#125;;</div><div class="line">    <span class="comment">//方案二</span></div><div class="line">    <span class="comment">/*var reader = new FileReader();</span></div><div class="line">    reader.readAsDataURL(blob);//FileReader将返回base64编码的data-uri对象</div><div class="line">    reader.onload = function()&#123;</div><div class="line">      img.src = this.result;</div><div class="line">    &#125;*/</div><div class="line">    <span class="comment">//方案三</span></div><div class="line">    <span class="comment">//img.src = url;//最简单方法</span></div><div class="line">    <span class="built_in">document</span>.body.appendChild(img);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">xhr.send();</div></pre></td></tr></table></figure>
<h4 id="ajax请求二进制文本并展示"><a href="#ajax请求二进制文本并展示" class="headerlink" title="ajax请求二进制文本并展示"></a>ajax请求二进制文本并展示</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">xhr.open(<span class="string">"GET"</span>,<span class="string">"http://localhost:8080/Information/download.jsp?data=node-fetch.js"</span>);</div><div class="line">xhr.responseType = <span class="string">"blob"</span>;</div><div class="line">xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>.status == <span class="number">200</span>)&#123;</div><div class="line">    <span class="keyword">var</span> blob = <span class="keyword">this</span>.response;</div><div class="line">    <span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader();</div><div class="line">    reader.readAsBinaryString(blob);<span class="comment">//该方法已被移出标准api,建议使用reader.readAsText(blob);</span></div><div class="line">    reader.onload=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="built_in">document</span>.body.innerHTML = <span class="string">"&lt;div&gt;"</span> + <span class="keyword">this</span>.result + <span class="string">"&lt;/div&gt;"</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">xhr.send();</div></pre></td></tr></table></figure>
<p>有关二进制文件的读取, 请移步这篇博客 <a href="http://www.cnblogs.com/jscode/archive/2013/04/27/3572239.html" target="_blank" rel="external">HTML5新特性之文件和二进制数据的操作</a> .</p>
<h3 id="如何等待多个ajax请求完成"><a href="#如何等待多个ajax请求完成" class="headerlink" title="如何等待多个ajax请求完成"></a>如何等待多个ajax请求完成</h3><p>原生js可以使用ES6新增的Promise. ES6的Promise基于 <a href="https://promisesaplus.com/" target="_blank" rel="external">Promises/A+</a> 规范(该部分 <a href="http://louiszhai.github.io/2016/10/19/fetch/">Fetch入门指南</a> 一文也有提及).</p>
<p>这里先提供一个解析responses的函数.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">todo</span>(<span class="params">responses</span>)</span>&#123;</div><div class="line">  responses.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</div><div class="line">    response.json().then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(res);</div><div class="line">    &#125;);</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>原生js使用 <code>Promise.all</code> 方法. 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p1 = fetch(<span class="string">"http://localhost:10108/test1"</span>),</div><div class="line">    p2 = fetch(<span class="string">"http://localhost:10108/test2"</span>);</div><div class="line"><span class="built_in">Promise</span>.all([p1, p2]).then(<span class="function"><span class="keyword">function</span>(<span class="params">responses</span>)</span>&#123;</div><div class="line">  todo(responses);</div><div class="line">  <span class="comment">//TODO do somethings</span></div><div class="line">&#125;);</div><div class="line"><span class="comment">//"test1"</span></div><div class="line"><span class="comment">//"test2"</span></div></pre></td></tr></table></figure>
<p>jquery可以使用$.when方法. 该方法接受一个或多个Deferred对象作为参数, 只有全部成功才调用resolved状态的回调函数, 但只要其中有一个失败，就调用rejected状态的回调函数. 其实, jq的Deferred是基于 Promises/A规范实现, 但并非完全遵循. (传送门: <a href="http://www.css88.com/archives/4750/comment-page-1" target="_blank" rel="external">jQuery 中的 Deferred 和 Promises (2)</a> ).</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p1 = $.ajax(<span class="string">"http://localhost:10108/test1"</span>),</div><div class="line">    p2 = $.ajax(<span class="string">"http://localhost:10108/test2"</span>);</div><div class="line">$.when(p1, p2).then(<span class="function"><span class="keyword">function</span>(<span class="params">res1, res2</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(res1);<span class="comment">//["test1", "success", Object]</span></div><div class="line">  <span class="built_in">console</span>.log(res2);<span class="comment">//["test2", "success", Object]</span></div><div class="line">  <span class="comment">//TODO do somethings</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>如上, $.when默认返回一个jqXHR对象, 可以直接进行链式调用. then方法的回调中默认传入相应的请求结果, 每个请求结果的都是数组, 数组中依次是responseText, 请求状态, 请求的jqXHR对象.</p>
<p>angular中可以借助 <code>$q.all()</code> 来实现. 别忘了, <code>$q</code> 需要在controller中注入. 此外, <code>$q</code> 相关讲解可参考 <a href="https://code.angularjs.org/1.2.6/docs/api/ng.$q" target="_blank" rel="external">AngularJS: ng.$q</a> 或 <a href="https://segmentfault.com/a/1190000000402555" target="_blank" rel="external">Angular $q service学习笔记</a> .</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p1 = fetch(<span class="string">"http://localhost:10108/test1"</span>),</div><div class="line">    p2 = fetch(<span class="string">"http://localhost:10108/test2"</span>);</div><div class="line">$q.all([p1, p2]).then(<span class="function"><span class="keyword">function</span>(<span class="params">responses</span>)</span>&#123;</div><div class="line">  todo(responses);</div><div class="line">  <span class="comment">//TODO do somethings</span></div><div class="line">&#125;);</div><div class="line"><span class="comment">//"test1"</span></div><div class="line"><span class="comment">//"test2"</span></div></pre></td></tr></table></figure>
<p><code>$q.all()</code> 实际上就是对 <code>Promise.all</code> 的封装.</p>
<h3 id="ajax与history的兼容"><a href="#ajax与history的兼容" class="headerlink" title="ajax与history的兼容"></a>ajax与history的兼容</h3><p>ajax的一大痛点就是无法支持浏览器前进和后退操作. 因此早期的Gmail 采用 iframe, 来模拟ajax的前进和后退.</p>
<p>如今, H5普及, pjax大行其道. pajax 就是 ajax+history.pushState 组合的一种技术. 使用它便可以无刷新通过浏览器前进和后退来改变页面内容.</p>
<p>先看下兼容性.</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">IE</th>
<th style="text-align:center">Edge</th>
<th style="text-align:center">Firefox</th>
<th style="text-align:center">Chrome</th>
<th style="text-align:center">Safari</th>
<th style="text-align:center">Opera</th>
<th style="text-align:center">iOS Safari</th>
<th style="text-align:center">Android Browser</th>
<th style="text-align:center">Chrome for Android</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">pushState/replaceState</td>
<td style="text-align:center">10</td>
<td style="text-align:center">12</td>
<td style="text-align:center">4</td>
<td style="text-align:center">5</td>
<td style="text-align:center">6</td>
<td style="text-align:center">11.5</td>
<td style="text-align:center">7.1</td>
<td style="text-align:center">4.3</td>
<td style="text-align:center">53</td>
</tr>
<tr>
<td style="text-align:center">history.state</td>
<td style="text-align:center">10</td>
<td style="text-align:center"></td>
<td style="text-align:center">4</td>
<td style="text-align:center">18</td>
<td style="text-align:center">6</td>
<td style="text-align:center">11.5</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>可见IE8,9并不能使用 H5的history. 需要使用垫片 <a href="https://github.com/devote/HTML5-History-API" target="_blank" rel="external">HTML5 History API expansion for browsers not supporting pushState, replaceState</a> .</p>
<h4 id="pjax"><a href="#pjax" class="headerlink" title="pjax"></a>pjax</h4><p>pjax简单易用, 仅需要如下三个api:</p>
<ul>
<li>history.pushState(obj, title, url) 表示往页面history末尾新增一个历史项(history entry), 此时history.length会+1.</li>
<li>history.replaceState(obj, title, url) 表示替换当前历史项为新的历史项. 此时history.length保持不变.</li>
<li>window.onpopstate 仅在浏览器前进和后退时触发(history.go(1), history.back() 及location.href=”xxx” 均会触发), 此时可在history.state中拿到刚刚塞进去的state, 即obj对象(其他数据类型亦可).</li>
</ul>
<p>我们注意到, 首次进入一个页面, 此时 <code>history.length</code> 值为1, <code>history.state</code> 为空. 如下:</p>
<p><img src="http://louiszhai.github.io/docImages/ajax19.png" alt="history.state"></p>
<p>1) 为了在onpopstate事件回调中每次都能拿到 <code>history.state</code> , 此时需要在页面载入完成后, 自动替换下当前url.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">history.replaceState(<span class="string">"init"</span>, title, <span class="string">"xxx.html?state=0"</span>);</div></pre></td></tr></table></figure>
<p>2) 每次发送ajax请求时, 在请求完成后, 调用如下, 从而实现浏览器history往前进.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">history.pushState(<span class="string">"ajax请求相关参数"</span>, title, <span class="string">"xxx.html?state=标识符"</span>);</div></pre></td></tr></table></figure>
<p>3) 浏览器前进和后退时, <code>popstate</code> 事件会自动触发, 此时我们手动取出 <code>history.state</code> , 构建参数并重新发送ajax请求或者直接取用state值, 从而实现无刷新还原页面.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"popstate"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> currentState = history.state;</div><div class="line">	<span class="comment">//TODO 拼接ajax请求参数并重新发送ajax请求, 从而回到历史页面</span></div><div class="line">  	<span class="comment">//TODO 或者从state中拿到关键值直接还原历史页面</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p> <code>popstate</code> 事件触发时, 默认会传入 <code>PopStateEvent</code> 事件对象. 该对象具有如下属性.</p>
<p><img src="http://louiszhai.github.io/docImages/ajax20.png" alt="PopStateEvent"></p>
<p>如有不懂, 更详细讲解请移步 : <a href="http://www.zhangxinxu.com/wordpress/2013/06/html5-history-api-pushstate-replacestate-ajax/" target="_blank" rel="external">ajax与HTML5 history pushState/replaceState实例 « 张鑫旭-鑫空间-鑫生活</a> .</p>
<h3 id="ajax缓存处理"><a href="#ajax缓存处理" class="headerlink" title="ajax缓存处理"></a>ajax缓存处理</h3><p>js中的http缓存没有开关, 受制于浏览器http缓存策略. 原生xhr请求中, 可通过如下设置关闭缓存.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">xhr.setRequestHeader(<span class="string">"If-Modified-Since"</span>,<span class="string">"0"</span>);</div><div class="line">xhr.setRequestHeader(<span class="string">"Cache-Control"</span>,<span class="string">"no-cache"</span>);</div><div class="line"><span class="comment">//或者 URL 参数后加上  "?timestamp=" + new Date().getTime()</span></div></pre></td></tr></table></figure>
<p>jquery的http缓存是否开启可通过在settings中指定cache.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$.ajax(&#123;</div><div class="line">  <span class="attr">url</span> : <span class="string">'url'</span>,</div><div class="line">  <span class="attr">dataType</span> : <span class="string">"xml"</span>,</div><div class="line">  <span class="attr">cache</span>: <span class="literal">true</span>,<span class="comment">//true表示缓存开启, false表示缓存不开启</span></div><div class="line">  success : <span class="function"><span class="keyword">function</span>(<span class="params">xml, status</span>)</span>&#123;    </div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>同时jquery还可以全局设置是否缓存. 如下将全局关闭ajax缓存.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$.ajaxSetup(&#123;<span class="attr">cache</span>:<span class="literal">false</span>&#125;);</div></pre></td></tr></table></figure>
<p>除此之外, 调试过程中出现的浏览器缓存尤为可恶. 建议开启隐私浏览器或者勾选☑️控制台的 <code>Disable cache</code> 选项. (这里以Chrome举例, 其他浏览器类似)</p>
<p><img src="http://louiszhai.github.io/docImages/ajax21.png" alt="PopStateEvent"></p>
<h3 id="ajax的错误处理"><a href="#ajax的错误处理" class="headerlink" title="ajax的错误处理"></a>ajax的错误处理</h3><p>前面已经提过, 通常只要是ajax请求收到了http状态码, 便不会进入到错误捕获里.(Chrome中407响应头除外)</p>
<p>实际上, <code>$.ajax</code> 方法略有区别, jquery的ajax方法还会在类型解析出错时触发error回调. 最常见的便是: dataType设置为json, 但是返回的data并非json格式, 此时 <code>$.ajax</code> 的error回调便会触发.</p>
<h3 id="ajax调试技巧"><a href="#ajax调试技巧" class="headerlink" title="ajax调试技巧"></a>ajax调试技巧</h3><p>有关调试, 如果接口只是做小部分修改. 那么可以使用charles(Mac) 或者fiddler(Windows), 做代理, 将请求的资源替换为本地文件, 或者使用其断点功能, 直接编辑response.</p>
<p>如果是新增接口的调试, 可以本地搭建node服务. 利用hosts文件配置dns + nginx将http请求转发到本地node服务器. 简易的node调试服务器可参考我的 <a href="https://github.com/Louiszhai/node-webserver" target="_blank" rel="external">node-webserver</a> . 如下举一个栗子🌰:</p>
<h4 id="hosts-nginx-node-webserver"><a href="#hosts-nginx-node-webserver" class="headerlink" title="hosts+nginx+node-webserver"></a>hosts+nginx+node-webserver</h4><p>假设我们要调试的是 www.test.com 的GET接口. 以下所有步骤以Mac为例, 其他系统, 请自行搜索🔍文件路径.</p>
<p>1) hosts配置.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo vim /etc/hosts</div><div class="line"><span class="comment">#新增一行 127.0.0.1 www.test.com</span></div></pre></td></tr></table></figure>
<p>2) nginx 配置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">brew install nginx <span class="comment">#安装</span></div><div class="line"><span class="comment">#安装成功后进入目标目录</span></div><div class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/etc/nginx/</div><div class="line"><span class="built_in">cd</span> servers <span class="comment">#默认配置入口为nginx.conf.同时servers目录下*.conf文件已自动加入到配置文件列表中</span></div><div class="line">vim test.conf</div><div class="line"><span class="comment">#粘贴如下内容</span></div><div class="line">server &#123;</div><div class="line">  listen       80;</div><div class="line">  server_name  www.test.com;</div><div class="line">  index index.html;</div><div class="line">  error_page   500 502 503 504  /50x.html;</div><div class="line">  location = /50x.html &#123;</div><div class="line">  	root   html;</div><div class="line">  &#125;</div><div class="line">  location / &#123;</div><div class="line">    proxy_pass http://localhost:10108/;</div><div class="line">    proxy_redirect off;</div><div class="line">    proxy_set_header Host <span class="variable">$host</span>;</div><div class="line">    proxy_set_header        X-Read-IP       <span class="variable">$remote_addr</span>;</div><div class="line">    proxy_set_header        X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">#:wq保存并退出</span></div><div class="line"><span class="comment">#启动nginx</span></div><div class="line">sudo nginx <span class="_">-s</span> reload <span class="comment">#如果启动了只需重启即可</span></div><div class="line">sudo nginx <span class="comment">#如果没有启动,便启动之</span></div></pre></td></tr></table></figure>
<p>3) node-webServer 配置</p>
<p>参考 <a href="https://github.com/Louiszhai/node-webserver" target="_blank" rel="external">node-webserver</a> . 启动服务前只需更改index.js, 在第9行后插入如下内容:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">'get': &#123;</div><div class="line">  '/': &#123;</div><div class="line">  	getKey : 'Welcome to Simple Node  WebServer!'</div><div class="line">  &#125;,</div><div class="line">  '接口api': '你的response内容'//插入的代码                               </div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<p>如需在nginx中配置CORS, 请看这里: <a href="http://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247484408&amp;idx=1&amp;sn=5c64dd43ff2060e1c4a22d93e4e887c9&amp;scene=1&amp;srcid=0901vPdwJR0crm8vJmjboYzI#rd" target="_blank" rel="external">Nginx通过CORS实现跨域</a>.</p>
<h4 id="编码问题"><a href="#编码问题" class="headerlink" title="编码问题"></a>编码问题</h4><p>XMLHttpRequest 返回的数据默认的字符编码是utf-8, post方法提交数据默认的字符编码也是utf-8. 若页面编码为gbk等中文编码, 那么就会产生乱码.</p>
<h3 id="后端接口测试技巧"><a href="#后端接口测试技巧" class="headerlink" title="后端接口测试技巧"></a>后端接口测试技巧</h3><p>通常, 如果后端接口开发OK了, 前端同学需要通过一些手段来确认接口是能正常访问的.</p>
<h4 id="使用命令测试OPTIONS请求"><a href="#使用命令测试OPTIONS请求" class="headerlink" title="使用命令测试OPTIONS请求"></a>使用命令测试OPTIONS请求</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">curl -I -X OPTIONS -H <span class="string">"Origin: http://example.com"</span> http://localhost:10108/</div><div class="line"><span class="comment"># response</span></div><div class="line">HTTP/1.1 200 OK</div><div class="line">X-Powered-By: Express</div><div class="line">Content-Type: text/json;charset=UTF-8</div><div class="line">Access-Control-Allow-Credentials: <span class="literal">true</span></div><div class="line">Access-Control-Allow-Headers: x-requested-with,Content-Type</div><div class="line">Access-Control-Allow-Methods: GET,POST,PUT,DELETE,OPTIONS</div><div class="line">Access-Control-Allow-Origin: http://example.com</div><div class="line">Access-Control-Max-Age: 3600</div><div class="line">Server: Node WebServer</div><div class="line">Website: https://github.com/Louiszhai/node-webserver</div><div class="line">Date: Fri, 21 Oct 2016 09:00:40 GMT</div><div class="line">Connection: keep-alive</div><div class="line">Transfer-Encoding: chunked</div></pre></td></tr></table></figure>
<p>以上, http状态码为200, 表示允许OPTIONS请求.</p>
<p>GET, POST 请求与GET类似, 其他请求亦然.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">curl -I -X GET -H <span class="string">"Origin: http://example.com"</span> http://localhost:10108/</div><div class="line"><span class="comment">#HTTP/1.1 200 OK</span></div><div class="line">curl -I -X POST -H <span class="string">"Origin: http://example.com"</span> http://localhost:10108/<span class="built_in">test</span></div><div class="line"><span class="comment">#HTTP/1.1 200 OK</span></div></pre></td></tr></table></figure>
<h4 id="postman"><a href="#postman" class="headerlink" title="postman"></a>postman</h4><p>除此之外, 我们还可以通过chrome的postman扩展进行测试. 请看postman素洁的界面:</p>
<p><img src="http://louiszhai.github.io/docImages/ajax26.png" alt=""></p>
<p>postman支持所有类型的http请求, 由于其向chrome申请了cookie访问权限及所有http(s)网站的访问权限. 因此可以放心使用它进行各种网站api的测试.</p>
<p>同时, 强烈建议阅读本文的你升级postman的使用技巧, 这里有篇: <a href="https://segmentfault.com/a/1190000005055899" target="_blank" rel="external">基于Postman的API自动化测试</a> , 拿走不谢.</p>
<h3 id="ajax移动端兼容性"><a href="#ajax移动端兼容性" class="headerlink" title="ajax移动端兼容性"></a>ajax移动端兼容性</h3><p>移动端的支持性比较弱, 使用需谨慎. 看表.</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">IOS Safari</th>
<th style="text-align:center">Opera Mini</th>
<th style="text-align:center">Android Browser</th>
<th style="text-align:center">Android Chrome</th>
<th style="text-align:center">Android UC</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">XMLHttpRequest</td>
<td style="text-align:center">8.4</td>
<td style="text-align:center">-</td>
<td style="text-align:center">4.4.4</td>
<td style="text-align:center">53</td>
<td style="text-align:center">11(part)</td>
</tr>
<tr>
<td style="text-align:center">fetch</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">52</td>
<td style="text-align:center">53</td>
<td style="text-align:center">-</td>
</tr>
</tbody>
</table>
<p>本篇为ajax而生, 通篇介绍 XMLHTTPRequest 相关的知识, 力求简明, 本欲为梳理知识, 为读者答疑解惑, 但因本人理解所限, 难免有所局限, 希望正在阅读的你取其精华去其糟粕. 谢谢.</p>
<hr>
<p>本文就讨论这么多内容,大家有什么问题或好的想法欢迎在下方参与<a href="#respond">留言和评论</a>.</p>
<p>本文作者: <a href="https://github.com/Louiszhai" target="_blank" rel="external">louis</a></p>
<p>本文链接: <a href="http://louiszhai.github.io/2016/11/02/ajax/">http://louiszhai.github.io/2016/11/02/ajax/</a></p>
<p>参考文章</p>
<ul>
<li><a href="https://xhr.spec.whatwg.org/" target="_blank" rel="external">XMLHttpRequest Standard</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html" target="_blank" rel="external">XMLHttpRequest Level 2 使用指南 - 阮一峰的网络日志</a></li>
<li><a href="https://segmentfault.com/a/1190000004322487" target="_blank" rel="external">你真的会使用XMLHttpRequest吗？ - WEB前端路上踩过的坑儿 - SegmentFault</a></li>
<li><a href="http://www.zhangxinxu.com/wordpress/2013/06/html5-history-api-pushstate-replacestate-ajax/" target="_blank" rel="external">ajax与HTML5 history pushState/replaceState实例 « 张鑫旭-鑫空间-鑫生活</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="external">跨域资源共享 CORS 详解 - 阮一峰的网络日志</a></li>
<li><a href="http://www.jquery123.com/jQuery.ajax/" target="_blank" rel="external">jQuery.ajax() | jQuery API 中文文档 -- jQuery 中文网</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      ajax XMLHttpRequest xhr fetch XDomainRequest jquery.ajax overrideMimeType CORS FileReader postman angular withCredentials setRequestHeader getAllResponseHeaders upload ajax与history的兼容 ajax跨域请求 ajax文件上传 ajax缓存处理 ajax错误处理 ajax调试技巧 pjax ajax请求二进制 多个ajax请求 options xhr一级 xhr二级 axios
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://louiszhai.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Fetch进阶指南</title>
    <link href="http://louiszhai.github.io/2016/11/02/fetch/"/>
    <id>http://louiszhai.github.io/2016/11/02/fetch/</id>
    <published>2016-11-02T04:48:08.000Z</published>
    <updated>2017-04-25T10:25:09.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h3><p>Fetch 是 web异步通信的未来. 从chrome42, Firefox39, Opera29, EdgeHTML14(并非Edge版本)起, fetch就已经被支持了. 其中chrome42~45版本, fetch对中文支持有问题, 建议从chrome46起使用fetch. 传送门: <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=511289" target="_blank" rel="external">fetch中文乱码</a> .</p>
<a id="more"></a>
<h3 id="Fetch"><a href="#Fetch" class="headerlink" title="Fetch"></a>Fetch</h3><p>先过一遍Fetch原生支持率.</p>
<p><img src="http://louiszhai.github.io/docImages/ajax07.png" alt=""><br><img src="http://louiszhai.github.io/docImages/ajax08.png" alt=""></p>
<p>可见要想在IE8/9/10/11中使用fetch还是有些犯难的,毕竟它连 Promise 都不支持, 更别说fetch了. 别急, 这里有polyfill(垫片). </p>
<ul>
<li>es5 的 polyfill — <a href="https://github.com/es-shims/es5-shim" target="_blank" rel="external"><code>es5-shim, es5-sham</code></a> .</li>
<li>Promise 的 polyfill — <a href="https://github.com/jakearchibald/es6-promise" target="_blank" rel="external"><code>es6-promise</code></a> .</li>
<li>fetch 的 polyfill — <a href="https://github.com/camsong/fetch-ie8" target="_blank" rel="external"><code>fetch-ie8</code></a> .</li>
</ul>
<p>由于IE8基于ES3, IE9支持大部分ES5, IE11支持少量ES5, 其中只有IE10对ES5支持比较完整. 因此IE8+浏览器, 建议依次装载上述垫片.</p>
<h4 id="尝试一个fetch"><a href="#尝试一个fetch" class="headerlink" title="尝试一个fetch"></a>尝试一个fetch</h4><p>先来看一个简单的fetch.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> word = <span class="string">'123'</span>,</div><div class="line">    url = <span class="string">'https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd='</span>+word+<span class="string">'&amp;json=1&amp;p=3'</span>;</div><div class="line">fetch(url,&#123;<span class="attr">mode</span>: <span class="string">"no-cors"</span>&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> response;</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(data);</div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Oops, error"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>fetch执行后返回一个 <code>Promise</code> 对象, 执行成功后, 成功打印出 <code>Response</code> 对象.</p>
<p><img src="http://louiszhai.github.io/docImages/ajax11.png" alt="response headers"></p>
<p>该fetch可以在任何域名的网站直接运行, 且能正常返回百度搜索的建议词条. 以下是常规输入时的是界面截图.</p>
<p><img src="http://louiszhai.github.io/docImages/ajax09.png" alt="response headers"></p>
<p>以下是刚才fetch到的部分数据. 其中key name 为”s”的字段的value就是以上的建议词条.(由于有高亮词条”12306”, 最后一条数据”12366”被顶下去了, 故上面截图上看不到)</p>
<p><img src="http://louiszhai.github.io/docImages/ajax10.png" alt="response headers"></p>
<p>看完栗子过后, 就要动真格了. 下面就来扒下 Fetch.</p>
<h4 id="Promise特性"><a href="#Promise特性" class="headerlink" title="Promise特性"></a>Promise特性</h4><p>fetch方法返回一个Promise对象, 根据 <code>Promise Api</code> 的特性, fetch可以方便地使用then方法将各个处理逻辑串起来, 使用 Promise.resolve() 或 Promise.reject() 方法将分别返会肯定结果的Promise或否定结果的Promise, 从而调用下一个then 或者 catch. 一但then中的语句出现错误, 也将跳到catch中.</p>
<p>Promise若有疑问, 请阅读 <a href="https://www.promisejs.org/" target="_blank" rel="external">Promises</a> .</p>
<p>① 我们不妨在 <a href="https://sp0.baidu.com" target="_blank" rel="external">https://sp0.baidu.com</a> 域名的网页控制台运行以下代码.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> word = <span class="string">'123'</span>,</div><div class="line">    url = <span class="string">'https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd='</span>+word+<span class="string">'&amp;json=1&amp;p=3'</span>;</div><div class="line">fetch(url).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'第一次进入then...'</span>);</div><div class="line">  <span class="keyword">if</span>(response.status&gt;=<span class="number">200</span> &amp;&amp; response.status&lt;<span class="number">300</span>)&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Content-Type: '</span> + response.headers.get(<span class="string">'Content-Type'</span>));</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Date: '</span> + response.headers.get(<span class="string">'Date'</span>));</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'status: '</span> + response.status);</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'statusText: '</span> + response.statusText);</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'type: '</span> + response.type);</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'url: '</span> + response.url);</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(response);</div><div class="line">  &#125;<span class="keyword">else</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(response.statusText));</div><div class="line">  &#125;</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'第二次进入then...'</span>);</div><div class="line">  <span class="built_in">console</span>.log(data);</div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'抛出的错误如下:'</span>);</div><div class="line">  <span class="built_in">console</span>.log(e);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>运行截图如下:</p>
<p><img src="http://louiszhai.github.io/docImages/ajax12.png" alt="fetch then"></p>
<p>② 我们不妨在非 <a href="https://sp0.baidu.com" target="_blank" rel="external">https://sp0.baidu.com</a> 域名的网页控制台再次运行以上代码.(别忘了给fetch的第二参数传递{mode: “no-cors”})</p>
<p>运行截图如下:</p>
<p><img src="http://louiszhai.github.io/docImages/ajax13.png" alt="fetch catch"></p>
<p>由于第一次进入then分支后, 返回了否定结果的 Promise.reject 对象. 因此代码进入到catch分支, 抛出了错误. 此时, 上述 <code>response.type</code> 为 <code>opaque</code> .</p>
<h4 id="response-type"><a href="#response-type" class="headerlink" title="response type"></a>response type</h4><p>一个fetch请求的响应类型(response.type)为如下三种之一:</p>
<ul>
<li>basic</li>
<li>cors</li>
<li>opaque</li>
</ul>
<p>如上情景①, 同域下, 响应类型为 “basic”.</p>
<p>如上情景②中, 跨域下, 服务器没有返回CORS响应头, 响应类型为 “opaque”. 此时我们几乎不能查看任何有价值的信息, 比如不能查看response, status, url等等等等.</p>
<p><img src="http://louiszhai.github.io/docImages/ajax14.png" alt="fetch type"></p>
<p>同样是跨域下, 如果服务器返回了CORS响应头, 那么响应类型将为 “cors”. 此时响应头中除 <code>Cache-Control</code> , <code>Content-Language</code> , <code>Content-Type</code> , <code>Expores</code> , <code>Last-Modified</code> 和 <code>Progma</code> 之外的字段都不可见.</p>
<p>注意: 无论是同域还是跨域, 以上 fetch 请求都到达了服务器.</p>
<h4 id="mode"><a href="#mode" class="headerlink" title="mode"></a>mode</h4><p>fetch可以设置不同的模式使得请求有效. 模式可在fetch方法的第二个参数对象中定义.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fetch(url, &#123;<span class="attr">mode</span>: <span class="string">'cors'</span>&#125;);</div></pre></td></tr></table></figure>
<p>可定义的模式如下:</p>
<ul>
<li>same-origin: 表示同域下可请求成功; 反之, 浏览器将拒绝发送本次fetch, 同时抛出错误 “TypeError: Failed to fetch(…)”.</li>
<li>cors: 表示同域和带有CORS响应头的跨域下可请求成功. 其他请求将被拒绝.</li>
<li>cors-with-forced-preflight: 表示在发出请求前, 将执行preflight检查.</li>
<li>no-cors: 常用于跨域请求不带CORS响应头场景, 此时响应类型为 “opaque”.</li>
</ul>
<p>除此之外, 还有两种不太常用的mode类型, 分别是 <code>navigate</code> , <code>websocket</code> , 它们是 <a href="https://html.spec.whatwg.org/multipage/" target="_blank" rel="external">HTML标准</a> 中特殊的值, 这里不做详细介绍.</p>
<h4 id="header"><a href="#header" class="headerlink" title="header"></a>header</h4><p>fetch获取http响应头非常easy. 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fetch(url).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123; </div><div class="line">    <span class="built_in">console</span>.log(response.headers.get(<span class="string">'Content-Type'</span>));</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>设置http请求头也一样简单.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> headers = <span class="keyword">new</span> Headers();</div><div class="line">headers.append(<span class="string">"Content-Type"</span>, <span class="string">"text/html"</span>);</div><div class="line">fetch(url,&#123;</div><div class="line">  <span class="attr">headers</span>: headers</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>header的内容也是可以被检索的.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> header = <span class="keyword">new</span> Headers(&#123;</div><div class="line">  <span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span></div><div class="line">&#125;);</div><div class="line"><span class="built_in">console</span>.log(header.has(<span class="string">"Content-Type"</span>)); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(header.has(<span class="string">"Content-Length"</span>)); <span class="comment">//false</span></div></pre></td></tr></table></figure>
<h4 id="post"><a href="#post" class="headerlink" title="post"></a>post</h4><p>在fetch中发送post请求, 同样可以在fetch方法的第二个参数对象中设置.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> headers = <span class="keyword">new</span> Headers();</div><div class="line">headers.append(<span class="string">"Content-Type"</span>, <span class="string">"application/json;charset=UTF-8"</span>);</div><div class="line">fetch(url, &#123;</div><div class="line">  <span class="attr">method</span>: <span class="string">'post'</span>,</div><div class="line">  <span class="attr">headers</span>: headers,</div><div class="line">  <span class="attr">body</span>: <span class="built_in">JSON</span>.stringify(&#123;</div><div class="line">    <span class="attr">date</span>: <span class="string">'2016-10-08'</span>,</div><div class="line">    <span class="attr">time</span>: <span class="string">'15:16:00'</span></div><div class="line">  &#125;)</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="credentials"><a href="#credentials" class="headerlink" title="credentials"></a>credentials</h4><p>跨域请求中需要带有cookie时, 可在fetch方法的第二个参数对象中添加credentials属性, 并将值设置为”include”.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fetch(url,&#123;</div><div class="line">  <span class="attr">credentials</span>: <span class="string">'include'</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>除此之外, credentials 还可以取以下值:</p>
<ul>
<li>omit: 缺省值, 默认为该值.</li>
<li>same-origin: 同源, 表示同域请求才发送cookie.</li>
</ul>
<h4 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h4><p>同 XMLHttpRequest 一样, 无论服务器返回什么样的状态码(chrome中除407之外的其他状态码), 它们都不会进入到错误捕获里. 也就是说, 此时, XMLHttpRequest 实例不会触发 <code>onerror</code> 事件回调, fetch 不会触发 reject. <strong>通常只在网络出现问题时或者ERR_CONNECTION_RESET时, 它们才会进入到相应的错误捕获里.</strong> (其中, 请求返回状态码为407时, chrome浏览器会触发onerror或者reject掉fetch.)</p>
<h4 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h4><p>cache表示如何处理缓存, 遵守http规范, 拥有如下几种值:</p>
<ul>
<li>default: 表示fetch请求之前将检查下http的缓存.</li>
<li>no-store: 表示fetch请求将完全忽略http缓存的存在. 这意味着请求之前将不再检查下http的缓存, 拿到响应后, 它也不会更新http缓存.</li>
<li>no-cache: 如果存在缓存, 那么fetch将发送一个条件查询request和一个正常的request, 拿到响应后, 它会更新http缓存.</li>
<li>reload: 表示fetch请求之前将忽略http缓存的存在, 但是请求拿到响应后, 它将主动更新http缓存.</li>
<li>force-cache: 表示fetch请求不顾一切的依赖缓存, 即使缓存过期了, 它依然从缓存中读取. 除非没有任何缓存, 那么它将发送一个正常的request.</li>
<li>only-if-cached: 表示fetch请求不顾一切的依赖缓存, 即使缓存过期了, 它依然从缓存中读取. 如果没有缓存, 它将抛出网络错误(该设置只在mode为”same-origin”时有效).</li>
</ul>
<p>如果fetch请求的header里包含 <code>If-Modified-Since</code>, <code>If-None-Match</code>, <code>If-Unmodified-Since</code>, <code>If-Match</code>, 或者 <code>If-Range</code> 之一, 且cache的值为 <code>default</code> , 那么fetch将自动把 cache的值设置为 <code>&quot;no-store&quot;</code> .</p>
<h4 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h4><h5 id="为什么是async-await"><a href="#为什么是async-await" class="headerlink" title="为什么是async/await"></a>为什么是async/await</h5><p>回调深渊一直是jser的一块心病, 虽然ES6提供了 Promise, 将嵌套平铺, 但使用起来依然不便. </p>
<p>要说ES6也提供了generator/yield, 它将一个函数执行暂停, 保存上下文, 再次调用时恢复当时的状态.(学习可参考 <a href="http://www.ruanyifeng.com/blog/2015/04/generator.html" target="_blank" rel="external">Generator 函数的含义与用法 - 阮一峰的网络日志</a>) 无论如何, 总感觉别扭. 如下摘自推库的一张图.</p>
<p><img src="http://louiszhai.github.io/docImages/ajax22.png" alt=""></p>
<p>我们不难看出其中的差距, callback简单粗暴, 层层回调, 回调越深入, 越不容易捋清楚逻辑. Promise 将异步操作规范化.使用then连接, 使用catch捕获错误, 堪称完美, 美中不足的是, then和catch中传递的依然是回调函数, 与心目中的同步代码不是一个套路.</p>
<p>为此, ES7 提供了更标准的解决方案 — async/await. async/await 几乎没有引入新的语法, 表面上看起来, 它就和alert一样易用,  虽然它尚处于ES7的草案中, 不过这并不影响我们提前使用它.</p>
<h5 id="async-await语法"><a href="#async-await语法" class="headerlink" title="async/await语法"></a>async/await语法</h5><p>async 用于声明一个异步函数, 该函数需返回一个 Promise 对象. 而 await 通常后接一个 Promise对象, 需等待该 Promise 对象的 resolve() 方法执行并且返回值后才能继续执行. (如果await后接的是其他对象, 便会立即执行)</p>
<p>因此, async/await 天生可用于处理 fetch请求(毫无违和感). 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> word = <span class="string">'123'</span>,</div><div class="line">    url = <span class="string">'https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd='</span>+word+<span class="string">'&amp;json=1&amp;p=3'</span>;</div><div class="line"><span class="function">(<span class="params"><span class="keyword">async</span> (</span>)=&gt;</span>&#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">let</span> res = <span class="keyword">await</span> fetch(url, &#123;<span class="attr">mode</span>: <span class="string">'no-cors'</span>&#125;);<span class="comment">//等待fetch被resolve()后才能继续执行</span></div><div class="line">    <span class="built_in">console</span>.log(res);</div><div class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</div><div class="line">    <span class="built_in">console</span>.log(e);</div><div class="line">  &#125;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>自然, async/await 也可处理 Promise 对象.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> wait = <span class="function"><span class="keyword">function</span>(<span class="params">ts</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">    setTimeout(resolve,ts,<span class="string">'Copy that!'</span>);</div><div class="line">  &#125;);</div><div class="line">&#125;;</div><div class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">let</span> res = <span class="keyword">await</span> wait(<span class="number">1000</span>);<span class="comment">//① 等待1s后返回结果</span></div><div class="line">    <span class="built_in">console</span>.log(res);</div><div class="line">    res = <span class="keyword">await</span> wait(<span class="number">1000</span>);<span class="comment">//② 重复执行一次</span></div><div class="line">    <span class="built_in">console</span>.log(res);</div><div class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</div><div class="line">    <span class="built_in">console</span>.log(e);</div><div class="line">  &#125;</div><div class="line">&#125;)();</div><div class="line"><span class="comment">//"Copy that!"</span></div></pre></td></tr></table></figure>
<p>可见使用await后, 可以直接得到返回值, 不必写 <code>.then(callback)</code> , 也不必写 <code>.catch(error)</code> 了, 更可以使用 <code>try catch</code> 标准语法捕获错误.</p>
<p>由于await采用的是同步的写法, 看起来它就和alert函数一样, 可以自动阻塞上下文. 因此它可以重复执行多次, 就像上述代码②一样.</p>
<p>可以看到, await/async 同步阻塞式的写法解决了完全使用 Promise 的一大痛点——不同Promise之间共享数据问题. Promise 需要设置上层变量从而实现数据共享, 而 await/async 就不存在这样的问题, 只需要像写alert一样书写就可以了.</p>
<p>值得注意的是, <strong>await 只能用于 async 声明的函数上下文中</strong>. 如下 forEach 中, 是不能直接使用await的.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> array = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line"><span class="function">(<span class="params"><span class="keyword">async</span> (</span>)=&gt;</span>&#123;</div><div class="line">  array.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</div><div class="line">    <span class="keyword">await</span> wait(<span class="number">1000</span>);<span class="comment">//这是错误的写法, 因await不在async声明的函数上下文中</span></div><div class="line">    <span class="built_in">console</span>.log(item);</div><div class="line">  &#125;);</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>如果是试图将async声明的函数作为回调传给forEach，该回调将同时触发多次，回调内部await依然有效，只是多次的await随着回调一起同步执行了，这便不符合我们阻塞循环的初衷。如下：</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">const <span class="function"><span class="keyword">fn</span> = <span class="title">async</span> <span class="params">(item)</span>=&gt;&#123;</span></div><div class="line">  await <span class="built_in">wait</span><span class="params">(<span class="number">1000</span>)</span>; <span class="comment">// 循环中的多个await同时执行，因此等待1s后将同时输出数组各个元素</span></div><div class="line">  console.<span class="built_in">log</span>(item);</div><div class="line">&#125;;</div><div class="line">array.forEach(<span class="function"><span class="keyword">fn</span>)</span>;</div></pre></td></tr></table></figure>
<p>正确的写法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(<span class="keyword">async</span> ()=&gt;&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>,len=array.length;i&lt;len;i++)&#123;</div><div class="line">    <span class="keyword">await</span> wait(<span class="number">1000</span>);</div><div class="line">    <span class="built_in">console</span>.log(array[i]);</div><div class="line">  &#125;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<h5 id="如何试运行async-await"><a href="#如何试运行async-await" class="headerlink" title="如何试运行async/await"></a>如何试运行async/await</h5><p>鉴于目前只有Edge支持 async/await, 我们可以使用以下方法之一运行我们的代码.</p>
<ol>
<li><p>随着node7.0的发布, node中可以使用如下方式直接运行:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">node --harmony-async-await test.js</div></pre></td></tr></table></figure>
</li>
<li><p>babel在线编译并运行 <a href="https://babeljs.io/repl/#?babili=false&amp;evaluate=true&amp;lineWrap=false&amp;presets=es2015%2Creact%2Cstage-2&amp;code=" target="_blank" rel="external">Babel · The compiler for writing next generation JavaScript</a> .</p>
</li>
<li><p>本地使用babel编译es6或更高版本es.</p>
<p>1) 安装.</p>
<p>由于Babel5默认自带各种转换插件, 不需要手动安装. 然而从Babel6开始, 插件需要手动下载, 因此以下安装babel后需要再顺便安装两个插件.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">npm i babel-cli -g	<span class="comment"># babel已更名为babel-cli</span></div><div class="line">npm install babel-preset-es2015 --save-dev</div><div class="line">npm install babel-preset-stage-0 --save-dev</div></pre></td></tr></table></figure>
<p>2) 书写.babelrc配置文件.</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"presets"</span>: [</div><div class="line">        <span class="string">"es2015"</span>,</div><div class="line">        <span class="string">"stage-0"</span></div><div class="line">    ],</div><div class="line">    <span class="attr">"plugins"</span>: []</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>3) 如果不配置.babelrc. 也可在命令行显式指定插件.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">babel es6.js -o es5.js --presets es2015 stage-0 <span class="comment"># 指定使用插件es2015和stage-0编译js</span></div></pre></td></tr></table></figure>
<p>4) 编译.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">babel es6.js -o es5.js  <span class="comment"># 编译源文件es6.js,输出为es5.js,编译规则在上述.babelrc中指定</span></div><div class="line">babel es6.js --out-file es5.js <span class="comment"># 或者将-o写全为--out-file也行</span></div><div class="line">bable es6.js <span class="comment"># 如果不指定输出文件路径,babel会将编译生成的文本标准输出到控制台</span></div></pre></td></tr></table></figure>
<p>5) 实时编译</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">babel es6.js -w -o es5.js <span class="comment"># 实时watch es6.js的变化,一旦改变就重新编译</span></div><div class="line">babel es6.js -watch -o es5.js <span class="comment"># -w也可写全为--watch</span></div></pre></td></tr></table></figure>
<p>6) 编译目录输出到其他目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">babel src <span class="_">-d</span> build <span class="comment"># 编译src目录下所有js,并输出到build目录</span></div><div class="line">babel src --out-dir build <span class="comment"># -d也可写全为--out-dir</span></div></pre></td></tr></table></figure>
<p>7) 编译目录输出到单个文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">babel src -o es5.js <span class="comment"># 编译src目录所有js,合并输出为es5.js</span></div></pre></td></tr></table></figure>
<p>8) 想要直接运行es6.js, 可使用babel-node.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">npm i babel-node -g <span class="comment"># 全局安装babel-node</span></div><div class="line">babel-node es6.js <span class="comment"># 直接运行js文件</span></div></pre></td></tr></table></figure>
<p>9) 如需在代码中使用fetch, 且使用babel-node运行, 需引入 <code>node-fetch</code> 模块.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i node-fetch --save-dev</div></pre></td></tr></table></figure>
<p>然后在es6.js中require <code>node-fetch</code> 模块.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fetch = <span class="built_in">require</span>(<span class="string">'node-fetch'</span>);</div></pre></td></tr></table></figure>
</li>
<li><p>本地使用traceur编译es6或更高版本es.请参考 <a href="http://www.codesec.net/view/450316.html" target="_blank" rel="external">在项目开发中优雅地使用ES6：Traceur &amp; Babel</a> .</p>
</li>
</ol>
<h3 id="如何弥补Fetch的不足"><a href="#如何弥补Fetch的不足" class="headerlink" title="如何弥补Fetch的不足"></a>如何弥补Fetch的不足</h3><p>fetch基于Promise, Promise受限, fetch也难幸免. ES6的Promise基于 <a href="https://promisesaplus.com/" target="_blank" rel="external">Promises/A+</a> 规范 (对规范感兴趣的同学可选读 <a href="http://www.cnblogs.com/fsjohnhuang/p/4135149.html" target="_blank" rel="external">剖析源码理解Promises/A规范</a> ), 它只提供极简的api, 没有 timeout 机制, 没有 progress 提示, 没有 deferred 处理 (这个可以被async/await替代).</p>
<h4 id="fetch-jsonp"><a href="#fetch-jsonp" class="headerlink" title="fetch-jsonp"></a>fetch-jsonp</h4><p>除此之外, fetch还不支持jsonp请求. 不过办法总比问题多, 万能的开源作者提供了 <a href="https://github.com/camsong/fetch-jsonp" target="_blank" rel="external"><code>fetch-jsonp</code></a> 库, 解决了这个问题. </p>
<p><code>fetch-jsonp</code> 使用起来非常简单. 如下是安装:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install fetch-jsonp --save-dev</div></pre></td></tr></table></figure>
<p>如下是使用:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">fetchJsonp(url, &#123;</div><div class="line">  <span class="attr">timeout</span>: <span class="number">3000</span>,</div><div class="line">  <span class="attr">jsonpCallback</span>: <span class="string">'callback'</span></div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(response.json());</div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(e)</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="abort"><a href="#abort" class="headerlink" title="abort"></a>abort</h4><p>由于Promise的限制, fetch 并不支持原生的abort机制, 但这并不妨碍我们使用 Promise.race() 实现一个.</p>
<blockquote>
<p>Promise.race(iterable) 方法返回一个Promise对象, 只要 iterable 中任意一个Promise 被 resolve 或者 reject 后, 外部的Promise 就会以相同的值被 resolve 或者 reject.</p>
</blockquote>
<p>支持性: 从 chrome33, Firefox29, Safari7.1, Opera20, EdgeHTML12(并非Edge版本) 起, Promise就被完整的支持. Promise.race()也随之可用. 下面我们来看下实现.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> _fetch = (<span class="function"><span class="keyword">function</span>(<span class="params">fetch</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">url,options</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> abort = <span class="literal">null</span>;</div><div class="line">    <span class="keyword">var</span> abort_promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</div><div class="line">      abort = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        reject(<span class="string">'abort.'</span>);</div><div class="line">        <span class="built_in">console</span>.info(<span class="string">'abort done.'</span>);</div><div class="line">      &#125;;</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">var</span> promise = <span class="built_in">Promise</span>.race([</div><div class="line">      fetch(url,options),</div><div class="line">      abort_promise</div><div class="line">    ]);</div><div class="line">    promise.abort = abort;</div><div class="line">    <span class="keyword">return</span> promise;</div><div class="line">  &#125;;</div><div class="line">&#125;)(fetch);</div></pre></td></tr></table></figure>
<p>然后, 使用如下方法测试新的fetch.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p = _fetch(<span class="string">'https://www.baidu.com'</span>,&#123;<span class="attr">mode</span>:<span class="string">'no-cors'</span>&#125;);</div><div class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'response:'</span>, res);</div><div class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'error:'</span>, e);</div><div class="line">&#125;);</div><div class="line">p.abort();</div><div class="line"><span class="comment">//"abort done."</span></div><div class="line"><span class="comment">//"error: abort."</span></div></pre></td></tr></table></figure>
<p>以上, fetch请求后, 立即调用abort方法, 该promise被拒绝, 符合预期. 细心的同学可能已经注意到了, “p.abort();” 该语句我是单独写一行的, 没有链式写在then方法之后. 为什么这么干呢? 这是因为then方法调用后, 返回的是新的promise对象. 该对象不具有abort方法, 因此使用时要注意绕开这个坑.</p>
<h4 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h4><p>同上, 由于Promise的限制, fetch 并不支持原生的timeout机制, 但这并不妨碍我们使用 Promise.race() 实现一个.</p>
<p>下面是一个简易的版本.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params">t</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span>setTimeout(resolve, t))</div><div class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'timeout'</span>);</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> p = fetch(<span class="string">'https://www.baidu.com'</span>,&#123;<span class="attr">mode</span>:<span class="string">'no-cors'</span>&#125;);</div><div class="line"><span class="built_in">Promise</span>.race([p, timer(<span class="number">1000</span>)]);</div><div class="line"><span class="comment">//"timeout"</span></div></pre></td></tr></table></figure>
<p>实际上, 无论超时时间设置为多长, 控制台都将输出log “timeout”. 这是因为, 即使fetch执行成功, 外部的promise执行完毕, 此时 setTimeout 所在的那个promise也不会reject.</p>
<p>下面我们来看一个类似xhr版本的timeout.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> _fetch = (<span class="function"><span class="keyword">function</span>(<span class="params">fetch</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">url,options</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> abort = <span class="literal">null</span>,</div><div class="line">        timeout = <span class="number">0</span>;</div><div class="line">    <span class="keyword">var</span> abort_promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</div><div class="line">      abort = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        reject(<span class="string">'timeout.'</span>);</div><div class="line">        <span class="built_in">console</span>.info(<span class="string">'abort done.'</span>);</div><div class="line">      &#125;;</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">var</span> promise = <span class="built_in">Promise</span>.race([</div><div class="line">      fetch(url,options),</div><div class="line">      abort_promise</div><div class="line">    ]);</div><div class="line">    promise.abort = abort;</div><div class="line">    <span class="built_in">Object</span>.defineProperty(promise, <span class="string">'timeout'</span>,&#123;</div><div class="line">      <span class="attr">set</span>: <span class="function"><span class="keyword">function</span>(<span class="params">ts</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span>((ts=+ts))&#123;</div><div class="line">          timeout = ts;</div><div class="line">          setTimeout(abort,ts);</div><div class="line">        &#125;</div><div class="line">      &#125;,</div><div class="line">      <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> timeout;</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> promise;</div><div class="line">  &#125;;</div><div class="line">&#125;)(fetch);</div></pre></td></tr></table></figure>
<p>然后, 使用如下方法测试新的fetch.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p = _fetch(<span class="string">'https://www.baidu.com'</span>,&#123;<span class="attr">mode</span>:<span class="string">'no-cors'</span>&#125;);</div><div class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'response:'</span>, res);</div><div class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'error:'</span>, e);</div><div class="line">&#125;);</div><div class="line">p.timeout = <span class="number">1</span>;</div><div class="line"><span class="comment">//"abort done."</span></div><div class="line"><span class="comment">//"error: timeout."</span></div></pre></td></tr></table></figure>
<h4 id="progress"><a href="#progress" class="headerlink" title="progress"></a>progress</h4><p>xhr的 onprogress 让我们可以掌控下载进度, fetch显然没有提供原生api 做类似的事情. 不过 Fetch中的<code>Response.body</code> 中实现了<code>getReader()</code>方法用于读取原始字节流, 该字节流可以循环读取, 直到body下载完成. 因此我们完全可以模拟fetch的progress.</p>
<p>以下是 stackoverflow 上的一段代码, 用于模拟fetch的progress事件. 为了方便测试, 请求url已改为本地服务.(原文请戳 <a href="http://stackoverflow.com/questions/35711724/progress-indicators-for-fetch" target="_blank" rel="external">javascript - Progress indicators for fetch? - Stack Overflow</a>)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">consume</span>(<span class="params">reader</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> total = <span class="number">0</span></div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">pump</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      reader.read().then(<span class="function">(<span class="params">&#123;done, value&#125;</span>) =&gt;</span> &#123;</div><div class="line">        <span class="keyword">if</span> (done) &#123;</div><div class="line">          resolve();</div><div class="line">          <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        total += value.byteLength;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">`received <span class="subst">$&#123;value.byteLength&#125;</span> bytes (<span class="subst">$&#123;total&#125;</span> bytes in total)`</span>);</div><div class="line">        pump();</div><div class="line">      &#125;).catch(reject)</div><div class="line">    &#125;</div><div class="line">    pump();</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line">fetch(<span class="string">'http://localhost:10101/notification/'</span>,&#123;<span class="attr">mode</span>:<span class="string">'no-cors'</span>&#125;)</div><div class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> consume(res.body.getReader()))</div><div class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"consumed the entire body without keeping the whole thing in memory!"</span>))</div><div class="line">  .catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"something went wrong: "</span> + e));</div></pre></td></tr></table></figure>
<p>以下是日志截图:</p>
<p><img src="http://louiszhai.github.io/docImages/ajax15.png" alt=""></p>
<p>刚好github上有个fetch progress的demo, 感兴趣的小伙伴请参看这里: <a href="https://labs.jxck.io/fetch/progress.html" target="_blank" rel="external">Fetch Progress DEMO</a> .</p>
<p>我们不妨来对比下, 使用xhr的onprogress事件回调, 输出如下:</p>
<p><img src="http://louiszhai.github.io/docImages/ajax16.png" alt=""></p>
<p>我试着适当增加响应body的size, 发现xhr的onprogress事件回调依然只执行两次. 通过多次测试发现其执行频率比较低, 远不及fetch progress.</p>
<hr>
<p>本问就讨论这么多内容,大家有什么问题或好的想法欢迎在下方参与<a href="#respond">留言和评论</a>.</p>
<p>本文作者: <a href="https://github.com/Louiszhai" target="_blank" rel="external">louis</a></p>
<p>本文链接: <a href="http://louiszhai.github.io/2016/10/19/fetch/">http://louiszhai.github.io/2016/10/19/fetch/</a></p>
<p>参考文章</p>
<ul>
<li><a href="https://fetch.spec.whatwg.org/#forbidden-header-name" target="_blank" rel="external">Fetch Standard</a></li>
<li><a href="https://segmentfault.com/a/1190000003810652" target="_blank" rel="external">传统 Ajax 已死，Fetch 永生</a></li>
<li><a href="https://cnodejs.org/topic/5640b80d3a6aa72c5e0030b6" target="_blank" rel="external">体验异步的终极解决方案-ES7的Async/Await</a></li>
<li><a href="https://tc39.github.io/ecma262/#sec-promise-constructor" target="_blank" rel="external">ES6-Promise</a></li>
<li><a href="http://www.tuicool.com/articles/QZBJ7zJ" target="_blank" rel="external">译-JavaScript Fetch API</a></li>
<li><a href="http://imweb.io/topic/57c6ea35808fd2fb204eef63" target="_blank" rel="external">让fetch也可以timeout</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      fetch async await mode promise progress abort
    
    </summary>
    
    
      <category term="javascript" scheme="http://louiszhai.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>全面解读Math对象及位运算</title>
    <link href="http://louiszhai.github.io/2016/07/01/Math/"/>
    <id>http://louiszhai.github.io/2016/07/01/Math/</id>
    <published>2016-06-30T23:57:48.000Z</published>
    <updated>2017-04-17T02:54:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>Math方法和位运算几乎是被忽略得最严重的知识点, 和正则一样, 不用不知道, 一用到处查. 为了告别这种低效的编程模式, 我特地总结此篇, 系统梳理了这两个知识点. 以此为册, 助你攻破它们.</p>
<h3 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h3><p>截至ES6, JavaScript 中内置(build-in)构造器/对象共有19个, 其中14个是构造器(Number,Boolean, String, Object, Function, Array, RegExp, Error, Date, Set, WeakSet, Map, Proxy, Promise), Global 不能直接访问, Arguments仅在函数调用时由JS引擎创建, 而 Math, JSON, Reflect 是以对象形式存在的, 本篇将带你走进 JS 内置对象-Math以及与之息息相关的位运算, 一探究竟.</p>
<a id="more"></a>
<h3 id="为什么Math这么设计"><a href="#为什么Math这么设计" class="headerlink" title="为什么Math这么设计"></a>为什么Math这么设计</h3><p>众所周知, 如果需要使用js进行一些常规的数学运算, 是一件十分麻烦的事情. 为了解决这个问题, ECMAScript 在1.1版本中便引入了 Math. Math 之所以被设计成一个对象, 而不是构造器, 是因为对象中的方法或属性可以作为静态方法或常量直接被调用, 方便使用, 同时, Math 也没有创建实例的必要.</p>
<h3 id="Math中的属性"><a href="#Math中的属性" class="headerlink" title="Math中的属性"></a>Math中的属性</h3><table>
<thead>
<tr>
<th style="text-align:center">属性名</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Math.E</td>
<td style="text-align:center">欧拉常数，也是自然对数的底数</td>
<td style="text-align:center">约2.718</td>
</tr>
<tr>
<td style="text-align:center">Math.LN2</td>
<td style="text-align:center">2的自然对数</td>
<td style="text-align:center">约0.693</td>
</tr>
<tr>
<td style="text-align:center">Math.LN10</td>
<td style="text-align:center">10的自然对数</td>
<td style="text-align:center">约2.303</td>
</tr>
<tr>
<td style="text-align:center">Math.LOG2E</td>
<td style="text-align:center">以2为底E的对数</td>
<td style="text-align:center">约1.443</td>
</tr>
<tr>
<td style="text-align:center">Math.LOG10E</td>
<td style="text-align:center">以10为底E的对数</td>
<td style="text-align:center">约0.434</td>
</tr>
<tr>
<td style="text-align:center">Math.PI</td>
<td style="text-align:center">圆周率</td>
<td style="text-align:center">约3.14</td>
</tr>
<tr>
<td style="text-align:center">Math.SQRT1_2</td>
<td style="text-align:center">1/2的平方根</td>
<td style="text-align:center">约0.707</td>
</tr>
<tr>
<td style="text-align:center">Math.SQRT2</td>
<td style="text-align:center">2的平方根</td>
<td style="text-align:center">约1.414</td>
</tr>
</tbody>
</table>
<h3 id="Math中的方法"><a href="#Math中的方法" class="headerlink" title="Math中的方法"></a>Math中的方法</h3><p>Math对象本就有很多用于运算的方法, 值得关注的是, ES6 规范又对Math对象做了一些扩展, 增加了一系列便捷的方法. 而这些方法大致可以分为以下三类.</p>
<h4 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h4><table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Math.sin(x)</td>
<td style="text-align:center">返回x的正弦值</td>
</tr>
<tr>
<td style="text-align:center">Math.sinh(x) ES6新增</td>
<td style="text-align:center">返回x的双曲正弦值</td>
</tr>
<tr>
<td style="text-align:center">Math.cos(x)</td>
<td style="text-align:center">返回x的余弦值</td>
</tr>
<tr>
<td style="text-align:center">Math.cosh(x) ES6新增</td>
<td style="text-align:center">返回x的双曲余弦值</td>
</tr>
<tr>
<td style="text-align:center">Math.tan(x)</td>
<td style="text-align:center">返回x的正切值</td>
</tr>
<tr>
<td style="text-align:center">Math.tanh(x) ES6新增</td>
<td style="text-align:center">返回x的双曲正切值</td>
</tr>
<tr>
<td style="text-align:center">Math.asin(x)</td>
<td style="text-align:center">返回x的反正弦值</td>
</tr>
<tr>
<td style="text-align:center">Math.asinh(x) ES6新增</td>
<td style="text-align:center">返回x的反双曲正弦值</td>
</tr>
<tr>
<td style="text-align:center">Math.acos(x)</td>
<td style="text-align:center">返回x的反余弦值</td>
</tr>
<tr>
<td style="text-align:center">Math.atan(x)</td>
<td style="text-align:center">返回x的反正切值</td>
</tr>
<tr>
<td style="text-align:center">Math.atan2(x, y)</td>
<td style="text-align:center">返回 y/x 的反正切值</td>
</tr>
<tr>
<td style="text-align:center">Math.atanh(x) ES6新增</td>
<td style="text-align:center">返回 x 的反双曲正切值</td>
</tr>
</tbody>
</table>
<h4 id="数学运算方法"><a href="#数学运算方法" class="headerlink" title="数学运算方法"></a>数学运算方法</h4><table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">例子</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Math.sqrt(x)</td>
<td style="text-align:center">返回x的平方根</td>
<td style="text-align:center">Math.sqrt(9);//3</td>
</tr>
<tr>
<td style="text-align:center">Math.exp(x)</td>
<td style="text-align:center">返回欧拉常数(e)的x次幂</td>
<td style="text-align:center">Math.exp(1);//约2.718</td>
</tr>
<tr>
<td style="text-align:center">Math.pow(x,y)</td>
<td style="text-align:center">返回x的y次幂, 如果y未初始化, 则返回x</td>
<td style="text-align:center">Math.pow(2, 3);//8</td>
</tr>
<tr>
<td style="text-align:center">Math.expm1(x) ES6新增</td>
<td style="text-align:center">返回欧拉常数(e)的x次幂减去1的值</td>
<td style="text-align:center">Math.exp(1);//约1.718</td>
</tr>
<tr>
<td style="text-align:center">Math.log(x)</td>
<td style="text-align:center">返回x的自然对数</td>
<td style="text-align:center">Math.log(1);//0</td>
</tr>
<tr>
<td style="text-align:center">Math.log1p(x) ES6新增</td>
<td style="text-align:center">返回x+1后的自然对数</td>
<td style="text-align:center">Math.log1p(0);//0</td>
</tr>
<tr>
<td style="text-align:center">Math.log2(x) ES6新增</td>
<td style="text-align:center">返回x以2为底的对数</td>
<td style="text-align:center">Math.log2(8);//3</td>
</tr>
<tr>
<td style="text-align:center">Math.log10(x) ES6新增</td>
<td style="text-align:center">返回x以10为底的对数</td>
<td style="text-align:center">Math.log10(100);//2</td>
</tr>
<tr>
<td style="text-align:center">Math.cbrt(x) ES6新增</td>
<td style="text-align:center">返回x的立方根</td>
<td style="text-align:center">Math.cbrt(8);//约2</td>
</tr>
<tr>
<td style="text-align:center">Math.clz32()  ES6新增</td>
<td style="text-align:center">返回一个数字在转换成 32位无符号整型数字的二进制形式后, 开头的 0 的个数</td>
<td style="text-align:center">Math.clz32(2);//30</td>
</tr>
<tr>
<td style="text-align:center">Math.hypot(x,y,z) ES6新增</td>
<td style="text-align:center">返回所有参数的平方和的平方根</td>
<td style="text-align:center">Math.hypot(3,4);//5</td>
</tr>
<tr>
<td style="text-align:center">Math.imul(x,y) ES6新增</td>
<td style="text-align:center">返回两个参数的类C的32位整数乘法运算的运算结果</td>
<td style="text-align:center">Math.imul(0xffffffff, 5);//-5</td>
</tr>
</tbody>
</table>
<h4 id="数值运算方法"><a href="#数值运算方法" class="headerlink" title="数值运算方法"></a>数值运算方法</h4><table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">例子</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Math.abs(x)</td>
<td style="text-align:center">返回x的绝对值</td>
<td style="text-align:center">Math.abs(-5);//5</td>
</tr>
<tr>
<td style="text-align:center">Math.floor(x)</td>
<td style="text-align:center">返回小于x的最大整数</td>
<td style="text-align:center">Math.floor(8.2);//8</td>
</tr>
<tr>
<td style="text-align:center">Math.ceil(x)</td>
<td style="text-align:center">返回大于x的最小整数</td>
<td style="text-align:center">Math.ceil(8.2);//9</td>
</tr>
<tr>
<td style="text-align:center">Math.trunc(x) ES6新增</td>
<td style="text-align:center">返回x的整数部分</td>
<td style="text-align:center">Math.trunc(1.23);//1</td>
</tr>
<tr>
<td style="text-align:center">Math.fround(x) ES6新增</td>
<td style="text-align:center">返回离它最近的<a href="https://en.wikipedia.org/wiki/Single-precision_floating-point_format" target="_blank" rel="external">单精度浮点数</a>形式的数字</td>
<td style="text-align:center">Math.fround(1.1);//1.100000023841858</td>
</tr>
<tr>
<td style="text-align:center">Math.min(x,y,z)</td>
<td style="text-align:center">返回多个数中的最小值</td>
<td style="text-align:center">Math.min(3,1,5);//1</td>
</tr>
<tr>
<td style="text-align:center">Math.max(x,y,z)</td>
<td style="text-align:center">返回多个数中的最大值</td>
<td style="text-align:center">Math.max(3,1,5);//5</td>
</tr>
<tr>
<td style="text-align:center">Math.round(x)</td>
<td style="text-align:center">返回四舍五入后的整数</td>
<td style="text-align:center">Math.round(8.2);//8</td>
</tr>
<tr>
<td style="text-align:center">Math.random()</td>
<td style="text-align:center">返回0到1之间的伪随机数</td>
<td style="text-align:center">Math.random();</td>
</tr>
<tr>
<td style="text-align:center">Math.sign(x) ES6新增</td>
<td style="text-align:center">返回一个数的符号( 5种返回值, 分别是 1, -1, 0, -0, NaN. 代表的各是正数, 负数, 正零, 负零, NaN)</td>
<td style="text-align:center">Math.sign(-5);//-1</td>
</tr>
</tbody>
</table>
<h4 id="附-Number类型的数值运算方法"><a href="#附-Number类型的数值运算方法" class="headerlink" title="附:Number类型的数值运算方法"></a>附:Number类型的数值运算方法</h4><p>Number.prototype中有一个方法叫做toFixed(), 用于将数值装换为指定小数位数的形式. </p>
<ul>
<li>没有参数或者参数为零的情况下, toFixed() 方法返回该数值的四舍五入后的整数形式, 等同于 Math.round(x);</li>
<li>其他情况下, 返回该数的指定小数位数的四舍五入后的结果.</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num = <span class="number">1234.56789</span>;</div><div class="line"><span class="built_in">console</span>.log(num.toFixed(),num.toFixed(<span class="number">0</span>));<span class="comment">//1235,1235</span></div><div class="line"><span class="built_in">console</span>.log(num.toFixed(<span class="number">1</span>));<span class="comment">//1234.6</span></div><div class="line"><span class="built_in">console</span>.log(<span class="number">-1.235</span>.toFixed(<span class="number">2</span>));<span class="comment">//-1.24</span></div></pre></td></tr></table></figure>
<h3 id="Math方法的一些规律"><a href="#Math方法的一些规律" class="headerlink" title="Math方法的一些规律"></a>Math方法的一些规律</h3><p>以上, 数值运算中, 存在如下规律:</p>
<ol>
<li>Math.trunc(x) 方法当 ① x为正数时, 运算结果同 Math.floor(x); ② x为负数时, 运算结果同 Math.ceil(x). 实际上, 它完全可以由位运算替代, 且运算速度更快, 如 2.5&amp;-1 或 2.5|0 或 ~~2.5 或 2.5^0 , 它们的运算结果都为2; 如 -2.5&amp;-1 或 -2.5|0 或 ~~-2.5 或 -2.5^0 , 它们的运算结果都为-2;</li>
<li>Math.min(x,y,z) 与 Math.max(x,y,z) 方法由于可接无限个参数, 可用于求数组元素的最小最大值. 如: <code>Math.max.apply(null,[5,3,8,9]); // 9</code> . 但是Math.min 不传参数返回 <code>Infinity</code>, Math.max 不传参数返回 <code>-Infinity</code> .</li>
<li>稍微利用 Math.random() 方法的特性, 就可以生成任意范围的数字. 如: 生成10到80之间的随机数, ~~(Math.random()*70 + 10);// 返回10~80之间的随机数, 包含10不包含80</li>
</ol>
<p>除去上述方法, Math作为对象, 继承了来之Object对象的方法. 其中一些如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Math</span>.valueOf();<span class="comment">//返回Math对象本身</span></div><div class="line">+<span class="built_in">Math</span>; <span class="comment">//NaN, 试图转换成数字,由于不能转换为数字,返回NaN</span></div><div class="line"><span class="built_in">Math</span>.toString();<span class="comment">//"[object Math]"</span></div></pre></td></tr></table></figure>
<h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p>Math对象提供的方法种类繁多, 且覆盖面非常全面, 基本上能够满足日常开发所需. 但同时我们也都知道, 使用Math对象的方法进行数值运算时, js代码经过解释编译, 最终会以二进制的方式进行运算. 这种运算方式效率较低, 那么能不能进一步提高运算的效率的呢? 如果我们使用位运算就可. 这是因为位运算本就是直接进行二进制运算.</p>
<h4 id="数值的二进制值"><a href="#数值的二进制值" class="headerlink" title="数值的二进制值"></a>数值的二进制值</h4><p>由于位运算是基于二进制的, 因此我们需要先获取数值的二进制值. 实际上, toString 方法已经帮我们做好了一部分工作, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//正整数可通过toString获取</span></div><div class="line"><span class="number">12.</span>.toString(<span class="number">2</span>);<span class="comment">//1100</span></div><div class="line"><span class="comment">//负整数问题就来了</span></div><div class="line">(<span class="number">-12</span>).toString(<span class="number">2</span>);<span class="comment">//-1100</span></div></pre></td></tr></table></figure>
<p>已知: 负数在计算机内部是采用补码表示的. 例如 -1, 1的原码是 0000 0001, 那么1的反码是 1111 1110, 补码是 1111 1111.</p>
<p>故: 负数的十进制转换为二进制时,符号位不变,其它位取反后+1. 即: <strong><code>-x的二进制 = x的二进制取反+1</code></strong> . 由按位取反可借助^运算符, 故负整数的二进制可以借助下面这个函数来获取:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBinary</span>(<span class="params">num</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> s = (-num).toString(<span class="number">2</span>),</div><div class="line">      array = [].map.call(s,<span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> v^<span class="number">1</span>;</div><div class="line">      &#125;);</div><div class="line">  array.reduceRight(<span class="function"><span class="keyword">function</span>(<span class="params">previousValue, value, index, array</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> v = previousValue ^ value;</div><div class="line">    array[index] = v;</div><div class="line">    <span class="keyword">return</span> +!v;</div><div class="line">  &#125;,<span class="number">1</span>);</div><div class="line">  <span class="keyword">return</span> array.join(<span class="string">''</span>);</div><div class="line">&#125;</div><div class="line">getBinary(<span class="number">-12</span>);<span class="comment">//0100, 前面未补全的部分全部为1</span></div></pre></td></tr></table></figure>
<p>然后, 多试几次就会发现:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">getBinary(<span class="number">-1</span>) == <span class="number">1.</span>.toString(<span class="number">2</span>); <span class="comment">//true</span></div><div class="line">getBinary(<span class="number">-2</span>) == <span class="number">2.</span>.toString(<span class="number">2</span>); <span class="comment">//true</span></div><div class="line">getBinary(<span class="number">-4</span>) == <span class="number">4.</span>.toString(<span class="number">2</span>); <span class="comment">//true</span></div><div class="line">getBinary(<span class="number">-8</span>) == <span class="number">8.</span>.toString(<span class="number">2</span>); <span class="comment">//true</span></div></pre></td></tr></table></figure>
<p>这表明:</p>
<ul>
<li><strong>2的整数次方的值与它的相对数, 他们后面真正有效的那几位都相同</strong>.</li>
</ul>
<p>同样, 负数的二进制转十进制时, 符号位不变, 其他位取反后+1. 可参考:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">translateBinary2Decimal</span>(<span class="params">binaryString</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> array = [].map.call(binaryString,<span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> v^<span class="number">1</span>;</div><div class="line">  &#125;);</div><div class="line">  array.reduceRight(<span class="function"><span class="keyword">function</span>(<span class="params">previousValue, value, index, array</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> v = previousValue ^ value;</div><div class="line">    array[index] = v;</div><div class="line">    <span class="keyword">return</span> +!v;</div><div class="line">  &#125;,<span class="number">1</span>);</div><div class="line">  <span class="keyword">return</span> <span class="built_in">parseInt</span>(array.join(<span class="string">''</span>),<span class="number">2</span>);</div><div class="line">&#125;</div><div class="line">translateBinary2Decimal(getBinary(<span class="number">-12</span>));<span class="comment">//12</span></div></pre></td></tr></table></figure>
<p>由上, 二进制转十进制和十进制转二进制的函数, 大部分都可以共用, 因此下面提供一个统一的函数解决它们的互转问题:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">translateBinary</span>(<span class="params">item</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> s = <span class="literal">null</span>,</div><div class="line">      array = <span class="literal">null</span>,</div><div class="line">      type = <span class="keyword">typeof</span> item,</div><div class="line">      symbol = !<span class="regexp">/^-/</span>.test(item+<span class="string">''</span>);</div><div class="line">  <span class="keyword">switch</span>(type)&#123;</div><div class="line">    <span class="keyword">case</span> <span class="string">"number"</span>: </div><div class="line">      s = <span class="built_in">Math</span>.abs(item).toString(<span class="number">2</span>);</div><div class="line">      <span class="keyword">if</span>(symbol)&#123;</div><div class="line">        <span class="keyword">return</span> s;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> <span class="string">"string"</span>:</div><div class="line">      <span class="keyword">if</span>(symbol)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">parseInt</span>(item,<span class="number">2</span>);</div><div class="line">      &#125;</div><div class="line">      s = item.substring(<span class="number">1</span>);</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//按位取反</span></div><div class="line">  array = [].map.call(s,<span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> v^<span class="number">1</span>;</div><div class="line">  &#125;);</div><div class="line">  <span class="comment">//+1</span></div><div class="line">  array.reduceRight(<span class="function"><span class="keyword">function</span>(<span class="params">previousValue, value, index, array</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> v = (previousValue + value)==<span class="number">2</span>;</div><div class="line">    array[index] = previousValue ^ value;</div><div class="line">    <span class="keyword">return</span> +v;</div><div class="line">  &#125;,<span class="number">1</span>);</div><div class="line">  s = array.join(<span class="string">''</span>);</div><div class="line">  <span class="keyword">return</span> type==<span class="string">"number"</span>?<span class="string">'-'</span>+s:-<span class="built_in">parseInt</span>(s,<span class="number">2</span>);</div><div class="line">&#125;</div><div class="line">translateBinary(<span class="number">-12</span>);<span class="comment">//"-0100"</span></div><div class="line">translateBinary(<span class="string">'-0100'</span>);<span class="comment">//-12</span></div></pre></td></tr></table></figure>
<h4 id="常用的二进制数"><a href="#常用的二进制数" class="headerlink" title="常用的二进制数"></a>常用的二进制数</h4><table>
<thead>
<tr>
<th style="text-align:center">二进制数</th>
<th style="text-align:center">二进制值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0xAAAAAAAA</td>
<td style="text-align:center">10101010101010101010101010101010</td>
</tr>
<tr>
<td style="text-align:center">0x55555555</td>
<td style="text-align:center">01010101010101010101010101010101</td>
</tr>
<tr>
<td style="text-align:center">0xCCCCCCCC</td>
<td style="text-align:center">11001100110011001100110011001100</td>
</tr>
<tr>
<td style="text-align:center">0x33333333</td>
<td style="text-align:center">00110011001100110011001100110011</td>
</tr>
<tr>
<td style="text-align:center">0xF0F0F0F0</td>
<td style="text-align:center">11110000111100001111000011110000</td>
</tr>
<tr>
<td style="text-align:center">0x0F0F0F0F</td>
<td style="text-align:center">00001111000011110000111100001111</td>
</tr>
<tr>
<td style="text-align:center">0xFF00FF00</td>
<td style="text-align:center">11111111000000001111111100000000</td>
</tr>
<tr>
<td style="text-align:center">0x00FF00FF</td>
<td style="text-align:center">00000000111111110000000011111111</td>
</tr>
<tr>
<td style="text-align:center">0xFFFF0000</td>
<td style="text-align:center">11111111111111110000000000000000</td>
</tr>
<tr>
<td style="text-align:center">0x0000FFFF</td>
<td style="text-align:center">00000000000000001111111111111111</td>
</tr>
</tbody>
</table>
<p>现在也可以使用上述方法来验证下常用的二进制值对不对. 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">translateBinary(<span class="number">0xAAAAAAAA</span>);<span class="comment">//"10101010101010101010101010101010"</span></div></pre></td></tr></table></figure>
<h4 id="按位与-amp"><a href="#按位与-amp" class="headerlink" title="按位与(&amp;)"></a>按位与(&amp;)</h4><p>&amp;运算符用于连接两个数, 连接的两个数它们二进制补码形式的值每位都将参与运算, 只有相对应的位上都为1时, 该位的运算才返回1. 比如 3 和 9 进行按位与运算, 以下是运算过程:</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="code">	0011	//3的二进制补码形式</span></div><div class="line"><span class="section">&amp;	1001	//9的二进制补码形式</span></div><div class="line">--------------------</div><div class="line"><span class="code">	0001	//1,相同位数依次运算,除最后一位都是1,返回1以外, 其它位数由于不同时为1都返回0</span></div></pre></td></tr></table></figure>
<p>由上, 3&amp;9的运算结果为1. 实际上, 由于按位与(&amp;)运算同位上返回1的要求较为严苛, 因此, 它是一种趋向减小最大值的运算.(无论最大值是正数还是负数, 参与按位与运算后, 该数总是趋向减少二进制值位上1的数量, 因此总是有值减小的趋势. ) 对于按位与(&amp;)运算, 满足如下规律:</p>
<ol>
<li><strong>数值与自身(或者-1)按位与运算返回数值自身</strong>.</li>
<li><strong>2的整数次方的值与它的相对数按位与运算返回它自身</strong>.</li>
<li><strong>任意整数与0进行按位与运算, 都将会返回0</strong>.</li>
<li><strong>任意整数与1进行按位与运算, 都只有0 或1 两个返回值</strong>.</li>
<li><strong>按位与运算的结果不大于两数中的最大值</strong>.</li>
</ol>
<p>由公式1, 我们可以对非整数取整. 即 <code>x&amp;x === x&amp;-1 === Math.trunc(x)</code> 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="number">5.2</span>&amp;<span class="number">5.2</span>);<span class="comment">//5</span></div><div class="line"><span class="built_in">console</span>.log(<span class="number">-5.2</span>&amp;<span class="number">-1</span>);<span class="comment">//-5</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.trunc(<span class="number">-5.2</span>)===(<span class="number">-5.2</span>&amp;<span class="number">-1</span>));<span class="comment">//true</span></div></pre></td></tr></table></figure>
<p>由公式4, 我们可以由此判断数值是否为奇数. 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(<span class="number">1</span> &amp; x)&#123;<span class="comment">//如果x为奇数,它的二进制补码形式最后一位必然是1,同1进行按位与运算后,将返回1,而1又会隐式转换为true</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"x为奇数"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="按位或"><a href="#按位或" class="headerlink" title="按位或(|)"></a>按位或(|)</h4><p>|不同于&amp;, |运算符连接的两个数, 只要其二进制补码形式的各位上有一个为1, 该位的运算就返回1, 否则返回0. 比如 3 和 12 进行按位或运算, 以下是运算过程:</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="code">	0011	//3的二进制补码形式</span></div><div class="line"><span class="section">|	1100	//12的二进制补码形式</span></div><div class="line">--------------------</div><div class="line"><span class="code">	1111	//15, 相同位数依次运算,遇1返回1,故最终结果为4个1.</span></div></pre></td></tr></table></figure>
<p>由上, 3|12的运算结果为15. 实际上, 由于按位与(&amp;)运算同位上返回0的要求较为严苛, 因此, 它是一种趋向增大最小值的运算. 对于按位或(|)运算, 满足如下规律: </p>
<ol>
<li><strong>数值与自身按位或运算返回数值自身</strong>.</li>
<li><strong>2的整数次方的值与它的相对数按位或运算返回它的相对数</strong>.</li>
<li><strong>任意整数与0进行按位或运算, 都将会返回它本身</strong>.</li>
<li><strong>任意整数与-1进行按位或运算, 都将返回-1</strong>.</li>
<li><strong>按位或运算的结果不小于两数中的最小值</strong>.</li>
</ol>
<p>稍微利用公式1, 我们便可以将非整数取整.   即 <strong><code>x|0 === Math.trunc(x)</code></strong> 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="number">5.2</span>|<span class="number">0</span>);<span class="comment">//5</span></div><div class="line"><span class="built_in">console</span>.log(<span class="number">-5.2</span>|<span class="number">0</span>);<span class="comment">//-5</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.trunc(<span class="number">-5.2</span>)===(<span class="number">-5.2</span>|<span class="number">0</span>));<span class="comment">//true</span></div></pre></td></tr></table></figure>
<p>为什么 5.2|0 运算后会返回5呢? 这是因为浮点数并不支持位运算, 运算前, 5.2会转换为整数5再和0进行位运算, 故, 最终返回5.</p>
<h4 id="按位非"><a href="#按位非" class="headerlink" title="按位非(~)"></a>按位非(~)</h4><p>~运算符, 返回数值二进制补码形式的反码. 什么意思呢, 就是说一个数值二进制补码形式中的每一位都将取反, 如果该位为1, 取反为0, 如果该位为0, 取反为1. 我们来举个例子理解下:</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">~	<span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0011</span>	<span class="comment">//3的32位二进制补码形式</span></div><div class="line">--------------------------------------------</div><div class="line">	<span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1100</span>	<span class="comment">//按位取反后为负数(最高位(第一位)表示正负,1代表负,0代表正)</span></div><div class="line">--------------------------------------------</div><div class="line">	<span class="number">1000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0011</span>	<span class="comment">//负数的二进制转换为十进制时,符号位不变,其它位取反(后+1)</span></div><div class="line">	<span class="number">1000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0100</span> <span class="comment">// +1</span></div><div class="line">--------------------------------------------</div><div class="line">                                      <span class="number">-4</span>	 <span class="comment">//最终运算结果为-4</span></div></pre></td></tr></table></figure>
<p>实际上, 按位非(~)操作不需要这么兴师动众地去计算, 它有且仅有一条运算规律:</p>
<ul>
<li><strong>按位非操作一个数值, 等同于这个数值加1然后符号改变. 即: <code>~x === -x-1</code></strong>.</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">~<span class="number">5</span> ==&gt; <span class="number">-5</span><span class="number">-1</span> === <span class="number">-6</span>;</div><div class="line">~<span class="number">-2016</span> ==&gt; <span class="number">2016</span><span class="number">-1</span> === <span class="number">2015</span>;</div></pre></td></tr></table></figure>
<p>由上述公式可推出: <strong><code>~~x === -(-x-1)-1 === x</code></strong>. 由于位运算摈除小数部分的特性, 连续两次按位非也可用于将非整数取整. 即, <strong><code>~~x === Math.trunc(x)</code></strong> 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(~~<span class="number">5.2</span>);<span class="comment">//5</span></div><div class="line"><span class="built_in">console</span>.log(~~<span class="number">-5.2</span>);<span class="comment">//-5</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.trunc(<span class="number">-5.2</span>)===(~~<span class="number">-5.2</span>));<span class="comment">//true</span></div></pre></td></tr></table></figure>
<p>按位非(~)运算符只能用来求数值的反码, 并且还不能输出反码的二进制字符串. 我们来稍微扩展下, 使它变得更易用.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">waveExtend</span>(<span class="params">item</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> s = <span class="keyword">typeof</span> item == <span class="string">'number'</span> &amp;&amp; translateBinary(~item);</div><div class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> s == <span class="string">'string'</span>?s:[].map.call(item,<span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> v===<span class="string">'-'</span>?v:v^<span class="number">1</span>;</div><div class="line">  &#125;).join(<span class="string">''</span>).replace(<span class="regexp">/^-?/</span>,<span class="function"><span class="keyword">function</span>(<span class="params">m</span>)</span>&#123;<span class="keyword">return</span> m==<span class="string">''</span>?<span class="string">'-'</span>:<span class="string">''</span>&#125;);</div><div class="line">&#125;</div><div class="line">waveExtend(<span class="number">-8</span>);<span class="comment">//111 -8反码,正数省略的位全部为0</span></div><div class="line">waveExtend(<span class="number">12</span>);<span class="comment">//-0011 12的反码,负数省略的位全部为1</span></div></pre></td></tr></table></figure>
<p>实际上, 按位非(~)运算符要求其运算数为整型, 如果运算数不是整型, 它将和其他位运算符一样尝试将其转换为32位整型, 如果无法转换, 就返回NaN. 那么~NaN等于多少呢?</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(~<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="number">20</span>);&#125;());<span class="comment">//先alert(20),然后输出-1</span></div></pre></td></tr></table></figure>
<p>以上语句意在打印一个自执行函数的按位非运算结果. 而该自执行函数又没有显式指定返回值, 默认将返回undefined. 因此它实际上是在输出~undefined的值. 而undefined值不能转换成整型, 通过测试, 运算结果为-1(即~NaN === -1). 我们不妨来看看下来测试, 以便加深理解.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(~<span class="string">'abc'</span>);<span class="comment">//-1</span></div><div class="line"><span class="built_in">console</span>.log(~[]);<span class="comment">//-1</span></div><div class="line"><span class="built_in">console</span>.log(~&#123;&#125;);<span class="comment">//-1</span></div><div class="line"><span class="built_in">console</span>.log(~<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;);<span class="comment">//-1</span></div><div class="line"><span class="built_in">console</span>.log(~<span class="regexp">/\d/</span>);<span class="comment">//-1</span></div><div class="line"><span class="built_in">console</span>.log(~<span class="literal">Infinity</span>);<span class="comment">//-1</span></div><div class="line"><span class="built_in">console</span>.log(~<span class="literal">null</span>);<span class="comment">//-1</span></div><div class="line"><span class="built_in">console</span>.log(~<span class="literal">undefined</span>);<span class="comment">//-1</span></div><div class="line"><span class="built_in">console</span>.log(~<span class="literal">NaN</span>);<span class="comment">//-1</span></div></pre></td></tr></table></figure>
<h4 id="按位异或"><a href="#按位异或" class="headerlink" title="按位异或(^)"></a>按位异或(^)</h4><p>^运算符连接的两个数, 它们二进制补码形式的值每位参与运算, 只有相对应的每位值不同, 才返回1, 否则返回0.<br>(相同则消去, 有些类似两两消失的消消乐). 如下:</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="code">	0011	//3的二进制补码形式</span></div><div class="line"><span class="section">^	1000	//8的二进制补码形式</span></div><div class="line">--------------------</div><div class="line"><span class="code">	1011	//11, 相同位数依次运算, 值不同的返回1</span></div></pre></td></tr></table></figure>
<p>对于按位异或(^)操作, 满足如下规律:</p>
<ol>
<li><strong>由于按位异或位运算的特殊性, 数值与自身按位异或运算返回0</strong>. 如: <code>8^8=0</code> , 公式为 <code>a^a=0</code> .</li>
<li><strong>任意整数与0进行按位异或运算, 都将会返回它本身</strong>. 如: <code>0^-98=-98</code> , 公式为 <code>0^a=a</code>.</li>
<li><strong>任意整数x与1(2的0次方)进行按位异或运算, 若它为奇数, 则返回 <code>x-1</code>, 若它为偶数, 则返回 <code>x+1</code> </strong>. 如: <code>1^-9=-10</code> , <code>1^100=101</code>  . 公式为 <code>1^奇=奇-1</code> , <code>1^偶=偶+1</code> ; 推而广之, <strong>任意整数x与2的n次方进行按位异或运算, 若它的二进制补码形式的倒数第n+1位是1, 则返回 <code>x-2的n次方</code>, 反之若为0, 则返回 <code>x+2的n次方</code> </strong>.</li>
<li><strong>任意整数x与-1(负2的1次方+1)进行按位异或运算, 则将返回 <code>-x-1</code>, 相当于~x运算 </strong>. 如: <code>-1^100=-101</code> , <code>-1^-9=8</code> . 公式为 <code>-1^x=-x-1=~x</code> .</li>
<li><strong>任意整数连续按位异或两次相同的数值, 返回它本身</strong>. 如: <code>3^8^8=3</code> , 公式为 <code>a^b^b=a</code> 或 <code>a^b^a=b</code> .</li>
<li><strong>按位异或满足操作数与运算结果3个数值之间的交换律: 按位异或的两个数值, 以及他们运算的结果, 共三个数值可以两两异或得到另外一个数值</strong> . 如: <code>3^9=10</code> , <code>3^10=9</code> , <code>9^10=3</code> ; 公式为 <code>a^b=c</code> , <code>a^c=b</code> , <code>b^c=a</code> .</li>
</ol>
<p>以上公式中, 1, 2, 3和4都是由按位异或运算特性推出的, 公式5可由公式1和2推出, 公式6可由公式5推出.</p>
<p>由于按位异或运算的这种可交换的性质, 我们可用它辅助交换两个整数的值. 如下, 假设这两个值为a和b:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a=<span class="number">1</span>,b=<span class="number">2</span>;</div><div class="line"><span class="comment">//常规方法</span></div><div class="line"><span class="keyword">var</span> tmp = a;</div><div class="line">a=b;</div><div class="line">b=tmp;</div><div class="line"><span class="built_in">console</span>.log(a,b);<span class="comment">//2 1</span></div><div class="line"></div><div class="line"><span class="comment">//使用按位异或~的方法</span></div><div class="line">a=a^b;	<span class="comment">//假设a,b的原始值分别为a0,b0</span></div><div class="line">b=a^b;	<span class="comment">//等价于 b=a0^b0^b0 ==&gt; b=a0</span></div><div class="line">a=a^b;	<span class="comment">//等价于 a=a0^b0^a0 ==&gt; a=b0</span></div><div class="line"><span class="built_in">console</span>.log(a,b);<span class="comment">//2 1</span></div><div class="line"><span class="comment">//以上可简写为</span></div><div class="line">a^=b;b^=a;a^=b;</div></pre></td></tr></table></figure>
<h4 id="位运算小结"><a href="#位运算小结" class="headerlink" title="位运算小结"></a>位运算小结</h4><p>由上可以看出:</p>
<ul>
<li>由于连接两个数值的位运算均是对相同的位进行比较操作, 故运算数值的先后位置并不重要, 这些位运算(&amp; | ^)满足交换律. 即: <code>a操作符b === b操作符a</code>.</li>
<li>位运算中, 数字0和1都比较特殊. 记住它们的规律, 常可简化运算.</li>
<li>位运算(&amp;|~^)可用于取整, 同 Math.trunc().</li>
</ul>
<h4 id="有符号左移-lt-lt"><a href="#有符号左移-lt-lt" class="headerlink" title="有符号左移(&lt;&lt;)"></a>有符号左移(&lt;&lt;)</h4><p>&lt;&lt;运算符, 表示将数值的32位二进制补码形式的除符号位之外的其他位都往左移动若干位数. 当x为整数时, 有: <code>x&lt;&lt;n === x*Math.pow(2,n)</code> 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="number">1</span>&lt;&lt;<span class="number">3</span>);<span class="comment">//8</span></div><div class="line"><span class="built_in">console</span>.log(<span class="number">100</span>&lt;&lt;<span class="number">4</span>);<span class="comment">//1600</span></div></pre></td></tr></table></figure>
<p>如此, Math.pow(2,n) 便可简写为 1&lt;&lt;n.</p>
<h5 id="运算符之一为NaN"><a href="#运算符之一为NaN" class="headerlink" title="运算符之一为NaN"></a>运算符之一为NaN</h5><p>对于表达式 <code>x&lt;&lt;n</code> , <strong>当运算数x无法被转换为整数时，运算结果为0.</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(&#123;&#125;&lt;&lt;<span class="number">3</span>);<span class="comment">//0</span></div><div class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span>&lt;&lt;<span class="number">2</span>);<span class="comment">//0</span></div></pre></td></tr></table></figure>
<p><strong>当运算数n无法被转换为整数时，运算结果为x.</strong> 相当于 <code>x&lt;&lt;0</code> .</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="number">2</span>&lt;&lt;<span class="literal">NaN</span>);<span class="comment">//2</span></div></pre></td></tr></table></figure>
<p><strong>当运算数x和n均无法被转换为整数时，运算结果为0.</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span>&lt;&lt;<span class="literal">NaN</span>);<span class="comment">//0</span></div></pre></td></tr></table></figure>
<h4 id="有符号右移-gt-gt"><a href="#有符号右移-gt-gt" class="headerlink" title="有符号右移(&gt;&gt;)"></a>有符号右移(&gt;&gt;)</h4><p>>&gt;运算符, 除了方向向右, 其他同&lt;&lt;运算符. 当x为整数时, 有: <code>x&gt;&gt;n === Math.floor(x*Math.pow(2,-n))</code> . 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="number">-5</span>&gt;&gt;<span class="number">2</span>);<span class="comment">//-2</span></div><div class="line"><span class="built_in">console</span>.log(<span class="number">-7</span>&gt;&gt;<span class="number">3</span>);<span class="comment">//-1</span></div></pre></td></tr></table></figure>
<p>右移负整数时, 返回值最大为-1.</p>
<p>右移正整数时, 返回值最小为0.</p>
<p>其他规律请参考 有符号左移时运算符之一为NaN的场景.</p>
<h4 id="无符号右移-gt-gt-gt"><a href="#无符号右移-gt-gt-gt" class="headerlink" title="无符号右移(&gt;&gt;&gt;)"></a>无符号右移(&gt;&gt;&gt;)</h4><p>>&gt;&gt;运算符, 表示连同符号也一起右移. </p>
<p>注意:无符号右移(&gt;&gt;&gt;)会把负数的二进制码当成正数的二进制码. 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="number">-8</span>&gt;&gt;&gt;<span class="number">5</span>);<span class="comment">//134217727</span></div><div class="line"><span class="built_in">console</span>.log(<span class="number">-1</span>&gt;&gt;&gt;<span class="number">0</span>);<span class="comment">//4294967295</span></div></pre></td></tr></table></figure>
<p>以上, 虽然-1没有发生向右位移, 但是-1的二进制码, 已经变成了正数的二进制码. 我们来回顾下这个过程.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">translateAry(<span class="number">-1</span>);<span class="comment">//-1,补全-1的二进制码至32位: 11111111111111111111111111111111</span></div><div class="line">translateAry(<span class="string">'11111111111111111111111111111111'</span>);<span class="comment">//4294967295</span></div></pre></td></tr></table></figure>
<p>可见, -1的二进制原码本就是32个1, 将这32个1当正数的二进制处理, 直接还原成十进制, 刚好就是 4294967295.</p>
<p>由此, 使用 &gt;&gt;&gt;运算符, 即使是右移0位, 对于负数而言也是翻天覆地的变化. 但是对于正数却没有改变. 利用这个特性, 可以判断数值的正负. 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSymbol</span>(<span class="params">num</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> num === (num&gt;&gt;&gt;<span class="number">0</span>)?<span class="string">"正数"</span>:<span class="string">"负数"</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(getSymbol(<span class="number">-100</span>), getSymbol(<span class="number">123</span>));<span class="comment">//负数 正数</span></div></pre></td></tr></table></figure>
<p>其他规律请参考 有符号左移时运算符之一为NaN的场景.</p>
<h4 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h4><p>使用运算符, 如果不知道它们的运算优先级. 就像驾驶法拉利却分不清楚油门和刹车一样恐怖. 因此我为您准备了常用运算符的运算优先级表. 请对号入座.</p>
<table>
<thead>
<tr>
<th style="text-align:center">优先级</th>
<th style="text-align:center">运算符</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">后置++ , 后置– , [] , () 或 .</td>
<td style="text-align:center">后置++,后置–,数组下标,括号 或 属性选择</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">- , 前置++ , 前置– , ! 或 ~</td>
<td style="text-align:center">负号,前置++,前置–, 逻辑非 或 按位非</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">* , / 或 %</td>
<td style="text-align:center">乘 , 除 或 取模</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">+ 或 -</td>
<td style="text-align:center">加 或 减</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">&lt;&lt; 或 &gt;&gt;</td>
<td style="text-align:center">左移 或 右移</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">> , &gt;= , &lt; 或 &lt;=</td>
<td style="text-align:center">大于, 大于等于, 小于 或 小于等于</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">== 或 !=</td>
<td style="text-align:center">等于 或 不等于</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">&amp;</td>
<td style="text-align:center">按位与</td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">^</td>
<td style="text-align:center">按位异或</td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">或</td>
<td style="text-align:center">按位或</td>
</tr>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:center">&amp;&amp;</td>
<td style="text-align:center">逻辑与</td>
</tr>
<tr>
<td style="text-align:center">12</td>
<td style="text-align:center">逻辑或</td>
<td style="text-align:center">逻辑或</td>
</tr>
<tr>
<td style="text-align:center">13</td>
<td style="text-align:center">?:</td>
<td style="text-align:center">条件运算符</td>
</tr>
<tr>
<td style="text-align:center">14</td>
<td style="text-align:center">=,/=,*=,%=,+=,-=,&lt;&lt;=,&gt;&gt;=,&amp;=,^=,按位或后赋值</td>
<td style="text-align:center">各种运算后赋值</td>
</tr>
<tr>
<td style="text-align:center">15</td>
<td style="text-align:center">,</td>
<td style="text-align:center">逗号</td>
</tr>
</tbody>
</table>
<p>可以看到, ① 除了按位非(~)以外, 其他的位运算符的优先级都是低于+-运算符的; ② 按位与(&amp;), 按位异或(^) 或 按位或(|) 的运算优先级均低于比较运算符(&gt;,&lt;,=等); ③位运算符中按位或(|)优先级最低.</p>
<h3 id="综合运用"><a href="#综合运用" class="headerlink" title="综合运用"></a>综合运用</h3><h4 id="计算绝对值"><a href="#计算绝对值" class="headerlink" title="计算绝对值"></a>计算绝对值</h4><p>使用有符号右移(&gt;&gt;)运算符, 以及按位异或(^)运算符, 我们可以实现一个 Math.abs方法. 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">abs</span>(<span class="params">num</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> x = num&gt;&gt;<span class="number">31</span>,	<span class="comment">//保留32二进制中的符号位,根据num的正负性分别返回0或-1</span></div><div class="line">      y = num^x;	<span class="comment">//返回正数,且利用按位异或中的公式2,若num为正数,num^0则返回num本身;若num为负数,则相当于num^-1,利用公式4, 此时返回-num-1</span></div><div class="line">  <span class="keyword">return</span> y-x;		<span class="comment">//若num为正数,则返回num-0即num;若num为负数则返回-num-1-(-1)即|num|</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="比较两数是否符号相同"><a href="#比较两数是否符号相同" class="headerlink" title="比较两数是否符号相同"></a>比较两数是否符号相同</h4><p>通常, 比较两个数是否符号相同, 我们使用x*y&gt;0 来判断即可. 但如果利用按位异或(^), 运算速度将更快.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="number">-17</span> ^ <span class="number">9</span> &gt; <span class="number">0</span>);<span class="comment">//false</span></div></pre></td></tr></table></figure>
<h4 id="对2的n次方取模-n为正整数"><a href="#对2的n次方取模-n为正整数" class="headerlink" title="对2的n次方取模(n为正整数)"></a>对2的n次方取模(n为正整数)</h4><p>比如 123%8, 实际上就是求一个余数, 并且这个余数还不大于8, 最大为7. 然后剩下的就是比较二进制值里, 123与7有几成相似了. 便不难推出公式: <code>x%(1&lt;&lt;n)==x&amp;(1&lt;&lt;n)-1</code> . </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="number">123</span>%<span class="number">8</span>);<span class="comment">//3</span></div><div class="line"><span class="built_in">console</span>.log(<span class="number">123</span>&amp;(<span class="number">1</span>&lt;&lt;<span class="number">3</span>)<span class="number">-1</span>);<span class="comment">//3 , 为什么-1时不用括号括起来, 这是因为-优先级高于&amp;</span></div></pre></td></tr></table></figure>
<h4 id="统计正数二进制值中1的个数"><a href="#统计正数二进制值中1的个数" class="headerlink" title="统计正数二进制值中1的个数"></a>统计正数二进制值中1的个数</h4><p>不妨先判断n的奇偶性, 为奇数时计数器增加1, 然后将n右移一位, 重复上面步骤, 直到递归退出.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTotalForOne</span>(<span class="params">n</span>)</span>&#123;</div><div class="line">  	<span class="keyword">return</span> n?(n&amp;<span class="number">1</span>)+<span class="built_in">arguments</span>.callee(n&gt;&gt;<span class="number">1</span>):<span class="number">0</span>;</div><div class="line">&#125;</div><div class="line">getTotalForOne(<span class="number">9</span>);<span class="comment">//2</span></div></pre></td></tr></table></figure>
<h4 id="实现加法运算"><a href="#实现加法运算" class="headerlink" title="实现加法运算"></a>实现加法运算</h4><p>加法运算, 从二进制值的角度看, 有 ①同位相加 和 ②遇2进1 两种运算(实际上, 十进制运算也是一样, 同位相加, 遇10进1). </p>
<p>首先我们看看第①种, 同位相加, 不考虑②遇2进1.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span> + <span class="number">1</span> = <span class="number">0</span></div><div class="line"><span class="number">1</span> + <span class="number">0</span> = <span class="number">1</span></div><div class="line"><span class="number">0</span> + <span class="number">1</span> = <span class="number">1</span></div><div class="line"><span class="number">0</span> + <span class="number">0</span> = <span class="number">0</span></div></pre></td></tr></table></figure>
<p>以上运算过程有没有很熟悉. 是不是和按位异或(^)运算有着惊人的相似. 如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span> ^ <span class="number">1</span> = <span class="number">0</span></div><div class="line"><span class="number">1</span> ^ <span class="number">0</span> = <span class="number">1</span></div><div class="line"><span class="number">0</span> ^ <span class="number">1</span> = <span class="number">1</span></div><div class="line"><span class="number">0</span> ^ <span class="number">0</span> = <span class="number">0</span></div></pre></td></tr></table></figure>
<p>因此①同位相加的运算, 完全可由按位异或(^)代替, 即: x^y.</p>
<p>那么②遇2进1 应该怎么实现呢? 实际上, 非位移位运算中, 只有按位与(&amp;)才能满足遇2的场景, 且只有有符号左移(&lt;&lt;)能满足进1的场景.</p>
<p>现在范围缩小了, 就看&amp;和&lt;&lt;运算符能不能真正满足需要了. 值得高兴的是, 按位与(&amp;)只有在同位都是1的情况下才返回1, 其他情况均返回0. 如果对其运算结果再做左移一位的运算, 即: (x&amp;y)&lt;&lt;1. 刚好满足了②遇2进1的场景.</p>
<p>因为我们是将①同位相加和②遇2进1的两种运算分开进行. 那么最终的加法运算结果应该还要做一次加法. 如下:</p>
<p>最终公式: <code>x + y = x^y + (x&amp;y)&lt;&lt;1</code> </p>
<p>这个公式并不完美, 因为它还是使用了加法, 推导公式怎么能直接使用推导结果呢? 太可怕了, 就不怕掉入递归深渊吗? 下面我们就来绕过这个坑. 而绕过这个坑有一个前提, 那就是只要 x^y 或 (x&amp;y)&lt;&lt;1中有一个值为0就行了, 这样便不用进行加法运算了. 讲了这么多, 不如看代码.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> _x = x^y,</div><div class="line">      _y = (x&amp;y)&lt;&lt;<span class="number">1</span>;</div><div class="line">  <span class="keyword">return</span> !_x &amp;&amp; _y || !_y &amp;&amp; _x || <span class="built_in">arguments</span>.callee(_x,_y);</div><div class="line">&#125;</div><div class="line">add(<span class="number">12345678</span>,<span class="number">87654321</span>);<span class="comment">//999999999</span></div><div class="line">add(<span class="number">9527</span>,<span class="number">-12</span>);<span class="comment">//9515</span></div></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>最后补充一点: 位运算一般只适用 [-2^31, 2^31-1] (即 -2147483648~2147483647) 以内的正负数. 超过这个范围, 计算将可能出现错误. 如下: </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="number">1</span>&lt;&lt;<span class="number">31</span>);<span class="comment">//-2147483648</span></div></pre></td></tr></table></figure>
<p>由于数值(2^31)超过了31位(加上保留的一个符号位,共32位), 故计算出错, 于是按照负数的方式解释二进制的值了.说好的不改变符号呢!!!</p>
<p>本文啰嗦几千字, 就为了说清楚两个事儿. ① Math对象中, 比较常用的就是数值运算方法, 不妨多看看, 其他的知道有这个api就行了. ② 位运算中, 则需要基本了解每种位运算符的运算方式, 如果能注意运算中 0和1等特殊数值 的一些妙用就更好了. 无论如何, 本文不可能面面俱到. 如果您对负数的位运算不甚理解, 建议去补下计算机的补码. 希望能对您有所帮助.</p>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><ol>
<li><code>相反数</code> : 只有符号不同的两个数, 我们就说其中一个是另一个的相反数.</li>
<li><code>补码</code>: 在计算机系统中, 数值一律用补码来表示和存储, 且正数的原码和补码相同, 负数的补码等于其原码按位取反再加1.</li>
</ol>
<hr>
<p>本问就讨论这么多内容, 如果您有什么问题或好的想法欢迎在下方参与<a href="#respond">留言和评论</a>.</p>
<p>本文作者: <a href="https://github.com/Louiszhai" target="_blank" rel="external">louis</a></p>
<p>本文链接: <a href="http://louiszhai.github.io/2016/07/01/Math/">http://louiszhai.github.io/2016/07/01/Math/</a></p>
<p>参考文章</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math" target="_blank" rel="external">Math - JavaScript | MDN</a></li>
<li><a href="http://www.cnblogs.com/xljzlw/p/4231354.html?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">js中位运算的运用 - 那时候的我 - 博客园</a></li>
<li><a href="http://blog.csdn.net/yunyu5120/article/details/6692072" target="_blank" rel="external">编程技巧–位运算的巧妙运用</a></li>
<li><a href="http://www.jb51.net/article/32130.htm" target="_blank" rel="external">c语言中用位运算实现加法技巧介绍_C 语言_脚本之家</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      Math floor ~ ~ abs random ceil 位运算 &amp; | ^ &lt;&lt; &gt;&gt; &gt;&gt;&gt; 按位与 按位或 按位非 按位异或 有符号左移 有符号右移 无符号右移
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://louiszhai.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式前端使用手册</title>
    <link href="http://louiszhai.github.io/2016/06/13/regexp/"/>
    <id>http://louiszhai.github.io/2016/06/13/regexp/</id>
    <published>2016-06-13T00:24:55.000Z</published>
    <updated>2017-04-17T02:54:08.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h3><p>你有没有在搜索文本的时候绞尽脑汁, 试了一个又一个表达式, 还是不行.</p>
<p>你有没有在表单验证的时候, 只是做做样子(只要不为空就好), 然后烧香拜佛, 虔诚祈祷, 千万不要出错.</p>
<p>你有没有在使用sed 和 grep 命令的时候, 感觉莫名其妙, 明明应该支持的元字符, 却就是匹配不到.</p>
<p>甚至, 你压根没遇到过上述情况, 你只是一遍又一遍的调用 replace 而已 (把非搜索文本全部替换为空, 然后就只剩搜索文本了), 面对别人家的简洁高效的语句, 你只能在心中呐喊, replace 大法好.</p>
<p>为什么要学正则表达式. 有位网友这么说: 江湖传说里, 程序员的正则表达式和医生的处方, 道士的鬼符齐名, 曰: 普通人看不懂的三件神器. 这个传说至少向我们透露了两点信息: 一是正则表达式很牛, 能和医生的处方, 道士的鬼符齐名, 并被大家提起, 可见其江湖地位. 二是正则表达式很难, 这也从侧面说明了, 如果你可以熟练的掌握并应用它, 在装逼的路上, 你将如日中天 (别问我中天是谁……) !</p>
<a id="more"></a>
<p>显然, 有关正则表达的介绍, 无须我多言. 这里就借助 Jeffrey Friedl 的《精通正则表达式》一书的序言正式抛个砖.</p>
<blockquote>
<p>​    “如果罗列计算机软件领域的伟大发明, 我相信绝对不会超过二十项, 在这个名单当中, 当然应该包括分组交换网络, Web, Lisp, 哈希算法, UNIX, 编译技术, 关系模型, 面向对象, XML这些大名鼎鼎的家伙, 而正则表达式也绝对不应该被漏掉. </p>
<p>​     对很多实际工作而言, 正则表达式简直是灵丹妙药, 能够成百倍的提高开发效率和程序质量, 正则表达式在生物信息学和人类基因图谱的研究中所发挥的关键作用, 更是被传为佳话. CSDN的创始人蒋涛先生在早年开发专业软件产品时, 就曾经体验过这一工具的巨大威力, 并且一直印象深刻.”</p>
</blockquote>
<p>因此, 我们没有理由不去了解正则表达式, 甚至是熟练掌握并运用它.</p>
<p>本文以正则基础语法开篇, 结合具体实例, 逐步讲解正则表达式匹配原理. 代码实例使用语言包括 js, php, python, java(因有些匹配模式, js并未支持, 需要借助其他语言讲解). 内容包括初阶技能和高阶技能, 适合新手学习和进阶. 本文力求简单通俗易懂, 同时为求全面, 涉及知识较多, 共计12k字, 篇幅较长, 请耐心阅读, 如有阅读障碍请及时<a href="#respond">联系我</a>.</p>
<h3 id="回顾历史"><a href="#回顾历史" class="headerlink" title="回顾历史"></a>回顾历史</h3><p>要论正则表达式的渊源, 最早可以追溯至对人类神经系统如何工作的早期研究. Warren McCulloch 和 Walter Pitts 这两位神经大咖 (神经生理学家) 研究出一种数学方式来描述这些神经网络.</p>
<p>1956 年, 一位叫 Stephen Kleene 的数学家在 McCulloch 和 Pitts 早期工作的基础上, 发表了一篇标题为”神经网事件的表示法”的论文, 引入了正则表达式的概念.</p>
<p>随后, 发现可以将这一工作应用于使用 Ken Thompson 的计算搜索算法的一些早期研究中. 而 Ken Thompson 又是 Unix 的主要发明人. 因此半个世纪以前的Unix 中的 qed 编辑器(1966 qed编辑器问世) 成了第一个使用正则表达式的应用程序.</p>
<p>至此之后, 正则表达式成为家喻户晓的文本处理工具, 几乎各大编程语言都以支持正则表达式作为卖点, 当然 JavaScript 也不例外.</p>
<h3 id="正则表达式的定义"><a href="#正则表达式的定义" class="headerlink" title="正则表达式的定义"></a>正则表达式的定义</h3><p>正则表达式是由普通字符和特殊字符(也叫元字符或限定符)组成的文字模板. 如下便是简单的匹配连续数字的正则表达式:</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="regexp">/[0-9]+/</span></div><div class="line"><span class="regexp">/\d+/</span></div></pre></td></tr></table></figure>
<p>“\d” 就是元字符, 而 “+” 则是限定符.</p>
<h4 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h4><table>
<thead>
<tr>
<th style="text-align:center">元字符</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">.</td>
<td style="text-align:center">匹配除换行符以外的任意字符</td>
</tr>
<tr>
<td style="text-align:center">\d</td>
<td style="text-align:center">匹配数字, 等价于字符组[0-9]</td>
</tr>
<tr>
<td style="text-align:center">\w</td>
<td style="text-align:center">匹配字母, 数字, 下划线或汉字</td>
</tr>
<tr>
<td style="text-align:center">\s</td>
<td style="text-align:center">匹配任意的空白符(包括制表符,空格,换行等)</td>
</tr>
<tr>
<td style="text-align:center">\b</td>
<td style="text-align:center">匹配单词开始或结束的位置</td>
</tr>
<tr>
<td style="text-align:center">^</td>
<td style="text-align:center">匹配行首</td>
</tr>
<tr>
<td style="text-align:center">$</td>
<td style="text-align:center">匹配行尾</td>
</tr>
</tbody>
</table>
<h4 id="反义元字符"><a href="#反义元字符" class="headerlink" title="反义元字符"></a>反义元字符</h4><table>
<thead>
<tr>
<th style="text-align:center">元字符</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">\D</td>
<td style="text-align:center">匹配非数字的任意字符, 等价于[^0-9]</td>
</tr>
<tr>
<td style="text-align:center">\W</td>
<td style="text-align:center">匹配除字母,数字,下划线或汉字之外的任意字符</td>
</tr>
<tr>
<td style="text-align:center">\S</td>
<td style="text-align:center">匹配非空白的任意字符</td>
</tr>
<tr>
<td style="text-align:center">\B</td>
<td style="text-align:center">匹配非单词开始或结束的位置</td>
</tr>
<tr>
<td style="text-align:center">[^x]</td>
<td style="text-align:center">匹配除x以外的任意字符</td>
</tr>
</tbody>
</table>
<p>可以看出正则表达式严格区分大小写.</p>
<h4 id="重复限定符"><a href="#重复限定符" class="headerlink" title="重复限定符"></a>重复限定符</h4><p>限定符共有6个, 假设重复次数为x次, 那么将有如下规则:</p>
<table>
<thead>
<tr>
<th style="text-align:center">限定符</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">*</td>
<td style="text-align:center">x&gt;=0</td>
</tr>
<tr>
<td style="text-align:center">+</td>
<td style="text-align:center">x&gt;=1</td>
</tr>
<tr>
<td style="text-align:center">?</td>
<td style="text-align:center">x=0 or x=1</td>
</tr>
<tr>
<td style="text-align:center">{n}</td>
<td style="text-align:center">x=n</td>
</tr>
<tr>
<td style="text-align:center">{n,}</td>
<td style="text-align:center">x&gt;=n</td>
</tr>
<tr>
<td style="text-align:center">{n,m}</td>
<td style="text-align:center">n&lt;=x&lt;=m</td>
</tr>
</tbody>
</table>
<h4 id="字符组"><a href="#字符组" class="headerlink" title="字符组"></a>字符组</h4><p>[…] 匹配中括号内字符之一. 如: [xyz]  匹配字符 x, y 或 z. 如果中括号中包含元字符, 则元字符降级为普通字符, 不再具有元字符的功能, 如 [+.?] 匹配 加号, 点号或问号.</p>
<h4 id="排除性字符组"><a href="#排除性字符组" class="headerlink" title="排除性字符组"></a>排除性字符组</h4><p>[^…] 匹配任何未列出的字符,. 如:  [^x]  匹配除x以外的任意字符.</p>
<h4 id="多选结构"><a href="#多选结构" class="headerlink" title="多选结构"></a>多选结构</h4><p>| 就是或的意思, 表示两者中的一个. 如: a|b 匹配a或者b字符.</p>
<h4 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h4><p>括号 常用来界定重复限定符的范围, 以及将字符<strong>分组</strong>. 如: (ab)+ 可以匹配abab..等, 其中 ab 便是一个分组.</p>
<h4 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h4><p>\ 即转义字符, 通常 <strong>\ * + ? | { [ ( ) ] }^ $ . # 和 空白</strong> 这些字符都需要转义.</p>
<h4 id="操作符的运算优先级"><a href="#操作符的运算优先级" class="headerlink" title="操作符的运算优先级"></a>操作符的运算优先级</h4><ol>
<li>\ 转义符</li>
<li>(), (?:), (?=), [] 圆括号或方括号</li>
<li>*, +, ?, {n}, {n,}, {n,m} 限定符</li>
<li>^, $ 位置</li>
<li>| “或” 操作</li>
</ol>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>我们来测试下上面的知识点, 写一个匹配手机号码的正则表达式, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(\+<span class="number">86</span>)?<span class="number">1</span>\d&#123;<span class="number">10</span>&#125;</div></pre></td></tr></table></figure>
<p>① “\+86” 匹配文本 “+86”, 后面接元字符问号, 表示可匹配1次或0次, 合起来表示 “(\+86)?” 匹配 “+86” 或者 “”.</p>
<p>② 普通字符”1” 匹配文本 “1”.</p>
<p>③ 元字符 “\d” 匹配数字0到9, 区间量词 “{10}” 表示匹配 10 次, 合起来表示 “\d{10}” 匹配连续的10个数字.</p>
<p>以上, 匹配结果如下:</p>
<p><img src="http://louiszhai.github.io/docImages/regexp01.png" alt=""></p>
<h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p>javaScript中正则表达式默认有如下五种修饰符:</p>
<ul>
<li>g (全文查找), 如上述截图, 实际上就开启了全文查找模式.</li>
<li>i (忽略大小写查找)</li>
<li>m (多行查找)</li>
<li>y (ES6新增的粘连修饰符)</li>
<li>u (ES6新增)</li>
</ul>
<h3 id="常用的正则表达式"><a href="#常用的正则表达式" class="headerlink" title="常用的正则表达式"></a>常用的正则表达式</h3><ol>
<li>汉字: ^[\u4e00-\u9fa5]{0,}$</li>
<li>Email: ^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$</li>
<li>URL: ^https?://([\w-]+.)+[\w-]+(/[\w-./?%&amp;=]*)?$</li>
<li>手机号码: ^1\d{10}$</li>
<li>身份证号: ^(\d{15}|\d{17}(\d|X))$</li>
<li>中国邮政编码: [1-9]\d{5}(?!\d) (邮政编码为6位数字)</li>
</ol>
<h4 id="密码验证"><a href="#密码验证" class="headerlink" title="密码验证"></a>密码验证</h4><p>密码验证是常见的需求, 一般来说, 常规密码大致会满足规律: 6-16位, 数字, 字母, 字符至少包含两种, 同时不能包含中文和空格. 如下便是常规密码验证的正则描述:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> reg = <span class="regexp">/(?!^[0-9]+$)(?!^[A-z]+$)(?!^[^A-z0-9]+$)^[^\s\u4e00-\u9fa5]&#123;6,16&#125;$/</span>;</div></pre></td></tr></table></figure>
<h3 id="正则的几大家族"><a href="#正则的几大家族" class="headerlink" title="正则的几大家族"></a>正则的几大家族</h3><h4 id="正则表达式分类"><a href="#正则表达式分类" class="headerlink" title="正则表达式分类"></a>正则表达式分类</h4><p>在 linux 和 osx 下, 常见的正则表达式, 至少有以下三种: </p>
<ul>
<li>基本的正则表达式( Basic Regular Expression 又叫 Basic RegEx  简称 <strong>BREs</strong> )</li>
<li>扩展的正则表达式( Extended Regular Expression 又叫 Extended RegEx 简称 <strong>EREs</strong> )</li>
<li>Perl 的正则表达式( Perl Regular Expression 又叫 Perl RegEx 简称 <strong>PREs</strong> )</li>
</ul>
<h4 id="正则表达式比较"><a href="#正则表达式比较" class="headerlink" title="正则表达式比较"></a>正则表达式比较</h4><table>
<thead>
<tr>
<th>字符</th>
<th>说明</th>
<th>Basic RegEx</th>
<th>Extended RegEx</th>
<th>python RegEx</th>
<th>Perl regEx</th>
</tr>
</thead>
<tbody>
<tr>
<td>转义</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>^</td>
<td>匹配行首，例如’^dog’匹配以字符串dog开头的行（注意：awk 指令中，’^’则是匹配字符串的开始）</td>
<td>^</td>
<td>^</td>
<td>^</td>
<td>^</td>
</tr>
<tr>
<td>$</td>
<td>匹配行尾，例如：’^、dog\$’ 匹配以字符串 dog 为结尾的行（注意：awk 指令中，’$’则是匹配字符串的结尾）</td>
<td>$</td>
<td>$</td>
<td>$</td>
<td>$</td>
</tr>
<tr>
<td>^$</td>
<td>匹配空行</td>
<td>^$</td>
<td>^$</td>
<td>^$</td>
<td>^$</td>
</tr>
<tr>
<td>^string$</td>
<td>匹配行，例如：’^dog$’匹配只含一个字符串 dog 的行</td>
<td>^string$</td>
<td>^string$</td>
<td>^string$</td>
<td>^string$</td>
</tr>
<tr>
<td>\&lt;</td>
<td>匹配单词，例如：’\&lt;frog’ （等价于’\bfrog’），匹配以 frog 开头的单词</td>
<td>\&lt;</td>
<td>\&lt;</td>
<td><strong>不支持</strong></td>
<td><strong>不支持</strong>（但可以使用\b来匹配单词，例如：’\bfrog’）</td>
</tr>
<tr>
<td>></td>
<td>匹配单词，例如：’frog>‘（等价于’frog\b ‘），匹配以 frog 结尾的单词</td>
<td>></td>
<td>></td>
<td><strong>不支持</strong></td>
<td><strong>不支持</strong>（但可以使用\b来匹配单词，例如：’frog\b’）</td>
</tr>
<tr>
<td>\<x></x></td>
<td>匹配一个单词或者一个特定字符，例如：’\<frog\>‘（等价于’\bfrog\b’）、’\<g\>‘</g\></frog\></td>
<td>\<x></x></td>
<td>\<x></x></td>
<td><strong>不支持</strong></td>
<td><strong>不支持</strong>（但可以使用\b来匹配单词，例如：’\bfrog\b’</td>
</tr>
<tr>
<td>()</td>
<td>匹配表达式，例如：不支持’（frog）’</td>
<td><strong>不支持</strong>（但可以使用，如：dog</td>
<td>()</td>
<td>()</td>
<td>()</td>
</tr>
<tr>
<td></td>
<td>匹配表达式，例如：不支持’（frog）’</td>
<td></td>
<td><strong>不支持</strong>（同())</td>
<td><strong>不支持</strong>（同())</td>
<td><strong>不支持</strong>（同())</td>
</tr>
<tr>
<td>？</td>
<td>匹配前面的子表达式 0 次或 1 次（等价于{0,1}），例如：where(is)?能匹配”where” 以及”whereis”</td>
<td><strong>不支持</strong>（同\?)</td>
<td>？</td>
<td>？</td>
<td>？</td>
</tr>
<tr>
<td>\?</td>
<td>匹配前面的子表达式 0 次或 1 次（等价于’{0,1}‘），例如：’whereis\? ‘能匹配 “where”以及”whereis”</td>
<td>\?</td>
<td><strong>不支持</strong>（同?)</td>
<td><strong>不支持</strong>（同?)</td>
<td><strong>不支持</strong>（同?)</td>
</tr>
<tr>
<td>?</td>
<td>当该字符紧跟在任何一个其他限制符（*, +, ?, {n},{n,}, {n,m}） 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，’o+?’ 将匹配单个”o”，而 ‘o+’ 将匹配所有 ‘o’</td>
<td><strong>不支持</strong></td>
<td><strong>不支持</strong></td>
<td><strong>不支持</strong></td>
<td><strong>不支持</strong></td>
</tr>
<tr>
<td>.</td>
<td>匹配除换行符（’\n’）之外的任意单个字符（注意：awk 指令中的句点能匹配换行符）</td>
<td>.</td>
<td>.（如果要匹配包括“\n”在内的任何一个字符，请使用: [\s\S]</td>
<td>.</td>
<td>.（如果要匹配包括“\n”在内的任何一个字符，请使用：’ [.\n] ‘</td>
</tr>
<tr>
<td>*</td>
<td>匹配前面的子表达式 0 次或多次（等价于{0, }），例如：zo* 能匹配 “z”以及 “zoo”</td>
<td>*</td>
<td>*</td>
<td>*</td>
<td>*</td>
</tr>
<tr>
<td>+</td>
<td>匹配前面的子表达式 1 次或多次（等价于’{1, }‘），例如：’whereis+ ‘能匹配 “whereis”以及”whereisis”</td>
<td>+</td>
<td><strong>不支持</strong>（同+)</td>
<td><strong>不支持</strong>（同+)</td>
<td><strong>不支持</strong>（同+)</td>
</tr>
<tr>
<td>+</td>
<td>匹配前面的子表达式 1 次或多次（等价于{1, }），例如：zo+能匹配 “zo”以及 “zoo”，但不能匹配 “z”</td>
<td><strong>不支持</strong>（同\+)</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td>{n}</td>
<td>n 必须是一个 0 或者正整数，匹配子表达式 n 次，例如：zo{2}能匹配</td>
<td><strong>不支持</strong>（同\{n\})</td>
<td>{n}</td>
<td>{n}</td>
<td>{n}</td>
</tr>
<tr>
<td>{n,}</td>
<td>“zooz”，但不能匹配 “Bob”n 必须是一个 0 或者正整数，匹配子表达式大于等于 n次，例如：go{2,}</td>
<td><strong>不支持</strong>（同\{n,\})</td>
<td>{n,}</td>
<td>{n,}</td>
<td>{n,}</td>
</tr>
<tr>
<td>{n,m}</td>
<td>能匹配 “good”，但不能匹配 godm 和 n 均为非负整数，其中 n &lt;= m，最少匹配 n 次且最多匹配 m 次 ，例如：o{1,3}将配”fooooood” 中的前三个 o（请注意在逗号和两个数之间不能有空格）</td>
<td><strong>不支持</strong>（同\{n,m\})</td>
<td>{n,m}</td>
<td>{n,m}</td>
<td>{n,m}</td>
</tr>
<tr>
<td>x l y</td>
<td>匹配 x 或 y</td>
<td><strong>不支持</strong>（同x \l y</td>
<td>x l y</td>
<td>x l y</td>
<td>x l y</td>
</tr>
<tr>
<td>[0-9]</td>
<td>匹配从 0 到 9 中的任意一个数字字符（注意：要写成递增）</td>
<td>[0-9]</td>
<td>[0-9]</td>
<td>[0-9]</td>
<td>[0-9]</td>
</tr>
<tr>
<td>[xyz]</td>
<td>字符集合，匹配所包含的任意一个字符，例如：’[abc]’可以匹配”lay” 中的 ‘a’（注意：如果元字符，例如：. *等，它们被放在[ ]中，那么它们将变成一个普通字符）</td>
<td>[xyz]</td>
<td>[xyz]</td>
<td>[xyz]</td>
<td>[xyz]</td>
</tr>
<tr>
<td>[^xyz]</td>
<td>负值字符集合，匹配未包含的任意一个字符（注意：不包括换行符），例如：’[^abc]’ 可以匹配 “Lay” 中的’L’（注意：[^xyz]在awk 指令中则是匹配未包含的任意一个字符+换行符）</td>
<td>[^xyz]</td>
<td>[^xyz]</td>
<td>[^xyz]</td>
<td>[^xyz]</td>
</tr>
<tr>
<td>[A-Za-z]</td>
<td>匹配大写字母或者小写字母中的任意一个字符（注意：要写成递增）</td>
<td>[A-Za-z]</td>
<td>[A-Za-z]</td>
<td>[A-Za-z]</td>
<td>[A-Za-z]</td>
</tr>
<tr>
<td>[^A-Za-z]</td>
<td>匹配除了大写与小写字母之外的任意一个字符（注意：写成递增）</td>
<td>[^A-Za-z]</td>
<td>[^A-Za-z]</td>
<td>[^A-Za-z]</td>
<td>[^A-Za-z]</td>
</tr>
<tr>
<td>\d</td>
<td>匹配从 0 到 9 中的任意一个数字字符（等价于 [0-9]）</td>
<td><strong>不支持</strong></td>
<td><strong>不支持</strong></td>
<td>\d</td>
<td>\d</td>
</tr>
<tr>
<td>\D</td>
<td>匹配非数字字符（等价于 [^0-9]）</td>
<td><strong>不支持</strong></td>
<td><strong>不支持</strong></td>
<td>\D</td>
<td>\D</td>
</tr>
<tr>
<td>\S</td>
<td>匹配任何非空白字符（等价于[^\f\n\r\t\v]）</td>
<td><strong>不支持</strong></td>
<td><strong>不支持</strong></td>
<td>\S</td>
<td>\S</td>
</tr>
<tr>
<td>\s</td>
<td>匹配任何空白字符，包括空格、制表符、换页符等等（等价于[ \f\n\r\t\v]）</td>
<td><strong>不支持</strong></td>
<td><strong>不支持</strong></td>
<td>\s</td>
<td>\s</td>
</tr>
<tr>
<td>\W</td>
<td>匹配任何非单词字符 (等价于[^A-Za-z0-9_])</td>
<td>\W</td>
<td>\W</td>
<td>\W</td>
<td>\W</td>
</tr>
<tr>
<td>\w</td>
<td>匹配包括下划线的任何单词字符（等价于[A-Za-z0-9_]）</td>
<td>\w</td>
<td>\w</td>
<td>\w</td>
<td>\w</td>
</tr>
<tr>
<td>\B</td>
<td>匹配非单词边界，例如：’er\B’ 能匹配 “verb” 中的’er’，但不能匹配”never” 中的’er’</td>
<td>\B</td>
<td>\B</td>
<td>\B</td>
<td>\B</td>
</tr>
<tr>
<td>\b</td>
<td>匹配一个单词边界，也就是指单词和空格间的位置，例如： ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的’er’</td>
<td>\b</td>
<td>\b</td>
<td>\b</td>
<td>\b</td>
</tr>
<tr>
<td>\t</td>
<td>匹配一个横向制表符（等价于 \x09和 \cI）</td>
<td><strong>不支持</strong></td>
<td><strong>不支持</strong></td>
<td>\t</td>
<td>\t</td>
</tr>
<tr>
<td>\v</td>
<td>匹配一个垂直制表符（等价于 \x0b和 \cK）</td>
<td><strong>不支持</strong></td>
<td><strong>不支持</strong></td>
<td>\v</td>
<td>\v</td>
</tr>
<tr>
<td>\n</td>
<td>匹配一个换行符（等价于 \x0a 和\cJ）</td>
<td><strong>不支持</strong></td>
<td><strong>不支持</strong></td>
<td>\n</td>
<td>\n</td>
</tr>
<tr>
<td>\f</td>
<td>匹配一个换页符（等价于\x0c 和\cL）</td>
<td><strong>不支持</strong></td>
<td><strong>不支持</strong></td>
<td>\f</td>
<td>\f</td>
</tr>
<tr>
<td>\r</td>
<td>匹配一个回车符（等价于 \x0d 和\cM）</td>
<td><strong>不支持</strong></td>
<td><strong>不支持</strong></td>
<td>\r</td>
<td>\r</td>
</tr>
<tr>
<td>\</td>
<td>匹配转义字符本身”\”</td>
<td>\</td>
<td>\</td>
<td>\</td>
<td>\</td>
</tr>
<tr>
<td>\cx</td>
<td>匹配由 x 指明的控制字符，例如：\cM匹配一个Control-M 或回车符，x 的值必须为A-Z 或 a-z 之一，否则，将 c 视为一个原义的 ‘c’ 字符</td>
<td><strong>不支持</strong></td>
<td><strong>不支持</strong></td>
<td></td>
<td>\cx</td>
</tr>
<tr>
<td>\xn</td>
<td>匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长，例如：’\x41’ 匹配 “A”。’\x041’ 则等价于’\x04’ &amp; “1”。正则表达式中可以使用 ASCII 编码</td>
<td><strong>不支持</strong></td>
<td><strong>不支持</strong></td>
<td></td>
<td>\xn</td>
</tr>
<tr>
<td>\num</td>
<td>匹配 num，其中 num是一个正整数。表示对所获取的匹配的引用</td>
<td><strong>不支持</strong></td>
<td>\num</td>
<td>\num</td>
<td></td>
</tr>
<tr>
<td>[:alnum:]</td>
<td>匹配任何一个字母或数字（[A-Za-z0-9]），例如：’[[:alnum:]] ‘</td>
<td>[:alnum:]</td>
<td>[:alnum:]</td>
<td>[:alnum:]</td>
<td>[:alnum:]</td>
</tr>
<tr>
<td>[:alpha:]</td>
<td>匹配任何一个字母（[A－Za－z]）， 例如：’ [[:alpha:]] ‘</td>
<td>[:alpha:]</td>
<td>[:alpha:]</td>
<td>[:alpha:]</td>
<td>[:alpha:]</td>
</tr>
<tr>
<td>[:digit:]</td>
<td>匹配任何一个数字（[0-9]），例如：’[[:digit:]] ‘</td>
<td>[:digit:]</td>
<td>[:digit:]</td>
<td>[:digit:]</td>
<td>[:digit:]</td>
</tr>
<tr>
<td>[:lower:]</td>
<td>匹配任何一个小写字母（[a-z]）， 例如：’ [[:lower:]] ‘</td>
<td>[:lower:]</td>
<td>[:lower:]</td>
<td>[:lower:]</td>
<td>[:lower:]</td>
</tr>
<tr>
<td>[:upper:]</td>
<td>匹配任何一个大写字母（[A-Z]）</td>
<td>[:upper:]</td>
<td>[:upper:]</td>
<td>[:upper:]</td>
<td>[:upper:]</td>
</tr>
<tr>
<td>[:space:]</td>
<td>任何一个空白字符： 支持制表符、空格，例如：’ [[:space:]] ‘</td>
<td>[:space:]</td>
<td>[:space:]</td>
<td>[:space:]</td>
<td>[:space:]</td>
</tr>
<tr>
<td>[:blank:]</td>
<td>空格和制表符（横向和纵向），例如：’[[:blank:]]’ó’[\s\t\v]’</td>
<td>[:blank:]</td>
<td>[:blank:]</td>
<td>[:blank:]</td>
<td>[:blank:]</td>
</tr>
<tr>
<td>[:graph:]</td>
<td>任何一个可以看得见的且可以打印的字符（注意：不包括空格和换行符等），例如：’[[:graph:]] ‘</td>
<td>[:graph:]</td>
<td>[:graph:]</td>
<td>[:graph:]</td>
<td>[:graph:]</td>
</tr>
<tr>
<td>[:print:]</td>
<td>任何一个可以打印的字符（注意：不包括：[:cntrl:]、字符串结束符’\0’、EOF 文件结束符（-1）， 但包括空格符号），例如：’[[:print:]] ‘</td>
<td>[:print:]</td>
<td>[:print:]</td>
<td>[:print:]</td>
<td>[:print:]</td>
</tr>
<tr>
<td>[:cntrl:]</td>
<td>任何一个控制字符（ASCII 字符集中的前 32 个字符，即：用十进制表示为从 0 到31，例如：换行符、制表符等等），例如：’ [[:cntrl:]]’</td>
<td>[:cntrl:]</td>
<td>[:cntrl:]</td>
<td>[:cntrl:]</td>
<td>[:cntrl:]</td>
</tr>
<tr>
<td>[:punct:]</td>
<td>任何一个标点符号（不包括：[:alnum:]、[:cntrl:]、[:space:]这些字符集）</td>
<td>[:punct:]</td>
<td>[:punct:]</td>
<td>[:punct:]</td>
<td>[:punct:]</td>
</tr>
<tr>
<td>[:xdigit:]</td>
<td>任何一个十六进制数（即：0-9，a-f，A-F）</td>
<td>[:xdigit:]</td>
<td>[:xdigit:]</td>
<td>[:xdigit:]</td>
<td>[:xdigit:]</td>
</tr>
</tbody>
</table>
<p><strong>注意</strong> </p>
<ul>
<li>js中支持的是EREs.</li>
<li>当使用 BREs ( 基本正则表达式 ) 时，必须在下列这些符号(?,+,|,{,},(,))前加上转义字符 \ .</li>
<li>上述[[:xxxx:]] 形式的正则表达式, 是php中内置的通用字符簇, js中并不支持.</li>
</ul>
<h3 id="linux-osx下常用命令与正则表达式的关系"><a href="#linux-osx下常用命令与正则表达式的关系" class="headerlink" title="linux/osx下常用命令与正则表达式的关系"></a>linux/osx下常用命令与正则表达式的关系</h3><p>我曾经尝试在 grep 和 sed 命令中书写正则表达式, 经常发现不能使用元字符, 而且有时候需要转义, 有时候不需要转义, 始终不能摸清它的规律. 如果恰好你也有同样的困惑, 那么请往下看, 相信应该能有所收获.</p>
<h4 id="grep-egrep-sed-awk-正则表达式特点"><a href="#grep-egrep-sed-awk-正则表达式特点" class="headerlink" title="grep , egrep , sed , awk  正则表达式特点"></a>grep , egrep , sed , awk  正则表达式特点</h4><ol>
<li><p>grep 支持：BREs、EREs、PREs 正则表达式</p>
<p>grep 指令后不跟任何参数, 则表示要使用 “BREs”</p>
<p>grep 指令后跟 ”-E” 参数, 则表示要使用 “EREs”</p>
<p>grep 指令后跟 “-P” 参数, 则表示要使用 “PREs”</p>
</li>
<li><p>egrep 支持：EREs、PREs 正则表达式</p>
<p>egrep 指令后不跟任何参数, 则表示要使用 “EREs”</p>
<p>egrep 指令后跟 “-P” 参数, 则表示要使用 “PREs”</p>
</li>
<li><p>sed 支持: BREs、EREs</p>
<p>sed 指令默认是使用 “BREs”</p>
<p>sed 指令后跟 “-r” 参数 , 则表示要使用“EREs”</p>
</li>
<li><p>awk 支持 EREs, 并且默认使用 “EREs”</p>
</li>
</ol>
<h3 id="正则表达式初阶技能"><a href="#正则表达式初阶技能" class="headerlink" title="正则表达式初阶技能"></a>正则表达式初阶技能</h3><h4 id="贪婪模式与非贪婪模式"><a href="#贪婪模式与非贪婪模式" class="headerlink" title="贪婪模式与非贪婪模式"></a>贪婪模式与非贪婪模式</h4><p>默认情况下, 所有的限定词都是贪婪模式, 表示尽可能多的去捕获字符; 而在限定词后增加?, 则是非贪婪模式, 表示尽可能少的去捕获字符. 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">"aaab"</span>,</div><div class="line">    reg1 = <span class="regexp">/a+/</span>, <span class="comment">//贪婪模式</span></div><div class="line">    reg2 = <span class="regexp">/a+?/</span>;<span class="comment">//非贪婪模式</span></div><div class="line"><span class="built_in">console</span>.log(str.match(reg1)); <span class="comment">//["aaa"], 由于是贪婪模式, 捕获了所有的a</span></div><div class="line"><span class="built_in">console</span>.log(str.match(reg2)); <span class="comment">//["a"], 由于是非贪婪模式, 只捕获到第一个a</span></div></pre></td></tr></table></figure>
<p>实际上, 非贪婪模式非常有效, 特别是当匹配html标签时. 比如匹配一个配对出现的div, 方案一可能会匹配到很多的div标签对, 而方案二则只会匹配一个div标签对.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">"&lt;div class='v1'&gt;&lt;div class='v2'&gt;test&lt;/div&gt;&lt;input type='text'/&gt;&lt;/div&gt;"</span>;</div><div class="line"><span class="keyword">var</span> reg1 = <span class="regexp">/&lt;div.*&lt;\/div&gt;/</span>; <span class="comment">//方案一,贪婪匹配</span></div><div class="line"><span class="keyword">var</span> reg2 = <span class="regexp">/&lt;div.*?&lt;\/div&gt;/</span>;<span class="comment">//方案二,非贪婪匹配</span></div><div class="line"><span class="built_in">console</span>.log(str.match(reg1));<span class="comment">//"&lt;div class='v1'&gt;&lt;div class='v2'&gt;test&lt;/div&gt;&lt;input type='text'/&gt;&lt;/div&gt;"</span></div><div class="line"><span class="built_in">console</span>.log(str.match(reg2));<span class="comment">//"&lt;div class='v1'&gt;&lt;div class='v2'&gt;test&lt;/div&gt;"</span></div></pre></td></tr></table></figure>
<h5 id="区间量词的非贪婪模式"><a href="#区间量词的非贪婪模式" class="headerlink" title="区间量词的非贪婪模式"></a>区间量词的非贪婪模式</h5><p>一般情况下, 非贪婪模式, 我们使用的是”*?”, 或 “+?” 这种形式, 还有一种是 “{n,m}?”.</p>
<p>区间量词”{n,m}” 也是匹配优先, 虽有匹配次数上限, 但是在到达上限之前, 它依然是尽可能多的匹配, 而”{n,m}?” 则表示在区间范围内, 尽可能少的匹配.</p>
<p><strong>需要注意的是</strong>: </p>
<ul>
<li>能达到同样匹配结果的贪婪与非贪婪模式, 通常是贪婪模式的匹配效率较高.</li>
<li>所有的非贪婪模式, 都可以通过修改量词修饰的子表达式, 转换为贪婪模式.</li>
<li>贪婪模式可以与<code>固化分组</code>(后面会讲到)结合，提升匹配效率，而非贪婪模式却不可以.</li>
</ul>
<h4 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h4><p>正则的分组主要通过小括号来实现, 括号包裹的子表达式作为一个分组, 括号后可以紧跟限定词表示重复次数. 如下, 小括号内包裹的abc便是一个分组:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/(abc)+<span class="regexp">/.test("abc123") == true</span></div></pre></td></tr></table></figure>
<p>那么分组有什么用呢? 一般来说, 分组是为了方便的表示重复次数, 除此之外, 还有一个作用就是用于捕获, 请往下看.</p>
<h4 id="捕获性分组"><a href="#捕获性分组" class="headerlink" title="捕获性分组"></a>捕获性分组</h4><p>捕获性分组, 通常由一对小括号加上子表达式组成. 捕获性分组会创建反向引用, 每个反向引用都由一个编号或名称来标识, js中主要是通过 <code>$+编号</code> 或者 <code>\+编号</code> 表示法进行引用. 如下便是一个捕获性分组的例子.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> color = <span class="string">"#808080"</span>;</div><div class="line"><span class="keyword">var</span> output = color.replace(<span class="regexp">/#(\d+)/</span>,<span class="string">"$1"</span>+<span class="string">"~~"</span>);<span class="comment">//自然也可以写成 "$1~~"</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">1</span>);<span class="comment">//808080</span></div><div class="line"><span class="built_in">console</span>.log(output);<span class="comment">//808080~~</span></div></pre></td></tr></table></figure>
<p>以上, (\d+) 表示一个捕获性分组, <code>RegExp.$1</code> 指向该分组捕获的内容. <code>$+编号</code> 这种引用通常在正则表达式之外使用. <code>\+编号</code> 这种引用却可以在正则表达式中使用, 可用于匹配不同位置相同部分的子串.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> url = <span class="string">"www.google.google.com"</span>;</div><div class="line"><span class="keyword">var</span> re = <span class="regexp">/([a-z]+)\.\1/</span>;</div><div class="line"><span class="built_in">console</span>.log(url.replace(re,<span class="string">"$1"</span>));<span class="comment">//"www.google.com"</span></div></pre></td></tr></table></figure>
<p>以上, 相同部分的”google”字符串只被替换一次.</p>
<h4 id="非捕获性分组"><a href="#非捕获性分组" class="headerlink" title="非捕获性分组"></a>非捕获性分组</h4><p>非捕获性分组, 通常由一对括号加上”?:”加上子表达式组成, 非捕获性分组不会创建反向引用, 就好像没有括号一样. 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> color = <span class="string">"#808080"</span>;</div><div class="line"><span class="keyword">var</span> output = color.replace(<span class="regexp">/#(?:\d+)/</span>,<span class="string">"$1"</span>+<span class="string">"~~"</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">1</span>);<span class="comment">//""</span></div><div class="line"><span class="built_in">console</span>.log(output);<span class="comment">//$1~~</span></div></pre></td></tr></table></figure>
<p>以上, (?:\d+) 表示一个非捕获性分组, 由于分组不捕获任何内容, 所以, <code>RegExp.$1</code> 就指向了空字符串.</p>
<p>同时, 由于<code>$1</code> 的反向引用不存在, 因此最终它被当成了普通字符串进行替换.</p>
<p>实际上, 捕获性分组和无捕获性分组在搜索效率方面也没什么不同, 没有哪一个比另一个更快.</p>
<h4 id="命名分组"><a href="#命名分组" class="headerlink" title="命名分组"></a>命名分组</h4><p>语法: (?<name>…)</name></p>
<p>命名分组也是捕获性分组,  它将匹配的字符串捕获到一个组名称或编号名称中, 在获得匹配结果后, 可通过分组名进行获取. 如下是一个python的命名分组的例子.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> re</div><div class="line">data = <span class="string">"#808080"</span></div><div class="line">regExp = <span class="string">r"#(?P&lt;one&gt;\d+)"</span></div><div class="line">replaceString = <span class="string">"\g&lt;one&gt;"</span> + <span class="string">"~~"</span></div><div class="line"><span class="keyword">print</span> re.sub(regExp,replaceString,data) <span class="comment"># 808080~~</span></div></pre></td></tr></table></figure>
<p>python的命名分组表达式与标准格式相比, 在 ? 后多了一大写的 P 字符, 并且python通过“\g&lt;命名&gt;”表示法进行引用. (如果是捕获性分组, python通过”\g&lt;编号&gt;”表示法进行引用)</p>
<p>与python不同的是, javaScript 中并不支持命名分组.</p>
<h4 id="固化分组"><a href="#固化分组" class="headerlink" title="固化分组"></a>固化分组</h4><p>固化分组, 又叫原子组.</p>
<p>语法: (?&gt;…)</p>
<p>如上所述, 我们在使用非贪婪模式时, 匹配过程中可能会进行多次的回溯, 回溯越多, 正则表达式的运行效率就越低. 而固化分组就是用来减少回溯次数的.</p>
<p>实际上, 固化分组(?&gt;…)的匹配与正常的匹配并无分别, 它并不会改变匹配结果. 唯一的不同就是: 固化分组匹配结束时, 它匹配到的文本已经固化为一个单元, 只能作为整体而保留或放弃, 括号内的子表达式中未尝试过的备用状态都会被放弃, 所以回溯永远也不能选择其中的状态(因此不能参与回溯). 下面我们来通过一个例子更好地理解固化分组.</p>
<p>假如要处理一批数据, 原格式为 123.456, 因为浮点数显示问题, 部分数据格式会变为123.456000000789这种, 现要求只保留小数点后2~3位, 但是最后一位不能为0, 那么这个正则怎么写呢?</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">"123.456000000789"</span>;</div><div class="line">str = str.replace(<span class="regexp">/(\.\d\d[1-9]?)\d*/</span>,<span class="string">"$1"</span>); <span class="comment">//123.456</span></div></pre></td></tr></table></figure>
<p>以上的正则, 对于”123.456” 这种格式的数据, 将白白处理一遍. 为了提高效率, 我们将正则最后的一个”*”改为”+”. 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">"123.456"</span>;</div><div class="line">str = str.replace(<span class="regexp">/(\.\d\d[1-9]?)\d+/</span>,<span class="string">"$1"</span>); <span class="comment">//123.45</span></div></pre></td></tr></table></figure>
<p>此时, “\d\d[1-9]?” 子表达式, 匹配是 “45”, 而不是 “456”, 这是因为正则末尾使用了”+”, 表示末尾至少要匹配一个数字, 因此末尾的子表达式”\d+” 匹配到了 “6”. 显然 “123.45” 不是我们期望的匹配结果, 那我们应该怎么做呢? 能否让 “[1-9]?” 一旦匹配成功, 便不再进行回溯, 这里就要用到我们上面说的固化分组.</p>
<p>“(\.\d\d(?&gt;[1-9]?))\d+” 便是上述正则的固化分组形式. 由于字符串 “123.456” 不满足该固化分组的正则, 所以, 匹配会失败, 符合我们期望.</p>
<p>下面我们来分析下固化分组的正则 (\.\d\d(?&gt;[1-9]?))\d+ 为什么匹配不到字符串”123.456”.</p>
<p>很明显, 对于上述固化分组, 只存在两种匹配结果.</p>
<p>情况①: 若 [1-9] 匹配失败, 正则会返回 ? 留下的备用状态. 然后匹配脱离固化分组, 继续前进到[\d+]. 当控制权离开固化分组时, 没有备用状态需要放弃(因固化分组中根本没有创建任何备用状态).</p>
<p>情况②: 若 [1-9] 匹配成功, 匹配脱离固化分组之后,  ? 保存的备用状态仍然存在, 但是, 由于它属于已经结束的固化分组, 所以会被抛弃.</p>
<p>对于字符串 “123.456”, 由于 [1-9] 能够匹配成功, 所以它符合情况②. 下面我们来还原情况②的执行现场. </p>
<ol>
<li>匹配所处的状态:  匹配已经走到了 “6” 的位置, 匹配将继续前进;==&gt;</li>
<li>子表达式 \d+ 发现无法匹配, 正则引擎便尝试回溯;==&gt;</li>
<li>查看是否存在备用状态以供回溯?==&gt;</li>
<li>“?” 保存的备用状态属于已经结束的固化分组, 所以该备用状态会被放弃;==&gt;</li>
<li>此时固化分组匹配到的 “6”, 便不能用于正则引擎的回溯;==&gt;</li>
<li>尝试回溯失败;==&gt;</li>
<li>正则匹配失败.==&gt;</li>
<li>文本 “123.456” 没有被正则表达式匹配上, 符合预期.</li>
</ol>
<p>相应的流程图如下:</p>
<style>

.fancy-ctn img[src$="regexp02.png"]{height:500px;width:396px;}

</style>

<p><img src="http://louiszhai.github.io/docImages/regexp02.png" alt="正则表达式流程图"></p>
<p>遗憾的是, javaScript, java 和 python中并不支持固化分组的语法, 不过, 它在php和.NET中表现良好. 下面提供了一个php版的固化分组形式的正则表达式, 以供尝试.</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$str = <span class="string">"123.456"</span>;</div><div class="line"><span class="keyword">echo</span> preg_replace(<span class="string">"/(\.\d\d(?&gt;[1-9]?))\d+/"</span>,<span class="string">"\\1"</span>,$str); <span class="comment">//固化分组</span></div></pre></td></tr></table></figure>
<p>不仅如此, php还提供了占有量词优先的语法. 如下:</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$str = <span class="string">"123.456"</span>;</div><div class="line"><span class="keyword">echo</span> preg_replace(<span class="string">"/(\.\d\d[1-9]?+)\d+/"</span>,<span class="string">"\\1"</span>,$str); <span class="comment">//占有量词优先</span></div></pre></td></tr></table></figure>
<p>虽然java不支持固化分组的语法, 但java也提供了占有量词优先的语法, 同样能够避免正则回溯. 如下: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String str = <span class="string">"123.456"</span>;</div><div class="line">System.out.println(str.replaceAll(<span class="string">"(\\.\\d\\d[1-9]?+)\\d+"</span>, <span class="string">"$1"</span>));<span class="comment">// 123.456</span></div></pre></td></tr></table></figure>
<p>值得注意的是: java中 replaceAll 方法需要转义反斜杠.</p>
<h3 id="正则表达式高阶技能-零宽断言"><a href="#正则表达式高阶技能-零宽断言" class="headerlink" title="正则表达式高阶技能-零宽断言"></a>正则表达式高阶技能-零宽断言</h3><p>如果说正则分组是写轮眼, 那么零宽断言就是万花筒写轮眼终极奥义-须佐能乎(这里借火影忍术打个比方). 合理地使用零宽断言, 能够能分组之不能, 极大地增强正则匹配能力, 它甚至可以帮助你在匹配条件非常模糊的情况下快速地定位文本.</p>
<p>零宽断言, 又叫环视. 环视只进行子表达式的匹配, 匹配到的内容不保存到最终的匹配结果, 由于匹配是零宽度的, 故最终匹配到的只是一个位置. </p>
<p>环视按照方向划分, 有顺序和逆序两种(也叫前瞻和后瞻), 按照是否匹配有肯定和否定两种, 组合之, 便有4种环视. 4种环视并不复杂, 如下便是它们的描述.</p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>字符</strong></th>
<th><strong>描述</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">(?:<em>pattern</em>)</td>
<td>非捕获性分组, 匹配pattern的位置, 但不捕获匹配结果.也就是说不创建反向引用, 就好像没有括号一样.</td>
<td>‘abcd(?:e)匹配’abcde</td>
</tr>
<tr>
<td style="text-align:center">(?=<em>pattern</em>)</td>
<td><strong>顺序肯定环视</strong>, 匹配后面是pattern 的位置, 不捕获匹配结果.</td>
<td>‘Windows (?=2000)’匹配 “Windows2000” 中的 “Windows”; 不匹配 “Windows3.1” 中的 “Windows”</td>
</tr>
<tr>
<td style="text-align:center">(?!<em>pattern</em>)</td>
<td><strong>顺序否定环视</strong>, 匹配后面不是 pattern 的位置, 不捕获匹配结果.</td>
<td>‘Windows (?!2000)’匹配 “Windows3.1” 中的 “Windows”; 不匹配 “Windows2000” 中的 “Windows”</td>
</tr>
<tr>
<td style="text-align:center">(?&lt;=<em>pattern</em>)</td>
<td><strong>逆序肯定环视</strong>, 匹配前面是 pattern 的位置, 不捕获匹配结果.</td>
<td>‘(?&lt;=Office)2000’匹配 “ Office2000” 中的 “2000”; 不匹配 “Windows2000” 中的 “2000”</td>
</tr>
<tr>
<td style="text-align:center">(?&lt;!<em>pattern</em>)</td>
<td><strong>逆序否定环视</strong>, 匹配前面不是 pattern 的位置, 不捕获匹配结果.</td>
<td>‘(?&lt;!Office)2000’匹配 “ Windows2000” 中的 “2000”; 不匹配 “ Office2000” 中的 “2000”</td>
</tr>
</tbody>
</table>
<p>非捕获性分组由于结构与环视相似, 故列在表中, 以做对比. 以上4种环视中, 目前 javaScript 中只支持前两种, 也就是只支持 <strong>顺序肯定环视</strong> 和 <strong>顺序否定环视</strong>. 下面我们通过实例来帮助理解下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">"123abc789"</span>,s;</div><div class="line"><span class="comment">//没有使用环视,abc直接被替换</span></div><div class="line">s = str.replace(<span class="regexp">/abc/</span>,<span class="number">456</span>);</div><div class="line"><span class="built_in">console</span>.log(s); <span class="comment">//123456789</span></div><div class="line"></div><div class="line"><span class="comment">//使用了顺序肯定环视,捕获到了a前面的位置,所以abc没有被替换,只是将3替换成了3456</span></div><div class="line">s = str.replace(<span class="regexp">/3(?=abc)/</span>,<span class="number">3456</span>);</div><div class="line"><span class="built_in">console</span>.log(s); <span class="comment">//123456abc789</span></div><div class="line"></div><div class="line"><span class="comment">//使用了顺序否定环视,由于3后面跟着abc,不满意条件,故捕获失败,所以原字符串没有被替换</span></div><div class="line">s = str.replace(<span class="regexp">/3(?!abc)/</span>,<span class="number">3456</span>);</div><div class="line"><span class="built_in">console</span>.log(s); <span class="comment">//123abc789</span></div></pre></td></tr></table></figure>
<p>下面通过python来演示下 <strong>逆序肯定环视</strong> 和 <strong>逆序否定环视</strong> 的用法.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> re</div><div class="line">data = <span class="string">"123abc789"</span></div><div class="line"><span class="comment"># 使用了逆序肯定环视,替换左边为123的连续的小写英文字母,匹配成功,故abc被替换为456</span></div><div class="line">regExp = <span class="string">r"(?&lt;=123)[a-z]+"</span></div><div class="line">replaceString = <span class="string">"456"</span></div><div class="line"><span class="keyword">print</span> re.sub(regExp,replaceString,data) <span class="comment"># 123456789</span></div><div class="line"></div><div class="line"><span class="comment"># 使用了逆序否定环视,由于英文字母左侧不能为123,故子表达式[a-z]+捕获到bc,最终bc被替换为456</span></div><div class="line">regExp = <span class="string">r"(?&lt;!123)[a-z]+"</span></div><div class="line">replaceString = <span class="string">"456"</span></div><div class="line"><span class="keyword">print</span> re.sub(regExp,replaceString,data) <span class="comment"># 123a456789</span></div></pre></td></tr></table></figure>
<p>需要注意的是: python 和 perl 语言中的 <strong>逆序环视</strong> 的子表达式只能使用定长的文本. 比如将上述 “(?&lt;=123)” (逆序肯定环视)子表达式写成 “(?&lt;=[0-9]+)”, python解释器将会报错: “error: look-behind requires fixed-width pattern”.</p>
<h4 id="场景回顾"><a href="#场景回顾" class="headerlink" title="场景回顾"></a>场景回顾</h4><h5 id="获取html片段"><a href="#获取html片段" class="headerlink" title="获取html片段"></a>获取html片段</h5><p>假如现在, js 通过 ajax 获取到一段 html 代码如下:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var responseText = "<span class="tag">&lt;<span class="name">div</span> <span class="attr">data</span>=<span class="string">'dev.xxx.txt'</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">'dev.xxx.png'</span> /&gt;</span>";</div></pre></td></tr></table></figure>
<p>现我们需要替换img标签的src 属性中的 “dev”字符串 为 “test” 字符串. </p>
<p>① 由于上述 responseText 字符串中包含至少两个子字符串 “dev”, 显然不能直接 replace 字符串 “dev”为 “test”. </p>
<p>② 同时由于 js 中不支持逆序环视, 我们也不能在正则中判断前缀为 “src=’”, 然后再替换”dev”. </p>
<p>③ 我们注意到 img 标签的 src 属性以 “.png” 结尾, 基于此, 就可以使用顺序肯定环视. 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> reg = <span class="regexp">/dev(?=[^']*png)/</span>; <span class="comment">//为了防止匹配到第一个dev, 通配符前面需要排除单引号或者是尖括号</span></div><div class="line"><span class="keyword">var</span> str = responseText.replace(reg,<span class="string">"test"</span>);</div><div class="line"><span class="built_in">console</span>.log(str);<span class="comment">//&lt;div data='dev.xxx'&gt;&lt;/div&gt;&lt;img src='test.xxx.png' /&gt;</span></div></pre></td></tr></table></figure>
<p>当然, 以上不止顺序肯定环视一种解法, 捕获性分组同样可以做到. 那么环视高级在哪里呢? 环视高级的地方就在于它通过一次捕获就可以定位到一个位置, 对于复杂的文本替换场景, 常有奇效, 而分组则需要更多的操作. 请往下看.</p>
<h5 id="千位分割符"><a href="#千位分割符" class="headerlink" title="千位分割符"></a>千位分割符</h5><blockquote>
<p>千位分隔符, 顾名思义, 就是数字中的逗号. 参考西方的习惯, 数字之中加入一个符号, 避免因数字太长难以直观的看出它的值. 故而数字之中, 每隔三位添加一个逗号, 即千位分隔符.</p>
</blockquote>
<p>那么怎么将一串数字转化为千位分隔符形式呢?</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">"1234567890"</span>;</div><div class="line">(+str).toLocaleString();<span class="comment">//"1,234,567,890"</span></div></pre></td></tr></table></figure>
<p>如上, <code>toLocaleString()</code> 返回当前对象的”本地化”字符串形式. </p>
<ul>
<li>如果该对象是Number类型, 那么将返回该数值的按照特定符号分割的字符串形式.</li>
<li>如果该对象是Array类型, 那么先将数组中的每项转化为字符串, 然后将这些字符串以指定分隔符连接起来并返回.</li>
</ul>
<p><code>toLocaleString</code> 方法特殊, 有本地化特性, 对于天朝, 默认的分隔符是英文逗号. 因此使用它恰好可以将数值转化为千位分隔符形式的字符串. 如果考虑到国际化, 以上方法就有可能会失效了.</p>
<p>我们尝试使用环视来处理下.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">thousand</span>(<span class="params">str</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> str.replace(<span class="regexp">/(?!^)(?=([0-9]&#123;3&#125;)+$)/g</span>,<span class="string">','</span>);</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(thousand(str));<span class="comment">//"1,234,567,890"</span></div><div class="line"><span class="built_in">console</span>.log(thousand(<span class="string">"123456"</span>));<span class="comment">//"123,456"</span></div><div class="line"><span class="built_in">console</span>.log(thousand(<span class="string">"1234567879876543210"</span>));<span class="comment">//"1,234,567,879,876,543,210"</span></div></pre></td></tr></table></figure>
<p>上述使用到的正则分为两块. <code>(?!^)</code> 和 <code>(?=([0-9]{3})+$)</code>. 我们先来看后面的部分, 然后逐步分析之.</p>
<ol>
<li>“[0-9]{3}” 表示连续3位数字.</li>
<li>“([0-9]{3})+” 表示连续3位数字至少出现一次或更多次.</li>
<li>“([0-9]{3})+$” 表示连续3的正整数倍的数字, 直到字符串末尾.</li>
<li>那么 <code>(?=([0-9]{3})+$)</code> 就表示匹配一个零宽度的位置, 并且从这个位置到字符串末尾, 中间拥有3的正整数倍的数字.</li>
<li>正则表达式使用全局匹配g, 表示匹配到一个位置后, 它会继续匹配, 直至匹配不到.</li>
<li>将这个位置替换为逗号, 实际上就是每3位数字添加一个逗号.</li>
<li>当然对于字符串”123456”这种刚好拥有3的正整数倍的数字的, 当然不能在1前面添加逗号. 那么使用 <code>(?!^)</code> 就指定了这个替换的位置不能为起始位置.</li>
</ol>
<p>千位分隔符实例, 展示了环视的强大, 一步到位.</p>
<h3 id="正则表达式在JS中的应用"><a href="#正则表达式在JS中的应用" class="headerlink" title="正则表达式在JS中的应用"></a>正则表达式在JS中的应用</h3><h4 id="ES6对正则的扩展"><a href="#ES6对正则的扩展" class="headerlink" title="ES6对正则的扩展"></a>ES6对正则的扩展</h4><p>ES6对正则扩展了又两种修饰符(其他语言可能不支持):</p>
<ul>
<li>y (粘连sticky修饰符), 与g类似, 也是全局匹配, 并且下一次匹配都是从上一次匹配成功的下一个位置开始, 不同之处在于, g修饰符只要剩余位置中存在匹配即可, 而y修饰符确保匹配必须从剩余的第一个位置开始.</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s = <span class="string">"abc_ab_a"</span>;</div><div class="line"><span class="keyword">var</span> r1 = <span class="regexp">/[a-z]+/g</span>;</div><div class="line"><span class="keyword">var</span> r2 = <span class="regexp">/[a-z]+/y</span>;</div><div class="line"><span class="built_in">console</span>.log(r1.exec(s),r1.lastIndex); <span class="comment">// ["abc", index: 0, input: "abc_ab_a"] 3</span></div><div class="line"><span class="built_in">console</span>.log(r2.exec(s),r2.lastIndex); <span class="comment">// ["abc", index: 0, input: "abc_ab_a"] 3</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(r1.exec(s),r1.lastIndex); <span class="comment">// ["ab", index: 4, input: "abc_ab_a"] 6</span></div><div class="line"><span class="built_in">console</span>.log(r2.exec(s),r2.lastIndex); <span class="comment">// null 0</span></div></pre></td></tr></table></figure>
<p>如上, 由于第二次匹配的开始位置是下标3,  对应的字符串是 “_”, 而使用y修饰符的正则对象r2, 需要从剩余的第一个位置开始, 所以匹配失败, 返回null.</p>
<p>正则对象的 sticky 属性, 表示是否设置了y修饰符. 这点将会在后面讲到.</p>
<ul>
<li>u 修饰符, 提供了对正则表达式添加4字节码点的支持. 比如 “𝌆” 字符是一个4字节字符, 直接使用正则匹配将会失败, 而使用u修饰符后, 将会等到正确的结果.</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s = <span class="string">"𝌆"</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="regexp">/^.$/</span>.test(s));<span class="comment">//false</span></div><div class="line"><span class="built_in">console</span>.log(<span class="regexp">/^.$/u</span>.test(s));<span class="comment">//true</span></div></pre></td></tr></table></figure>
<h5 id="UCS-2字节码"><a href="#UCS-2字节码" class="headerlink" title="UCS-2字节码"></a>UCS-2字节码</h5><p>有关字节码点, 稍微提下. javaScript 只能处理UCS-2编码(js于1995年5月被Brendan Eich花费10天设计出来, 比1996年7月发布的编码规范UTF-16早了一年多, 当时只有UCS-2可选). 由于UCS-2先天不足, 造成了所有字符在js中都是2个字节. 如果是4个字节的字符, 将会默认被当作两个双字节字符处理. 因此 js 的字符处理函数都会受到限制, 无法返回正确结果. 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s = <span class="string">"𝌆"</span>;</div><div class="line"><span class="built_in">console</span>.log(s == <span class="string">"\uD834\uDF06"</span>);<span class="comment">//true 𝌆相当于UTF-16中的0xD834DF06</span></div><div class="line"><span class="built_in">console</span>.log(s.length);<span class="comment">//2 长度为2, 表示这是4字节字符</span></div></pre></td></tr></table></figure>
<p>幸运的是, ES6可以自动识别4字节的字符.因此遍历字符串可以直接使用for of循环. 同时, js中如果直接使用码点表示Unicode字符, 对于4字节字符, ES5里是没办法识别的. 为此ES6修复了这个问题, 只需将码点放在大括号内即可.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(s === <span class="string">"\u1D306"</span>);<span class="comment">//false   ES5无法识别𝌆</span></div><div class="line"><span class="built_in">console</span>.log(s === <span class="string">"\u&#123;1D306&#125;"</span>);<span class="comment">//true  ES6可以借助大括号识别𝌆</span></div></pre></td></tr></table></figure>
<h5 id="附-ES6新增的处理4字节码的函数"><a href="#附-ES6新增的处理4字节码的函数" class="headerlink" title="附: ES6新增的处理4字节码的函数"></a>附: ES6新增的处理4字节码的函数</h5><ul>
<li><strong>String.fromCodePoint()</strong>：从Unicode码点返回对应字符</li>
<li><strong>String.prototype.codePointAt()</strong>：从字符返回对应的码点</li>
<li><strong>String.prototype.at()</strong>：返回字符串给定位置的字符</li>
</ul>
<p>有关js中的unicode字符集, 请参考阮一峰老师的 <a href="http://www.ruanyifeng.com/blog/2014/12/unicode.html" target="_blank" rel="external"><code>Unicode与JavaScript详解</code></a>.</p>
<p>以上是ES6对正则的扩展. 另一个方面, 从方法上看, javaScript 中与正则表达式有关的方法有: </p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>compile</th>
<th>test</th>
<th>exec</th>
<th>match</th>
<th>search</th>
<th>replace</th>
<th>split</th>
</tr>
</thead>
<tbody>
<tr>
<td>所属对象</td>
<td>RegExp</td>
<td>RegExp</td>
<td>RegExp</td>
<td>String</td>
<td>String</td>
<td>String</td>
<td>String</td>
</tr>
</tbody>
</table>
<p>由上, 一共有7个与js相关的方法, 这些方法分别来自于 RegExp 与 String 对象. 首先我们先来看看js中的正则类 RegExp.</p>
<h4 id="RegExp"><a href="#RegExp" class="headerlink" title="RegExp"></a>RegExp</h4><p>RegExp 对象表示正则表达式, 主要用于对字符串执行模式匹配.</p>
<p>语法: new RegExp(pattern[, flags])</p>
<p>参数 <em>pattern</em> 是一个字符串, 指定了正则表达式字符串或其他的正则表达式对象.</p>
<p>参数 <em>flags</em> 是一个可选的字符串, 包含属性 “g”、”i” 和 “m”, 分别用于指定全局匹配、区分大小写的匹配和多行匹配. 如果<em>pattern</em> 是正则表达式, 而不是字符串, 则必须省略该参数.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> pattern = <span class="string">"[0-9]"</span>;</div><div class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(pattern,<span class="string">"g"</span>);</div><div class="line"><span class="comment">// 上述创建正则表达式对象,可以用对象字面量形式代替,也推荐下面这种</span></div><div class="line"><span class="keyword">var</span> reg = <span class="regexp">/[0-9]/g</span>;</div></pre></td></tr></table></figure>
<p>以上, 通过对象字面量和构造函数创建正则表达式, 有个小插曲.</p>
<p>“对于正则表达式的直接量, ECMAscript 3规定在每次它时都会返回同一个RegExp对象, 因此用直接量创建的正则表达式的会共享一个实例. 直到ECMAScript 5才规定每次返回不同的实例.”</p>
<p>所以, 现在我们基本不用担心这个问题, 只需要注意在低版本的非IE浏览器中尽量使用构造函数创建正则(这点上, IE一直遵守ES5规定, 其他浏览器的低级版本遵循ES3规定).</p>
<p>RegExp 实例对象包含如下属性:</p>
<table>
<thead>
<tr>
<th style="text-align:center">实例属性</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">global</td>
<td style="text-align:center">是否包含全局标志(true/false)</td>
</tr>
<tr>
<td style="text-align:center">ignoreCase</td>
<td style="text-align:center">是否包含区分大小写标志(true/false)</td>
</tr>
<tr>
<td style="text-align:center">multiline</td>
<td style="text-align:center">是否包含多行标志(true/false)</td>
</tr>
<tr>
<td style="text-align:center">source</td>
<td style="text-align:center">返回创建RegExp对象实例时指定的表达式文本字符串形式</td>
</tr>
<tr>
<td style="text-align:center">lastIndex</td>
<td style="text-align:center">表示原字符串中匹配的字符串末尾的后一个位置, 默认为0</td>
</tr>
<tr>
<td style="text-align:center">flags(ES6)</td>
<td style="text-align:center">返回正则表达式的修饰符</td>
</tr>
<tr>
<td style="text-align:center">sticky(ES6)</td>
<td style="text-align:center">是否设置了y(粘连)修饰符(true/false)</td>
</tr>
</tbody>
</table>
<h5 id="compile"><a href="#compile" class="headerlink" title="compile"></a>compile</h5><p>compile 方法用于在执行过程中改变和重新编译正则表达式.</p>
<p>语法: compile(pattern[, flags])</p>
<p>参数介绍请参考上述 RegExp 构造器. 用法如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"abc"</span>, <span class="string">"gi"</span>); </div><div class="line"><span class="keyword">var</span> reg2 = reg.compile(<span class="string">"new abc"</span>, <span class="string">"g"</span>);</div><div class="line"><span class="built_in">console</span>.log(reg);<span class="comment">// /new abc/g</span></div><div class="line"><span class="built_in">console</span>.log(reg2);<span class="comment">// undefined</span></div></pre></td></tr></table></figure>
<p>可见 compile 方法会改变原正则表达式对象, 并重新编译, 而且它的返回值为空.</p>
<h5 id="test"><a href="#test" class="headerlink" title="test"></a>test</h5><p>test 方法用于检测一个字符串是否匹配某个正则规则, 只要是字符串中含有与正则规则匹配的文本, 该方法就返回true, 否则返回 false.</p>
<p>语法: test(string), 用法如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="regexp">/[0-9]+/</span>.test(<span class="string">"abc123"</span>));<span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="regexp">/[0-9]+/</span>.test(<span class="string">"abc"</span>));<span class="comment">//false</span></div></pre></td></tr></table></figure>
<p>以上, 字符串”abc123” 包含数字, 故 test 方法返回 true; 而 字符串”abc” 不包含数字, 故返回 false.</p>
<p>如果需要使用 test 方法测试字符串是否完成匹配某个正则规则, 那么可以在正则表达式里增加开始(^)和结束($)元字符. 如下: </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="regexp">/^[0-9]+$/</span>.test(<span class="string">"abc123"</span>));<span class="comment">//false</span></div></pre></td></tr></table></figure>
<p>以上, 由于字符串”abc123” 并非以数字开始, 也并非以数字结束, 故 test 方法返回false.</p>
<p>实际上, 如果正则表达式带有全局标志(带有参数g)时, test 方法还受正则对象的lastIndex属性影响,如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> reg = <span class="regexp">/[a-z]+/</span>;<span class="comment">//正则不带全局标志</span></div><div class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">"abc"</span>));<span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">"de"</span>));<span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> reg = <span class="regexp">/[a-z]+/g</span>;<span class="comment">//正则带有全局标志g</span></div><div class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">"abc"</span>));<span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(reg.lastIndex);<span class="comment">//3, 下次运行test时,将从索引为3的位置开始查找</span></div><div class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">"de"</span>));<span class="comment">//false</span></div></pre></td></tr></table></figure>
<p>该影响将在exec 方法讲解中予以分析.</p>
<h5 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h5><p>exec 方法用于检测字符串对正则表达式的匹配, 如果找到了匹配的文本, 则返回一个结果数组, 否则返回null.</p>
<p>语法: exec(string)</p>
<p>exec 方法返回的数组中包含两个额外的属性, index 和 input. 并且该数组具有如下特点:</p>
<ul>
<li>第 0 个项表示正则表达式捕获的文本</li>
<li>第 1~n 项表示第 1~n 个反向引用, 依次指向第 1~n 个分组捕获的文本, 可以使用RegExp.$ + “编号1~n”  依次获取分组中的文本</li>
<li>index 表示匹配字符串的初始位置</li>
<li>input 表示正在检索的字符串</li>
</ul>
<p>无论正则表达式有无全局标示”g”, exec 的表现都相同. 但正则表达式对象的表现却有些不同. 下面我们来详细说明下正则表达式对象的表现都有哪些不同.</p>
<p>假设正则表达式对象为 reg , 检测的字符为 string , reg.exec(string) 返回值为 array.</p>
<p>若 reg 包含全局标示”g”, 那么 reg.lastIndex 属性表示原字符串中匹配的字符串末尾的后一个位置, 即下次匹配开始的位置, 此时 reg.lastIndex == array.index(匹配开始的位置) + array[0].length(匹配字符串的长度). 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> reg = <span class="regexp">/([a-z]+)/gi</span>,</div><div class="line">    string = <span class="string">"World Internet Conference"</span>;</div><div class="line"><span class="keyword">var</span> array = reg.exec(string);</div><div class="line"><span class="built_in">console</span>.log(array);<span class="comment">//["World", "World", index: 0, input: "World Internet Conference"]</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">1</span>);<span class="comment">//World</span></div><div class="line"><span class="built_in">console</span>.log(reg.lastIndex);<span class="comment">//5, 刚好等于 array.index + array[0].length</span></div></pre></td></tr></table></figure>
<p>随着检索继续, array.index 的值将往后递增, 也就是说, reg.lastIndex 的值也会同步往后递增. 因此, 我们也可以通过反复调用 exec 方法来遍历字符串中所有的匹配文本. 直到 exec 方法再也匹配不到文本时, 它将返回 null, 并把 reg.lastIndex 属性重置为 0. </p>
<p>接着上述例子, 我们继续执行代码, 看看上面说的对不对, 如下所示:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">array = reg.exec(string);</div><div class="line"><span class="built_in">console</span>.log(array);<span class="comment">//["Internet", "Internet", index: 6, input: "World Internet Conference"]</span></div><div class="line"><span class="built_in">console</span>.log(reg.lastIndex);<span class="comment">//14</span></div><div class="line"></div><div class="line">array = reg.exec(string);</div><div class="line"><span class="built_in">console</span>.log(array);<span class="comment">//["Conference", "Conference", index: 15, input: "World Internet Conference"]</span></div><div class="line"><span class="built_in">console</span>.log(reg.lastIndex);<span class="comment">//25</span></div><div class="line"></div><div class="line">array = reg.exec(string);</div><div class="line"><span class="built_in">console</span>.log(array);<span class="comment">//null</span></div><div class="line"><span class="built_in">console</span>.log(reg.lastIndex);<span class="comment">//0</span></div></pre></td></tr></table></figure>
<p>以上代码中, 随着反复调用 exec 方法, reg.lastIndex 属性最终被重置为 0.</p>
<p><strong>问题回顾</strong></p>
<p>在 test 方法的讲解中, 我们留下了一个问题. 如果正则表达式带有全局标志g, 以上 test 方法的执行结果将受 reg.lastIndex影响, 不仅如此, exec 方法也一样. 由于 reg.lastIndex 的值并不总是为零, 并且它决定了下次匹配开始的位置, 如果在一个字符串中完成了一次匹配之后要开始检索新的字符串, 那就必须要手动地把 lastIndex 属性重置为 0. 避免出现下面这种错误:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> reg = <span class="regexp">/[0-9]+/g</span>,</div><div class="line">    str1 = <span class="string">"123abc"</span>,</div><div class="line">    str2 = <span class="string">"123456"</span>;</div><div class="line">reg.exec(str1);</div><div class="line"><span class="built_in">console</span>.log(reg.lastIndex);<span class="comment">//3</span></div><div class="line"><span class="keyword">var</span> array = reg.exec(str2);</div><div class="line"><span class="built_in">console</span>.log(array);<span class="comment">//["456", index: 3, input: "123456"]</span></div></pre></td></tr></table></figure>
<p>以上代码, 正确执行结果应该是 “123456”,  因此建议在第二次执行 exec 方法前, 增加一句 “reg.lastIndex = 0;”.</p>
<p>若 reg 不包含全局标示”g”, 那么 exec 方法的执行结果(array)将与 string.match(reg) 方法执行结果完全相同.</p>
<h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p>match, search, replace, split 方法请参考 <a href="http://louiszhai.github.io/2016/01/12/js.String/"><code>字符串常用方法</code></a> 中的讲解.</p>
<p>如下展示了使用捕获性分组处理文本模板, 最终生成完整字符串的过程:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> tmp = <span class="string">"An $&#123;a&#125; a $&#123;b&#125; keeps the $&#123;c&#125; away"</span>;</div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">a</span>:<span class="string">"apple"</span>,</div><div class="line">  <span class="attr">b</span>:<span class="string">"day"</span>,</div><div class="line">  <span class="attr">c</span>:<span class="string">"doctor"</span></div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">tmpl</span>(<span class="params">t,o</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> t.replace(<span class="regexp">/\$&#123;(.)&#125;/g</span>,<span class="function"><span class="keyword">function</span>(<span class="params">m,p</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'m:'</span>+m+<span class="string">' p:'</span>+p);</div><div class="line">    <span class="keyword">return</span> o[p];</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line">tmpl(tmp,obj);</div></pre></td></tr></table></figure>
<p>上述功能使用ES6可这么实现:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">a</span>:<span class="string">"apple"</span>,</div><div class="line">  <span class="attr">b</span>:<span class="string">"day"</span>,</div><div class="line">  <span class="attr">c</span>:<span class="string">"doctor"</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">with</span>(obj)&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">`An <span class="subst">$&#123;a&#125;</span> a <span class="subst">$&#123;b&#125;</span> keeps the <span class="subst">$&#123;c&#125;</span> away`</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="正则表达式在H5中的应用"><a href="#正则表达式在H5中的应用" class="headerlink" title="正则表达式在H5中的应用"></a>正则表达式在H5中的应用</h3><p>H5中新增了 pattern 属性, 规定了用于验证输入字段的模式, pattern的模式匹配支持正则表达式的书写方式. 默认 pattern 属性是全部匹配, 即无论正则表达式中有无 “^”, “$” 元字符, 它都是匹配所有文本.</p>
<p>注: pattern 适用于以下 input 类型：text, search, url, telephone, email 以及 password. 如果需要取消表单验证, 在form标签上增加 novalidate 属性即可.</p>
<h3 id="正则引擎"><a href="#正则引擎" class="headerlink" title="正则引擎"></a>正则引擎</h3><p>目前正则引擎有两种, DFA 和 NFA, NFA又可以分为传统型NFA和POSIX NFA.</p>
<ul>
<li>DFA Deterministic finite automaton 确定型有穷自动机</li>
<li>NFA Non-deterministic finite automaton　非确定型有穷自动机</li>
<li>Traditional NFA</li>
<li>POSIX NFA</li>
</ul>
<p>DFA引擎不支持回溯, 匹配快速, 并且不支持捕获组, 因此也就不支持反向引用. 上述awk, egrep命令均支持 DFA引擎. </p>
<p>POSIX NFA主要指符合POSIX标准的NFA引擎, 像 javaScript, java, php, python, c#等语言均实现了NFA引擎.</p>
<p>有关正则表达式详细的匹配原理, 暂时没在网上看到适合的文章, 建议选读 Jeffrey Friedl 的 &lt;精通正则表达式&gt;[第三版] 中第4章-表达式的匹配原理(p143-p183), Jeffrey Friedl 对正则表达式有着深刻的理解, 相信他能够帮助您更好的学习正则.</p>
<p>有关NFA引擎的简单实现, 可以参考文章 <a href="http://www.cnblogs.com/catch/p/3722082.html" target="_blank" rel="external">基于ε-NFA的正则表达式引擎 - twoon</a>.</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在学习正则的初级阶段, 重在理解 ①贪婪与非贪婪模式, ②分组, ③捕获性与非捕获性分组, ④命名分组, ⑤固化分组, 体会设计的精妙之处. 而高级阶段, 主要在于熟练运用⑥零宽断言(或环视)解决问题, 并且熟悉正则匹配的原理. </p>
<p>实际上, 正则在 javaScript 中的功能不算强大, js 仅仅支持了①贪婪与非贪婪模式, ②分组, ③捕获性与非捕获性分组 以及 ⑥零宽断言中的顺序环视. 如果再稍微熟悉些 js 中7种与正则有关的方法(compile, test, exec, match, search, replace, split), 那么处理文本或字符串将游刃有余.</p>
<p>正则表达式, 在文本处理方面天赋异禀, 它的功能十分强大, 很多时候甚至是唯一解决方案. 正则不局限于js, 当下热门的编辑器(比如Sublime, Atom) 以及 IDE(比如WebStorm, IntelliJ IDEA) 都支持它. 您甚至可以在任何时候任何语言中, 尝试使用正则解决问题, 也许之前不能解决的问题, 现在可以轻松的解决.</p>
<p>附其他语言正则资料:</p>
<ul>
<li><a href="http://wiki.ubuntu.org.cn/Python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97" target="_blank" rel="external">Python正则表达式操作指南</a></li>
<li><a href="http://blog.csdn.net/allwefantasy/article/details/3136570/" target="_blank" rel="external">java正则表达式</a></li>
</ul>
<hr>
<p>本文就讨论这么多内容,大家有什么问题或好的想法欢迎在下方参与<a href="#respond">留言和评论</a>.</p>
<p>本文作者: <a href="https://github.com/Louiszhai" target="_blank" rel="external">louis</a></p>
<p>本文简介: 本文断断续续历时两个月而成, 共计12k字, 为求简洁全面地还原前端场景中正则的使用规律, 搜集了大量正则相关资料, 并剔除不少冗余字句, 码字不易, 喜欢的请点个赞👍或者收藏, 我将持续保持更新.</p>
<p>本文链接: <a href="http://louiszhai.github.io/2016/06/13/regular/">http://louiszhai.github.io/2016/06/13/regular/</a></p>
<p>参考文章</p>
<ul>
<li>Jeffrey Friedl 的 &lt;精通正则表达式&gt;[第三版]</li>
<li><a href="http://blog.csdn.net/fdl19881/article/details/7800877" target="_blank" rel="external">linux shell 正则表达式(BREs,EREs,PREs)差异比较</a></li>
<li><a href="http://www.jb51.net/article/28035.htm" target="_blank" rel="external">正则表达式之捕获组/非捕获组介绍_正则表达式_脚本之家</a></li>
<li><a href="http://www.cnblogs.com/kissdodog/archive/2013/04/22/3036649.html" target="_blank" rel="external">正则表达式(一) – 元字符 - 逆心 - 博客园</a></li>
<li><a href="http://blog.csdn.net/hguisu/article/details/8244560" target="_blank" rel="external">正则表达式详解 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET</a></li>
<li><a href="http://www.cnblogs.com/taek/archive/2012/02/08/2342741.html" target="_blank" rel="external">正则表达式之固化分组 - taek - 博客园</a></li>
<li><a href="http://www.jb51.net/article/31491.htm" target="_blank" rel="external">正则表达式之 贪婪与非贪婪模式详解（概述）_正则表达式_脚本之家</a></li>
<li><a href="http://blog.csdn.net/nebula1982/article/details/6659702" target="_blank" rel="external">JAVASCRIPT 正则表达式学习–&gt;基础与零宽断言（转自司徒正美） - 随风之羽 - 博客频道 - CSDN.NET</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/12/unicode.html" target="_blank" rel="external">Unicode与JavaScript详解 - 阮一峰的网络日志</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      regexp 正则表达式 反向引用 贪婪模式 非贪婪模式 元字符 字符组 限定符 操作符 ES6扩展 固化分组 占有量词优先 环视 顺序环视 逆序环视
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>详解IE7以下独有的hasLayout</title>
    <link href="http://louiszhai.github.io/2016/03/31/css-hasLayout/"/>
    <id>http://louiszhai.github.io/2016/03/31/css-hasLayout/</id>
    <published>2016-03-31T05:57:56.000Z</published>
    <updated>2017-04-17T02:54:08.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是hasLayout"><a href="#什么是hasLayout" class="headerlink" title="什么是hasLayout"></a>什么是hasLayout</h3><blockquote>
<p>hasLayout property: Gets a value that indicates whether the object has layout.</p>
</blockquote>
<p><strong>hasLayout</strong> 是IE渲染引擎的一个内部实现. IE中, 一个元素要么自己计算大小组织内容(自己渲染), 要么依赖父元素来计算大小和组织内容(依赖祖先元素渲染). 为了区分两者, 渲染引擎采用了 hasLayout 属性, 该属性可以设置为 true 或 false. 若一个元素的 hasLayout 属性值为 true 时, 这个元素便拥有了一个布局(layout), 该元素便不在依赖某个祖先元素进行渲染, 而是它自己就去渲染自己了, 它会负责对自己和可能的子孙元素进行尺寸计算和定位, 这意味着这个元素需要花更多的代价来维护自身和里面的内容; 相反的, 若元素的 hasLayout 属性值为 false时, 它会直接依赖于某个祖先元素来完成这些工作, 最终造成很多的IE bugs.</p>
<a id="more"></a>
<h3 id="默认情况下hasLayout-true的元素"><a href="#默认情况下hasLayout-true的元素" class="headerlink" title="默认情况下hasLayout=true的元素"></a>默认情况下hasLayout=true的元素</h3><p>下列元素默认拥有 layout:</p>
<ul>
<li>html body</li>
<li>table tr th td</li>
<li>img</li>
<li>hr</li>
<li>input button file select textarea fieldset</li>
<li>marquee</li>
<li>frameset frame iframe </li>
<li>objects applets embed</li>
</ul>
<h3 id="怎么触发及清除-hasLayout"><a href="#怎么触发及清除-hasLayout" class="headerlink" title="怎么触发及清除 hasLayout"></a>怎么触发及清除 hasLayout</h3><p>以下css样式的设置, 会触发元素的 hasLayout:</p>
<ul>
<li><em>position: absolute</em>(IE5+)</li>
<li><em>float: left|right</em>(IE5+)</li>
<li><em>display: inline-block</em>(IE5+)</li>
<li><em>width|height: “auto”以外的任何值</em>(IE5+; 只对block元素有效)</li>
<li><em>zoom: “normal”以外的任何值</em>(IE5.5+; IE私有属性)</li>
<li><em>writing-mode: tb-rl</em>(IE5+; IE私有属性)</li>
<li><em>overflow: hidden|scroll|auto</em>(IE7; 此属性在IE6及更早版本中不能应用在未触发hasLayout的元素上)</li>
<li><em>overflow-x|-y: hidden|scroll|auto</em>(IE7; 此属性在IE6及更早版本中不触发hasLayout; 此属性在CSS3中才获支持)</li>
<li><em>position: fixed</em>(IE7)</li>
<li><em>min-width: 任何值</em>(IE7; 即使是0)</li>
<li><em>max-width: “none”以外的任何值</em>(IE7)</li>
<li><em>min-height: 任何值</em>(IE7)</li>
<li><em>max-height: “none”以外的任何值</em>(IE7)</li>
<li><em>position: fixed</em>(IE7)</li>
</ul>
<p>以下css样式的设置, 会清除已经触发的 hasLayout:</p>
<ul>
<li><em>position: static</em>(IE5+)</li>
<li><em>float: none</em>(IE5+)</li>
<li><em>display: “inline-block”以外的任何值</em>(IE5+)</li>
<li><em>width|height: “auto”</em>(IE5+; 对inline元素无效)</li>
<li><em>zoom: “normal”</em>(IE5.5+; IE私有属性)</li>
<li><em>writing-mode: 从’tb-rl’到’lr-tb’</em>(IE5+; IE私有属性)</li>
<li><em>max-width|max-height: “none”</em>(IE7)</li>
<li><em>overflow: visible</em>(IE7)</li>
</ul>
<h3 id="hasLayout-的影响"><a href="#hasLayout-的影响" class="headerlink" title="hasLayout 的影响"></a>hasLayout 的影响</h3><ol>
<li><strong>浮动元素可以被 layout 元素自动包含</strong>. 一般情况下, 由于浮动元素脱离普通文档流会造成父元素的坍塌. 但是在IE6-7下, 通过触发父元素的 hasLayout, 可以使得父元素自动包含浮动的子元素, 从而修复坍塌问题. 一般我们设置父元素的 *height:1%; 即可, 1%并不会改变实际高度, 只是触发了 hasLayout, 该方法被称为霍莉破解(Holly hack), 需要注意的是, 当这个元素的 overflow 属性被设置为 visible 时, 这个方法就失效了.</li>
<li>正常情况下, 浮动元素旁边的元素, 其内容应该环绕该浮动元素. 如果这个元素拥有 layout, 那么这个元素就会表现为一个矩形, 其内容不会环绕浮动元素.</li>
<li>IE独有的滤镜属性(filter) 只适用于 layout 元素, 若一个div 设置了<strong>filter:alpha(opacity=90)</strong>, 又没有触发该div 的 hasLayout, 那么透明的设置将无效.</li>
<li>hasLayout 影响块级元素鼠标的响应区域, 通常 hasLayout=false时, 只有文字区域才有响应, 而 hasLayout=true 时, 整个块级元素都是可以响应的.</li>
</ol>
<h3 id="hasLayout-引起的bug"><a href="#hasLayout-引起的bug" class="headerlink" title="hasLayout 引起的bug"></a>hasLayout 引起的bug</h3><ol>
<li>IE6 及更低版本的双空白边浮动 bug, 修复方案: display:inline;</li>
<li>IE5-6的 3 像素偏移 bug, 修复方案: _height:1%;</li>
<li>IE6 的躲躲猫(peek-a-boo) bug, 修复方案: _height:1%;</li>
<li>IE6-7负margin隐藏Bug, 修复方案: 去掉父元素的hasLayout; 或者赋hasLayout给子元素, 并添加position:relative;</li>
</ol>
<h3 id="怎么检测IE下的某个元素是否拥有hasLayout"><a href="#怎么检测IE下的某个元素是否拥有hasLayout" class="headerlink" title="怎么检测IE下的某个元素是否拥有hasLayout"></a>怎么检测IE下的某个元素是否拥有hasLayout</h3><p>在 IE Developer Toolbar 下, 拥有 haslayout的元素, 通常显示为 “haslayout = -1”. 也可通过js的方式检测, 如下所示:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>);</div><div class="line"><span class="built_in">console</span>.log(element.currentStyle.hasLayout);<span class="comment">//该方式只能获取值, 而不能设置</span></div></pre></td></tr></table></figure>
<p>以下代码可用于在IE6-7下测试某个元素是否拥有hasLayout:</p>
<p>Code example: <a href="http://samples.msdn.microsoft.com/workshop/samples/author/dhtml/refs/hasLayout.htm" target="_blank" rel="external">http://samples.msdn.microsoft.com/workshop/samples/author/dhtml/refs/hasLayout.htm</a></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span> </div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> </div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span> </div><div class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>hasLayout Property<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span> </div><div class="line"> </div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> </div><div class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>hasLayout Property<span class="tag">&lt;/<span class="name">h1</span>&gt;</span> </div><div class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>This example uses the <span class="tag">&lt;<span class="name">strong</span>&gt;</span>hasLayout<span class="tag">&lt;/<span class="name">strong</span>&gt;</span> property of the <span class="tag">&lt;<span class="name">strong</span>&gt;</span>currentStyle<span class="tag">&lt;/<span class="name">strong</span>&gt;</span> object to  </div><div class="line">    show that an element has layout when it is absolutely positioned, or when its height and/or width are specified.   </div><div class="line">    The <span class="tag">&lt;<span class="name">strong</span>&gt;</span>hasLayout<span class="tag">&lt;/<span class="name">strong</span>&gt;</span> property returns <span class="tag">&lt;<span class="name">strong</span>&gt;</span>true<span class="tag">&lt;/<span class="name">strong</span>&gt;</span> for an object that has layout, and  </div><div class="line">    <span class="tag">&lt;<span class="name">strong</span>&gt;</span>false<span class="tag">&lt;/<span class="name">strong</span>&gt;</span> for an object that has no layout.<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </div><div class="line">  <span class="tag">&lt;<span class="name">fieldset</span> <span class="attr">style</span>=<span class="string">"width: 50%; text-align: center;"</span>&gt;</span> </div><div class="line">    <span class="tag">&lt;<span class="name">legend</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>hasLayout<span class="tag">&lt;/<span class="name">strong</span>&gt;</span> Property<span class="tag">&lt;/<span class="name">legend</span>&gt;</span> </div><div class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"text-align: left;"</span>&gt;</span><span class="tag">&lt;<span class="name">em</span>&gt;</span>Which DIV element has layout?<span class="tag">&lt;/<span class="name">em</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span> </div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"oWidthSet"</span> <span class="attr">style</span>=<span class="string">"width: 100%; text-align: left;"</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>DIV<span class="tag">&lt;/<span class="name">strong</span>&gt;</span> element A has its <span class="tag">&lt;<span class="name">strong</span>&gt;</span>width<span class="tag">&lt;/<span class="name">strong</span>&gt;</span> set to <span class="tag">&lt;<span class="name">strong</span>&gt;</span>100%<span class="tag">&lt;/<span class="name">strong</span>&gt;</span>.<span class="tag">&lt;/<span class="name">div</span>&gt;</span> </div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"oNotSet"</span> <span class="attr">style</span>=<span class="string">"text-align: left;"</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>DIV<span class="tag">&lt;/<span class="name">strong</span>&gt;</span> element B is not positioned, and neither its <span class="tag">&lt;<span class="name">strong</span>&gt;</span>height<span class="tag">&lt;/<span class="name">strong</span>&gt;</span> nor <span class="tag">&lt;<span class="name">strong</span>&gt;</span>width<span class="tag">&lt;/<span class="name">strong</span>&gt;</span> is set.<span class="tag">&lt;/<span class="name">div</span>&gt;</span> </div><div class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span> </div><div class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"document.getElementById('messageBox').textContent = document.getElementById('oWidthSet').currentStyle.hasLayout;"</span>&gt;</span>DIV Element A<span class="tag">&lt;/<span class="name">button</span>&gt;</span> </div><div class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"document.getElementById('messageBox').textContent = document.getElementById('oNotSet').currentStyle.hasLayout;"</span>&gt;</span>DIV Element B<span class="tag">&lt;/<span class="name">button</span>&gt;</span> </div><div class="line">  <span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span> </div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"messageBox"</span> <span class="attr">style</span>=<span class="string">"padding-top: 1em; font-weight: bold;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span> </div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>另外, 若一个元素没有布局(layout), 那么IE下 clientWidth/clientHeight 总是返回0. 基于这点, 可以使用另一种js的方法检测元素是否拥有hasLayout, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(element.clientHeight==<span class="number">0</span>);<span class="comment">//等于true则表示该元素不拥有hasLayout</span></div></pre></td></tr></table></figure>
<h3 id="需要注意的是"><a href="#需要注意的是" class="headerlink" title="需要注意的是"></a>需要注意的是</h3><ul>
<li>hasLayout 功能只存在于IE7及低版本的浏览器上, IE8中已删除 hasLayout 功能.</li>
<li>hasLayout 触发后, 没有办法直接设置 hasLayout=false, 只有将那些触发 hasLayout 的 css 属性去除, 才能恢复原样.</li>
</ul>
<hr>
<p>本文就讨论这么多内容,大家有什么问题或好的想法欢迎在下方参与<a href="#respond">留言和评论</a>.</p>
<p>本文作者: <a href="https://github.com/Louiszhai" target="_blank" rel="external">louis</a></p>
<p>本文链接: <a href="http://louiszhai.github.io/2016/03/31/css-hasLayout/">http://louiszhai.github.io/2016/03/31/css-hasLayout/</a></p>
<p>参考文章</p>
<ul>
<li><a href="https://msdn.microsoft.com/library/ms530751(v=vs.85).aspx" target="_blank" rel="external">display property (Internet Explorer)</a></li>
<li><a href="http://blog.csdn.net/hedong37518585/article/details/6639263" target="_blank" rel="external">hasLayout 介绍，以及其触发条件 - 何东狮吼 - 博客频道 - CSDN.NET</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_50502064010135lr.html" target="_blank" rel="external">认识hasLayout——IE6、7浏览器css bug的一大罪恶根源_ICER_JIN_新浪博客</a></li>
<li><a href="https://msdn.microsoft.com/zh-cn/data/ms530764" target="_blank" rel="external">hasLayout property (Internet Explorer)</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      css IE6 IE7 hasLayout
    
    </summary>
    
    
      <category term="css" scheme="http://louiszhai.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>你不知道的margin属性</title>
    <link href="http://louiszhai.github.io/2016/03/23/css-margin/"/>
    <id>http://louiszhai.github.io/2016/03/23/css-margin/</id>
    <published>2016-03-23T12:47:36.000Z</published>
    <updated>2017-04-17T02:54:08.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h3><p>margin属性处于盒子模型的最外层, 用以隔开其他元素, 它可以依次设置4个长度值, 分别表示 “上 右 下 左” 的间距, 其中第1个和第3个值相对应, 第2个与第4个相对应, 如果省略前者, 后者将取与前者相同的数值. margin属性共存在以下 4 种表示方式:</p>
<ul>
<li>margin: 10px 1rem 1em 5%; 共 4 个数值, 表示依次设置 上, 右, 下, 左的间距;</li>
<li>margin: 10px 1rem 1em; 共 3 个数值, 省略第4个值, 左间距将取右间距的值, 表示依次设置 上, 左右, 下的间距;</li>
<li>margin: 10px 1rem; 共 2 个数值, 省略第3,4个值, 左间距将取右间距的值, 下间距将取上间距的值, 表示依次设置 上下, 左右的间距;</li>
<li>margin: 10px; 共 1 个数值, 同时省略第2,3,4个值, 表示上下左右的间距均为10px;</li>
</ul>
<p>若是块级元素, 借助 margin:0 auto; 即可实现水平居中.</p>
<p>看到这里, 你可能会觉得这些你都懂了, 这不要紧, 显然本文也不是为了科普margin的基础语法, 请往下看.</p>
<a id="more"></a>
<h3 id="垂直外边距合并问题"><a href="#垂直外边距合并问题" class="headerlink" title="垂直外边距合并问题"></a>垂直外边距合并问题</h3><p>别被上面这个名词给吓倒了, 简单地说, 外边距合并指的是, 当两个垂直外边距相遇时, 它们将形成一个外边距. 合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者. 你可以查看<a href="http://www.w3school.com.cn/css/css_margin_collapsing.asp" target="_blank" rel="external">W3Shool CSS外边距合并</a>了解这个基本知识.</p>
<p>实际工作中, 垂直外边距合并问题常见于第一个子元素的margin-top会顶开父元素与父元素相邻元素的间距, 而且只在标准浏览器下(FirfFox、Chrome、Opera、Sarfi)产生问题, IE下反而表现良好.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></div><div class="line">  <span class="selector-class">.outer-box</span>&#123;</div><div class="line">  	<span class="attribute">margin-top</span>:<span class="number">15px</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="selector-class">.inner-box</span>&#123;</div><div class="line">  	<span class="attribute">margin-top</span>:<span class="number">30px</span>;</div><div class="line">  &#125;</div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"outer-box"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"inner-box"</span>&gt;</span>1234567890<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>打开控制台, 你会发现内部div距离顶部的距离是30px, 而不是45px, 这是因为内部div与外部div的margin-top属性做了合并, 取两者中的最大值, 即 30px.</p>
<p>如果按照CSS规范, IE的“良好表现”其实是一个错误的表现, 因为IE的hasLayout渲染导致了这个“表现良好”的外观. 而其他标准浏览器则会表现出“有问题”的外观. 好了, 如果你读过了上面W3Shcool的CSS外边距合并的文章后, 就很容易讨论这个问题了. 这个问题发生的原因是<strong>根据规范, 一个盒子如果没有上补白(padding-top)和上边框(border-top), 那么这个盒子的上边距会和其内部文档流中的第一个子元素的上边距重叠</strong>.</p>
<p>基于此, 该问题便很好解决了, 给外部div设置一个透明的1像素的border-top即可.</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.outer-box</span>&#123;</div><div class="line">  <span class="attribute">margin-top</span>:<span class="number">15px</span>;</div><div class="line">  <span class="attribute">border-top</span>:<span class="number">1px</span> solid transparent;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="margin是否对内联元素生效"><a href="#margin是否对内联元素生效" class="headerlink" title="margin是否对内联元素生效?"></a>margin是否对内联元素生效?</h3><p>margin也能用于内联元素, 这是规范所允许的, 但是margin-top和margin-bottom对内联元素（对行）的高度没有影响, 并且由于边界效果(margin效果)是透明的, 他也没有任何的视觉影响.</p>
<p>这是因为边界应用于内联元素时不改变元素的行高度，如果你要改变内联元素的行高即类似文本的行间距, 那么你只能使用这三个属性: line-height, fong-size, vertical-align. 请记住, 这个影响内联元素高度的是line-height而不是height, 因为内联元素是一行行的, 定一个height的话, 那这到底是整段inline元素的高呢? 还是inline元素一行的高呢? 这都说不准, 所以统一都给每行定一个高, 只能是line-height了.</p>
<p><strong>margin-top/margin-bottom对内联元素没有实际效果, 不过margin-left/margin-right还是能够对内联元素产生影响的</strong>. 应用margin:10px 20px 30px 40px;, 左边这个css如果写在inline元素上, 他的效果大致是, 上下无效果, 左边离他相邻元素或者文本距离为40px, 右边离他相邻元素或者文本距离为20px.</p>
<h3 id="有关margin的常见bug"><a href="#有关margin的常见bug" class="headerlink" title="有关margin的常见bug"></a>有关margin的常见bug</h3><p>下面罗列一下常见的有关margin的bug, 可能不全, 非常欢迎交流探讨, 请在<a href="#respond">回复</a>中补充.</p>
<h4 id="IE6中浮动元素3px间隔Bug"><a href="#IE6中浮动元素3px间隔Bug" class="headerlink" title="IE6中浮动元素3px间隔Bug"></a>IE6中浮动元素3px间隔Bug</h4><p>发生场景: 发生在一个元素浮动，然后一个不浮动的元素自然上浮与之靠近会出现的3px的bug.<br>解决方法: 右边元素也一起浮动; 或者为右边元素添加IE6 Hack “_margin-left:-3px;” 从而消除3px间距.<br>原因分析：IE6浏览器缺陷Bug.</p>
<h4 id="inline-block元素之间空白Bug"><a href="#inline-block元素之间空白Bug" class="headerlink" title="inline-block元素之间空白Bug"></a>inline-block元素之间空白Bug</h4><p>发生场景: IE8+、Chrome、Firefox、Safari等浏览器下的效果, 两个inline-block的元素之间会存在一定的空白间距, 空白间距的宽度与父元素的font-size大小有关.</p>
<p>解决方法: 可以为inline-block元素设置为负的margin-left; 或父元素font-size设置为0, 子元素再重新设置回来, 如需兼容所有浏览器, 请参考 <a href="http://louiszhai.github.io/2016/03/27/css-inline-block/">inline-block空白间距解决方案探讨</a>.</p>
<p>原因分析: HTML 中的换行符、空格符、制表符等合并为空白符, 字体大小不为 0 的情况下, 空白符自然占据一定的宽度, 因此产生了元素间的空隙.</p>
<h4 id="IE6-7负margin隐藏Bug"><a href="#IE6-7负margin隐藏Bug" class="headerlink" title="IE6/7负margin隐藏Bug"></a>IE6/7负margin隐藏Bug</h4><p>发生场景: 当给一个有hasLayout的父元素内的非hasLayout元素设置负margin时, 超出父元素部分不可见.<br>解决方法: 去掉父元素的hasLayout; 或者赋hasLayout给子元素,并添加position:relative;<br>原理分析: IE6/7独有的hasLayout产生问题.</p>
<h4 id="IE6-7下ul-ol标记消失bug"><a href="#IE6-7下ul-ol标记消失bug" class="headerlink" title="IE6/7下ul/ol标记消失bug"></a>IE6/7下ul/ol标记消失bug</h4><p>发生场合: 当ul/ol触发了haslayout并且是在ul/ol上写margin-left, 前面默认的ul/ol标记会消失.<br>解决方法: 给li设置margin-left, 而不是给ul/ol设置margin-left.<br>原因分析：IE6/7浏览器Bug.</p>
<h4 id="IE6-7下margin与absolute元素重叠bug"><a href="#IE6-7下margin与absolute元素重叠bug" class="headerlink" title="IE6/7下margin与absolute元素重叠bug"></a>IE6/7下margin与absolute元素重叠bug</h4><p>发生场景: 双栏自适应布局中, 左侧元素absolute绝对定位, 右侧的margin撑开距离定位. 在IE6/7下左侧应用了absolute属性的块级元素与右边的自适应的文字内容重叠.<br>解决方法: 把左侧块级元素更改为内联元素, 比如把div更换为span.<br>原因分析: 这是由于IE6-7浏览器将inline水平标签元素和block水平的标签元素没有加以区分一视同仁渲染了. 属于IE6-7浏览器渲染Bug.</p>
<h4 id="IE6-7-8下auto-margin居中bug"><a href="#IE6-7-8下auto-margin居中bug" class="headerlink" title="IE6/7/8下auto margin居中bug"></a>IE6/7/8下auto margin居中bug</h4><p>发生场景: 给block元素设置margin auto无法居中<br>解决方法: 出现这种bug的原因通常是没有Doctype, 然后触发了ie的quirks mode, 加上Doctype声明就可以了. 在《打败IE的葵花宝典》里给出的方法是给block元素添加一个width能够解决, 但据测试, 加with此种方法是无效的, 如果没有Doctype即使给元素添加width也无法让block元素居中.<br>原因分析: 缺少Doctype声明.</p>
<h4 id="IE8下input-button-submit-设置margin-0-auto无法居中"><a href="#IE8下input-button-submit-设置margin-0-auto无法居中" class="headerlink" title="IE8下input[button | submit] 设置margin:0 auto无法居中"></a>IE8下input[button | submit] 设置margin:0 auto无法居中</h4><p>发生场景: ie8下, 如果给像button这样的标签（如button input[type=”button”] input[type=”submit”]）设置{ display: block; margin:0 auto; }如果不设置宽度的话无法居中.<br>解决方法: 可以给为input加上宽度.<br>原因分析: IE8浏览器Bug.</p>
<h4 id="IE8百分比padding垂直margin-bug"><a href="#IE8百分比padding垂直margin-bug" class="headerlink" title="IE8百分比padding垂直margin bug"></a>IE8百分比padding垂直margin bug</h4><p>发生场景: 当父元素设置了百分比的padding, 子元素有垂直的margin的时候, 就好像父元素被设置了margin一样.<br>解决方法: 给父元素加一个overflow:hidden/auto。<br>原因分析: IE8浏览器Bug.</p>
<hr>
<p>本文就讨论这么多内容,大家有什么问题或好的想法欢迎在下方参与<a href="#respond">留言和评论</a>.</p>
<p>本文作者: <a href="https://github.com/Louiszhai" target="_blank" rel="external">louis</a></p>
<p>本文链接: <a href="http://louiszhai.github.io/2016/03/23/css-margin/">http://louiszhai.github.io/2016/03/23/css-margin/</a></p>
<p>参考文章</p>
<ul>
<li><a href="http://www.hicss.net/do-not-tell-me-you-understand-margin/" target="_blank" rel="external">不要告诉我你懂margin</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      css margin margin-left margin-top margin-right margin-bottom
    
    </summary>
    
    
      <category term="css" scheme="http://louiszhai.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>16种方法实现水平居中垂直居中</title>
    <link href="http://louiszhai.github.io/2016/03/12/css-center/"/>
    <id>http://louiszhai.github.io/2016/03/12/css-center/</id>
    <published>2016-03-12T11:03:04.000Z</published>
    <updated>2017-04-20T02:41:44.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h3><p>熟悉水平居中和垂直居中的方法, 不为别的, 就为用的时候能够信手拈来. 下面直接步入正题.</p>
<a id="more"></a>
<h3 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h3><p>1) 若是行内元素, 给其父元素设置 text-align:center,即可实现行内元素水平居中.</p>
<p>2) 若是块级元素, 该元素设置 margin:0 auto即可.</p>
<p>3) 若子元素包含 float:left 属性, 为了让子元素水平居中, 则可让父元素宽度设置为fit-content,并且配合margin, 作如下设置:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.parent</span>&#123;</div><div class="line">  	<span class="attribute">width</span>: -moz-fit-content;</div><div class="line">	<span class="attribute">width</span>: -webkit-fit-content;</div><div class="line">	<span class="attribute">width</span>:fit-content;</div><div class="line">	<span class="attribute">margin</span>:<span class="number">0</span> auto;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>fit-content是CSS3中给width属性新加的一个属性值,它配合margin可以轻松实现水平居中, 目前只支持Chrome 和 Firefox浏览器.</p>
<p>4) 使用flex 2012年版本布局, 可以轻松的实现水平居中, 子元素设置如下:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.son</span>&#123;</div><div class="line">	<span class="attribute">display</span>: flex;</div><div class="line">	<span class="attribute">justify-content</span>: center;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>5) 使用flex 2009年版本, 父元素display: box;box-pack: center;如下设置:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.parent</span> &#123;</div><div class="line">	<span class="attribute">display</span>: -webkit-box;</div><div class="line">	<span class="attribute">-webkit-box-orient</span>: horizontal;</div><div class="line">	<span class="attribute">-webkit-box-pack</span>: center;</div><div class="line">	<span class="attribute">display</span>: -moz-box;</div><div class="line">	<span class="attribute">-moz-box-orient</span>: horizontal;</div><div class="line">	<span class="attribute">-moz-box-pack</span>: center;</div><div class="line">	<span class="attribute">display</span>: -o-box;</div><div class="line">  	<span class="attribute">-o-box-orient</span>: horizontal;</div><div class="line">  	<span class="attribute">-o-box-pack</span>: center;</div><div class="line">  	<span class="attribute">display</span>: -ms-box;</div><div class="line">  	<span class="attribute">-ms-box-orient</span>: horizontal;</div><div class="line">  	<span class="attribute">-ms-box-pack</span>: center;</div><div class="line">  	<span class="attribute">display</span>: box;</div><div class="line">  	<span class="attribute">box-orient</span>: horizontal;</div><div class="line">  	<span class="attribute">box-pack</span>: center;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>6) 使用CSS3中新增的transform属性, 子元素设置如下:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.son</span>&#123;</div><div class="line">	<span class="attribute">position</span>:absolute;</div><div class="line">  	<span class="attribute">left</span>:<span class="number">50%</span>;</div><div class="line">  	<span class="attribute">transform</span>:<span class="built_in">translate</span>(-50%,0);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>7) 使用绝对定位方式, 以及负值的margin-left, 子元素设置如下:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.son</span>&#123;</div><div class="line">	<span class="attribute">position</span>:absolute;</div><div class="line">	<span class="attribute">width</span>:固定;</div><div class="line">    <span class="attribute">left</span>:<span class="number">50%</span>;</div><div class="line">    <span class="attribute">margin-left</span>:-<span class="number">0.5</span>宽度;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>8) 使用绝对定位方式, 以及left:0;right:0;margin:0 auto; 子元素设置如下:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.son</span>&#123;</div><div class="line">	<span class="attribute">position</span>:absolute;</div><div class="line">	<span class="attribute">width</span>:固定;</div><div class="line">	<span class="attribute">left</span>:<span class="number">0</span>;</div><div class="line">	<span class="attribute">right</span>:<span class="number">0</span>;</div><div class="line">	<span class="attribute">margin</span>:<span class="number">0</span> auto;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h3><h4 id="单行文本"><a href="#单行文本" class="headerlink" title="单行文本"></a>单行文本</h4><p>1) 若元素是单行文本, 则可设置 line-height 等于父元素高度</p>
<h4 id="行内块级元素"><a href="#行内块级元素" class="headerlink" title="行内块级元素"></a>行内块级元素</h4><p>2) 若元素是行内块级元素, 基本思想是使用display: inline-block, vertical-align: middle和一个伪元素让内容块处于容器中央.</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.parent</span><span class="selector-pseudo">::after</span>, <span class="selector-class">.son</span>&#123;</div><div class="line">	<span class="attribute">display</span>:inline-block;</div><div class="line">	<span class="attribute">vertical-align</span>:middle;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.parent</span><span class="selector-pseudo">::after</span>&#123;</div><div class="line">	<span class="attribute">content</span>:<span class="string">''</span>;</div><div class="line">	<span class="attribute">height</span>:<span class="number">100%</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是一种很流行的方法, 也适应IE7.</p>
<h4 id="元素高度不定"><a href="#元素高度不定" class="headerlink" title="元素高度不定"></a>元素高度不定</h4><p>3) 可用 <strong>vertical-align</strong> 属性, 而vertical-align只有在父层为 td 或者 th 时, 才会生效, 对于其他块级元素, 例如 div、p 等, 默认情况是不支持的. 为了使用vertical-align, 我们需要设置父元素display:table, 子元素 display:table-cell;vertical-align:middle;</p>
<p><strong>优点</strong></p>
<p>元素高度可以动态改变, 不需再CSS中定义, 如果父元素没有足够空间时, 该元素内容也不会被截断.</p>
<p><strong>缺点</strong></p>
<p>IE6~7, 甚至IE8 beta中无效.</p>
<p>4) 可用 <strong>Flex 2012版</strong>, 这是CSS布局未来的趋势. Flexbox是CSS3新增属性, 设计初衷是为了解决像垂直居中这样的常见布局问题. 相关的文章如《<a href="http://louiszhai.github.io/2017/01/13/flex/">弹性盒模型Flex指南</a>》</p>
<p>父元素做如下设置即可保证子元素垂直居中:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.parent</span> &#123;</div><div class="line">  <span class="attribute">display</span>: flex;</div><div class="line">  <span class="attribute">align-items</span>: center;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>优点</strong></p>
<ul>
<li>内容块的宽高任意, 优雅的溢出.</li>
</ul>
<ul>
<li>可用于更复杂高级的布局技术中.</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>IE8/IE9不支持</li>
<li>需要浏览器厂商前缀</li>
<li>渲染上可能会有一些问题</li>
</ul>
<p>5) 使用flex 2009版.</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.parent</span> &#123;</div><div class="line">  	<span class="attribute">display</span>: box;</div><div class="line">  	<span class="attribute">box-orient</span>: vertical;</div><div class="line">  	<span class="attribute">box-pack</span>: center;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>优点</strong></p>
<p>实现简单, 扩展性强</p>
<p><strong>缺点</strong></p>
<p>兼容性差, 不支持IE</p>
<p>6) 可用 <strong>transform</strong> , 设置父元素相对定位(position:relative), 子元素如下css样式:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.son</span>&#123;</div><div class="line">	<span class="attribute">position</span>:absolute;</div><div class="line">	<span class="attribute">top</span>:<span class="number">50%</span>;</div><div class="line">	<span class="attribute">-webkit-transform</span>: <span class="built_in">translate</span>(-50%,-50%);  </div><div class="line">	<span class="attribute">-ms-transform</span>: <span class="built_in">translate</span>(-50%,-50%);</div><div class="line">	<span class="attribute">transform</span>: <span class="built_in">translate</span>(-50%,-50%);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>优点</strong></p>
<p>代码量少</p>
<p><strong>缺点</strong></p>
<p>IE8不支持, 属性需要追加浏览器厂商前缀, 可能干扰其他 transform 效果, 某些情形下会出现文本或元素边界渲染模糊的现象.</p>
<h4 id="元素高度固定"><a href="#元素高度固定" class="headerlink" title="元素高度固定"></a>元素高度固定</h4><p>7) 设置父元素相对定位(position:relative), 子元素如下css样式:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.son</span>&#123;</div><div class="line">	<span class="attribute">position</span>:absolute;</div><div class="line">	<span class="attribute">top</span>:<span class="number">50%</span>;</div><div class="line">	<span class="attribute">height</span>:固定;</div><div class="line">	<span class="attribute">margin-top</span>:-<span class="number">0.5</span>高度;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>优点</strong></p>
<p>适用于所有浏览器.</p>
<p><strong>缺点</strong></p>
<p>父元素空间不够时, 子元素可能不可见(当浏览器窗口缩小时,滚动条不出现时).如果子元素设置了overflow:auto, 则高度不够时, 会出现滚动条.</p>
<p>8) 设置父元素相对定位(position:relative), 子元素如下css样式:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.son</span>&#123;</div><div class="line">	<span class="attribute">position</span>:absolute;</div><div class="line">	<span class="attribute">height</span>:固定;</div><div class="line">	<span class="attribute">top</span>:<span class="number">0</span>;</div><div class="line">	<span class="attribute">bottom</span>:<span class="number">0</span>;</div><div class="line">	<span class="attribute">margin</span>:auto <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>优点</strong></p>
<p>简单</p>
<p><strong>缺点</strong></p>
<p>没有足够空间时, 子元素会被截断, 但不会有滚动条.</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>水平居中较为简单, 共提供了8种方法, 一般情况下 text-align:center,marin:0 auto; 足矣</p>
<ul>
<li>① text-align:center;</li>
</ul>
<ul>
<li>② margin:0 auto;</li>
<li>③ width:fit-content;</li>
<li>④ flex</li>
<li>⑤ 盒模型</li>
<li>⑥ transform</li>
<li>⑦ ⑧ 两种不同的绝对定位方法</li>
</ul>
<p>垂直居中, 共提供了8种方法.</p>
<ul>
<li>① 单行文本, line-height</li>
<li>② 行内块级元素, 使用 display: inline-block, vertical-align: middle; 加上伪元素辅助实现</li>
<li>③ vertical-align</li>
<li>④ flex</li>
<li>⑤ 盒模型</li>
<li>⑥ transform</li>
<li>⑦ ⑧ 两种不同的绝对定位方法</li>
</ul>
<p>我们发现, flex, 盒模型, transform, 绝对定位, 这几种方法同时适用于水平居中和垂直居中.</p>
<p>希望对大家有所帮助.</p>
<hr>
<p>本问就讨论这么多内容,大家有什么问题或好的想法欢迎在下方参与<a href="#respond">留言和评论</a>.</p>
<p>本文作者: <a href="https://github.com/Louiszhai" target="_blank" rel="external">louis</a></p>
<p>本文链接: <a href="http://louiszhai.github.io/2016/03/12/css-center/">http://louiszhai.github.io/2016/03/12/css-center/</a></p>
<p>参考文章</p>
<ul>
<li><a href="http://blog.csdn.net/freshlover/article/details/11579669" target="_blank" rel="external">盘点8种CSS实现垂直居中水平居中的绝对定位居中技术 - freshlover的专栏 - 博客频道 - CSDN.NET</a></li>
<li><a href="https://www.smashingmagazine.com/2013/05/centering-elements-with-flexbox/" target="_blank" rel="external">Designing CSS Layouts With Flexbox Is As Easy As Pie – Smashing Magazine</a></li>
<li><a href="http://www.w3cplus.com/css/elements-horizontally-center-with-css.html" target="_blank" rel="external">六种实现元素水平居中_水平居中, 垂直居中 教程_大漠</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      css 水平居中 垂直居中 fit-content flex translate line-height vertical-align
    
    </summary>
    
    
      <category term="CSS" scheme="http://louiszhai.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>float深入分析</title>
    <link href="http://louiszhai.github.io/2016/03/12/css-float/"/>
    <id>http://louiszhai.github.io/2016/03/12/css-float/</id>
    <published>2016-03-12T09:55:04.000Z</published>
    <updated>2017-04-17T02:54:08.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h3><p>float即浮动, 使用float, 该浮动元素便会脱离正常的文档流, 使其浮动到父元素的行的一端(元素向左或向右移动, 直到碰到浮动元素, 或者达到父元素内容的边界, 不包括padding), 并且其他元素将忽略该浮动元素并填补其原先的空间.</p>
<p>这里需要捋清一个概念, 所谓文档流是什么?</p>
<p><strong>文档流</strong>: 元素按照自上到下, 自左到右的顺序依次排放, 即文档流.</p>
<p>float特别适合这种图文混排, 文字环绕图片的效果, 布局上灵活多变. 但不太适合动画, 因其可能造成reflow性能问题, 此时宜用绝对定位(position:absolute)或者固定定位(position:fixed).</p>
<a id="more"></a>
<h3 id="float对布局的影响"><a href="#float对布局的影响" class="headerlink" title="float对布局的影响"></a>float对布局的影响</h3><h4 id="对行框的影响"><a href="#对行框的影响" class="headerlink" title="对行框的影响"></a>对行框的影响</h4><p>浮动元素旁边的行框被缩短, 从而给浮动框留出空间, 行框围绕浮动框.</p>
<p>因此, 创建浮动框可以使文本围绕图像, 如下:</p>
<p>float01.gif</p>
<p>float02.gif</p>
<h4 id="对父元素的影响"><a href="#对父元素的影响" class="headerlink" title="对父元素的影响"></a>对父元素的影响</h4><p>元素浮动后, 会脱离正常文档流, 原文档中, 该浮动元素似乎消失了, 因此它不能撑开父元素, 容易造成父元素的塌陷.</p>
<h4 id="对兄弟元素的影响"><a href="#对兄弟元素的影响" class="headerlink" title="对兄弟元素的影响"></a>对兄弟元素的影响</h4><p>若兄弟元素是 <strong>块级元素</strong>.</p>
<p>现代浏览器及IE8+下, 该兄弟元素会忽视浮动元素而占据它的位置, 并且该兄弟元素会处于浮动元素的下层(并且无法通过z-index属性改变他们的层叠关系), 然而它的内容文字和其他行内元将会环绕浮动元素.</p>
<p>对此, IE6,7分别有不同的表现. IE6,7中, 该兄弟元素会紧跟在浮动元素的右侧, 并且IE6中会保留3px的空隙; IE7中则没有空隙.</p>
<p>若兄弟元素是 <strong>内联元素</strong></p>
<p>则内联元素将环绕浮动元素排列.</p>
<h4 id="对兄弟元素-浮动-的影响"><a href="#对兄弟元素-浮动-的影响" class="headerlink" title="对兄弟元素(浮动)的影响"></a>对兄弟元素(浮动)的影响</h4><p>若兄弟元素是 <strong>同一方向浮动</strong>.</p>
<p>则兄弟元素相对该浮动元素按照从左到右(float:left)或者从右到左(float:right)的顺序依次排列.</p>
<p>若兄弟元素是 <strong>反方向浮动</strong>.</p>
<p>则兄弟元素和浮动元素将组成两个向左或向右的浮动队列, 分别相对浮动方向同时向行中间浮动. 他们尽可能处于同一行, 如果行的宽度不足以容纳这两个队列, 两个队列将错开成两行, DOM结构中处于之前的浮动队列将优先排在上面一行, 另一个浮动队列将排在下一行或者部分排在下一行.</p>
<h4 id="对自身元素的影响"><a href="#对自身元素的影响" class="headerlink" title="对自身元素的影响"></a>对自身元素的影响</h4><p>浮动元素默认被视作<strong>块级对象</strong>(block-level).</p>
<h4 id="对子元素的影响"><a href="#对子元素的影响" class="headerlink" title="对子元素的影响"></a>对子元素的影响</h4><p>浮动元素, 其高度或宽度取浮动子元素和非浮动子元素高度或宽度的最大值.</p>
<h4 id="对父元素非浮动兄弟元素的影响"><a href="#对父元素非浮动兄弟元素的影响" class="headerlink" title="对父元素非浮动兄弟元素的影响"></a>对父元素非浮动兄弟元素的影响</h4><p>父元素之外的非浮动元素将会无视该浮动元素, 他们只会相对父元素按照正常文档流去排列.</p>
<h4 id="对父元素浮动兄弟元素的影响"><a href="#对父元素浮动兄弟元素的影响" class="headerlink" title="对父元素浮动兄弟元素的影响"></a>对父元素浮动兄弟元素的影响</h4><p>父元素之外的浮动兄弟元素, 会本能的找到该浮动元素, 现象参照 “对兄弟元素(浮动)的影响”.</p>
<h3 id="清除浮动的2种方法"><a href="#清除浮动的2种方法" class="headerlink" title="清除浮动的2种方法"></a>清除浮动的2种方法</h3><p>如上, float会带来父元素的塌陷, 下面提供两种解决方案, 以弥补float的缺陷.</p>
<p>如下DOM, 由于子元素设置为float:left, 此时父元素并不会被撑大, 高度为0, 背景将无法展示.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></div><div class="line">	<span class="selector-class">.outer</span>&#123;</div><div class="line">		<span class="attribute">background</span>:<span class="number">#ccc</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="selector-class">.inner</span>&#123;</div><div class="line">		<span class="attribute">float</span>:left;</div><div class="line">		<span class="attribute">width</span>:<span class="number">150px</span>;</div><div class="line">		<span class="attribute">height</span>:<span class="number">100px</span>;</div><div class="line">		<span class="attribute">margin</span>:<span class="number">10px</span>;</div><div class="line">		<span class="attribute">border</span>:<span class="number">1px</span> solid red;</div><div class="line">	&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"outer"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"inner"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"inner"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"inner"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>IE6~7下可通过设置父元素的样式为zoom:1来清除浮动, 其他浏览器请参考如下两种方法清除浮动.</p>
<h4 id="overflow"><a href="#overflow" class="headerlink" title="overflow"></a>overflow</h4><p>父元素使用overflow:auto|hidden, 切记不可使用overflow:visible.</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.outer</span>&#123;</div><div class="line">	<span class="attribute">overflow</span>:auto|hidden;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="after伪类"><a href="#after伪类" class="headerlink" title="after伪类"></a>after伪类</h4><p>利用clear:both属性, 同时为避免加入dom元素, 使用after伪元素设置如下属性即可:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.outer</span><span class="selector-pseudo">::after</span>&#123;</div><div class="line">	<span class="attribute">content</span>:<span class="string">''</span>;</div><div class="line">	<span class="attribute">display</span>:block;</div><div class="line">	<span class="attribute">clear</span>:both;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>本文就讨论这么多内容,大家有什么问题或好的想法欢迎在下方参与<a href="#respond">留言和评论</a>.</p>
<p>本文作者: <a href="https://github.com/Louiszhai" target="_blank" rel="external">louis</a></p>
<p>本文链接: <a href="http://louiszhai.github.io/2016/03/12/css-float/">http://louiszhai.github.io/2016/03/12/css-float/</a></p>
<p>参考文章</p>
<ul>
<li><a href="http://www.w3cplus.com/css/float.html" target="_blank" rel="external">float深入剖析_float 教程_w3cplus</a></li>
<li><a href="http://www.wuwenyuan.com/1079.html" target="_blank" rel="external">网站CSS布局：float布局与position优势对比 | 网络营销技巧</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      css float clear:both overflow:auto 文档流
    
    </summary>
    
    
      <category term="CSS" scheme="http://louiszhai.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>xss攻防浅谈</title>
    <link href="http://louiszhai.github.io/2016/03/05/xss/"/>
    <id>http://louiszhai.github.io/2016/03/05/xss/</id>
    <published>2016-03-05T01:48:09.000Z</published>
    <updated>2017-04-17T02:54:08.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h3><p><strong>XSS</strong> (Cross-Site Script) 攻击又叫跨站脚本攻击, 本质是一种注入攻击. 其原理, 简单的说就是利用各种手段把恶意代码添加到网页中, 并让受害者执行这段脚本. XSS能做用户使用浏览器能做的一切事情. 伟大的同源策略也无法保证不受XSS攻击，因为此时攻击者就在同源之内.</p>
<a id="more"></a>
<h3 id="xss攻击方式"><a href="#xss攻击方式" class="headerlink" title="xss攻击方式"></a>xss攻击方式</h3><p>从攻击的方式可以分为</p>
<ul>
<li>反射型</li>
<li>存储型</li>
<li>文档型</li>
</ul>
<p>这种分类方式有些过时, 长久以来, 人们认为XSS分类有以上三种, 但实际情况中经常无法区分, 所以更明确的分类方式可以分为以下两类:</p>
<ul>
<li>client(客户端型)</li>
<li>server(服务端型)</li>
</ul>
<p>当一端xss代码是在服务端被插入的, 那么这就是服务端型xss, 同理, 如果代码在客户端插入, 就是客户端型xss.</p>
<h3 id="防止xss攻击"><a href="#防止xss攻击" class="headerlink" title="防止xss攻击"></a>防止xss攻击</h3><h4 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h4><p>无论是服务端型还是客户端型xss，攻击达成都需要两个条件</p>
<ul>
<li>代码被注入</li>
<li>代码被执行</li>
</ul>
<p>其实只要做好无论任何情况下保证代码不被执行就能完全杜绝xss攻击.</p>
<p>总之, 任何时候都不要把不受信任的数据直接插入到dom中的任何位置, 一定要做转义。</p>
<p><strong>对于某些位置,不受信任的数据做转义就可以保证安全</strong></p>
<ul>
<li>一般的标签属性值</li>
<li>div body 的内部html</li>
</ul>
<p><strong>对于某些位置，即使做了转义依然不安全</strong></p>
<ul>
<li>script标签中</li>
<li>注释中</li>
<li>表签的属性名名</li>
<li>标签名</li>
<li>css标签中</li>
</ul>
<p>使用JSON.parse 而不是eval, request 的content-type要指定是Content-Type: application/json;</p>
<p>如果链接的URL中部分是动态生成的, 一定要做转义.</p>
<h4 id="使用浏览器自带的xss-filter"><a href="#使用浏览器自带的xss-filter" class="headerlink" title="使用浏览器自带的xss-filter"></a>使用浏览器自带的xss-filter</h4><p><img src="http://louiszhai.github.io/docImages/xss01.png" alt="xss-filter"></p>
<blockquote>
<p>可以通过http头控制是否打开 xss-filter, 默认为开启.</p>
</blockquote>
<p>通常情况下, 在http header中加入以下字段表示启用xss-filter.</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attr">X-XSS-Protection:</span><span class="number">1</span> (默认)</div><div class="line"><span class="attr">X-XSS-Protection:</span><span class="number">1</span>;mode=block (强制不渲染, chrome跳空白页,IE展示一个<span class="comment">#号)</span></div></pre></td></tr></table></figure>
<p>如需禁用xss-filter, 将 <code>X-XSS-Protection</code> 设置为0即可.</p>
<p>如上, 现代浏览器都对反射型xss有一定的防御力, 其原理是检查url和dom中元素的相关性. 但这并不能完全防止反射型xss. 这里有个可供测试的链接, 传送门: <a href="http://www.enhanceie.com/test/xss/" target="_blank" rel="external">XSS Test Page</a>.</p>
<p>另外, 浏览器对于存储型xss并没有抵抗力, 原因很简单, 用户的需求是多种多样的. 所以, 抵御xss这件事情不能指望浏览器.</p>
<h4 id="Content-Security-Policy"><a href="#Content-Security-Policy" class="headerlink" title="Content Security Policy"></a>Content Security Policy</h4><p>Content Security Policy, 即内容安全策略, 简称csp.</p>
<p>为了缓解很大一部分潜在的跨站脚本问题, 浏览器的扩展程序系统引入了CSP. CSP 管理网站允许加载的内容, 并且使用白名单的机制对网站加载或执行的资源起作用. 在网页中, 这样的策略通过 HTTP 头信息或者 meta 元素定义.</p>
<p>CSP 并不是用来防止 xss 攻击的, 而是最小化 xss 发生后所造成的伤害. 实际上, 除了开发者自己做好 xss 转义, 并没有别的方法可以防止 xss 的发生. CSP 可以说是HTML5给web安全带来的最实惠的东西. 那么如何引入 CSP 呢?</p>
<ol>
<li>通过response头</li>
</ol>
<blockquote>
<p>只允许脚本从本源加载Content-Security-Policy: script-src ‘self’</p>
</blockquote>
<ol>
<li>通过HTML的META标签</li>
</ol>
<blockquote>
<p>作用同上&lt;meta http-equiv=”Content-Security-Policy” content=”script-src ‘self’”&gt;</p>
</blockquote>
<p>那么CSP 除了限制script-src 之外还能限制什么呢？</p>
<blockquote>
<p>base-uri : 限制这篇文档的uri  </p>
<p>child-src ：限制子窗口的源(iframe,弹窗等),取代frame-src  </p>
<p>connect-src ：限制脚本可以访问的源  </p>
<p>font-src : 限制字体的源  </p>
<p>form-action : 限制表单能够提交到的源  </p>
<p>frame-ancestors : 限制了当前页面可以被哪些页面以iframe,frame,object等方式加载  </p>
<p>frame-src ：deprecated with child-src,限制了当前页面可以加载哪些源，与frame-ancestors对应 </p>
<p>img-src : 限制图片可以从哪些源加载  </p>
<p>media-src : 限制video, audio, source, track 能够从哪些源加载  </p>
<p>object-src ：限制插件可以从哪些源加载  </p>
<p>sandbox ：强制打开沙盒模式</p>
</blockquote>
<p>可以看出, CSP是一个强大的策略, 几乎可以限制了所有能够用到的资源的来源. 使用好CSP可以很大成都降低XSS带来的风险.</p>
<p>另外, CSP还提供一个报告的头域 <code>Content-Security-Policy-Report-Only</code>, 使用这个头域, 浏览器会向服务器报告csp状态.</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Content-Security-Policy-Report-Only</span>: script-src 'self'; report-uri http://cspReport/</div></pre></td></tr></table></figure>
<p>使用了上面的设置, 若页面上存在内联的js, 它依然会执行, 不过浏览器会向发送一个post请求, 包含如下信息.</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&#123; </div><div class="line">  <span class="attr">"csp-report"</span>:</div><div class="line">  	&#123; </div><div class="line">      <span class="attr">"document-uri"</span>: <span class="string">"http://cspReport/test.php"</span>,</div><div class="line">      <span class="attr">"referrer"</span>: <span class="string">""</span>,</div><div class="line">      <span class="attr">"violated-directive"</span>: <span class="string">"script-src 'self'"</span>,</div><div class="line">      <span class="attr">"original-policy"</span>: <span class="string">"script-src 'self'; report-uri http://cspReport/"</span>,</div><div class="line">      <span class="attr">"blocked-uri"</span>: <span class="string">""</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>CSP 目前有两版, [CSP1][<a href="https://www.w3.org/TR/2012/CR-CSP-20121115/" target="_blank" rel="external">https://www.w3.org/TR/2012/CR-CSP-20121115/</a>] 和 [CSP2][<a href="https://www.w3.org/TR/CSP2/" target="_blank" rel="external">https://www.w3.org/TR/CSP2/</a>]. 两版的支持状态可以在 <a href="http://caniuse.com/#search=csp" target="_blank" rel="external">http://caniuse.com/#search=csp</a> 中查到. 如下:</p>
<p><strong>CSP1支持性</strong></p>
<p><img src="http://louiszhai.github.io/docImages/xss03-csp1.png" alt="CSP1"></p>
<p><strong>CSP2支持性</strong></p>
<p><img src="http://louiszhai.github.io/docImages/xss03-csp2.png" alt="CSP2"></p>
<p>CSP虽然提供了强大的安全保护, 但是他也造成了如下问题: Eval及相关函数被禁用、内嵌的JavaScript代码将不会执行、只能通过白名单来加载远程脚本.</p>
<h4 id="X-Frame-Options"><a href="#X-Frame-Options" class="headerlink" title="X-Frame-Options"></a>X-Frame-Options</h4><p>X-Frame-Options 响应头是用来给浏览器指示允许一个页面可否在 <code>frame</code>, <code>iframe</code> 或者 <code>object</code> 等标签中展现的标记. 网站可以使用此功能, 来确保自己网站的内容没有被嵌到别人的网站中去, 也从而避免了点击劫持 (clickjacking) 的攻击. 但以后可能被CSP的 frame-ancestors取代。目前支持的状态比起 CSP frame-ancestors要好.</p>
<p>X-Frame-Options 共有三个值:</p>
<ul>
<li>DENY 表示这个页面不允许被以frame的方式加载 </li>
<li>SAMEORIGIN 表示这个页面只允许被同源页面加载</li>
<li>ALLOW-FROM uri 表示这个页面只能被特定的域加载</li>
</ul>
<p>服务器配置</p>
<p><strong>java代码:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">response.addHeader(<span class="string">"x-frame-options"</span>,<span class="string">"SAMEORIGIN"</span>);</div></pre></td></tr></table></figure>
<p><strong>Nginx配置:</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">addheader X-Frame-Options SAMEORIGIN</div></pre></td></tr></table></figure>
<p><strong>Apache配置:</strong></p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute"><span class="nomarkup">Header</span></span> always append X-Frame-Options SAMEORIGIN</div></pre></td></tr></table></figure>
<p><strong>浏览器兼容性</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th>Chrome</th>
<th>Firefox (Gecko)</th>
<th>Internet Explorer</th>
<th>Opera</th>
<th>Safari</th>
</tr>
</thead>
<tbody>
<tr>
<td>基础支持</td>
<td>4.1.249.1042</td>
<td><a href="https://developer.mozilla.org/en-US/Firefox/Releases/NaN" target="_blank" rel="external">3.6.9</a> (1.9.2.9)</td>
<td>8.0</td>
<td>10.5</td>
<td>4.0</td>
</tr>
<tr>
<td>ALLOW-FROM 支持</td>
<td>Not supported</td>
<td><a href="https://developer.mozilla.org/en-US/Firefox/Releases/18" target="_blank" rel="external">18.0</a></td>
<td>8.0?</td>
<td>?</td>
<td>Not supported</td>
</tr>
</tbody>
</table>
<h4 id="Http-Only"><a href="#Http-Only" class="headerlink" title="Http-Only"></a>Http-Only</h4><p>使用 http-only后, 可禁止js读写cookie,  可以保证即使发生了xss, 用户的cookie也是安全的.</p>
<h4 id="iframe-沙箱环境"><a href="#iframe-沙箱环境" class="headerlink" title="iframe 沙箱环境"></a>iframe 沙箱环境</h4><p>HTML5为iframe提供了安全属性 sandbox, 进而限制iframe的能力. 如下:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"untrusted.html"</span> <span class="attr">sandbox</span>=<span class="string">"allow-scripts allow-forms"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></div></pre></td></tr></table></figure>
<h4 id="其他安全相关的HTTP头"><a href="#其他安全相关的HTTP头" class="headerlink" title="其他安全相关的HTTP头"></a>其他安全相关的HTTP头</h4><h5 id="X-Content-Type-Options"><a href="#X-Content-Type-Options" class="headerlink" title="X-Content-Type-Options"></a>X-Content-Type-Options</h5><p>X-Content-Type-Options 阻止浏览器进行content-type 嗅探, 能够防止类型嗅探攻击.</p>
<p>这个header主要用来防止在IE9、chrome和safari中的MIME类型混淆攻击. 通常浏览器可以通过嗅探内容本身的方法来决定它是什么类型, 而不是看响应中的content-type值. 通过设置 X-Content-Type-Options：如果content-type和期望的类型匹配，则不需要嗅探，只能从外部加载确定类型的资源. 举个例子, 如果加载了一个样式表, 那么资源的MIME类型只能是text/css, 对于IE中的脚本资源, 以下的内容类型是有效的:</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">application</span>/ecmascript  </div><div class="line"><span class="built_in">application</span>/javascript  </div><div class="line"><span class="built_in">application</span>/x-javascript  </div><div class="line"><span class="built_in">text</span>/ecmascript  </div><div class="line"><span class="built_in">text</span>/javascript  </div><div class="line"><span class="built_in">text</span>/jscript  </div><div class="line"><span class="built_in">text</span>/x-javascript  </div><div class="line"><span class="built_in">text</span>/vbs  </div><div class="line"><span class="built_in">text</span>/vbscript</div></pre></td></tr></table></figure>
<p>对于chrome, 则支持下面的MIME 类型:</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">text</span>/javascript  </div><div class="line"><span class="built_in">text</span>/ecmascript  </div><div class="line"><span class="built_in">application</span>/javascript  </div><div class="line"><span class="built_in">application</span>/ecmascript  </div><div class="line"><span class="built_in">application</span>/x-javascript  </div><div class="line"><span class="built_in">text</span>/javascript1<span class="number">.1</span>  </div><div class="line"><span class="built_in">text</span>/javascript1<span class="number">.2</span>  </div><div class="line"><span class="built_in">text</span>/javascript1<span class="number">.3</span>  </div><div class="line"><span class="built_in">text</span>/jscript  </div><div class="line"><span class="built_in">text</span>/live <span class="keyword">script</span></div></pre></td></tr></table></figure>
<p><strong>正确的设置</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nosniff – 这个是唯一正确的设置.</div></pre></td></tr></table></figure>
<p>通常不正确的设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">‘nosniff’ – 引号是不允许的</div><div class="line">: nosniff – 冒号也是错误的</div></pre></td></tr></table></figure>
<p><strong>如何检测</strong></p>
<p>在IE和chrome中打开开发者工具，在控制台中观察配置了nosniff和没有配置nosniff的输出有啥区别.</p>
<h5 id="HPKP-Public-Key-Pinning"><a href="#HPKP-Public-Key-Pinning" class="headerlink" title="HPKP(Public Key Pinning)"></a>HPKP(Public Key Pinning)</h5><p>HPKP 是一个response 头, 用来检测一个证书的公钥是否发生了改变, 防止中间人攻击.</p>
<p>我们知道, 受信任的 CA（证书颁发机构）有好几百个, 他们成为整个网站身份认证过程中一个较大的攻击面. 现有的证书信任链机制最大的问题是, 任何一家受信任的 CA 都可以签发任意网站的站点证书, 这些证书在浏览器看来, 都是合法的.</p>
<p>HPKP 技术给予我们主动选择信任 CA 的权利. 它的工作原理是通过响应头或者 <meta> 标签告诉浏览器当前网站的证书指纹, 以及过期时间等其它信息. 未来一段时间内, 浏览器再次访问这个网站必须验证证书链中的证书指纹, 如果跟之前指定的值不匹配, 即便证书本身是合法的, 也必须断开连接.</p>
<p>HPKP 官方文档见 <a href="https://tools.ietf.org/html/rfc7469" target="_blank" rel="external">RFC7469</a> , 目前 Firefox 35+ 和 Chrome 38+ 已经支持. 它的基本格式如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Public-Key-Pins: pin-sha256=&quot;base64==&quot;; max-age=expireTime [; includeSubdomains][; report-uri=&quot;reportURI&quot;]</div></pre></td></tr></table></figure>
<h5 id="HSTS-HTTP-Strict-Transport-Security"><a href="#HSTS-HTTP-Strict-Transport-Security" class="headerlink" title="HSTS (HTTP Strict-Transport-Security)"></a>HSTS (HTTP Strict-Transport-Security)</h5><p>HSTS 是国际互联网工程组织IETE正在推行一种新的Web安全协议, 可以用来抵御中间人攻击, 它强制浏览器使用TSL作为数据通道, 即强制使用HTTPS与服务器创建连接.</p>
<p>服务器开启HSTS的方法是, 当客户端通过HTTPS发出请求时, 在服务器返回的超文本传输协议响应头中包含Strict-Transport-Security字段. 非加密传输时设置的HSTS字段无效.</p>
<p>比如, <a href="https://xxx" target="_blank" rel="external">https://xxx</a> 的响应头含有Strict-Transport-Security: max-age=31536000; includeSubDomains. 这意味着两点:</p>
<p>在接下来的一年（即31536000秒）中, 浏览器只要向xxx或其子域名发送HTTP请求时, 必须采用HTTPS来发起连接. 比如, 用户点击超链接或在地址栏输入 <a href="http://xxx/" target="_blank" rel="external">http://xxx/</a> , 浏览器应当自动将 http 转写成 https, 然后直接向 <a href="https://xxx/" target="_blank" rel="external">https://xxx/</a> 发送请求.</p>
<p>在接下来的一年中, 如果 xxx 服务器发送的TLS证书无效, 用户不能忽略浏览器警告继续访问网站.</p>
<p>不足就是, 用户首次访问网址是不受HSTS保护的, 这是因为首次还未收到HSTS. 解决方案有两个, 一是浏览器预置 HSTS域名列表, Google Chrome、Firefox 和 Internet Explorer 实现了这一方案. 二是将HSTS信息加入到域名系统记录中.</p>
<h3 id="前端xss过滤"><a href="#前端xss过滤" class="headerlink" title="前端xss过滤"></a>前端xss过滤</h3><p>最后提供一种前端xss过滤的方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">xssCheck</span>(<span class="params">str,reg</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> str ? str.replace(reg || <span class="regexp">/[&amp;&lt;"&gt;'](?:(amp|lt|quot|gt|#39|nbsp|#\d+);)?/g</span>, <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span>(b)&#123;</div><div class="line">      <span class="keyword">return</span> a;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">      <span class="keyword">return</span> &#123;</div><div class="line">        <span class="string">'&lt;'</span>:<span class="string">'&amp;lt;'</span>,</div><div class="line">        <span class="string">'&amp;'</span>:<span class="string">'&amp;amp;'</span>,</div><div class="line">        <span class="string">'"'</span>:<span class="string">'&amp;quot;'</span>,</div><div class="line">        <span class="string">'&gt;'</span>:<span class="string">'&amp;gt;'</span>,</div><div class="line">        <span class="string">"'"</span>:<span class="string">'&amp;#39;'</span>,</div><div class="line">      &#125;[a]</div><div class="line">    &#125;</div><div class="line">  &#125;) : <span class="string">''</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>本文就讨论这么多内容,大家有什么问题或好的想法欢迎在下方参与<a href="#respond">留言和评论</a>.</p>
<p>本文作者: <a href="https://github.com/Louiszhai" target="_blank" rel="external">louis</a></p>
<p>本文链接: <a href="http://louiszhai.github.io/2016/03/05/xss/">http://louiszhai.github.io/2016/03/05/xss/</a></p>
<p>参考文章</p>
<ul>
<li><a href="http://drops.wooyun.org/web/13009?hmsr=toutiao.io&amp;utmmedium=toutiao.io&amp;utmsource=toutiao.io" target="_blank" rel="external">前端防御XSS | WooYun知识库</a></li>
<li><a href="http://www.freebuf.com/articles/web/61268.html" target="_blank" rel="external">XSS攻击冷门花样玩法总结 - FreeBuf.COM | 关注黑客与极客</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzIyMDEzMTA2MQ==&amp;mid=401875767&amp;idx=1&amp;sn=86a401bcc11370535d313e41fcbcc6d7&amp;scene=0&amp;key=710a5d99946419d9484c49931c8df7fccdb8be90ca92888dfb8ade9a572144b5de476f1987b1fbfb8a5c196503e7db51&amp;ascene=0&amp;uin=MTM4MjU5NzA0MA%3D%3D&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.11.3+build(15D21)&amp;version=11020012&amp;pass_ticket=1exiEovV05ofjBqO9qcL3sCuVBh%2BiM6aXpmJHZAB5a7ELhT%2FamprKJVHp83U9s2C" target="_blank" rel="external">关于Web安全，99%的网站都忽略了这些</a></li>
<li><a href="http://www.tuicool.com/articles/jURNfy" target="_blank" rel="external">HTTP Public Key Pinning 介绍 - 推酷</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      xss xss漏洞 xss攻击 xss浅谈 前端xss
    
    </summary>
    
    
      <category term="XSS" scheme="http://louiszhai.github.io/tags/XSS/"/>
    
  </entry>
  
  <entry>
    <title>JS字符串常用方法</title>
    <link href="http://louiszhai.github.io/2016/01/12/js.String/"/>
    <id>http://louiszhai.github.io/2016/01/12/js.String/</id>
    <published>2016-01-12T12:27:09.000Z</published>
    <updated>2017-04-17T02:54:08.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h3><p>javaScript 中, 字符串无处不在, 并且所有的字符串方法均来自 String.prototype, 这一节, 我们走进看一看String内部, 探讨那些常用或不常用的字符串操作方法.</p>
<a id="more"></a>
<h3 id="String-prototype"><a href="#String-prototype" class="headerlink" title="String.prototype"></a>String.prototype</h3><p>String.prototype 属性指向 String 的原型对象. 以下是它的属性特性:</p>
<table>
<thead>
<tr>
<th>writable</th>
<th>false</th>
</tr>
</thead>
<tbody>
<tr>
<td>enumerable</td>
<td>false</td>
</tr>
<tr>
<td>configurable</td>
<td>false</td>
</tr>
</tbody>
</table>
<p>所有的字符串实例都继承自 String.prototype. 因此任何 String.prototype 上的改变都会在字符串上体现出来.</p>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><ul>
<li>String.prototype.constructor 指向构造器(String())</li>
<li>String.prototype.length 表示字符串长度</li>
</ul>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>字符串方法分为两种, 一种是html无关的方法, 一种是html有关的方法. 我们先看第一种. 但是无论字符串方法如何厉害, 都不至于强大到可以改变原字符串.</p>
<h5 id="HTML无关的方法"><a href="#HTML无关的方法" class="headerlink" title="HTML无关的方法"></a>HTML无关的方法</h5><p>常用的方法有, charAt, charCodeAt, concat, indexOf, lastIndexOf, localeCompare, match, replace, search, slice, split, substr, substring, toLocaleLowerCase, toLocaleUpperCase, toLowerCase, toString, toUpperCase, trim, valueof 等ES5支持的, 以及 codePointAt, contains, endsWith, normalize, repeat, startsWith 等ES6支持的, 还包括 quote, toSource, trimLeft, trimRight 等非标准的.</p>
<p>接下来我们将对各个方法分别举例阐述其用法. 若没有特别说明, 该方法将兼容所有目前主流浏览器.</p>
<h6 id="charAt"><a href="#charAt" class="headerlink" title="charAt"></a>charAt</h6><p>charAt() 方法返回字符串中指定位置的字符。</p>
<p>语法: <em>str</em>.charAt(index)</p>
<p>index 为字符串索引(取值从0至length-1), 如果超出该范围, 则返回空串.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">"Hello, World"</span>.charAt(<span class="number">8</span>));<span class="comment">//o, 返回下标为8的字符串o</span></div></pre></td></tr></table></figure>
<h6 id="charCodeAt"><a href="#charCodeAt" class="headerlink" title="charCodeAt"></a>charCodeAt</h6><p>charCodeAt() 返回指定索引处字符的 Unicode 数值.</p>
<p>语法: str.charCodeAt(index)</p>
<p>index 为一个从0至length-1的整数. 如果不是一个数值，则默认为 0, 如果小于0或者大于字符串长度, 则返回 NaN.</p>
<p>Unicode 编码单元（code points）的范围从 0 到 1,114,111。开头的 128 个 Unicode 编码单元和 ASCII 字符编码一样. </p>
<p>charCodeAt() 总是返回一个小于 65,536 的值. 因为高位编码单元需要由一对字符来表示, 为了查看其编码的完成字符, 需要查看 charCodeAt(i) 以及 charCodeAt(i+1) 的值. 如需更多了解请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/prototype" target="_blank" rel="external">fixedCharCodeAt</a>.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">"Hello, World"</span>.charCodeAt(<span class="number">8</span>));<span class="comment">//111</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"前端工程师"</span>.charCodeAt(<span class="number">2</span>));<span class="comment">//24037, 可见也可以查看中文Unicode编码</span></div></pre></td></tr></table></figure>
<h6 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h6><p>concat() 方法将一个或多个字符串拼接在一起, 组成新的字符串并返回.</p>
<p>语法: <em>str</em>.concat(string2, string3, …)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">"早"</span>.concat(<span class="string">"上"</span>,<span class="string">"好"</span>));<span class="comment">//早上好</span></div></pre></td></tr></table></figure>
<p>但是 concat 的性能表现不佳, 强烈推荐使用赋值操作符(+, +=) 代替 concat. “+” 操作符大概快了 concat 几十倍.(数据参考 <a href="http://jsperf.com/concat-vs-plus-vs-join" target="_blank" rel="external">性能测试</a>).</p>
<h6 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h6><h6 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf"></a>lastIndexOf</h6><p>indexOf() 方法用于查找子字符串在字符串中首次出现的位置. 没有则返回 -1. 该方法严格区分大小写, 并且从左往右查找. 而 lastIndexOf 则从右往左查找, 其它与前者一致.</p>
<p>语法: str.indexOf(searchValue [, fromIndex=0])</p>
<p>searchValue 表示被查找的字符串, fromIndex 表示开始查找的位置, 默认为0, 如果小于0, 则查找整个字符串, 若超过字符串长度, 则该方法返回-1, 除非被查找的是空字符串, 此时返回字符串长度.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">""</span>.indexOf(<span class="string">""</span>,<span class="number">100</span>));<span class="comment">//0</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"IT改变世界"</span>.indexOf(<span class="string">"世界"</span>));<span class="comment">//4</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"IT改变世界"</span>.lastIndexOf(<span class="string">"世界"</span>));<span class="comment">//4</span></div></pre></td></tr></table></figure>
<h6 id="locateCompare"><a href="#locateCompare" class="headerlink" title="locateCompare"></a>locateCompare</h6><p>locateCompare() 方法用来比较字符串, 如果指定字符串在原字符串的前面则返回负数, 否则返回正数或0, 其中0 表示两个字符串相同. 该方法实现依赖具体的本地实现, 不同的语言下可能有不同的返回.</p>
<p>语法: <em>str</em>.localeCompare(str2 [, locales [, options]])</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">"apple"</span>;</div><div class="line"><span class="keyword">var</span> str2 = <span class="string">"orange"</span>;</div><div class="line"><span class="built_in">console</span>.log(str.localeCompare(str2));<span class="comment">//-1</span></div><div class="line"><span class="built_in">console</span>.log(str.localeCompare(<span class="string">"123"</span>));<span class="comment">//1</span></div></pre></td></tr></table></figure>
<p>目前 Safari 浏览器暂不支持该方法. Chrome 24, Firefox 29, IE11, Opera 15 已实现了它.</p>
<h6 id="match"><a href="#match" class="headerlink" title="match"></a>match</h6><p>match() 方法用于测试字符串是否支持指定正则表达式的规则, 即使传入的是非正则表达式对象, 它也会隐式地使用 new RegExp(obj) 将其转换为正则表达式对象.</p>
<p>语法: <em>str</em>.match(regexp)</p>
<p>该方法返回包含匹配结果的数组, 如果没有匹配项, 则返回 null.</p>
<p><strong>描述</strong></p>
<ul>
<li>若正则表达式没有 g 标志, 则返回同 RegExp.exec(str) 相同的结果. 而且返回的数组拥有一个额外的 input 属性, 该属性包含原始字符串, 另外该数组还拥有一个 index 属性, 该属性表示匹配字符串在原字符串中索引(从0开始).</li>
<li>若正则表达式包含 g 标志, 则该方法返回一个包含所有匹配结果的数组, 没有匹配到则返回 null.</li>
</ul>
<p><strong>相关 RegExp 方法</strong></p>
<ul>
<li>若需测试字符串是否匹配正则, 请参考 RegExp.test(str).</li>
<li>若只需第一个匹配结果, 请参考 RegExp.exec(str).</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">"World Internet Conference"</span>;</div><div class="line"><span class="built_in">console</span>.log(str.match(<span class="regexp">/[a-d]/i</span>));<span class="comment">//["d", index: 4, input: "World Internet Conference"]</span></div><div class="line"><span class="built_in">console</span>.log(str.match(<span class="regexp">/[a-d]/gi</span>));<span class="comment">//["d", "C", "c"]</span></div><div class="line"><span class="comment">//RegExp 方法如下</span></div><div class="line"><span class="built_in">console</span>.log(<span class="regexp">/[a-d]/gi</span>.test(str));<span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="regexp">/[a-d]/gi</span>.exec(str));<span class="comment">//["d", index: 4, input: "World Internet Conference"]</span></div></pre></td></tr></table></figure>
<p>由上可知, RegExp.test(str) 方法只要匹配到了一个字符也返回true. 而</p>
<p>RegExp.exec(str) 方法无论正则中有没有包含 g 标志, RegExp.exec将直接返回第一个匹配结果, 且该结果同 str.match(regexp) 方法不包含 g 标志时的返回一致.</p>
<h6 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h6><p>该方法在之前已经讲过, 详细请参考 <a href="http://louiszhai.github.io/2015/12/11/js.replace/"><code>String.prototype.replace高阶技能</code></a> .</p>
<h6 id="search"><a href="#search" class="headerlink" title="search"></a>search</h6><p>search() 方法用于测试字符串对象是否包含某个正则匹配. 相当于正则表达式的 test 方法. 且该方法比 match() 方法更快. 如果匹配成功, search() 返回正则表达式在字符串中首次匹配项的索引, 否则返回-1.</p>
<p>语法: <em>str</em>.search(regexp)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">"abcdefg"</span>;</div><div class="line"><span class="built_in">console</span>.log(str.search(<span class="regexp">/[d-g]/</span>));<span class="comment">//3, 匹配到子串"defg",而d在原字符串中的索引为3</span></div></pre></td></tr></table></figure>
<p>search() 方法不支持全局匹配(正则中包含g参数), 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(str.search(<span class="regexp">/[d-g]/g</span>));<span class="comment">//3, 与无g参数时,返回相同</span></div></pre></td></tr></table></figure>
<h6 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h6><p>slice() 方法提取字符串的一部分, 并返回新的字符串. 该方法有些类似Array.prototype.slice 方法.</p>
<p>语法: <em>str</em>.slice(start, end)</p>
<p>首先 end 参数可选, start可取正值, 也可取负值. </p>
<p>取正值时表示从索引为start的位置截取到end的位置(不包括end所在位置的字符, 如果end省略则截取到字符串末尾).</p>
<p>取负值时表示从索引为 length+start 位置截取到end所在位置的字符.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">"It is our choices that show what we truly are, far more than our abilities."</span>;</div><div class="line"><span class="built_in">console</span>.log(str.slice(<span class="number">0</span>,<span class="number">-30</span>));<span class="comment">//It is our choices that show what we truly are</span></div><div class="line"><span class="built_in">console</span>.log(str.slice(<span class="number">-30</span>));<span class="comment">//, far more than our abilities.</span></div></pre></td></tr></table></figure>
<h6 id="split"><a href="#split" class="headerlink" title="split"></a>split</h6><p>split() 方法把原字符串分割成子字符串组成数组, 并返回该数组.</p>
<p>语法: <em>str</em>.split(separator, limit)</p>
<p>两个参数均是可选的, 其中 separator 表示分隔符, 它可以是字符串也可以是正则表达式. 如果忽略 separator, 则返回的数组包含一个由原字符串组成的元素. 如果 separator 是一个空串, 则 str 将会被分割成一个由原字符串中字符组成的数组. limit 表示从返回的数组中截取前 limit 个元素, 从而限定返回的数组长度.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">"today is a sunny day"</span>;</div><div class="line"><span class="built_in">console</span>.log(str.split());<span class="comment">//["today is a sunny day"]</span></div><div class="line"><span class="built_in">console</span>.log(str.split(<span class="string">""</span>));<span class="comment">//["t", "o", "d", "a", "y", " ", "i", "s", " ", "a", " ", "s", "u", "n", "n", "y", " ", "d", "a", "y"]</span></div><div class="line"><span class="built_in">console</span>.log(str.split(<span class="string">" "</span>));<span class="comment">//["today", "is", "a", "sunny", "day"]</span></div></pre></td></tr></table></figure>
<p>使用limit限定返回的数组大小. 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(str.split(<span class="string">" "</span>));<span class="comment">//["today"]</span></div></pre></td></tr></table></figure>
<p>使用正则分隔符(RegExp separator). 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(str.split(<span class="regexp">/\s*is\s*/</span>));<span class="comment">//["today", "a sunny day"]</span></div></pre></td></tr></table></figure>
<p>若正则分隔符里包含捕获括号, 则括号匹配的结果将会包含在返回的数组中.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(str.split(<span class="regexp">/(\s*is\s*)/</span>));<span class="comment">//["today", " is ", "a sunny day"]</span></div></pre></td></tr></table></figure>
<h6 id="substr"><a href="#substr" class="headerlink" title="substr"></a>substr</h6><p>substr() 方法返回字符串指定位置开始的指定数量的字符.</p>
<p>语法: <em>str</em>.substr(start[, length])</p>
<p>start 表示开始截取字符的位置, 可取正值或负值. 取正值时表示start位置的索引, 取负值时表示 length+start位置的索引.</p>
<p>length 表示截取的字符长度.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">"Yesterday is history. Tomorrow is mystery. But today is a gift."</span>;</div><div class="line"><span class="built_in">console</span>.log(str.substr(<span class="number">47</span>));<span class="comment">//today is a gift.</span></div><div class="line"><span class="built_in">console</span>.log(str.substr(<span class="number">-16</span>));<span class="comment">//today is a gift.</span></div></pre></td></tr></table></figure>
<p>目前 Microsoft’s JScript 不支持 start 参数取负的索引, 如需在 IE 下支持, 请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/substr#Description" target="_blank" rel="external">Polyfill</a>.</p>
<h6 id="substring"><a href="#substring" class="headerlink" title="substring"></a>substring</h6><p>substring() 方法返回字符串两个索引之间的子串.</p>
<p>语法: <em>str</em>.substring(indexA[, indexB])</p>
<p>indexA, indexB 表示字符串索引, 其中 indexB 可选, 如果省略, 则表示返回从 indexA 到字符串末尾的子串.</p>
<p><strong>描述</strong></p>
<p>substring 要截取的是从 indexA 到 indexB(不包含)之间的字符, 符合以下规律:</p>
<ul>
<li>若 indexA == indexB, 则返回一个空字符串;</li>
<li>若 省略 indexB, 则提取字符一直到字符串末尾;</li>
<li>若 任一参数小于 0 或 NaN, 则被当作 0;</li>
<li>若 任一参数大于 length, 则被当作 length.</li>
</ul>
<p>而 如果 indexA &gt; indexB, 则 substring 的执行效果就像是两个参数调换一般. 比如: str.substring(0,1) == str.substring(1,0)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">"Get outside every day. Miracles are waiting everywhere."</span>;</div><div class="line"><span class="built_in">console</span>.log(str.substring(<span class="number">1</span>,<span class="number">1</span>));<span class="comment">//""</span></div><div class="line"><span class="built_in">console</span>.log(str.substring(<span class="number">0</span>));<span class="comment">//Get outside every day. Miracles are waiting everywhere.</span></div><div class="line"><span class="built_in">console</span>.log(str.substring(<span class="number">-1</span>));<span class="comment">//Get outside every day. Miracles are waiting everywhere.</span></div><div class="line"><span class="built_in">console</span>.log(str.substring(<span class="number">0</span>,<span class="number">100</span>));<span class="comment">//Get outside every day. Miracles are waiting everywhere.</span></div><div class="line"><span class="built_in">console</span>.log(str.substring(<span class="number">22</span>,<span class="literal">NaN</span>));<span class="comment">//Get outside every day.</span></div></pre></td></tr></table></figure>
<h6 id="toLocaleLowerCase"><a href="#toLocaleLowerCase" class="headerlink" title="toLocaleLowerCase"></a>toLocaleLowerCase</h6><h6 id="toLocaleUpperCase"><a href="#toLocaleUpperCase" class="headerlink" title="toLocaleUpperCase"></a>toLocaleUpperCase</h6><p>toLocaleLowerCase() 方法返回调用该方法的字符串被转换成小写的值, 转换规则根据本地化的大小写映射. 而 toLocaleUpperCase() 方法则是转换成大写的值.</p>
<p>语法: <em>str</em>.toLocaleLowerCase(), <em>str</em>.toLocaleUpperCase()</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">'ABCDEFG'</span>.toLocaleLowerCase());<span class="comment">//abcdefg</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'abcdefg'</span>.toLocaleUpperCase());<span class="comment">//ABCDEFG</span></div></pre></td></tr></table></figure>
<h6 id="toLowerCase"><a href="#toLowerCase" class="headerlink" title="toLowerCase"></a>toLowerCase</h6><h6 id="toUpperCase"><a href="#toUpperCase" class="headerlink" title="toUpperCase"></a>toUpperCase</h6><p>这两个方法分别表示将字符串转换为相应的小写,大写形式, 并返回. 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">'ABCDEFG'</span>.toLowerCase());<span class="comment">//abcdefg</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'abcdefg'</span>.toUpperCase());<span class="comment">//ABCDEFG</span></div></pre></td></tr></table></figure>
<h6 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h6><h6 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf"></a>valueOf</h6><p>这两个方法都是返回指定对象的字符串形式.</p>
<p>语法: <em>str</em>.toString(), <em>str</em>.valueOf()</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">"abc"</span>;</div><div class="line"><span class="built_in">console</span>.log(str.toString());<span class="comment">//abc</span></div><div class="line"><span class="built_in">console</span>.log(str.toString()==str.valueOf());<span class="comment">//true</span></div></pre></td></tr></table></figure>
<p>尽管他们是如此的相似, 但仍能抓住他们之间细微的差别, 请尝试运行以下一段代码:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = &#123;</div><div class="line">    <span class="attr">toString</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">"test"</span>; &#125;,</div><div class="line">    <span class="attr">valueOf</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">123</span>; &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">alert(x); <span class="comment">// test</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"x="</span> + x); <span class="comment">// "x=123"</span></div><div class="line"><span class="built_in">console</span>.log(x + <span class="string">"=x"</span>); <span class="comment">// "123=x"</span></div><div class="line"><span class="built_in">console</span>.log(x + <span class="string">"1"</span>); <span class="comment">// 1231</span></div><div class="line"><span class="built_in">console</span>.log(x + <span class="number">1</span>); <span class="comment">// 124</span></div><div class="line"><span class="built_in">console</span>.log([<span class="string">"x="</span>, x].join(<span class="string">""</span>)); <span class="comment">// "x=test"</span></div></pre></td></tr></table></figure>
<p>我们发现当 “+” 操作符存在时, x趋向于转换为数字, 表达式会优先调用 valueOf 方法, 如果调用数组的 join 方法, x趋向于转换为字符串, 表达式会优先调用 toString 方法.</p>
<h6 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h6><p>trim() 方法清除字符串首尾的空白并返回.</p>
<p>语法: <em>str</em>.trim()</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">"    abc    "</span>.trim());<span class="comment">//abc</span></div></pre></td></tr></table></figure>
<p>trim() 方法是 ECMAScript 5.1 标准加入的, 它并不支持IE9以下的低版本IE浏览器, 如需支持, 请参考以下兼容写法:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(!<span class="built_in">String</span>.prototype.trim) &#123;</div><div class="line">  <span class="built_in">String</span>.prototype.trim = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.replace(<span class="regexp">/^\s+|\s+$/g</span>,<span class="string">''</span>);</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h6 id="codePointAt"><a href="#codePointAt" class="headerlink" title="codePointAt"></a>codePointAt</h6><p>codePointAt() 方法返回使用UTF-16编码的给定位置的值的非负整数. 该方法遵循 ES6标准, 并非所有浏览器都支持.</p>
<p>语法: <em>str</em>.codePointAt(position)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">"a"</span>.codePointAt(<span class="number">0</span>));<span class="comment">//97</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"\u4f60\u597d"</span>.codePointAt(<span class="number">0</span>));<span class="comment">//20320</span></div></pre></td></tr></table></figure>
<p>codePointAt 符合 ES6 标准, 如需支持, 请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/codePointAt#Polyfill" target="_blank" rel="external">Polyfill</a> .</p>
<h6 id="contains"><a href="#contains" class="headerlink" title="contains"></a>contains</h6><p>contains() 方法尚处于 ES6 规范的草案中, 它用来判断一个字符串是否属于另一个字符, 如果是, 则返回true, 如果不是, 则返回false.</p>
<p>语法: <em>str</em>.contains(subString [, position])</p>
<p>subString 表示要搜索的字符串, position 表示从当前字符串的哪个位置开始搜索字符串, 默认值为0.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">"Practice makes perfect."</span>;</div><div class="line"><span class="built_in">console</span>.log(str.contains(<span class="string">"perfect"</span>));<span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(str.contains(<span class="string">"perfect"</span>,<span class="number">100</span>));<span class="comment">//false</span></div></pre></td></tr></table></figure>
<p>实际上, 目前只有 Firefox 17及之后的版本实现了该方法.</p>
<h6 id="endsWith"><a href="#endsWith" class="headerlink" title="endsWith"></a>endsWith</h6><p>endsWith() 方法基本与 contains() 功能相同, 不同的是, 它用来判断一个字符串是否是原字符串的结尾. 若是则返回true, 否则返回false.</p>
<p>语法: <em>str</em>.endsWith(substring [, position])</p>
<p>与contains 方法不同, position 参数的默认值为字符串长度.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">"Learn and live."</span>;</div><div class="line"><span class="built_in">console</span>.log(str.endsWith(<span class="string">"live."</span>));<span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(str.endsWith(<span class="string">"Learn"</span>,<span class="number">5</span>));<span class="comment">//true</span></div></pre></td></tr></table></figure>
<p>同样目前只有 Firefox 17版本及之后的版本实现了该方法. 其他浏览器请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith#Polyfill" target="_blank" rel="external">Polyfill</a>.</p>
<h6 id="normalize"><a href="#normalize" class="headerlink" title="normalize"></a>normalize</h6><p>normalize() 方法尚处于 ES6 规范的草案中, 它会按照指定的 Unicode 正规形式将原字符串正规化.</p>
<p>语法: <em>str</em>.normalize([form])</p>
<p>form 参数可省略, 目前有四种 Unicode 正规形式, 即 “NFC”, “NFD”, “NFKC” 以及 “NFKD”, form的默认值为 “NFC”. 如果form 传入了非法的参数值, 则会抛出 RangeError 异常.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">"\u4f60\u597d"</span>;</div><div class="line"><span class="built_in">console</span>.log(str.normalize());<span class="comment">//你好</span></div><div class="line"><span class="built_in">console</span>.log(str.normalize(<span class="string">"NFC"</span>));<span class="comment">//你好</span></div><div class="line"><span class="built_in">console</span>.log(str.normalize(<span class="string">"NFD"</span>));<span class="comment">//你好</span></div><div class="line"><span class="built_in">console</span>.log(str.normalize(<span class="string">"NFKC"</span>));<span class="comment">//你好</span></div><div class="line"><span class="built_in">console</span>.log(str.normalize(<span class="string">"NFKD"</span>));<span class="comment">//你好</span></div></pre></td></tr></table></figure>
<p>目前只有 Chrome, Firefox 浏览器实现了该方法.</p>
<h6 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h6><p>repeat() 方法尚处于 ES6 规范的草案中, 它返回重复原字符串多次的新字符串.</p>
<p>语法: <em>str</em>.repeat(count)</p>
<p>count 参数只能取大于等于0 的数字, 若该数字不为整数, 将自动转换为整数形式. 如果取负数或者其他值将报错</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">"A still tongue makes a wise head."</span>;</div><div class="line"><span class="built_in">console</span>.log(str.repeat(<span class="number">0</span>));<span class="comment">//""</span></div><div class="line"><span class="built_in">console</span>.log(str.repeat(<span class="number">1</span>));<span class="comment">//A still tongue makes a wise head.</span></div><div class="line"><span class="built_in">console</span>.log(str.repeat(<span class="number">1.5</span>));<span class="comment">//A still tongue makes a wise head.</span></div><div class="line"><span class="built_in">console</span>.log(str.repeat(<span class="number">-1</span>));<span class="comment">//RangeError:Invalid count value</span></div></pre></td></tr></table></figure>
<p>目前只有 Chrome 41, Firefox 24版本浏览器实现了该方法. 其他浏览器请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/repeat#Polyfill" target="_blank" rel="external">Polyfill</a>.</p>
<h6 id="startsWith"><a href="#startsWith" class="headerlink" title="startsWith"></a>startsWith</h6><p>startsWith() 方法用来判断当前字符串是否是以给定字符串开始的, 若是则返回true, 否则返回false.</p>
<p>语法: <em>str</em>.startsWith(subString [, position])</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">"Where there is a will, there is a way."</span>;</div><div class="line"><span class="built_in">console</span>.log(str.startsWith(<span class="string">"Where"</span>));<span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(str.startsWith(<span class="string">"there"</span>,<span class="number">6</span>));<span class="comment">//true</span></div></pre></td></tr></table></figure>
<p>目前只有 Firefox 17 版本实现了该方法, 其他浏览器请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith#Polyfill" target="_blank" rel="external">Polyfill</a>.</p>
<p>其它非标准的方法暂时不作介绍. 如需了解请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/prototype" target="_blank" rel="external">String.prototype - JavaScript | MDN</a> 中标注为感叹号的方法.</p>
<h5 id="HTML有关的方法"><a href="#HTML有关的方法" class="headerlink" title="HTML有关的方法"></a>HTML有关的方法</h5><p>常用的方法有 anchor, link 其它方法如 big, blink, bold, fixed, fontcolor, fontsize, italics, small, strike, sub, sup均已废除.</p>
<p>接下来我们将介绍 anchor和link 两个方法, 其他废除方法不作介绍.</p>
<h6 id="anchor"><a href="#anchor" class="headerlink" title="anchor"></a>anchor</h6><p>anchor() 方法创建一个锚标签.</p>
<p>语法: <em>str</em>.anchor(name)</p>
<p>name 指定被创建的a标签的name属性, 使用该方法创建的锚点, 将会成为 document.anchors 数组的元素.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">"this is a anchor tag"</span>;</div><div class="line"><span class="built_in">document</span>.body.innerHTML = <span class="built_in">document</span>.body.innerHTML + str.anchor(<span class="string">"anchor1"</span>);<span class="comment">//body末尾将会追加这些内容 &lt;a name="anchor1"&gt;this is a anchor tag&lt;/a&gt;</span></div></pre></td></tr></table></figure>
<h6 id="link"><a href="#link" class="headerlink" title="link"></a>link</h6><p>link() 方法同样创建一个a标签.</p>
<p>语法: <em>str</em>.link(url)</p>
<p>url 指定被创建的a标签的href属性, 如果url中包含特殊字符, 将自动进行编码. 例如 &amp;会被转义为 &amp;, “ 会被转义为 “ &amp;\quot; 使用该方法创建的a标签, 将会成为 document.links 数组中的元素.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">"百度"</span>;</div><div class="line"><span class="built_in">document</span>.write(str.link(<span class="string">"https://www.baidu.com"</span>));<span class="comment">//&lt;a href="https://www.baidu.com"&gt;百度&lt;/a&gt;</span></div></pre></td></tr></table></figure>
<hr>
<p>实际上 String.prototype 中, 常用的方法就charAt, indexOf, lastIndexOf, match, replace, search, slice, split, substr, substring, toLowerCase, toUpperCase, trim, valueof 等这些. 熟悉它们的语法规则就能熟练地驾驭字符串.</p>
<hr>
<p>本文就讨论这么多内容,大家有什么问题或好的想法欢迎在下方参与<a href="#respond">留言和评论</a>.</p>
<p>本文作者: <a href="https://github.com/Louiszhai" target="_blank" rel="external">louis</a></p>
<p>本文链接: <a href="http://louiszhai.github.io/2016/01/12/js.String/">http://louiszhai.github.io/2016/01/12/js.String/</a></p>
<p>参考文章</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/prototype" target="_blank" rel="external">String.prototype - JavaScript | MDN</a></li>
<li><a href="http://stackoverflow.com/questions/2485632/valueof-vs-tostring-in-javascript" target="_blank" rel="external">valueOf() vs. toString() in Javascript - Stack Overflow</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      JavaScript String String.prototype indexOf charAt match search split valueOf trim substr substring
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://louiszhai.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Function.prototype.bind方法指南</title>
    <link href="http://louiszhai.github.io/2016/01/11/bind/"/>
    <id>http://louiszhai.github.io/2016/01/11/bind/</id>
    <published>2016-01-11T00:01:33.000Z</published>
    <updated>2017-04-17T02:54:08.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h3><p>ES5新增了 Function.prototype.bind 方法, 该方法不同于jquery的bind 方法, 它主要用于固定 this 作用域, 避免各种由于上下文切换造成的语义问题. 常用在 setTimeout, for循环等内部.</p>
<a id="more"></a>
<h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p>语法: func.bind(thisArg, arg1, arg2, ….)</p>
<p>bind() 方法会返回一个新函数, 又叫绑定函数, 当调用这个绑定函数时, 绑定函数会以创建它时传入 bind() 方法的第一个参数作为当前的上下文, 即this, 传入 bind() 方法的第二个及之后的参数加上绑定函数运行时自身的参数按照顺序作为原函数的参数来调用原函数.</p>
<p>绑定函数也能使用new操作符创建对象; 这就好比把原函数当做构造器. 此时提供的this将被忽略, this之后的参数将依然前置到运行时的参数列表中.</p>
<h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>下面我们来看看bind 的基本用法.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">8</span>;</div><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line">  <span class="attr">x</span>: <span class="number">10</span>,</div><div class="line">  <span class="attr">getX</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  	<span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> f = o.getX;</div><div class="line">f();<span class="comment">//8, 由于没有绑定执行时的上下文, this默认指向window, 打印了全局变量x的值</span></div><div class="line"><span class="keyword">var</span> g = f.bind(o);</div><div class="line">g();<span class="comment">//10, 绑定this后, 成功的打印了o对象的x属性的值.</span></div></pre></td></tr></table></figure>
<h4 id="分离参数"><a href="#分离参数" class="headerlink" title="分离参数"></a>分离参数</h4><p>bind() 方法还可以设置函数拥有的初始参数. 这些参数作为bind() 的第2,3…个参数跟在this(或其他对象的后面), 调用绑定函数时, 这些参数将插入到参数列表的最开始位置, 而传递给绑定函数的参数将跟在他们后面.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//打印十个斐波那契数</span></div><div class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">n1, n2, length</span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span>(<span class="built_in">arguments</span>.length&lt;<span class="number">3</span>) <span class="built_in">console</span>.log(<span class="string">'参数不够...'</span>);</div><div class="line">  <span class="keyword">var</span> array = [n1, n2];</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">2</span>;i&lt;length;i++)&#123;</div><div class="line">  	array[i] = array[i<span class="number">-2</span>] + array[i<span class="number">-1</span>];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> array;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> g = f.bind(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">1</span>);</div><div class="line"><span class="built_in">console</span>.log(g(<span class="number">10</span>));<span class="comment">//[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]</span></div></pre></td></tr></table></figure>
<h4 id="绑定参数"><a href="#绑定参数" class="headerlink" title="绑定参数"></a>绑定参数</h4><p>如果使用new 操作符去构造绑定函数的实例时, 原来提供的this 将被忽略, this之后的参数将依然前置到构造函数的参数列表中. 此时 bind() 方法便具备了保留参数的能力, 我们可以此达到类似柯里化的效果.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span>(<span class="built_in">arguments</span>.length!=<span class="number">0</span>)</div><div class="line">  	<span class="keyword">this</span>.sum = <span class="built_in">Array</span>.prototype.reduce.call(<span class="built_in">arguments</span>,<span class="function"><span class="keyword">function</span>(<span class="params">prev,item</span>)</span>&#123;<span class="comment">//对传入参数求和</span></div><div class="line"> 		<span class="keyword">return</span> prev + item;</div><div class="line">	&#125;);</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.join.call(<span class="built_in">arguments</span>);<span class="comment">// 返回传入参数的字符串形式</span></div><div class="line">&#125;</div><div class="line">f.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.sum;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> g = f.bind(<span class="literal">null</span>,<span class="number">2</span>);</div><div class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> g(<span class="number">8</span>);</div><div class="line"><span class="built_in">console</span>.log(x.toString());<span class="comment">//10, 可见x被绑定了2+8=10</span></div><div class="line"><span class="built_in">console</span>.log(g(<span class="number">8</span>));<span class="comment">//2,8 这告诉我们绑定的两个参数正是2和8</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(x <span class="keyword">instanceof</span> g);<span class="comment">//true, 可见通过new创建的x继承了g</span></div><div class="line"><span class="built_in">console</span>.log(x <span class="keyword">instanceof</span> f);<span class="comment">//true, 可见x也继承了f</span></div><div class="line"><span class="built_in">console</span>.log(g <span class="keyword">instanceof</span> <span class="built_in">Function</span>);<span class="comment">//true, 可见bind f()方法之后, 返回了一个新的函数g</span></div><div class="line"><span class="comment">//函数g可用于求和,如下:</span></div><div class="line"><span class="built_in">console</span>.log(g(<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>));<span class="comment">//27 2+1+3+5+7+9=27</span></div></pre></td></tr></table></figure>
<h4 id="快捷调用"><a href="#快捷调用" class="headerlink" title="快捷调用"></a>快捷调用</h4><p>使用Array.prototype的方法处理类数组对象时(鸭式辨型), 不可避免的需要借用call 或者 apply 方法, 使用 bind() 方法, 我们可以简化这个过程. 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> _slice = <span class="built_in">Array</span>.prototype.slice;</div><div class="line"><span class="keyword">var</span> slice = <span class="built_in">Function</span>.prototype.call.bind(_slice);</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> slice(<span class="built_in">arguments</span>,<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line">f(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);<span class="comment">//[2, 3, 4, 5]</span></div></pre></td></tr></table></figure>
<p>下面的实例将解释 bind() 方法做了一件什么事情:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> _slice = <span class="built_in">Array</span>.prototype.slice;</div><div class="line"><span class="keyword">var</span> slice = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> _slice.apply(<span class="built_in">arguments</span>[<span class="number">0</span>],_slice.call(<span class="built_in">arguments</span>,<span class="number">1</span>));</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> slice(<span class="built_in">arguments</span>,<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line">f(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);<span class="comment">//[2, 3, 4, 5]</span></div></pre></td></tr></table></figure>
<p>如下, 是bind() 方法的简单实现.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">thisArg,argN</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> _this = <span class="keyword">this</span>;</div><div class="line">  <span class="keyword">var</span> _arg = _slice.call(<span class="built_in">arguments</span>,<span class="number">1</span>);</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">   	<span class="keyword">var</span> arg = _slice.call(<span class="built_in">arguments</span>);</div><div class="line">    arg = _arg.concat(arg);</div><div class="line">  	<span class="keyword">return</span> _this.apply(thisArg,arg);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出来, 使用 bind() 方法后, 代码优雅得多.</p>
<p>注: 作为ES5标准加入的bind方法显然不支持 IE9之前的低版本IE, 如需使用, 请参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind#Compatibility" target="_blank" rel="external">Polyfill</a>.</p>
<hr>
<p>本文就讨论这么多内容,大家有什么问题或好的想法欢迎在下方参与<a href="#respond">留言和评论</a>.</p>
<p>本文作者: <a href="https://github.com/Louiszhai" target="_blank" rel="external">louis</a></p>
<p>本文链接: <a href="http://louiszhai.github.io/2016/01/11/bind/">http://louiszhai.github.io/2016/01/11/bind/</a></p>
<p>参考文章</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="external">Function.prototype.bind() - JavaScript | MDN</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      JavaScript bind Function.prototype.bind call apply
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://louiszhai.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>由同源策略到前端跨域</title>
    <link href="http://louiszhai.github.io/2016/01/11/cross-domain/"/>
    <id>http://louiszhai.github.io/2016/01/11/cross-domain/</id>
    <published>2016-01-11T00:01:33.000Z</published>
    <updated>2017-04-20T02:12:14.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h3><p>同源策略 (Same-Origin Policy) 最早由 Netscape 公司提出, 所谓同源就是要求, 域名, 协议, 端口相同. 非同源的脚本不能访问或者操作其他域的页面对象(如DOM等). 作为著名的安全策略, 虽然它只是一个规范, 并不强制要求,  但现在所有支持 javaScript 的浏览器都会使用这个策略. 以至于该策略成为浏览器最核心最基本的安全功能, 如果缺少了同源策略, web的安全将无从谈起.</p>
<a id="more"></a>
<h3 id="同源策略的限制"><a href="#同源策略的限制" class="headerlink" title="同源策略的限制"></a>同源策略的限制</h3><p>同源策略下的web世界, 域的壁垒高筑, 从而保证各个网页相互独立, 互相之间不能直接访问, iframe, ajax 均受其限制, 而script标签不受此限制.</p>
<p>注: 以下如非特别说明, 均指非CORS的, 普通跨域请求.</p>
<h4 id="iframe限制"><a href="#iframe限制" class="headerlink" title="iframe限制"></a>iframe限制</h4><ul>
<li>可以访问同域资源, 可读写;</li>
<li>访问跨域页面时, 只读.</li>
</ul>
<h4 id="Ajax限制"><a href="#Ajax限制" class="headerlink" title="Ajax限制"></a>Ajax限制</h4><p>Ajax 的限制比 iframe 限制更严.</p>
<ul>
<li>同域资源可读写;</li>
<li>跨域请求会直接被浏览器拦截.(chrome下跨域请求不会发起, 其他浏览器一般是可发送跨域请求, 但响应被浏览器拦截)</li>
</ul>
<h4 id="Script限制"><a href="#Script限制" class="headerlink" title="Script限制"></a>Script限制</h4><p>script并无跨域限制, 这是因为script标签引入的文件不能够被客户端的 js 获取到, 不会影响到原页面的安全, 因此script标签引入的文件没必要遵循浏览器的同源策略. 相反, ajax 加载的文件内容可被客户端 js 获取到, 引入的文件内容可能会泄漏或者影响原页面安全, 故, ajax必须遵循同源策略.</p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>同源策略要求三同, 即: <strong>同域</strong>, <strong>同协议</strong>, <strong>同端口</strong>.</p>
<ul>
<li>同域即host相同, 顶级域名, 一级域名, 二级域名, 三级域名等必须相同, 且域名不能与 ip 对应;</li>
<li>同协议要求, http与https协议必须保持一致;</li>
<li>同端口要求, 端口号必须相同.</li>
</ul>
<p>IE有些例外, 它仅仅只是验证主机名以及访问协议，而忽略了端口号.</p>
<p>这里需要澄清一个概念, 所谓的域, 跟 js 等资源的存放服务器没有关系, 比如你到 baidu.com 使用 script 标签请求了 google.com 下的js, 那么该 js 所在域是 baidu.com, 而不是 google.com. 换言之, 它能操作baidu.com的页面对象, 却不能操作google.com的页面对象.</p>
<h3 id="跨域访问"><a href="#跨域访问" class="headerlink" title="跨域访问"></a>跨域访问</h3><p>实际上, 我们又不可避免地需要做一些跨域的请求, 下面提供几种方案去绕过同源策略:</p>
<h4 id="使用代理"><a href="#使用代理" class="headerlink" title="使用代理"></a>使用代理</h4><p>虽然ajax和iframe受同源策略限制, 但服务器端代码请求, 却不受此限制, 我们可以基于此去伪造一个同源请求, 实现跨域的访问. 如下便是实现思路:</p>
<ol>
<li>请求同域下的web服务器;</li>
<li>web服务器像代理一样去请求真正的第三方服务器;</li>
<li>代理拿到数据过后, 直接返回给客户端ajax.</li>
</ol>
<p>这样, 我们便拿到了跨域数据.</p>
<h4 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h4><p>由上, script标签并不受同源策略约束, 基于script 标签可做 jsonp 形式的访问, 可以通过第三方服务器生成动态的js代码来回调本地的js方法，而方法中的参数则由第三方服务器在后台获取，并以JSON的形式填充到JS方法当中. 即 JSON with Padding. 具体如下:</p>
<p>1) 可用js生成以下html 代码, 去做jsonp的请求.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"https://www.targetDomain.com/jsonp?callback=callbackName"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>使用 jquery, 即</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">jQuery.getJSON(</div><div class="line">  <span class="string">"https://www.yourdomain.com/jsonp?callback=?"</span>,</div><div class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">"name: "</span> + data.name);</div><div class="line">  &#125;</div><div class="line">);</div></pre></td></tr></table></figure>
<p>其中回调函数名 “callback” 为 “?”, 即不需要用户指定，而是由jquery生成.</p>
<p>2) 服务器端,以 java 为例, 参考如下: </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</div><div class="line">  //获取JSON数据</div><div class="line">  String jsonData = "&#123;\"name\":\"jsonp\""&#125;";</div><div class="line">  //获取回调函数名</div><div class="line">  String callback = req.getParameter("callback");  </div><div class="line">  //拼接动态JS代码</div><div class="line">  String output = callback + "(" + jsonData + ");</div><div class="line">    resp.setContentType("text/javascript");</div><div class="line">  PrintWriter out = resp.getWriter();</div><div class="line">  out.println(output);</div><div class="line">  // 响应为 callbackName(&#123;\"name\":\"jsonp\""&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage"></a>postMessage</h4><p>ES5新增的 postMessage() 方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递.</p>
<p>语法: postMessage(data,origin)</p>
<p><strong>data</strong>: 要传递的数据，html5规范中提到该参数可以是JavaScript的任意基本类型或可复制的对象，然而并不是所有浏览器都做到了这点儿，部分浏览器只能处理字符串参数，所以我们在传递参数的时候建议使用JSON.stringify()方法对对象参数序列化，在低版本IE中引用json2.js可以实现类似效果.</p>
<p><strong>origin</strong>：字符串参数，指明目标窗口的源，协议+主机+端口号[+URL]，URL会被忽略，所以可以不写，这个参数是为了安全考虑，postMessage()方法只会将message传递给指定窗口，当然如果愿意也可以建参数设置为”*”，这样可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/“。</p>
<p>父页面发送消息: </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.frames[<span class="number">0</span>].postMessage(<span class="string">'message'</span>, origin)</div></pre></td></tr></table></figure>
<p>iframe接受消息: </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">	<span class="keyword">if</span>(e.source!=<span class="built_in">window</span>.parent) <span class="keyword">return</span>;<span class="comment">//若消息源不是父页面则退出</span></div><div class="line">  	<span class="comment">//TODO ...</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>其中 e 对象有三个重要的属性    </p>
<ul>
<li>data, 表示父页面传递过来的message</li>
<li>source, 表示发送消息的窗口对象</li>
<li>origin, 表示发送消息窗口的源(协议+主机+端口号)</li>
</ul>
<h4 id="CORS-跨域访问"><a href="#CORS-跨域访问" class="headerlink" title="CORS 跨域访问"></a>CORS 跨域访问</h4><p>HTML5带来了一种新的跨域请求的方式 — CORS, 即 <a href="https://www.w3.org/TR/cors/" target="_blank" rel="external">Cross-origin resource sharing</a>. 它更加安全, 上述的 JSONP, postMessage 等, 资源本身没有能力保证自己不被滥用. CORS的目标是保护资源只被可信的访问源以正确的方式访问.</p>
<p>目前, 主流的浏览器都支持此协议, 可以在caniuse.com 中查到<a href="http://caniuse.com/#search=cors" target="_blank" rel="external">http://caniuse.com/#search=cors</a>.</p>
<p>简而言之, 浏览器不再一味禁止跨域访问, 而是检查目的站点的响应头域, 进而判断是否允许当前站点访问. 通常, 服务器使用以下的这些响应头域用来通知浏览器:</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Response headers[edit]</div><div class="line"><span class="keyword">Access</span>-Control-Allow-Origin</div><div class="line"><span class="keyword">Access</span>-Control-Allow-Credentials</div><div class="line"><span class="keyword">Access</span>-Control-Allow-Methods</div><div class="line"><span class="keyword">Access</span>-Control-Allow-Headers</div><div class="line"><span class="keyword">Access</span>-Control-Expose-Headers</div><div class="line"><span class="keyword">Access</span>-Control-<span class="built_in">Max</span>-Age</div></pre></td></tr></table></figure>
<p>CORS的解决办法是在服务端Response的HTTP头域加入资源的访问权限信息. 如: A站只需要在response头中加一个字段就能让B站跨站访问.</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">access</span>-control-allow-origin:*</div></pre></td></tr></table></figure>
<p>其中<code>*</code> 表示通配, 所有的域都能访问此资源, 如果严谨一些只允许B站访问:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">access-control-allow-origin:<span class="xml"><span class="tag">&lt;<span class="name">B-DOMAIN</span>&gt;</span></span></div></pre></td></tr></table></figure>
<p>这样B站就可以直接访问此资源, 不需要JSONP 也不需要iframe了.</p>
<p>CORS需要指定METHOD访问, 对于GET和POST请求, 至少要指定以下三种methods, 如下:</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">Access</span>-Control-Allow-Methods: POST, GET, OPTIONS</div></pre></td></tr></table></figure>
<p>如果是POST请求, 且提交的数据类型是json, 那么, CORS需要指定headers.</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">Access</span>-Control-Allow-Headers: Content-<span class="keyword">Type</span></div></pre></td></tr></table></figure>
<p>CORS默认是不带cookie的, 设置以下字段将允许浏览器发送cookie.</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">Access</span>-Control-Allow-Credentials: <span class="literal">true</span></div></pre></td></tr></table></figure>
<p>除此之外, 为了跨站发送cookie等验证信息, <code>access-control-allow-origin</code> 字段将不允许设置为<code>*</code>, 它需要明确指定与请求网页一致的域名.</p>
<p>同时, 请求网页中需要做如下显式设置才能真正发送cookie.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xhr.withCredentials = <span class="literal">true</span>;</div></pre></td></tr></table></figure>
<h4 id="document-domain"><a href="#document-domain" class="headerlink" title="document.domain"></a>document.domain</h4><p>通过修改document的domain属性，我们可以在域和子域或者不同的子域之间通信(即它们必须在同一个一级域名下). 同域策略认为域和子域隶属于不同的域，比如a.com和 script.a.com是不同的域，这时，我们无法在a.com下的页面中调用script.a.com中定义的JavaScript方法。但是当我们把它们document的domain属性都修改为a.com，浏览器就会认为它们处于同一个域下，那么我们就可以互相获取对方数据或者操作对方DOM了。</p>
<p>比如, 我们在 www.a.com/a.html 下, 现在想获取 www.script.a.com/b.html, 即主域名相同, 二级域名不同. 那么可以这么做:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.domain = <span class="string">'a.com'</span>;</div><div class="line"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</div><div class="line">iframe.src = <span class="string">'http://www.script.a.com/b.html'</span>;</div><div class="line">iframe.style.display = <span class="string">'none'</span>;</div><div class="line"><span class="built_in">document</span>.body.appendChild(iframe);</div><div class="line">iframe.addEventListener(<span class="string">'load'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="comment">//TODO 载入完成时做的事情</span></div><div class="line">	<span class="comment">//var _document = iframe.contentWindow.document;</span></div><div class="line"> 	<span class="comment">//...</span></div><div class="line">&#125;,<span class="literal">false</span>);</div></pre></td></tr></table></figure>
<p>注意: </p>
<ul>
<li>2个页面都要设置, 哪怕 a.html 页已处于 <em>a.com</em> 域名下, 也必须显式设置.</li>
<li>document.domain只能设置为一级域名，比如这里a页不能设置为<em>www.a.com</em> (二级域名).</li>
</ul>
<p>利用domain属性跨域具有以下局限性:</p>
<ul>
<li>两个页面要在同一个一级域名下, 且必须同协议, 同端口, 即子域互跨;</li>
<li>只适用于iframe.</li>
</ul>
<h5 id="Internet-Explorer同源策略绕过"><a href="#Internet-Explorer同源策略绕过" class="headerlink" title="Internet Explorer同源策略绕过"></a>Internet Explorer同源策略绕过</h5><p>Internet Explorer8以及前面的版本很容易通过document.domain实现同源策略绕过, 通过重写文档对象, 域属性这个问题可以十分轻松的被利用.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> <span class="built_in">document</span>;</div><div class="line"><span class="built_in">document</span> = &#123;&#125;;</div><div class="line"><span class="built_in">document</span>.domain = <span class="string">'http://www.a.com'</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.domain);</div></pre></td></tr></table></figure>
<p>如果你在最新的浏览器中运行这段代码, 可能在JavaScript控制台会显示一个同源策略绕过错误.</p>
<h4 id="window-name"><a href="#window-name" class="headerlink" title="window.name"></a>window.name</h4><p>window 对象的name属性是一个很特别的属性, 当该window的location变化, 然后重新加载, 它的name属性可以依然保持不变. 那么我们可以在页面 A中用iframe加载其他域的页面B, 而页面B中用JavaScript把需要传递的数据赋值给window.name, iframe加载完成之后（iframe.onload）, 页面A修改iframe的地址, 将其变成同域的一个地址, 然后就可以读出iframe的window.name的值了(因为A中的window.name和iframe中的window.name互相独立的, 所以不能直接在A中获取window.name, 而要通过iframe获取其window.name). 这个方式非常适合单向的数据请求，而且协议简单、安全. 不会像JSONP那样不做限制地执行外部脚本.</p>
<h4 id="location-hash"><a href="#location-hash" class="headerlink" title="location.hash"></a>location.hash</h4><p><strong>location.hash(两个iframe之间), 又称FIM, Fragment Identitier Messaging的简写</strong>.</p>
<p>因为父窗口可以对iframe进行URL读写, iframe也可以读写父窗口的URL, URL有一部分被称为hash, 就是#号及其后面的字符, 它一般用于浏览器锚点定位, Server端并不关心这部分, 所以这部分的修改不会产生HTTP请求, 但是会产生浏览器历史记录. 此方法的原理就是改变URL的hash部分来进行双向通信. 每个window通过改变其他 window的location来发送消息（由于两个页面不在同一个域下IE、Chrome不允许修改parent.location.hash的值，所以要借助于父窗口域名下的一个代理iframe）, 并通过监听自己的URL的变化来接收消息. 这个方式的通信会造成一些不必要的浏览器历史记录, 而且有些浏览器不支持onhashchange事件, 需要轮询来获知URL的改变, 最后, 这样做也存在缺点, 比如数据直接暴露在了url中, 数据容量和类型都有限等.</p>
<h4 id="Access-Control"><a href="#Access-Control" class="headerlink" title="Access Control"></a>Access Control</h4><p>此跨域方法目前只在很少的浏览器中得以支持, 这些浏览器可以发送一个跨域的HTTP请求（Firefox, Google Chrome等通过XMLHTTPRequest实现, IE8下通过XDomainRequest实现）, 请求的响应必须包含一个Access- Control-Allow-Origin的HTTP响应头, 该响应头声明了请求域的可访问权限. 例如baidu.com对google.com下的getUsers.php发送了一个跨域的HTTP请求（通过ajax）, 那么getUsers.php必须加入如下的响应头:</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">header(<span class="string">"Access-Control-Allow-Origin: http://www.baidu.com"</span>);<span class="comment">//表示允许baidu.com跨域请求本文件</span></div></pre></td></tr></table></figure>
<h4 id="flash-URLLoder"><a href="#flash-URLLoder" class="headerlink" title="flash URLLoder"></a>flash URLLoder</h4><p>flash有自己的一套安全策略, 服务器可以通过crossdomain.xml文件来声明能被哪些域的SWF文件访问, SWF也可以通过API来确定自身能被哪些域的SWF加载. 当跨域访问资源时, 例如从域 a.com 请求域 b.com上的数据, 我们可以借助flash来发送HTTP请求. </p>
<ul>
<li>首先, 修改域 b.com上的 crossdomain.xml(一般存放在根目录, 如果没有需要手动创建) , 把 a.com 加入到白名单;</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span><span class="meta">?&gt;</span></span></div><div class="line"><span class="tag">&lt;<span class="name">cross-domain-policy</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">site-control</span> <span class="attr">permitted-cross-domain-policies</span>=<span class="string">"by-content-type"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">allow-access-from</span> <span class="attr">domain</span>=<span class="string">"a.com"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">cross-domain-policy</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>其次, 通过Flash URLLoader发送HTTP请求, 拿到请求后并返回;</li>
<li>最后, 通过Flash API把响应结果传递给JavaScript.</li>
</ul>
<p>Flash URLLoader是一种很普遍的跨域解决方案，不过需要支持iOS的话，这个方案就不可行了.</p>
<h4 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h4><p>在WebSocket出现之前, 很多网站为了实现实时推送技术, 通常采用的方案是轮询(Polling)和Comet技术, Comet又可细分为两种实现方式, 一种是长轮询机制, 一种称为流技术, 这两种方式实际上是对轮询技术的改进, 这些方案带来很明显的缺点, 需要由浏览器对服务器发出HTTP request, 大量消耗服务器带宽和资源. 面对这种状况, HTML5定义了WebSocket协议, 能更好的节省服务器资源和带宽并实现真正意义上的实时推送.</p>
<p>WebSocket 本质上是一个基于TCP的协议, 它的目标是在一个单独的持久链接上提供全双工(full-duplex), 双向通信, 以基于事件的方式, 赋予浏览器实时通信能力. 既然是双向通信, 就意味着服务器端和客户端可以同时发送并响应请求, 而不再像HTTP的请求和响应. (同源策略对 web sockets 不适用)</p>
<p>原理: 为了建立一个WebSocket连接，客户端浏览器首先要向服务器发起一个HTTP请求, 这个请求和通常的HTTP请求不同, 包含了一些附加头信息, 其中附加头信息”Upgrade: WebSocket”表明这是一个申请协议升级的HTTP请求, 服务器端解析这些附加的头信息然后产生应答信息返回给客户端, 客户端和服务器端的WebSocket连接就建立起来了, 双方就可以通过这个连接通道自由的传递信息, 并且这个连接会持续存在直到客户端或者服务器端的某一方主动的关闭连接.</p>
<p>一个典型WebSocket客户端请求头：</p>
<p><img src="http://louiszhai.github.io/docImages/cross-domain03.jpg" alt="WebSocket客户端请求头"></p>
<hr>
<p>本问就讨论这么多内容,大家有什么问题或好的想法欢迎在下方参与<a href="#respond">留言和评论</a>.</p>
<p>本文作者: <a href="https://github.com/Louiszhai" target="_blank" rel="external">louis</a></p>
<p>本文链接: <a href="http://louiszhai.github.io/2016/03/02/cross-domain/">http://louiszhai.github.io/2016/03/02/cross-domain/</a></p>
<p>参考文章</p>
<ul>
<li><a href="http://lc87624.iteye.com/blog/1123148" target="_blank" rel="external">学习总结 前端跨域请求的解决办法——JSONP-哥墨迹的iteye-ITeye技术网站</a></li>
<li><a href="http://www.cnblogs.com/dolphinX/p/3464056.html" target="_blank" rel="external">html5 postMessage解决跨域、跨窗口消息传递-Samaritans-博客园</a></li>
<li><a href="http://blog.csdn.net/kongjiea/article/details/44201021" target="_blank" rel="external">深入理解前端跨域方法和原理-kongjiea笔记-博客频道-CSDN.NET</a></li>
<li><a href="http://web.jobbole.com/83864/" target="_blank" rel="external">跨域访问和防盗链基本原理-WEB前端-伯乐在线</a></li>
<li><a href="http://unicorn-kid.com/fe-node/2014/08/07/JavaScript%20%E8%B7%A8%E5%9F%9F%20%E4%B9%8B%E4%B8%80%20%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5.html" target="_blank" rel="external">Javascript 跨域 之一 同源策略 - KID</a></li>
<li><a href="http://www.freebuf.com/articles/web/65468.html" target="_blank" rel="external">同源策略详解及绕过（Part1） - FreeBuf.COM | 关注黑客与极客</a></li>
<li><a href="http://www.plhwin.com/2014/05/28/nodejs-socketio/" target="_blank" rel="external">使用Node.js+Socket.IO搭建WebSocket实时应用 | 潘良虎的随想录</a></li>
<li><a href="http://blog.jackxy.com/cross-origin-123/" target="_blank" rel="external">跨域资源访问的几种方式</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      JavaScript Same-Origin 同源策略 跨域 jsonp postMessage CORS domain
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://louiszhai.github.io/tags/JavaScript/"/>
    
  </entry>
  
</feed>
