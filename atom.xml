<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[louis blog]]></title>
  <subtitle><![CDATA[程序猿 前端攻城师]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://louiszhai.github.io/"/>
  <updated>2016-08-14T14:14:32.000Z</updated>
  <id>http://louiszhai.github.io/</id>
  
  <author>
    <name><![CDATA[louis]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[全面解读Math对象及位运算]]></title>
    <link href="http://louiszhai.github.io/2016/07/01/Math/"/>
    <id>http://louiszhai.github.io/2016/07/01/Math/</id>
    <published>2016-06-30T23:57:48.000Z</published>
    <updated>2016-08-14T14:14:32.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u5BFC_u8BFB"><a href="#u5BFC_u8BFB" class="headerlink" title="导读"></a>导读</h3><p>截至ES5, JavaScript 中内置(build-in)构造器/对象共有13个, 其中9个是构造器(Number,Boolean, String, Object, Function, Array, RegExp, Error, Date), Global 不能直接访问, Arguments仅在函数调用时由JS引擎创建, 而 Math, JSON 是以对象形式存在的, 本篇将带你走进 JS 内置对象-Math的世界, 一探究竟.</p>
<a id="more"></a>
<h3 id="u4E3A_u4EC0_u4E48Math_u8FD9_u4E48_u8BBE_u8BA1"><a href="#u4E3A_u4EC0_u4E48Math_u8FD9_u4E48_u8BBE_u8BA1" class="headerlink" title="为什么Math这么设计"></a>为什么Math这么设计</h3><p>众所周知, 如果需要使用js进行一些常规的数学运算, 是一件十分麻烦的事情. 为了解决这个问题, ECMAScript 在1.1版本中便引入了 Math. Math 之所以被设计成一个对象, 而不是构造器, 是因为对象中的方法可以作为静态方法直接被调用, 方便使用, 同时, Math 也没有创建实例的必要.</p>
<h3 id="Math_u4E2D_u7684_u5C5E_u6027"><a href="#Math_u4E2D_u7684_u5C5E_u6027" class="headerlink" title="Math中的属性"></a>Math中的属性</h3><table>
<thead>
<tr>
<th style="text-align:center">属性名</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Math.E</td>
<td style="text-align:center">欧拉常数，也是自然对数的底数</td>
<td style="text-align:center">约2.718</td>
</tr>
<tr>
<td style="text-align:center">Math.LN2</td>
<td style="text-align:center">2的自然对数</td>
<td style="text-align:center">约0.693</td>
</tr>
<tr>
<td style="text-align:center">Math.LN10</td>
<td style="text-align:center">10的自然对数</td>
<td style="text-align:center">约2.303</td>
</tr>
<tr>
<td style="text-align:center">Math.LOG2E</td>
<td style="text-align:center">以2为底E的对数</td>
<td style="text-align:center">约1.443</td>
</tr>
<tr>
<td style="text-align:center">Math.LOG10E</td>
<td style="text-align:center">以10为底E的对数</td>
<td style="text-align:center">约0.434</td>
</tr>
<tr>
<td style="text-align:center">Math.PI</td>
<td style="text-align:center">圆周率</td>
<td style="text-align:center">约3.14</td>
</tr>
<tr>
<td style="text-align:center">Math.SQRT1_2</td>
<td style="text-align:center">1/2的平方根</td>
<td style="text-align:center">约0.707</td>
</tr>
<tr>
<td style="text-align:center">Math.SQRT2</td>
<td style="text-align:center">2的平方根</td>
<td style="text-align:center">约1.414</td>
</tr>
</tbody>
</table>
<h3 id="Math_u4E2D_u7684_u65B9_u6CD5"><a href="#Math_u4E2D_u7684_u65B9_u6CD5" class="headerlink" title="Math中的方法"></a>Math中的方法</h3><p>Math对象本就有很多用于运算的方法, 值得关注的是, ES6 规范又对Math对象做了一些扩展, 增加了一系列便捷的方法. 而这些方法大致可以分为以下三类.</p>
<h4 id="u4E09_u89D2_u51FD_u6570"><a href="#u4E09_u89D2_u51FD_u6570" class="headerlink" title="三角函数"></a>三角函数</h4><table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Math.sin(x)</td>
<td style="text-align:center">返回x的正弦值</td>
</tr>
<tr>
<td style="text-align:center">Math.sinh(x) ES6新增</td>
<td style="text-align:center">返回x的双曲正弦值</td>
</tr>
<tr>
<td style="text-align:center">Math.cos(x)</td>
<td style="text-align:center">返回x的余弦值</td>
</tr>
<tr>
<td style="text-align:center">Math.cosh(x) ES6新增</td>
<td style="text-align:center">返回x的双曲余弦值</td>
</tr>
<tr>
<td style="text-align:center">Math.tan(x)</td>
<td style="text-align:center">返回x的正切值</td>
</tr>
<tr>
<td style="text-align:center">Math.tanh(x) ES6新增</td>
<td style="text-align:center">返回x的双曲正切值</td>
</tr>
<tr>
<td style="text-align:center">Math.asin(x)</td>
<td style="text-align:center">返回x的反正弦值</td>
</tr>
<tr>
<td style="text-align:center">Math.asinh(x) ES6新增</td>
<td style="text-align:center">返回x的反双曲正弦值</td>
</tr>
<tr>
<td style="text-align:center">Math.acos(x)</td>
<td style="text-align:center">返回x的反余弦值</td>
</tr>
<tr>
<td style="text-align:center">Math.atan(x)</td>
<td style="text-align:center">返回x的反正切值</td>
</tr>
<tr>
<td style="text-align:center">Math.atan2(x, y)</td>
<td style="text-align:center">返回 y/x 的反正切值</td>
</tr>
<tr>
<td style="text-align:center">Math.atanh(x) ES6新增</td>
<td style="text-align:center">返回 x 的反双曲正切值</td>
</tr>
</tbody>
</table>
<h4 id="u6570_u5B66_u8FD0_u7B97_u65B9_u6CD5"><a href="#u6570_u5B66_u8FD0_u7B97_u65B9_u6CD5" class="headerlink" title="数学运算方法"></a>数学运算方法</h4><table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">例子</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Math.sqrt(x)</td>
<td style="text-align:center">返回x的平方根</td>
<td style="text-align:center">Math.sqrt(9);//3</td>
</tr>
<tr>
<td style="text-align:center">Math.exp(x)</td>
<td style="text-align:center">返回欧拉常数(e)的x次幂</td>
<td style="text-align:center">Math.exp(1);//约2.718</td>
</tr>
<tr>
<td style="text-align:center">Math.pow(x,y)</td>
<td style="text-align:center">返回x的y次幂, 如果y未初始化, 则返回x</td>
<td style="text-align:center">Math.pow(2, 3);//8</td>
</tr>
<tr>
<td style="text-align:center">Math.expm1(x) ES6新增</td>
<td style="text-align:center">返回欧拉常数(e)的x次幂减去1的值</td>
<td style="text-align:center">Math.exp(1);//约1.718</td>
</tr>
<tr>
<td style="text-align:center">Math.log(x)</td>
<td style="text-align:center">返回x的自然对数</td>
<td style="text-align:center">Math.log(1);//0</td>
</tr>
<tr>
<td style="text-align:center">Math.log1p(x) ES6新增</td>
<td style="text-align:center">返回x+1后的自然对数</td>
<td style="text-align:center">Math.log1p(0);//0</td>
</tr>
<tr>
<td style="text-align:center">Math.log2(x) ES6新增</td>
<td style="text-align:center">返回x以2为底的对数</td>
<td style="text-align:center">Math.log2(8);//3</td>
</tr>
<tr>
<td style="text-align:center">Math.log10(x) ES6新增</td>
<td style="text-align:center">返回x以10为底的对数</td>
<td style="text-align:center">Math.log10(100);//2</td>
</tr>
<tr>
<td style="text-align:center">Math.cbrt(x) ES6新增</td>
<td style="text-align:center">返回x的立方根</td>
<td style="text-align:center">Math.cbrt(8);//约2</td>
</tr>
<tr>
<td style="text-align:center">Math.clz32()  ES6新增</td>
<td style="text-align:center">返回一个数字在转换成 32位无符号整型数字的二进制形式后, 开头的 0 的个数</td>
<td style="text-align:center">Math.clz32(2);//30</td>
</tr>
<tr>
<td style="text-align:center">Math.hypot(x,y,z) ES6新增</td>
<td style="text-align:center">返回所有参数的平方和的平方根</td>
<td style="text-align:center">Math.hypot(3,4);//5</td>
</tr>
<tr>
<td style="text-align:center">Math.imul(x,y) ES6新增</td>
<td style="text-align:center">返回两个参数的类C的32位整数乘法运算的运算结果</td>
<td style="text-align:center">Math.imul(0xffffffff, 5);//-5</td>
</tr>
</tbody>
</table>
<h4 id="u6570_u503C_u8FD0_u7B97_u65B9_u6CD5"><a href="#u6570_u503C_u8FD0_u7B97_u65B9_u6CD5" class="headerlink" title="数值运算方法"></a>数值运算方法</h4><table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">例子</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Math.abs(x)</td>
<td style="text-align:center">返回x的绝对值</td>
<td style="text-align:center">Math.abs(-5);//5</td>
</tr>
<tr>
<td style="text-align:center">Math.floor(x)</td>
<td style="text-align:center">返回小于x的最大整数</td>
<td style="text-align:center">Math.floor(8.2);//8</td>
</tr>
<tr>
<td style="text-align:center">Math.ceil(x)</td>
<td style="text-align:center">返回大于x的最小整数</td>
<td style="text-align:center">Math.ceil(8.2);//9</td>
</tr>
<tr>
<td style="text-align:center">Math.trunc(x) ES6新增</td>
<td style="text-align:center">返回x的整数部分</td>
<td style="text-align:center">Math.trunc(1.23);//1</td>
</tr>
<tr>
<td style="text-align:center">Math.fround(x) ES6新增</td>
<td style="text-align:center">返回离它最近的<a href="https://en.wikipedia.org/wiki/Single-precision_floating-point_format" target="_blank" rel="external">单精度浮点数</a>形式的数字</td>
<td style="text-align:center">Math.fround(1.1);//1.100000023841858</td>
</tr>
<tr>
<td style="text-align:center">Math.min(x,y,z)</td>
<td style="text-align:center">返回多个数中的最小值</td>
<td style="text-align:center">Math.min(3,1,5);//1</td>
</tr>
<tr>
<td style="text-align:center">Math.max(x,y,z)</td>
<td style="text-align:center">返回多个数中的最大值</td>
<td style="text-align:center">Math.max(3,1,5);//5</td>
</tr>
<tr>
<td style="text-align:center">Math.round(x)</td>
<td style="text-align:center">返回四舍五入后的整数</td>
<td style="text-align:center">Math.round(8.2);//8</td>
</tr>
<tr>
<td style="text-align:center">Math.random()</td>
<td style="text-align:center">返回0到1之间的伪随机数</td>
<td style="text-align:center">Math.random();</td>
</tr>
<tr>
<td style="text-align:center">Math.sign(x) ES6新增</td>
<td style="text-align:center">返回一个数的符号( 5种返回值, 分别是 1, -1, 0, -0, NaN. 代表的各是正数, 负数, 正零, 负零, NaN)</td>
<td style="text-align:center">Math.sign(-5);//-1</td>
</tr>
</tbody>
</table>
<h4 id="u9644_3ANumber_u7C7B_u578B_u7684_u6570_u503C_u8FD0_u7B97_u65B9_u6CD5"><a href="#u9644_3ANumber_u7C7B_u578B_u7684_u6570_u503C_u8FD0_u7B97_u65B9_u6CD5" class="headerlink" title="附:Number类型的数值运算方法"></a>附:Number类型的数值运算方法</h4><p>Number.prototype中有一个方法叫做toFixed(), 用于将数值装换为指定小数位数的形式. </p>
<ul>
<li>没有参数或者参数为零的情况下, toFixed() 方法返回该数值的四舍五入后的整数形式, 等同于 Math.round(x);</li>
<li>其他情况下, 返回该数的指定小数位数的四舍五入后的结果.</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">1234.56789</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num.toFixed(),num.toFixed(<span class="number">0</span>));<span class="comment">//1235,1235</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toFixed(<span class="number">1</span>));<span class="comment">//1234.6</span></span><br><span class="line"><span class="built_in">console</span>.log(-<span class="number">1.235</span>.toFixed(<span class="number">2</span>));<span class="comment">//-1.24</span></span><br></pre></td></tr></table></figure>
<h3 id="Math_u65B9_u6CD5_u7684_u4E00_u4E9B_u89C4_u5F8B"><a href="#Math_u65B9_u6CD5_u7684_u4E00_u4E9B_u89C4_u5F8B" class="headerlink" title="Math方法的一些规律"></a>Math方法的一些规律</h3><p>以上, 数值运算中, 存在如下规律:</p>
<ol>
<li>Math.trunc(x) 方法当 ① x为正数时, 运算结果同 Math.floor(x); ② x为负数时, 运算结果同 Math.ceil(x). 实际上, 它完全可以由位运算替代, 且运算速度更快, 如 2.5&amp;-1 或 2.5|0 或 ~~2.5 或 2.5^0 , 它们的运算结果都为2; 如 -2.5&amp;-1 或 -2.5|0 或 ~~-2.5 或 -2.5^0 , 它们的运算结果都为-2;</li>
<li>Math.min(x,y,z) 与 Math.max(x,y,z) 方法由于可接无限个参数, 可用于求数组元素的最小最大值. 如: <code>Math.max.apply(null,[5,3,8,9]); // 9</code> . 但是Math.min 不传参数返回 <code>Infinity</code>, Math.max 不传参数返回 <code>-Infinity</code> .</li>
<li>稍微利用 Math.random() 方法的特性, 就可以生成任意范围的数字. 如: 生成10到80之间的随机数, ~~(Math.random()*70 + 10);// 返回10~80之间的随机数, 包含10不包含80</li>
</ol>
<p>除去上述方法, Math作为对象, 继承了来之Object对象的方法. 其中一些如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.valueOf();<span class="comment">//返回Math对象本身</span></span><br><span class="line">+<span class="built_in">Math</span>; <span class="comment">//NaN, 试图转换成数字,由于不能转换为数字,返回NaN</span></span><br><span class="line"><span class="built_in">Math</span>.toString();<span class="comment">//"[object Math]"</span></span><br></pre></td></tr></table></figure>
<h3 id="u4F4D_u8FD0_u7B97"><a href="#u4F4D_u8FD0_u7B97" class="headerlink" title="位运算"></a>位运算</h3><p>Math对象提供的方法种类繁多, 且覆盖面非常全面, 基本上能够满足日常开发所需. 但同时我们也都知道, 使用Math对象的方法进行数值运算时, js代码经过解释编译, 最终会以二进制的方式进行运算. 这种运算方式效率较低, 那么能不能进一步提高运算的效率的呢? 如果我们使用位运算就可. 这是因为位运算本就是直接进行二进制运算.</p>
<h4 id="u6570_u503C_u7684_u4E8C_u8FDB_u5236_u503C"><a href="#u6570_u503C_u7684_u4E8C_u8FDB_u5236_u503C" class="headerlink" title="数值的二进制值"></a>数值的二进制值</h4><p>由于位运算是基于二进制的, 因此我们需要先获取数值的二进制值. 实际上, toString 方法已经帮我们做好了一部分工作, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正整数可通过toString获取</span></span><br><span class="line"><span class="number">12.</span>.toString(<span class="number">2</span>);<span class="comment">//1100</span></span><br><span class="line"><span class="comment">//负整数问题就来了</span></span><br><span class="line">(-<span class="number">12</span>).toString(<span class="number">2</span>);<span class="comment">//-1100</span></span><br></pre></td></tr></table></figure>
<p>已知: 负数在计算机内部是采用补码表示的. 例如 -1, 1的原码是 0000 0001, 那么1的反码是 1111 1110, 补码是 1111 1111.</p>
<p>故: 负数的十进制转换为二进制时,符号位不变,其它位取反后+1. 即: <strong><code>-x的二进制 = x的二进制取反+1</code></strong> . 由按位取反可借助^运算符, 故负整数的二进制可以借助下面这个函数来获取:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBinary</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> s = (-num).toString(<span class="number">2</span>),</span><br><span class="line">      array = [].map.call(s,<span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v^<span class="number">1</span>;</span><br><span class="line">      &#125;);</span><br><span class="line">  array.reduceRight(<span class="function"><span class="keyword">function</span>(<span class="params">previousValue, value, index, array</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> v = previousValue ^ value;</span><br><span class="line">    array[index] = v;</span><br><span class="line">    <span class="keyword">return</span> +!v;</span><br><span class="line">  &#125;,<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> array.join(<span class="string">''</span>);</span><br><span class="line">&#125;</span><br><span class="line">getBinary(-<span class="number">12</span>);<span class="comment">//0100, 前面未补全的部分全部为1</span></span><br></pre></td></tr></table></figure>
<p>然后, 多试几次就会发现:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getBinary(-<span class="number">1</span>) == <span class="number">1.</span>.toString(<span class="number">2</span>); <span class="comment">//true</span></span><br><span class="line">getBinary(-<span class="number">2</span>) == <span class="number">2.</span>.toString(<span class="number">2</span>); <span class="comment">//true</span></span><br><span class="line">getBinary(-<span class="number">4</span>) == <span class="number">4.</span>.toString(<span class="number">2</span>); <span class="comment">//true</span></span><br><span class="line">getBinary(-<span class="number">8</span>) == <span class="number">8.</span>.toString(<span class="number">2</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>这表明:</p>
<ul>
<li><strong>2的整数次方的值与它的相对数, 他们后面真正有效的那几位都相同</strong>.</li>
</ul>
<p>同样, 负数的二进制转十进制时, 符号位不变, 其他位取反后+1. 可参考:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">translateBinary2Decimal</span>(<span class="params">binaryString</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> array = [].map.call(binaryString,<span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v^<span class="number">1</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  array.reduceRight(<span class="function"><span class="keyword">function</span>(<span class="params">previousValue, value, index, array</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> v = previousValue ^ value;</span><br><span class="line">    array[index] = v;</span><br><span class="line">    <span class="keyword">return</span> +!v;</span><br><span class="line">  &#125;,<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">parseInt</span>(array.join(<span class="string">''</span>),<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">translateBinary2Decimal(getBinary(-<span class="number">12</span>));<span class="comment">//12</span></span><br></pre></td></tr></table></figure>
<p>由上, 二进制转十进制和十进制转二进制的函数, 大部分都可以共用, 因此下面提供一个统一的函数解决它们的互转问题:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">translateBinary</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> s = <span class="literal">null</span>,</span><br><span class="line">      array = <span class="literal">null</span>,</span><br><span class="line">      type = <span class="keyword">typeof</span> item,</span><br><span class="line">      symbol = !<span class="regexp">/^-/</span>.test(item+<span class="string">''</span>);</span><br><span class="line">  <span class="keyword">switch</span>(type)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"number"</span>: </span><br><span class="line">      s = <span class="built_in">Math</span>.abs(item).toString(<span class="number">2</span>);</span><br><span class="line">      <span class="keyword">if</span>(symbol)&#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"string"</span>:</span><br><span class="line">      <span class="keyword">if</span>(symbol)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">parseInt</span>(item,<span class="number">2</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      s = item.substring(<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//按位取反</span></span><br><span class="line">  array = [].map.call(s,<span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v^<span class="number">1</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">//+1</span></span><br><span class="line">  array.reduceRight(<span class="function"><span class="keyword">function</span>(<span class="params">previousValue, value, index, array</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> v = (previousValue + value)==<span class="number">2</span>;</span><br><span class="line">    array[index] = previousValue ^ value;</span><br><span class="line">    <span class="keyword">return</span> +v;</span><br><span class="line">  &#125;,<span class="number">1</span>);</span><br><span class="line">  s = array.join(<span class="string">''</span>);</span><br><span class="line">  <span class="keyword">return</span> type==<span class="string">"number"</span>?<span class="string">'-'</span>+s:-<span class="built_in">parseInt</span>(s,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">translateBinary(-<span class="number">12</span>);<span class="comment">//-0100</span></span><br><span class="line">translateBinary(<span class="string">'-0100'</span>);<span class="comment">//-12</span></span><br></pre></td></tr></table></figure>
<h4 id="u5E38_u7528_u7684_u4E8C_u8FDB_u5236_u6570"><a href="#u5E38_u7528_u7684_u4E8C_u8FDB_u5236_u6570" class="headerlink" title="常用的二进制数"></a>常用的二进制数</h4><table>
<thead>
<tr>
<th style="text-align:center">二进制数</th>
<th style="text-align:center">二进制值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0xAAAAAAAA</td>
<td style="text-align:center">10101010101010101010101010101010</td>
</tr>
<tr>
<td style="text-align:center">0x55555555</td>
<td style="text-align:center">01010101010101010101010101010101</td>
</tr>
<tr>
<td style="text-align:center">0xCCCCCCCC</td>
<td style="text-align:center">11001100110011001100110011001100</td>
</tr>
<tr>
<td style="text-align:center">0x33333333</td>
<td style="text-align:center">00110011001100110011001100110011</td>
</tr>
<tr>
<td style="text-align:center">0xF0F0F0F0</td>
<td style="text-align:center">11110000111100001111000011110000</td>
</tr>
<tr>
<td style="text-align:center">0x0F0F0F0F</td>
<td style="text-align:center">00001111000011110000111100001111</td>
</tr>
<tr>
<td style="text-align:center">0xFF00FF00</td>
<td style="text-align:center">11111111000000001111111100000000</td>
</tr>
<tr>
<td style="text-align:center">0x00FF00FF</td>
<td style="text-align:center">00000000111111110000000011111111</td>
</tr>
<tr>
<td style="text-align:center">0xFFFF0000</td>
<td style="text-align:center">11111111111111110000000000000000</td>
</tr>
<tr>
<td style="text-align:center">0x0000FFFF</td>
<td style="text-align:center">00000000000000001111111111111111</td>
</tr>
</tbody>
</table>
<p>现在也可以使用上述方法来验证下常用的二进制值对不对. 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">translateBinary(<span class="number">0xAAAAAAAA</span>);<span class="comment">//10101010101010101010101010101010</span></span><br></pre></td></tr></table></figure>
<h4 id="u6309_u4F4D_u4E0E_28_26amp_3B_29"><a href="#u6309_u4F4D_u4E0E_28_26amp_3B_29" class="headerlink" title="按位与(&amp;)"></a>按位与(&amp;)</h4><p>&amp;运算符用于连接两个数, 连接的两个数它们二进制形式的值每位都将参与运算, 只有相对应的位上都为1时, 该位的运算才返回1. 比如 3 和 9 进行按位与运算, 以下是运算过程:</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0011	//3的二进制形式</span><br><span class="line"><span class="header">&amp;	1001	//9的二进制形式</span><br><span class="line">----------</span></span><br><span class="line"><span class="code">	0001	//1,相同位数依次运算,除最后一位都是1,返回1以外, 其它位数由于不同时为1都返回0</span></span><br></pre></td></tr></table></figure>
<p>由上, 3&amp;9的运算结果为1. 实际上, 对于按位与(&amp;)运算, 满足如下规律:</p>
<ol>
<li><strong>数值与自身(或者-1)按位与运算返回数值自身</strong>.</li>
<li><strong>2的整数次方的值与它的相对数按位与运算返回它自身</strong>.</li>
<li><strong>任意整数与0进行按位与运算, 都将会返回0</strong>.</li>
<li><strong>任意整数与1进行按位与运算, 都只有0 或1 两个返回值</strong>.</li>
<li><strong>按位与运算的结果不大于两数中的最大值</strong>.</li>
</ol>
<p>由公式1, 我们可以对非整数取整. 即 <code>x&amp;x === x&amp;-1 === Math.trunc(x)</code> 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">5.2</span>&amp;<span class="number">5.2</span>);<span class="comment">//5</span></span><br><span class="line"><span class="built_in">console</span>.log(-<span class="number">5.2</span>&amp;-<span class="number">1</span>);<span class="comment">//-5</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.trunc(-<span class="number">5.2</span>)===(-<span class="number">5.2</span>&amp;-<span class="number">1</span>));<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>由公式4, 我们可以由此判断数值是否为奇数. 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="number">1</span> &amp; x)&#123;<span class="comment">//如果x为奇数,它的二进制形式最后一位必然是1,同1进行按位与运算后,将返回1,而1又会隐式转换为true</span></span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"x为奇数"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u6309_u4F4D_u6216_28_7C_29"><a href="#u6309_u4F4D_u6216_28_7C_29" class="headerlink" title="按位或(|)"></a>按位或(|)</h4><p>|不同于&amp;, |运算符连接的两个数, 只要其二进制形式的各位上有一个为1, 该位的运算就返回1, 否则返回0. 比如 3 和 12 进行按位或运算, 以下是运算过程:</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0011	//3的二进制形式</span><br><span class="line"><span class="header">|	1100	//12的二进制形式</span><br><span class="line">----------</span></span><br><span class="line"><span class="code">	1111	//15, 相同位数依次运算,遇1返回1,故最终结果为4个1.</span></span><br></pre></td></tr></table></figure>
<p>由上, 3|12的运算结果为15. 实际上, 对于按位或(|)运算, 满足如下规律: </p>
<ol>
<li><strong>数值与自身按位或运算返回数值自身</strong>.</li>
<li><strong>2的整数次方的值与它的相对数按位或运算返回它的相对数</strong>.</li>
<li><strong>任意整数与0进行按位或运算, 都将会返回它本身</strong>.</li>
<li><strong>任意整数与-1进行按位或运算, 都将返回-1</strong>.</li>
<li><strong>按位或运算的结果介于参与运算的两个数值之间</strong>.</li>
</ol>
<p>稍微利用公式1, 我们便可以将非整数取整.   即 <strong><code>x|0 === Math.trunc(x)</code></strong> 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">5.2</span>|<span class="number">0</span>);<span class="comment">//5</span></span><br><span class="line"><span class="built_in">console</span>.log(-<span class="number">5.2</span>|<span class="number">0</span>);<span class="comment">//-5</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.trunc(-<span class="number">5.2</span>)===(-<span class="number">5.2</span>|<span class="number">0</span>));<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>为什么 5.2|0 运算后会返回5呢? 这是因为浮点数并不支持位运算, 运算前, 5.2会转换为整数5再和0进行位运算, 故, 最终返回5.</p>
<h4 id="u6309_u4F4D_u975E_28_7E_29"><a href="#u6309_u4F4D_u975E_28_7E_29" class="headerlink" title="按位非(~)"></a>按位非(~)</h4><p>~运算符, 返回数值二进制形式的反码. 什么意思呢, 就是说一个数值二进制形式中的每一位都将取反, 如果该位为1, 取反为0, 如果该位为0, 取反为1. 我们来举个例子理解下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">~	<span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0011</span>	<span class="comment">//3的32位二进制形式</span></span><br><span class="line">--------------------------------------------</span><br><span class="line">	<span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1100</span>	<span class="comment">//按位取反后为负数(最高位(第一位)表示正负,1代表负,0代表正)</span></span><br><span class="line">--------------------------------------------</span><br><span class="line">	<span class="number">1000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0011</span>	<span class="comment">//负数的二进制转换为十进制时,符号位不变,其它位取反(后+1)</span></span><br><span class="line">	<span class="number">1000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0100</span> <span class="comment">// +1</span></span><br><span class="line">--------------------------------------------</span><br><span class="line">									-<span class="number">4</span>	 <span class="comment">//最终运算结果为-4</span></span><br></pre></td></tr></table></figure>
<p>实际上, 按位非(~)操作不需要这么兴师动众地去计算, 它有且仅有一条运算规律:</p>
<ul>
<li><strong>按位非操作一个数值, 等同于这个数值加1然后符号改变. 即: <code>~x === -x-1</code></strong>.</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~<span class="number">5</span> ==&gt; -<span class="number">5</span>-<span class="number">1</span> === -<span class="number">6</span>;</span><br><span class="line">~-<span class="number">2016</span> ==&gt; <span class="number">2016</span>-<span class="number">1</span> === <span class="number">2015</span>;</span><br></pre></td></tr></table></figure>
<p>由上述公式可推出: <strong><code>~~x === -(-x-1)-1 === x</code></strong>. 由于位运算摈除小数部分的特性, 连续两次按位非也可用于将非整数取整. 即, <strong><code>~~x === Math.trunc(x)</code></strong> 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(~~<span class="number">5.2</span>);<span class="comment">//5</span></span><br><span class="line"><span class="built_in">console</span>.log(~~-<span class="number">5.2</span>);<span class="comment">//-5</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.trunc(-<span class="number">5.2</span>)===(~~-<span class="number">5.2</span>));<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>按位非(~)运算符只能用来求数值的反码, 并且还不能输出反码的二进制字符串. 我们来稍微扩展下, 使它变得更易用.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">waveExtend</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> s = <span class="keyword">typeof</span> item == <span class="string">'number'</span> &amp;&amp; translateBinary(~item);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> s == <span class="string">'string'</span>?s:[].map.call(item,<span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v===<span class="string">'-'</span>?v:v^<span class="number">1</span>;</span><br><span class="line">  &#125;).join(<span class="string">''</span>).replace(<span class="regexp">/^-?/</span>,<span class="function"><span class="keyword">function</span>(<span class="params">m</span>)</span>&#123;<span class="keyword">return</span> m==<span class="string">''</span>?<span class="string">'-'</span>:<span class="string">''</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line">waveExtend(-<span class="number">8</span>);<span class="comment">//111 -8反码,正数省略的位全部为0</span></span><br><span class="line">waveExtend(<span class="number">12</span>);<span class="comment">//-0011 12的反码,负数省略的位全部为1</span></span><br></pre></td></tr></table></figure>
<h4 id="u6309_u4F4D_u5F02_u6216_28_5E_29"><a href="#u6309_u4F4D_u5F02_u6216_28_5E_29" class="headerlink" title="按位异或(^)"></a>按位异或(^)</h4><p>^运算符连接的两个数, 它们二进制形式的值每位参与运算, 只有相对应的每位值不同, 才返回1, 否则返回0.<br>(相同则消去, 有些类似两两消失的消消乐). 如下:</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">	0011	//3的二进制形式</span></span><br><span class="line"><span class="header">^	1000	//8的二进制形式</span><br><span class="line">-----------</span></span><br><span class="line"><span class="code">	1011	//11, 相同位数依次运算, 值不同的返回1</span></span><br></pre></td></tr></table></figure>
<p>对于按位异或(^)操作, 满足如下规律:</p>
<ol>
<li><strong>由于按位异或位运算的特殊性, 数值与自身按位异或运算返回0</strong>. 如: <code>8^8=0</code> , 公式为 <code>a^a=0</code> .</li>
<li><strong>任意整数与0进行按位异或运算, 都将会返回它本身</strong>. 如: <code>0^-98=-98</code> , 公式为 <code>0^a=a</code>.</li>
<li><strong>任意整数x与1(2的0次方)进行按位异或运算, 若它为奇数, 则返回 <code>x-1</code>, 若它为偶数, 则返回 <code>x+1</code> </strong>. 如: <code>1^-9=-10</code> , <code>1^100=101</code>  . 公式为 <code>1^奇=奇-1</code> , <code>1^偶=偶+1</code> ; 推而广之, <strong>任意整数x与2的n次方进行按位异或运算, 若它的二进制形式的倒数第n+1位是1, 则返回 <code>x-2的n次方</code>, 反之若为0, 则返回 <code>x+2的n次方</code> </strong>.</li>
<li><strong>任意整数x与-1(负2的1次方+1)进行按位异或运算, 则将返回 <code>-x-1</code>, 相当于~x运算 </strong>. 如: <code>-1^100=-101</code> , <code>-1^-9=8</code> . 公式为 <code>-1^x=-x-1=~x</code> .</li>
<li><strong>任意整数连续按位异或两次相同的数值, 返回它本身</strong>. 如: <code>3^8^8=3</code> , 公式为 <code>a^b^b=a</code> 或 <code>a^b^a=b</code> .</li>
<li><strong>按位异或满足操作数与运算结果3个数值之间的交换律: 按位异或的两个数值, 以及他们运算的结果, 共三个数值可以两两异或得到另外一个数值</strong> . 如: <code>3^9=10</code> , <code>3^10=9</code> , <code>9^10=3</code> ; 公式为 <code>a^b=c</code> , <code>a^c=b</code> , <code>b^c=a</code> .</li>
</ol>
<p>以上公式中, 1, 2, 3和4都是由按位异或运算特性推出的, 公式5可由公式1和2推出, 公式6可由公式5推出.</p>
<p>由于按位异或运算的这种可交换的性质, 我们可用它辅助交换两个整数的值. 如下, 假设这两个值为a和b:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="number">1</span>,b=<span class="number">2</span>;</span><br><span class="line"><span class="comment">//常规方法</span></span><br><span class="line"><span class="keyword">var</span> tmp = a;</span><br><span class="line">a=b;</span><br><span class="line">b=tmp;</span><br><span class="line"><span class="built_in">console</span>.log(a,b);<span class="comment">//2 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用按位异或~的方法</span></span><br><span class="line">a=a^b;	<span class="comment">//假设a,b的原始值分别为a0,b0</span></span><br><span class="line">b=a^b;	<span class="comment">//等价于 b=a0^b0^b0 ==&gt; b=a0</span></span><br><span class="line">a=a^b;	<span class="comment">//等价于 a=a0^b0^a0 ==&gt; a=b0</span></span><br><span class="line"><span class="built_in">console</span>.log(a,b);<span class="comment">//2 1</span></span><br><span class="line"><span class="comment">//以上可简写为</span></span><br><span class="line">a^=b;b^=a;a^=b;</span><br></pre></td></tr></table></figure>
<h4 id="u4F4D_u8FD0_u7B97_u5C0F_u7ED3"><a href="#u4F4D_u8FD0_u7B97_u5C0F_u7ED3" class="headerlink" title="位运算小结"></a>位运算小结</h4><p>由上可以看出:</p>
<ul>
<li>由于连接两个数值的位运算均是对相同的位进行比较操作, 故运算数值的先后位置并不重要, 这些位运算(&amp; | ^)满足交换律. 即: <code>a操作符b === b操作符a</code>.</li>
<li>位运算中, 数字0和1都比较特殊. 记住它们的规律, 常可简化运算.</li>
<li>位运算(&amp;|~^)可用于取整, 同 Math.trunc().</li>
</ul>
<h4 id="u6709_u7B26_u53F7_u5DE6_u79FB_28_26lt_3B_26lt_3B_29"><a href="#u6709_u7B26_u53F7_u5DE6_u79FB_28_26lt_3B_26lt_3B_29" class="headerlink" title="有符号左移(&lt;&lt;)"></a>有符号左移(&lt;&lt;)</h4><p>&lt;&lt;运算符, 表示将数值的32位二进制形式的除符号位之外的其他位都往左移动若干位数. 当x为整数时, 有: <code>x&lt;&lt;n === x*Math.pow(2,n)</code> 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>&lt;&lt;<span class="number">3</span>);<span class="comment">//8</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">100</span>&lt;&lt;<span class="number">4</span>);<span class="comment">//1600</span></span><br></pre></td></tr></table></figure>
<p>如此, Math.pow(2,n) 便可简写为 1&lt;&lt;n.</p>
<p>据说, 乘上一个2的倍数数值, 可以改用有符号左移(&lt;&lt;)运算符, 将加速 300%.</p>
<h4 id="u6709_u7B26_u53F7_u53F3_u79FB_28_26gt_3B_26gt_3B_29"><a href="#u6709_u7B26_u53F7_u53F3_u79FB_28_26gt_3B_26gt_3B_29" class="headerlink" title="有符号右移(&gt;&gt;)"></a>有符号右移(&gt;&gt;)</h4><p>>&gt;运算符, 除了方向向右, 其他同&lt;&lt;运算符. 当x为整数时, 有: <code>x&gt;&gt;n === x*Math.pow(2,-n)</code> . 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(-<span class="number">5</span>&gt;&gt;<span class="number">2</span>);<span class="comment">//-2</span></span><br><span class="line"><span class="built_in">console</span>.log(-<span class="number">7</span>&gt;&gt;<span class="number">3</span>);<span class="comment">//-1</span></span><br></pre></td></tr></table></figure>
<p>右移负整数时, 返回值最大为-1.</p>
<p>右移正整数时, 返回值最小为0.</p>
<p>据说, 除以一个2的倍数数值, 可以改用有符号左移(&gt;&gt;)运算符, 将加速 350%.</p>
<h4 id="u65E0_u7B26_u53F7_u53F3_u79FB_28_26gt_3B_26gt_3B_26gt_3B_29"><a href="#u65E0_u7B26_u53F7_u53F3_u79FB_28_26gt_3B_26gt_3B_26gt_3B_29" class="headerlink" title="无符号右移(&gt;&gt;&gt;)"></a>无符号右移(&gt;&gt;&gt;)</h4><p>>&gt;&gt;运算符, 表示连同符号也一起右移. </p>
<p>注意:无符号右移(&gt;&gt;&gt;)会把负数的二进制码当成正数的二进制码. 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(-<span class="number">8</span>&gt;&gt;&gt;<span class="number">5</span>);<span class="comment">//134217727</span></span><br><span class="line"><span class="built_in">console</span>.log(-<span class="number">1</span>&gt;&gt;&gt;<span class="number">0</span>);<span class="comment">//4294967295</span></span><br></pre></td></tr></table></figure>
<p>以上, 虽然-1没有发生向右位移, 但是-1的二进制码, 已经变成了正数的二进制码. 我们来回顾下这个过程.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">translateAry(-<span class="number">1</span>);<span class="comment">//-1,补全-1的二进制码至32位: 11111111111111111111111111111111</span></span><br><span class="line">translateAry(<span class="string">'11111111111111111111111111111111'</span>);<span class="comment">//4294967295</span></span><br></pre></td></tr></table></figure>
<p>可见, -1的二进制形式本就是32个1, 将这32个1当正数的二进制处理, 直接还原成十进制, 刚好就是 4294967295.</p>
<p>由此, 使用 &gt;&gt;&gt;运算符, 即使是右移0位, 对于负数而言也是翻天覆地的变化. 但是对于正数却没有改变. 利用这个特性, 可以判断数值的正负. 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSymbol</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num === (num&gt;&gt;&gt;<span class="number">0</span>)?<span class="string">"正数"</span>:<span class="string">"负数"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getSymbol(-<span class="number">100</span>), getSymbol(<span class="number">123</span>));<span class="comment">//负数 正数</span></span><br></pre></td></tr></table></figure>
<h4 id="u8FD0_u7B97_u7B26_u4F18_u5148_u7EA7"><a href="#u8FD0_u7B97_u7B26_u4F18_u5148_u7EA7" class="headerlink" title="运算符优先级"></a>运算符优先级</h4><table>
<thead>
<tr>
<th style="text-align:center">优先级</th>
<th style="text-align:center">运算符</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">后置++ , 后置– , [] , () 或 .</td>
<td style="text-align:center">后置++,后置–,数组下标,括号 或 属性选择</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">- , 前置++ , 前置– , ! 或 ~</td>
<td style="text-align:center">负号,前置++,前置–, 逻辑非 或 按位非</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">* , / 或 %</td>
<td style="text-align:center">乘 , 除 或 取模</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">+ 或 -</td>
<td style="text-align:center">加 或 减</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">&lt;&lt; 或 &gt;&gt;</td>
<td style="text-align:center">左移 或 右移</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">> , &gt;= , &lt; 或 &lt;=</td>
<td style="text-align:center">大于, 大于等于, 小于 或 小于等于</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">== 或 !=</td>
<td style="text-align:center">等于 或 不等于</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">&amp;</td>
<td style="text-align:center">按位与</td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">^</td>
<td style="text-align:center">按位异或</td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">\</td>
<td style="text-align:center"></td>
<td>按位或</td>
</tr>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:center">&amp;&amp;</td>
<td style="text-align:center">逻辑与</td>
</tr>
<tr>
<td style="text-align:center">12</td>
<td style="text-align:center">\</td>
<td style="text-align:center">\</td>
<td></td>
<td>逻辑或</td>
</tr>
<tr>
<td style="text-align:center">13</td>
<td style="text-align:center">?:</td>
<td style="text-align:center">条件运算符</td>
</tr>
<tr>
<td style="text-align:center">14</td>
<td style="text-align:center">=,/=,*=,%=,+=,-=,&lt;&lt;=,&gt;&gt;=,&amp;=,^=,\</td>
<td style="text-align:center">=</td>
<td>各种运算后赋值</td>
</tr>
<tr>
<td style="text-align:center">15</td>
<td style="text-align:center">,</td>
<td style="text-align:center">逗号</td>
</tr>
</tbody>
</table>
<p>可以看到, ① 除了按位非(~)以外, 其他的位运算符的优先级都是低于+-运算符的; ② 按位与(&amp;), 按位异或(^) 或 按位或(|) 的运算优先级均低于比较运算符(&gt;,&lt;,=等); ③位运算符中按位或(|)优先级最低.</p>
<h3 id="u7EFC_u5408_u8FD0_u7528"><a href="#u7EFC_u5408_u8FD0_u7528" class="headerlink" title="综合运用"></a>综合运用</h3><h4 id="u8BA1_u7B97_u7EDD_u5BF9_u503C"><a href="#u8BA1_u7B97_u7EDD_u5BF9_u503C" class="headerlink" title="计算绝对值"></a>计算绝对值</h4><p>使用有符号右移(&gt;&gt;)运算符, 以及按位异或(^)运算符, 我们可以实现一个 Math.abs方法. 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">abs</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = num&gt;&gt;<span class="number">31</span>,	<span class="comment">//保留32二进制中的符号位,根据num的正负性分别返回0或-1</span></span><br><span class="line">      y = num^x;	<span class="comment">//返回正数,且利用按位异或中的公式2,若num为正数,num^0则返回num本身;若num为负数,则相当于num^-1,利用公式4, 此时返回-num-1</span></span><br><span class="line">  <span class="keyword">return</span> y-x;		<span class="comment">//若num为正数,则返回num-0即num;若num为负数则返回-num-1-(-1)即|num|</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u6BD4_u8F83_u4E24_u6570_u662F_u5426_u7B26_u53F7_u76F8_u540C"><a href="#u6BD4_u8F83_u4E24_u6570_u662F_u5426_u7B26_u53F7_u76F8_u540C" class="headerlink" title="比较两数是否符号相同"></a>比较两数是否符号相同</h4><p>通常, 比较两个数是否符号相同, 我们使用x*y&gt;0 来判断即可. 但如果利用按位异或(^), 运算速度将更快.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(-<span class="number">17</span> ^ <span class="number">9</span> &gt; <span class="number">0</span>);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<h4 id="u5BF92_u7684n_u6B21_u65B9_u53D6_u6A21_28n_u4E3A_u6B63_u6574_u6570_29"><a href="#u5BF92_u7684n_u6B21_u65B9_u53D6_u6A21_28n_u4E3A_u6B63_u6574_u6570_29" class="headerlink" title="对2的n次方取模(n为正整数)"></a>对2的n次方取模(n为正整数)</h4><p>比如 123%8, 实际上就是求一个余数, 并且这个余数还不大于8, 最大为7. 然后剩下的就是比较二进制值里, 123与7有几成相似了. 便不难推出公式: <code>x%(1&lt;&lt;n)==x&amp;(1&lt;&lt;n)-1</code> . </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">123</span>%<span class="number">8</span>);<span class="comment">//3</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">123</span>&amp;(<span class="number">1</span>&lt;&lt;<span class="number">3</span>)-<span class="number">1</span>);<span class="comment">//3 , 为什么-1时不用括号括起来, 这是因为-优先级高于&amp;</span></span><br></pre></td></tr></table></figure>
<h4 id="u7EDF_u8BA1_u6B63_u6570_u4E8C_u8FDB_u5236_u503C_u4E2D1_u7684_u4E2A_u6570"><a href="#u7EDF_u8BA1_u6B63_u6570_u4E8C_u8FDB_u5236_u503C_u4E2D1_u7684_u4E2A_u6570" class="headerlink" title="统计正数二进制值中1的个数"></a>统计正数二进制值中1的个数</h4><p>不妨先判断n的奇偶性, 为奇数时计数器增加1, 然后将n右移一位, 重复上面步骤, 直到递归退出.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTotalForOne</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">  	<span class="keyword">return</span> n?(n&amp;<span class="number">1</span>)+<span class="built_in">arguments</span>.callee(n&gt;&gt;<span class="number">1</span>):<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">getTotalForOne(<span class="number">9</span>);<span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<h4 id="u5B9E_u73B0_u52A0_u6CD5_u8FD0_u7B97"><a href="#u5B9E_u73B0_u52A0_u6CD5_u8FD0_u7B97" class="headerlink" title="实现加法运算"></a>实现加法运算</h4><p>加法运算, 从二进制值的角度看, 有 ①同位相加 和 ②遇2进1 两种运算(实际上, 十进制运算也是一样, 同位相加, 遇10进1). </p>
<p>首先我们看看第①种, 同位相加, 不考虑②遇2进1.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="number">1</span> = <span class="number">0</span></span><br><span class="line"><span class="number">1</span> + <span class="number">0</span> = <span class="number">1</span></span><br><span class="line"><span class="number">0</span> + <span class="number">1</span> = <span class="number">1</span></span><br><span class="line"><span class="number">0</span> + <span class="number">0</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>以上运算过程有没有很熟悉. 是不是和按位异或(^)运算有着惊人的相似. 如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> ^ <span class="number">1</span> = <span class="number">0</span></span><br><span class="line"><span class="number">1</span> ^ <span class="number">0</span> = <span class="number">1</span></span><br><span class="line"><span class="number">0</span> ^ <span class="number">1</span> = <span class="number">1</span></span><br><span class="line"><span class="number">0</span> ^ <span class="number">0</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>因此①同位相加的运算, 完全可由按位异或(^)代替, 即: x^y.</p>
<p>那么②遇2进1 应该怎么实现呢? 实际上, 非位移位运算中, 只有按位与(&amp;)才能满足遇2的场景, 且只有有符号左移(&lt;&lt;)能满足进1的场景.</p>
<p>现在范围缩小了, 就看&amp;和&lt;&lt;运算符能不能真正满足需要了. 值得高兴的是, 按位与(&amp;)只有在同位都是1的情况下才返回1, 其他情况均返回0. 如果对其运算结果再做左移一位的运算, 即: (x&amp;y)&lt;&lt;1. 刚好满足了②遇2进1的场景.</p>
<p>因为我们是将①同位相加和②遇2进1的两种运算分开进行. 那么最终的加法运算结果应该还要做一次加法. 如下:</p>
<p>最终公式: <code>x + y = x^y + (x&amp;y)&lt;&lt;1</code> </p>
<p>这个公式并不完美, 因为它还是使用了加法, 推导公式怎么能直接使用推导结果呢? 太可怕了, 就不怕掉入递归深渊吗? 下面我们就来绕过这个坑. 而绕过这个坑有一个前提, 那就是只要 x^y 或 (x&amp;y)&lt;&lt;1中有一个值为0就行了, 这样便不用进行加法运算了. 讲了这么多, 不如看代码.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _x = x^y,</span><br><span class="line">      _y = (x&amp;y)&lt;&lt;<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> !_x &amp;&amp; _y || !_y &amp;&amp; _x || <span class="built_in">arguments</span>.callee(_x,_y);</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">12345678</span>,<span class="number">87654321</span>);<span class="comment">//999999999</span></span><br><span class="line">add(<span class="number">9527</span>,-<span class="number">12</span>);<span class="comment">//9515</span></span><br></pre></td></tr></table></figure>
<h3 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h3><p>Math对象中, 比较常用的就是数值运算方法, 不妨多看看, 其他的知道有这个api就行了. 而位运算中, 则需要基本了解每种位运算符的运算方式, 如果能注意运算中 0和1等特殊数值 的一些妙用就更好了. 同时, 如果对负数的位运算不甚理解, 建议去补下计算机的补码.希望能对您有所帮助.</p>
<p>实际上, 位运算一般只适用 [-2^31, 2^31-1] (即 -2147483648~2147483647) 以内的正负数. 超过这个范围, 计算将可能出现错误. 如下: </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>&lt;&lt;<span class="number">31</span>);<span class="comment">//-2147483648 由于数值(2^31)超过了31位(加上保留的一个符号位,共32位), 故计算出错, 按照负数的方式解释二进制的值了.说好的不改变符号呢!!!</span></span><br></pre></td></tr></table></figure>
<h3 id="u6CE8_u89E3"><a href="#u6CE8_u89E3" class="headerlink" title="注解"></a>注解</h3><ol>
<li><code>相反数</code> : 只有符号不同的两个数, 我们就说其中一个是另一个的相反数.</li>
</ol>
<hr>
<p>本问就讨论这么多内容,大家有什么问题或好的想法欢迎在下方参与<a href="#respond">留言和评论</a>.</p>
<p>本文作者: <a href="https://github.com/Louiszhai" target="_blank" rel="external">louis</a></p>
<p>本文链接: <a href="http://louiszhai.github.io/2016/07/01/Math/">http://louiszhai.github.io/2016/07/01/Math/</a></p>
<p>参考文章</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math" target="_blank" rel="external">Math - JavaScript | MDN</a></li>
<li><a href="http://www.cnblogs.com/xljzlw/p/4231354.html?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">js中位运算的运用 - 那时候的我 - 博客园</a></li>
<li><a href="http://blog.csdn.net/yunyu5120/article/details/6692072" target="_blank" rel="external">编程技巧–位运算的巧妙运用</a></li>
<li><a href="http://www.jb51.net/article/32130.htm" target="_blank" rel="external">c语言中用位运算实现加法技巧介绍_C 语言_脚本之家</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[Math floor ~ ~ abs random ceil 位运算 & | ^ << >> >>>]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://louiszhai.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[正则表达式前端使用手册]]></title>
    <link href="http://louiszhai.github.io/2016/06/13/regexp/"/>
    <id>http://louiszhai.github.io/2016/06/13/regexp/</id>
    <published>2016-06-13T00:24:55.000Z</published>
    <updated>2016-08-02T01:18:23.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u5BFC_u8BFB"><a href="#u5BFC_u8BFB" class="headerlink" title="导读"></a>导读</h3><p>你有没有在搜索文本的时候绞尽脑汁, 试了一个又一个表达式, 还是不行.</p>
<p>你有没有在表单验证的时候, 只是做做样子(只要不为空就好), 然后烧香拜佛, 虔诚祈祷, 千万不要出错.</p>
<p>你有没有在使用sed 和 grep 命令的时候, 感觉莫名其妙, 明明应该支持的元字符, 却就是匹配不到.</p>
<p>甚至, 你压根没遇到过上述情况, 你只是一遍又一遍的调用 replace 而已 (把非搜索文本全部替换为空, 然后就只剩搜索文本了), 面对别人家的简洁高效的语句, 你只能在心中呐喊, replace 大法好.</p>
<p>为什么要学正则表达式. 有位网友这么说: 江湖传说里, 程序员的正则表达式和医生的处方, 道士的鬼符齐名, 曰: 普通人看不懂的三件神器. 这个传说至少向我们透露了两点信息: 一是正则表达式很牛, 能和医生的处方, 道士的鬼符齐名, 并被大家提起, 可见其江湖地位. 二是正则表达式很难, 这也从侧面说明了, 如果你可以熟练的掌握并应用它, 在装逼的路上, 你将如日中天 (别问我中天是谁……) !</p>
<a id="more"></a>
<p>显然, 有关正则表达的介绍, 无须我多言. 这里就借助 Jeffrey Friedl 的《精通正则表达式》一书的序言正式抛个砖.</p>
<blockquote>
<p>​    “如果罗列计算机软件领域的伟大发明, 我相信绝对不会超过二十项, 在这个名单当中, 当然应该包括分组交换网络, Web, Lisp, 哈希算法, UNIX, 编译技术, 关系模型, 面向对象, XML这些大名鼎鼎的家伙, 而正则表达式也绝对不应该被漏掉. </p>
<p>​     对很多实际工作而言, 正则表达式简直是灵丹妙药, 能够成百倍的提高开发效率和程序质量, 正则表达式在生物信息学和人类基因图谱的研究中所发挥的关键作用, 更是被传为佳话. CSDN的创始人蒋涛先生在早年开发专业软件产品时, 就曾经体验过这一工具的巨大威力, 并且一直印象深刻.”</p>
</blockquote>
<p>因此, 我们没有理由不去了解正则表达式, 甚至是熟练掌握并运用它.</p>
<p>本文以正则基础语法开篇, 结合具体实例, 逐步讲解正则表达式匹配原理. 代码实例使用语言包括 js, php, python, java(因有些匹配模式, js并未支持, 需要借助其他语言讲解). 内容包括初阶技能和高阶技能, 适合新手学习和进阶. 本文力求简单通俗易懂, 如有阅读障碍请及时<a href="#respond">联系我</a>.</p>
<h3 id="u56DE_u987E_u5386_u53F2"><a href="#u56DE_u987E_u5386_u53F2" class="headerlink" title="回顾历史"></a>回顾历史</h3><p>要论正则表达式的渊源, 最早可以追溯至对人类神经系统如何工作的早期研究. Warren McCulloch 和 Walter Pitts 这两位神经大咖 (神经生理学家) 研究出一种数学方式来描述这些神经网络.</p>
<p>1956 年, 一位叫 Stephen Kleene 的数学家在 McCulloch 和 Pitts 早期工作的基础上, 发表了一篇标题为”神经网事件的表示法”的论文, 引入了正则表达式的概念.</p>
<p>随后, 发现可以将这一工作应用于使用 Ken Thompson 的计算搜索算法的一些早期研究中. 而 Ken Thompson 又是 Unix 的主要发明人. 因此半个世纪以前的Unix 中的 qed 编辑器(1966 qed编辑器问世) 成了第一个使用正则表达式的应用程序.</p>
<p>至此之后, 正则表达式成为家喻户晓的文本处理工具, 几乎各大编程语言都以支持正则表达式作为卖点, 当然 JavaScript 也不例外.</p>
<h3 id="u6B63_u5219_u8868_u8FBE_u5F0F_u7684_u5B9A_u4E49"><a href="#u6B63_u5219_u8868_u8FBE_u5F0F_u7684_u5B9A_u4E49" class="headerlink" title="正则表达式的定义"></a>正则表达式的定义</h3><p>正则表达式是由普通字符和特殊字符(也叫元字符或限定符)组成的文字模板. 如下便是简单的匹配连续数字的正则表达式:</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/[0-9]+/</span></span><br><span class="line"><span class="regexp">/\d+/</span></span><br></pre></td></tr></table></figure>
<p>“\d” 就是元字符, 而 “+” 则是限定符.</p>
<h4 id="u5143_u5B57_u7B26"><a href="#u5143_u5B57_u7B26" class="headerlink" title="元字符"></a>元字符</h4><table>
<thead>
<tr>
<th style="text-align:center">元字符</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">.</td>
<td style="text-align:center">匹配除换行符以外的任意字符</td>
</tr>
<tr>
<td style="text-align:center">\d</td>
<td style="text-align:center">匹配数字, 等价于字符组[0-9]</td>
</tr>
<tr>
<td style="text-align:center">\w</td>
<td style="text-align:center">匹配字母, 数字, 下划线或汉字</td>
</tr>
<tr>
<td style="text-align:center">\s</td>
<td style="text-align:center">匹配任意的空白符(包括制表符,空格,换行等)</td>
</tr>
<tr>
<td style="text-align:center">\b</td>
<td style="text-align:center">匹配单词开始或结束的位置</td>
</tr>
<tr>
<td style="text-align:center">^</td>
<td style="text-align:center">匹配行首</td>
</tr>
<tr>
<td style="text-align:center">$</td>
<td style="text-align:center">匹配行尾</td>
</tr>
</tbody>
</table>
<h4 id="u53CD_u4E49_u5143_u5B57_u7B26"><a href="#u53CD_u4E49_u5143_u5B57_u7B26" class="headerlink" title="反义元字符"></a>反义元字符</h4><table>
<thead>
<tr>
<th style="text-align:center">元字符</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">\D</td>
<td style="text-align:center">匹配非数字的任意字符, 等价于[^0-9]</td>
</tr>
<tr>
<td style="text-align:center">\W</td>
<td style="text-align:center">匹配除字母,数字,下划线或汉字之外的任意字符</td>
</tr>
<tr>
<td style="text-align:center">\S</td>
<td style="text-align:center">匹配非空白的任意字符</td>
</tr>
<tr>
<td style="text-align:center">\B</td>
<td style="text-align:center">匹配非单词开始或结束的位置</td>
</tr>
<tr>
<td style="text-align:center">[^x]</td>
<td style="text-align:center">匹配除x以外的任意字符</td>
</tr>
</tbody>
</table>
<p>可以看出正则表达式严格区分大小写.</p>
<h4 id="u91CD_u590D_u9650_u5B9A_u7B26"><a href="#u91CD_u590D_u9650_u5B9A_u7B26" class="headerlink" title="重复限定符"></a>重复限定符</h4><p>限定符共有6个, 假设重复次数为x次, 那么将有如下规则:</p>
<table>
<thead>
<tr>
<th style="text-align:center">限定符</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">*</td>
<td style="text-align:center">x&gt;=0</td>
</tr>
<tr>
<td style="text-align:center">+</td>
<td style="text-align:center">x&gt;=1</td>
</tr>
<tr>
<td style="text-align:center">?</td>
<td style="text-align:center">x=0 or x=1</td>
</tr>
<tr>
<td style="text-align:center">{n}</td>
<td style="text-align:center">x=n</td>
</tr>
<tr>
<td style="text-align:center">{n,}</td>
<td style="text-align:center">x&gt;=n</td>
</tr>
<tr>
<td style="text-align:center">{n,m}</td>
<td style="text-align:center">n&lt;=x&lt;=m</td>
</tr>
</tbody>
</table>
<h4 id="u5B57_u7B26_u7EC4"><a href="#u5B57_u7B26_u7EC4" class="headerlink" title="字符组"></a>字符组</h4><p>[…] 匹配中括号内字符之一. 如: [xyz]  匹配字符 x, y 或 z. 如果中括号中包含元字符, 则元字符降级为普通字符, 不再具有元字符的功能, 如 [+.?] 匹配 加号, 点号或问号.</p>
<h4 id="u6392_u9664_u6027_u5B57_u7B26_u7EC4"><a href="#u6392_u9664_u6027_u5B57_u7B26_u7EC4" class="headerlink" title="排除性字符组"></a>排除性字符组</h4><p>[^…] 匹配任何未列出的字符,. 如:  [^x]  匹配除x以外的任意字符.</p>
<h4 id="u591A_u9009_u7ED3_u6784"><a href="#u591A_u9009_u7ED3_u6784" class="headerlink" title="多选结构"></a>多选结构</h4><p>| 就是或的意思, 表示两者中的一个. 如: a|b 匹配a或者b字符.</p>
<h4 id="u62EC_u53F7"><a href="#u62EC_u53F7" class="headerlink" title="括号"></a>括号</h4><p>括号 常用来界定重复限定符的范围, 以及将字符<strong>分组</strong>. 如: (ab)+ 可以匹配abab..等, 其中 ab 便是一个分组.</p>
<h4 id="u8F6C_u4E49_u5B57_u7B26"><a href="#u8F6C_u4E49_u5B57_u7B26" class="headerlink" title="转义字符"></a>转义字符</h4><p>\ 即转义字符, 通常 <strong>\ * + ? | { [ ( ) ] }^ $ . # 和 空白</strong> 这些字符都需要转义.</p>
<h4 id="u64CD_u4F5C_u7B26_u7684_u8FD0_u7B97_u4F18_u5148_u7EA7"><a href="#u64CD_u4F5C_u7B26_u7684_u8FD0_u7B97_u4F18_u5148_u7EA7" class="headerlink" title="操作符的运算优先级"></a>操作符的运算优先级</h4><ol>
<li>\ 转义符</li>
<li>(), (?:), (?=), [] 圆括号或方括号</li>
<li>*, +, ?, {n}, {n,}, {n,m} 限定符</li>
<li>^, $ 位置</li>
<li>| “或” 操作</li>
</ol>
<h4 id="u6D4B_u8BD5"><a href="#u6D4B_u8BD5" class="headerlink" title="测试"></a>测试</h4><p>我们来测试下上面的知识点, 写一个匹配手机号码的正则表达式, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(\+<span class="number">86</span>)?<span class="number">1</span>\d&#123;<span class="number">10</span>&#125;</span><br></pre></td></tr></table></figure>
<p>① “\+86” 匹配文本 “+86”, 后面接元字符问号, 表示可匹配1次或0次, 合起来表示 “(\+86)?” 匹配 “+86” 或者 “”.</p>
<p>② 普通字符”1” 匹配文本 “1”.</p>
<p>③ 元字符 “\d” 匹配数字0到9, 区间量词 “{10}” 表示匹配 10 次, 合起来表示 “\d{10}” 匹配连续的10个数字.</p>
<p>以上, 匹配结果如下:</p>
<p><img src="http://louiszhai.github.io/docImages/regexp01.png" alt=""></p>
<h3 id="u4FEE_u9970_u7B26"><a href="#u4FEE_u9970_u7B26" class="headerlink" title="修饰符"></a>修饰符</h3><p>javaScript中正则表达式默认有如下五种修饰符:</p>
<ul>
<li>g (全文查找), 如上述截图, 实际上就开启了全文查找模式.</li>
<li>i (忽略大小写查找)</li>
<li>m (多行查找)</li>
<li>y (ES6新增的粘连修饰符)</li>
<li>u (ES6新增)</li>
</ul>
<h3 id="u5E38_u7528_u7684_u6B63_u5219_u8868_u8FBE_u5F0F"><a href="#u5E38_u7528_u7684_u6B63_u5219_u8868_u8FBE_u5F0F" class="headerlink" title="常用的正则表达式"></a>常用的正则表达式</h3><ol>
<li>汉字: ^[\u4e00-\u9fa5]{0,}$</li>
<li>Email: ^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$</li>
<li>URL: ^https?://([\w-]+.)+[\w-]+(/[\w-./?%&amp;=]*)?$</li>
<li>手机号码: ^1\d{10}$</li>
<li>身份证号: ^\d{15}|\d{17}(\d|X)$</li>
<li>中国邮政编码: [1-9]\d{5}(?!\d) (邮政编码为6位数字)</li>
</ol>
<h4 id="u5BC6_u7801_u9A8C_u8BC1"><a href="#u5BC6_u7801_u9A8C_u8BC1" class="headerlink" title="密码验证"></a>密码验证</h4><p>密码验证是常见的需求, 一般来说, 常规密码大致会满足规律: 6-16位, 数字, 字母, 字符至少包含两种, 同时不能包含中文和空格. 如下便是常规密码验证的正则描述:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/(?!^[0-9]+$)(?!^[A-z]+$)(?!^[^A-z0-9]+$)^[^\s\u4e00-\u9fa5]&#123;6,16&#125;$/</span>;</span><br></pre></td></tr></table></figure>
<h3 id="u6B63_u5219_u7684_u51E0_u5927_u5BB6_u65CF"><a href="#u6B63_u5219_u7684_u51E0_u5927_u5BB6_u65CF" class="headerlink" title="正则的几大家族"></a>正则的几大家族</h3><h4 id="u6B63_u5219_u8868_u8FBE_u5F0F_u5206_u7C7B"><a href="#u6B63_u5219_u8868_u8FBE_u5F0F_u5206_u7C7B" class="headerlink" title="正则表达式分类"></a>正则表达式分类</h4><p>在 linux 和 osx 下, 常见的正则表达式, 至少有以下三种: </p>
<ul>
<li>基本的正则表达式( Basic Regular Expression 又叫 Basic RegEx  简称 <strong>BREs</strong> )</li>
<li>扩展的正则表达式( Extended Regular Expression 又叫 Extended RegEx 简称 <strong>EREs</strong> )</li>
<li>Perl 的正则表达式( Perl Regular Expression 又叫 Perl RegEx 简称 <strong>PREs</strong> )</li>
</ul>
<h4 id="u6B63_u5219_u8868_u8FBE_u5F0F_u6BD4_u8F83"><a href="#u6B63_u5219_u8868_u8FBE_u5F0F_u6BD4_u8F83" class="headerlink" title="正则表达式比较"></a>正则表达式比较</h4><table>
<thead>
<tr>
<th>字符</th>
<th>说明</th>
<th>Basic RegEx</th>
<th>Extended RegEx</th>
<th>python RegEx</th>
<th>Perl regEx</th>
</tr>
</thead>
<tbody>
<tr>
<td>转义</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>^</td>
<td>匹配行首，例如’^dog’匹配以字符串dog开头的行（注意：awk 指令中，’^’则是匹配字符串的开始）</td>
<td>^</td>
<td>^</td>
<td>^</td>
<td>^</td>
</tr>
<tr>
<td>$</td>
<td>匹配行尾，例如：’^、dog\$’ 匹配以字符串 dog 为结尾的行（注意：awk 指令中，’$’则是匹配字符串的结尾）</td>
<td>$</td>
<td>$</td>
<td>$</td>
<td>$</td>
</tr>
<tr>
<td>^$</td>
<td>匹配空行</td>
<td>^$</td>
<td>^$</td>
<td>^$</td>
<td>^$</td>
</tr>
<tr>
<td>^string$</td>
<td>匹配行，例如：’^dog$’匹配只含一个字符串 dog 的行</td>
<td>^string$</td>
<td>^string$</td>
<td>^string$</td>
<td>^string$</td>
</tr>
<tr>
<td>\&lt;</td>
<td>匹配单词，例如：’\&lt;frog’ （等价于’\bfrog’），匹配以 frog 开头的单词</td>
<td>\&lt;</td>
<td>\&lt;</td>
<td><strong>不支持</strong></td>
<td><strong>不支持</strong>（但可以使用\b来匹配单词，例如：’\bfrog’）</td>
</tr>
<tr>
<td>></td>
<td>匹配单词，例如：’frog>‘（等价于’frog\b ‘），匹配以 frog 结尾的单词</td>
<td>></td>
<td>></td>
<td><strong>不支持</strong></td>
<td><strong>不支持</strong>（但可以使用\b来匹配单词，例如：’frog\b’）</td>
</tr>
<tr>
<td>\<x></x></td>
<td>匹配一个单词或者一个特定字符，例如：’\<frog\>‘（等价于’\bfrog\b’）、’\<g\>‘</g\></frog\></td>
<td>\<x></x></td>
<td>\<x></x></td>
<td><strong>不支持</strong></td>
<td><strong>不支持</strong>（但可以使用\b来匹配单词，例如：’\bfrog\b’</td>
</tr>
<tr>
<td>()</td>
<td>匹配表达式，例如：不支持’（frog）’</td>
<td><strong>不支持</strong>（但可以使用，如：dog</td>
<td>()</td>
<td>()</td>
<td>()</td>
</tr>
<tr>
<td></td>
<td>匹配表达式，例如：不支持’（frog）’</td>
<td></td>
<td><strong>不支持</strong>（同())</td>
<td><strong>不支持</strong>（同())</td>
<td><strong>不支持</strong>（同())</td>
</tr>
<tr>
<td>？</td>
<td>匹配前面的子表达式 0 次或 1 次（等价于{0,1}），例如：where(is)?能匹配”where” 以及”whereis”</td>
<td><strong>不支持</strong>（同\?)</td>
<td>？</td>
<td>？</td>
<td>？</td>
</tr>
<tr>
<td>\?</td>
<td>匹配前面的子表达式 0 次或 1 次（等价于’{0,1}‘），例如：’whereis\? ‘能匹配 “where”以及”whereis”</td>
<td>\?</td>
<td><strong>不支持</strong>（同?)</td>
<td><strong>不支持</strong>（同?)</td>
<td><strong>不支持</strong>（同?)</td>
</tr>
<tr>
<td>?</td>
<td>当该字符紧跟在任何一个其他限制符（*, +, ?, {n},{n,}, {n,m}） 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，’o+?’ 将匹配单个”o”，而 ‘o+’ 将匹配所有 ‘o’</td>
<td><strong>不支持</strong></td>
<td><strong>不支持</strong></td>
<td><strong>不支持</strong></td>
<td><strong>不支持</strong></td>
</tr>
<tr>
<td>.</td>
<td>匹配除换行符（’\n’）之外的任意单个字符（注意：awk 指令中的句点能匹配换行符）</td>
<td>.</td>
<td>.（如果要匹配包括“\n”在内的任何一个字符，请使用: [\s\S]</td>
<td>.</td>
<td>.（如果要匹配包括“\n”在内的任何一个字符，请使用：’ [.\n] ‘</td>
</tr>
<tr>
<td>*</td>
<td>匹配前面的子表达式 0 次或多次（等价于{0, }），例如：zo* 能匹配 “z”以及 “zoo”</td>
<td>*</td>
<td>*</td>
<td>*</td>
<td>*</td>
</tr>
<tr>
<td>+</td>
<td>匹配前面的子表达式 1 次或多次（等价于’{1, }‘），例如：’whereis+ ‘能匹配 “whereis”以及”whereisis”</td>
<td>+</td>
<td><strong>不支持</strong>（同+)</td>
<td><strong>不支持</strong>（同+)</td>
<td><strong>不支持</strong>（同+)</td>
</tr>
<tr>
<td>+</td>
<td>匹配前面的子表达式 1 次或多次（等价于{1, }），例如：zo+能匹配 “zo”以及 “zoo”，但不能匹配 “z”</td>
<td><strong>不支持</strong>（同\+)</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td>{n}</td>
<td>n 必须是一个 0 或者正整数，匹配子表达式 n 次，例如：zo{2}能匹配</td>
<td><strong>不支持</strong>（同\{n\})</td>
<td>{n}</td>
<td>{n}</td>
<td>{n}</td>
</tr>
<tr>
<td>{n,}</td>
<td>“zooz”，但不能匹配 “Bob”n 必须是一个 0 或者正整数，匹配子表达式大于等于 n次，例如：go{2,}</td>
<td><strong>不支持</strong>（同\{n,\})</td>
<td>{n,}</td>
<td>{n,}</td>
<td>{n,}</td>
</tr>
<tr>
<td>{n,m}</td>
<td>能匹配 “good”，但不能匹配 godm 和 n 均为非负整数，其中 n &lt;= m，最少匹配 n 次且最多匹配 m 次 ，例如：o{1,3}将配”fooooood” 中的前三个 o（请注意在逗号和两个数之间不能有空格）</td>
<td><strong>不支持</strong>（同\{n,m\})</td>
<td>{n,m}</td>
<td>{n,m}</td>
<td>{n,m}</td>
</tr>
<tr>
<td>x l y</td>
<td>匹配 x 或 y</td>
<td><strong>不支持</strong>（同x \l y</td>
<td>x l y</td>
<td>x l y</td>
<td>x l y</td>
</tr>
<tr>
<td>[0-9]</td>
<td>匹配从 0 到 9 中的任意一个数字字符（注意：要写成递增）</td>
<td>[0-9]</td>
<td>[0-9]</td>
<td>[0-9]</td>
<td>[0-9]</td>
</tr>
<tr>
<td>[xyz]</td>
<td>字符集合，匹配所包含的任意一个字符，例如：’[abc]’可以匹配”lay” 中的 ‘a’（注意：如果元字符，例如：. *等，它们被放在[ ]中，那么它们将变成一个普通字符）</td>
<td>[xyz]</td>
<td>[xyz]</td>
<td>[xyz]</td>
<td>[xyz]</td>
</tr>
<tr>
<td>[^xyz]</td>
<td>负值字符集合，匹配未包含的任意一个字符（注意：不包括换行符），例如：’[^abc]’ 可以匹配 “Lay” 中的’L’（注意：[^xyz]在awk 指令中则是匹配未包含的任意一个字符+换行符）</td>
<td>[^xyz]</td>
<td>[^xyz]</td>
<td>[^xyz]</td>
<td>[^xyz]</td>
</tr>
<tr>
<td>[A-Za-z]</td>
<td>匹配大写字母或者小写字母中的任意一个字符（注意：要写成递增）</td>
<td>[A-Za-z]</td>
<td>[A-Za-z]</td>
<td>[A-Za-z]</td>
<td>[A-Za-z]</td>
</tr>
<tr>
<td>[^A-Za-z]</td>
<td>匹配除了大写与小写字母之外的任意一个字符（注意：写成递增）</td>
<td>[^A-Za-z]</td>
<td>[^A-Za-z]</td>
<td>[^A-Za-z]</td>
<td>[^A-Za-z]</td>
</tr>
<tr>
<td>\d</td>
<td>匹配从 0 到 9 中的任意一个数字字符（等价于 [0-9]）</td>
<td><strong>不支持</strong></td>
<td><strong>不支持</strong></td>
<td>\d</td>
<td>\d</td>
</tr>
<tr>
<td>\D</td>
<td>匹配非数字字符（等价于 [^0-9]）</td>
<td><strong>不支持</strong></td>
<td><strong>不支持</strong></td>
<td>\D</td>
<td>\D</td>
</tr>
<tr>
<td>\S</td>
<td>匹配任何非空白字符（等价于[^\f\n\r\t\v]）</td>
<td><strong>不支持</strong></td>
<td><strong>不支持</strong></td>
<td>\S</td>
<td>\S</td>
</tr>
<tr>
<td>\s</td>
<td>匹配任何空白字符，包括空格、制表符、换页符等等（等价于[ \f\n\r\t\v]）</td>
<td><strong>不支持</strong></td>
<td><strong>不支持</strong></td>
<td>\s</td>
<td>\s</td>
</tr>
<tr>
<td>\W</td>
<td>匹配任何非单词字符 (等价于[^A-Za-z0-9_])</td>
<td>\W</td>
<td>\W</td>
<td>\W</td>
<td>\W</td>
</tr>
<tr>
<td>\w</td>
<td>匹配包括下划线的任何单词字符（等价于[A-Za-z0-9_]）</td>
<td>\w</td>
<td>\w</td>
<td>\w</td>
<td>\w</td>
</tr>
<tr>
<td>\B</td>
<td>匹配非单词边界，例如：’er\B’ 能匹配 “verb” 中的’er’，但不能匹配”never” 中的’er’</td>
<td>\B</td>
<td>\B</td>
<td>\B</td>
<td>\B</td>
</tr>
<tr>
<td>\b</td>
<td>匹配一个单词边界，也就是指单词和空格间的位置，例如： ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的’er’</td>
<td>\b</td>
<td>\b</td>
<td>\b</td>
<td>\b</td>
</tr>
<tr>
<td>\t</td>
<td>匹配一个横向制表符（等价于 \x09和 \cI）</td>
<td><strong>不支持</strong></td>
<td><strong>不支持</strong></td>
<td>\t</td>
<td>\t</td>
</tr>
<tr>
<td>\v</td>
<td>匹配一个垂直制表符（等价于 \x0b和 \cK）</td>
<td><strong>不支持</strong></td>
<td><strong>不支持</strong></td>
<td>\v</td>
<td>\v</td>
</tr>
<tr>
<td>\n</td>
<td>匹配一个换行符（等价于 \x0a 和\cJ）</td>
<td><strong>不支持</strong></td>
<td><strong>不支持</strong></td>
<td>\n</td>
<td>\n</td>
</tr>
<tr>
<td>\f</td>
<td>匹配一个换页符（等价于\x0c 和\cL）</td>
<td><strong>不支持</strong></td>
<td><strong>不支持</strong></td>
<td>\f</td>
<td>\f</td>
</tr>
<tr>
<td>\r</td>
<td>匹配一个回车符（等价于 \x0d 和\cM）</td>
<td><strong>不支持</strong></td>
<td><strong>不支持</strong></td>
<td>\r</td>
<td>\r</td>
</tr>
<tr>
<td>\</td>
<td>匹配转义字符本身”\”</td>
<td>\</td>
<td>\</td>
<td>\</td>
<td>\</td>
</tr>
<tr>
<td>\cx</td>
<td>匹配由 x 指明的控制字符，例如：\cM匹配一个Control-M 或回车符，x 的值必须为A-Z 或 a-z 之一，否则，将 c 视为一个原义的 ‘c’ 字符</td>
<td><strong>不支持</strong></td>
<td><strong>不支持</strong></td>
<td></td>
<td>\cx</td>
</tr>
<tr>
<td>\xn</td>
<td>匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长，例如：’\x41’ 匹配 “A”。’\x041’ 则等价于’\x04’ &amp; “1”。正则表达式中可以使用 ASCII 编码</td>
<td><strong>不支持</strong></td>
<td><strong>不支持</strong></td>
<td></td>
<td>\xn</td>
</tr>
<tr>
<td>\num</td>
<td>匹配 num，其中 num是一个正整数。表示对所获取的匹配的引用</td>
<td><strong>不支持</strong></td>
<td>\num</td>
<td>\num</td>
<td></td>
</tr>
<tr>
<td>[:alnum:]</td>
<td>匹配任何一个字母或数字（[A-Za-z0-9]），例如：’[[:alnum:]] ‘</td>
<td>[:alnum:]</td>
<td>[:alnum:]</td>
<td>[:alnum:]</td>
<td>[:alnum:]</td>
</tr>
<tr>
<td>[:alpha:]</td>
<td>匹配任何一个字母（[A－Za－z]）， 例如：’ [[:alpha:]] ‘</td>
<td>[:alpha:]</td>
<td>[:alpha:]</td>
<td>[:alpha:]</td>
<td>[:alpha:]</td>
</tr>
<tr>
<td>[:digit:]</td>
<td>匹配任何一个数字（[0-9]），例如：’[[:digit:]] ‘</td>
<td>[:digit:]</td>
<td>[:digit:]</td>
<td>[:digit:]</td>
<td>[:digit:]</td>
</tr>
<tr>
<td>[:lower:]</td>
<td>匹配任何一个小写字母（[a-z]）， 例如：’ [[:lower:]] ‘</td>
<td>[:lower:]</td>
<td>[:lower:]</td>
<td>[:lower:]</td>
<td>[:lower:]</td>
</tr>
<tr>
<td>[:upper:]</td>
<td>匹配任何一个大写字母（[A-Z]）</td>
<td>[:upper:]</td>
<td>[:upper:]</td>
<td>[:upper:]</td>
<td>[:upper:]</td>
</tr>
<tr>
<td>[:space:]</td>
<td>任何一个空白字符： 支持制表符、空格，例如：’ [[:space:]] ‘</td>
<td>[:space:]</td>
<td>[:space:]</td>
<td>[:space:]</td>
<td>[:space:]</td>
</tr>
<tr>
<td>[:blank:]</td>
<td>空格和制表符（横向和纵向），例如：’[[:blank:]]’ó’[\s\t\v]’</td>
<td>[:blank:]</td>
<td>[:blank:]</td>
<td>[:blank:]</td>
<td>[:blank:]</td>
</tr>
<tr>
<td>[:graph:]</td>
<td>任何一个可以看得见的且可以打印的字符（注意：不包括空格和换行符等），例如：’[[:graph:]] ‘</td>
<td>[:graph:]</td>
<td>[:graph:]</td>
<td>[:graph:]</td>
<td>[:graph:]</td>
</tr>
<tr>
<td>[:print:]</td>
<td>任何一个可以打印的字符（注意：不包括：[:cntrl:]、字符串结束符’\0’、EOF 文件结束符（-1）， 但包括空格符号），例如：’[[:print:]] ‘</td>
<td>[:print:]</td>
<td>[:print:]</td>
<td>[:print:]</td>
<td>[:print:]</td>
</tr>
<tr>
<td>[:cntrl:]</td>
<td>任何一个控制字符（ASCII 字符集中的前 32 个字符，即：用十进制表示为从 0 到31，例如：换行符、制表符等等），例如：’ [[:cntrl:]]’</td>
<td>[:cntrl:]</td>
<td>[:cntrl:]</td>
<td>[:cntrl:]</td>
<td>[:cntrl:]</td>
</tr>
<tr>
<td>[:punct:]</td>
<td>任何一个标点符号（不包括：[:alnum:]、[:cntrl:]、[:space:]这些字符集）</td>
<td>[:punct:]</td>
<td>[:punct:]</td>
<td>[:punct:]</td>
<td>[:punct:]</td>
</tr>
<tr>
<td>[:xdigit:]</td>
<td>任何一个十六进制数（即：0-9，a-f，A-F）</td>
<td>[:xdigit:]</td>
<td>[:xdigit:]</td>
<td>[:xdigit:]</td>
<td>[:xdigit:]</td>
</tr>
</tbody>
</table>
<p><strong>注意</strong> </p>
<ul>
<li>js中支持的是EREs.</li>
<li>当使用 BREs ( 基本正则表达式 ) 时，必须在下列这些符号(?,+,|,{,},(,))前加上转义字符 \ .</li>
<li>上述[[:xxxx:]] 形式的正则表达式, 是php中内置的通用字符簇, js中并不支持.</li>
</ul>
<h3 id="linux/osx_u4E0B_u5E38_u7528_u547D_u4EE4_u4E0E_u6B63_u5219_u8868_u8FBE_u5F0F_u7684_u5173_u7CFB"><a href="#linux/osx_u4E0B_u5E38_u7528_u547D_u4EE4_u4E0E_u6B63_u5219_u8868_u8FBE_u5F0F_u7684_u5173_u7CFB" class="headerlink" title="linux/osx下常用命令与正则表达式的关系"></a>linux/osx下常用命令与正则表达式的关系</h3><p>我曾经尝试在 grep 和 sed 命令中书写正则表达式, 经常发现不能使用元字符, 而且有时候需要转义, 有时候不需要转义, 始终不能摸清它的规律. 如果恰好你也有同样的困惑, 那么请往下看, 相信应该能有所收获.</p>
<h4 id="grep__2C_egrep__2C_sed__2C_awk__u6B63_u5219_u8868_u8FBE_u5F0F_u7279_u70B9"><a href="#grep__2C_egrep__2C_sed__2C_awk__u6B63_u5219_u8868_u8FBE_u5F0F_u7279_u70B9" class="headerlink" title="grep , egrep , sed , awk  正则表达式特点"></a>grep , egrep , sed , awk  正则表达式特点</h4><ol>
<li><p>grep 支持：BREs、EREs、PREs 正则表达式</p>
<p>grep 指令后不跟任何参数, 则表示要使用 “BREs”</p>
<p>grep 指令后跟 ”-E” 参数, 则表示要使用 “EREs”</p>
<p>grep 指令后跟 “-P” 参数, 则表示要使用 “PREs”</p>
</li>
<li><p>egrep 支持：EREs、PREs 正则表达式</p>
<p>egrep 指令后不跟任何参数, 则表示要使用 “EREs”</p>
<p>egrep 指令后跟 “-P” 参数, 则表示要使用 “PREs”</p>
</li>
<li><p>sed 支持: BREs、EREs</p>
<p>sed 指令默认是使用 “BREs”</p>
<p>sed 指令后跟 “-r” 参数 , 则表示要使用“EREs”</p>
</li>
<li><p>awk 支持 EREs, 并且默认使用 “EREs”</p>
</li>
</ol>
<h3 id="u6B63_u5219_u8868_u8FBE_u5F0F_u521D_u9636_u6280_u80FD"><a href="#u6B63_u5219_u8868_u8FBE_u5F0F_u521D_u9636_u6280_u80FD" class="headerlink" title="正则表达式初阶技能"></a>正则表达式初阶技能</h3><h4 id="u8D2A_u5A6A_u6A21_u5F0F_u4E0E_u975E_u8D2A_u5A6A_u6A21_u5F0F"><a href="#u8D2A_u5A6A_u6A21_u5F0F_u4E0E_u975E_u8D2A_u5A6A_u6A21_u5F0F" class="headerlink" title="贪婪模式与非贪婪模式"></a>贪婪模式与非贪婪模式</h4><p>默认情况下, 所有的限定词都是贪婪模式, 表示尽可能多的去捕获字符; 而在限定词后增加?, 则是非贪婪模式, 表示尽可能少的去捕获字符. 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"aaab"</span>,</span><br><span class="line">    reg1 = <span class="regexp">/a+/</span>, <span class="comment">//贪婪模式</span></span><br><span class="line">    reg2 = <span class="regexp">/a+?/</span>;<span class="comment">//非贪婪模式</span></span><br><span class="line"><span class="built_in">console</span>.log(str.match(reg1)); <span class="comment">//["aaa"], 由于是贪婪模式, 捕获了所有的a</span></span><br><span class="line"><span class="built_in">console</span>.log(str.match(regs)); <span class="comment">//["a"], 由于是非贪婪模式, 只捕获到第一个a</span></span><br></pre></td></tr></table></figure>
<p>实际上, 非贪婪模式非常有效, 特别是当匹配html标签时. 比如匹配一个配对出现的div, 方案一可能会匹配到很多的div标签对, 而方案二则只会匹配一个div标签对.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"&lt;div class='v1'&gt;&lt;div class='v2'&gt;test&lt;/div&gt;&lt;input type='text'/&gt;&lt;/div&gt;"</span>;</span><br><span class="line"><span class="keyword">var</span> reg1 = <span class="regexp">/&lt;div.*&lt;\/div&gt;/</span>; <span class="comment">//方案一,贪婪匹配</span></span><br><span class="line"><span class="keyword">var</span> reg2 = <span class="regexp">/&lt;div.*?&lt;\/div&gt;/</span>;<span class="comment">//方案二,非贪婪匹配</span></span><br><span class="line"><span class="built_in">console</span>.log(str.match(reg1));<span class="comment">//"&lt;div class='v1'&gt;&lt;div class='v2'&gt;test&lt;/div&gt;&lt;input type='text'/&gt;&lt;/div&gt;"</span></span><br><span class="line"><span class="built_in">console</span>.log(str.match(reg2));<span class="comment">//"&lt;div class='v1'&gt;&lt;div class='v2'&gt;test&lt;/div&gt;"</span></span><br></pre></td></tr></table></figure>
<h5 id="u533A_u95F4_u91CF_u8BCD_u7684_u975E_u8D2A_u5A6A_u6A21_u5F0F"><a href="#u533A_u95F4_u91CF_u8BCD_u7684_u975E_u8D2A_u5A6A_u6A21_u5F0F" class="headerlink" title="区间量词的非贪婪模式"></a>区间量词的非贪婪模式</h5><p>一般情况下, 非贪婪模式, 我们使用的是”*?”, 或 “+?” 这种形式, 还有一种是 “{n,m}?”.</p>
<p>区间量词”{n,m}” 也是匹配优先, 虽有匹配次数上限, 但是在到达上限之前, 它依然是尽可能多的匹配, 而”{n,m}?” 则表示在区间范围内, 尽可能少的匹配.</p>
<p><strong>需要注意的是</strong>: </p>
<ul>
<li>能达到同样匹配结果的贪婪与非贪婪模式, 通常是贪婪模式的匹配效率较高.</li>
<li>所有的非贪婪模式, 都可以通过修改量词修饰的子表达式, 转换为贪婪模式.</li>
<li>贪婪模式可以与<code>固化分组</code>(后面会讲到)结合，提升匹配效率，而非贪婪模式却不可以.</li>
</ul>
<h4 id="u5206_u7EC4"><a href="#u5206_u7EC4" class="headerlink" title="分组"></a>分组</h4><p>正则的分组主要通过小括号来实现, 括号包裹的子表达式作为一个分组, 括号后可以紧跟限定词表示重复次数. 如下, 小括号内包裹的abc便是一个分组:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/(abc)+<span class="regexp">/.test("abc123") == true</span></span><br></pre></td></tr></table></figure>
<p>那么分组有什么用呢? 一般来说, 分组是为了方便的表示重复次数, 除此之外, 还有一个作用就是用于捕获, 请往下看.</p>
<h4 id="u6355_u83B7_u6027_u5206_u7EC4_u4E0E_u975E_u6355_u83B7_u6027_u5206_u7EC4"><a href="#u6355_u83B7_u6027_u5206_u7EC4_u4E0E_u975E_u6355_u83B7_u6027_u5206_u7EC4" class="headerlink" title="捕获性分组与非捕获性分组"></a>捕获性分组与非捕获性分组</h4><p><strong>捕获性分组</strong>, 通常由一对小括号加上子表达式组成. 捕获性分组会创建反向引用, 每个反向引用都由一个编号或名称来标识, 并通过“$”+”编号”表示法进行引用. 如下便是一个捕获性分组的例子.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">"#808080"</span>;</span><br><span class="line"><span class="keyword">var</span> output = color.replace(<span class="regexp">/#(\d+)/</span>,<span class="string">"$1"</span>+<span class="string">"~~"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">1</span>);<span class="comment">//808080</span></span><br><span class="line"><span class="built_in">console</span>.log(output);<span class="comment">//808080~~</span></span><br></pre></td></tr></table></figure>
<p>以上, (\d+) 表示一个捕获性分组, “$1” 指向该分组捕获的内容.</p>
<p><strong>非捕获性分组</strong>, 通常由一对括号加上”?:”加上子表达式组成, 非捕获性分组不会创建反向引用. 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">"#808080"</span>;</span><br><span class="line"><span class="keyword">var</span> output = color.replace(<span class="regexp">/#(?:\d+)/</span>,<span class="string">"$1"</span>+<span class="string">"~~"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">1</span>);<span class="comment">//""</span></span><br><span class="line"><span class="built_in">console</span>.log(output);<span class="comment">//$1~~</span></span><br></pre></td></tr></table></figure>
<p>以上, (?:\d+) 表示一个非捕获性分组, 由于分组不捕获任何内容, 所以, “$1” 指向空字符串.</p>
<p>实际上, 捕获性分组和无捕获性分组在搜索效率方面也没什么不同, 没有哪一个比另一个更快.</p>
<h4 id="u547D_u540D_u5206_u7EC4"><a href="#u547D_u540D_u5206_u7EC4" class="headerlink" title="命名分组"></a>命名分组</h4><p>语法: (?<name>…)</name></p>
<p>命名分组也是捕获性分组,  它将匹配的字符串捕获到一个组名称或编号名称中, 在获得匹配结果后, 可通过分组名进行获取. 如下是一个python的命名分组的例子.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">data = <span class="string">"#808080"</span></span><br><span class="line">regExp = <span class="string">r"#(?P&lt;one&gt;\d+)"</span></span><br><span class="line">replaceString = <span class="string">"\g&lt;one&gt;"</span> + <span class="string">"~~"</span></span><br><span class="line"><span class="keyword">print</span> re.sub(regExp,replaceString,data) <span class="comment"># 808080~~</span></span><br></pre></td></tr></table></figure>
<p>python的命名分组表达式与标准格式相比, 在 ? 后多了一大写的 P 字符, 并且python通过“\g&lt;命名&gt;”表示法进行引用. (如果是捕获性分组, python通过”\g&lt;编号&gt;”表示法进行引用)</p>
<p>与python不同的是, javaScript 中并不支持命名分组.</p>
<h4 id="u56FA_u5316_u5206_u7EC4"><a href="#u56FA_u5316_u5206_u7EC4" class="headerlink" title="固化分组"></a>固化分组</h4><p>语法: (?&gt;…)</p>
<p>如上所述, 我们在使用非贪婪模式时, 匹配过程中可能会进行多次的回溯, 回溯越多, 正则表达式的运行效率就越低. 而固化分组就是用来减少回溯次数的.</p>
<p>实际上, 固化分组(?&gt;…)的匹配与正常的匹配并无分别, 它并不会改变匹配结果. 唯一的不同就是: 固化分组匹配结束时, 它匹配到的文本已经固化为一个单元, 只能作为整体而保留或放弃, 括号内的子表达式中未尝试过的备用状态都会被放弃, 所以回溯永远也不能选择其中的状态(因此不能参与回溯). 下面我们来通过一个例子更好地理解固化分组.</p>
<p>假如要处理一批数据, 原格式为 123.456, 因为浮点数显示问题, 部分数据格式会变为123.456000000789这种, 现要求只保留小数点后2~3位, 但是最后一位不能为0, 那么这个正则怎么写呢?</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"123.456000000789"</span>;</span><br><span class="line">str = str.replace(<span class="regexp">/(\.\d\d[1-9]?)\d*/</span>,<span class="string">"$1"</span>); <span class="comment">//123.456</span></span><br></pre></td></tr></table></figure>
<p>以上的正则, 对于”123.456” 这种格式的数据, 将白白处理一遍. 为了提高效率, 我们将正则最后的一个”*”改为”+”. 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"123.456"</span>;</span><br><span class="line">str = str.replace(<span class="regexp">/(\.\d\d[1-9]?)\d+/</span>,<span class="string">"$1"</span>); <span class="comment">//123.45</span></span><br></pre></td></tr></table></figure>
<p>此时, “\d\d[1-9]?” 子表达式, 匹配是 “45”, 而不是 “456”, 这是因为正则末尾使用了”+”, 表示末尾至少要匹配一个数字, 因此末尾的子表达式”\d+” 匹配到了 “6”. 显然 “123.45” 不是我们期望的匹配结果, 那我们应该怎么做呢? 能否让 “[1-9]?” 一旦匹配成功, 便不再进行回溯, 这里就要用到我们上面说的固化分组.</p>
<p>“(\.\d\d(?&gt;[1-9]?))\d+” 便是上述正则的固化分组形式. 由于字符串 “123.456” 不满足该固化分组的正则, 所以, 匹配会失败, 符合我们期望.</p>
<p>下面我们来分析下固化分组的正则 (\.\d\d(?&gt;[1-9]?))\d+ 为什么匹配不到字符串”123.456”.</p>
<p>很明显, 对于上述固化分组, 只存在两种匹配结果.</p>
<p>情况①: 若 [1-9] 匹配失败, 正则会返回 ? 留下的备用状态. 然后匹配脱离固化分组, 继续前进到[\d+]. 当控制权离开固化分组时, 没有备用状态需要放弃(因固化分组中根本没有创建任何备用状态).</p>
<p>情况②: 若 [1-9] 匹配成功, 匹配脱离固化分组之后,  ? 保存的备用状态仍然存在, 但是, 由于它属于已经结束的固化分组, 所以会被抛弃.</p>
<p>对于字符串 “123.456”, 由于 [1-9] 能够匹配成功, 所以它符合情况②. 下面我们来还原情况②的执行现场. </p>
<ol>
<li>匹配所处的状态:  匹配已经走到了 “6” 的位置, 匹配将继续前进;==&gt;</li>
<li>子表达式 \d+ 发现无法匹配, 正则引擎便尝试回溯;==&gt;</li>
<li>查看是否存在备用状态以供回溯?==&gt;</li>
<li>“?” 保存的备用状态属于已经结束的固化分组, 所以该备用状态会被放弃;==&gt;</li>
<li>此时固化分组匹配到的 “6”, 便不能用于正则引擎的回溯;==&gt;</li>
<li>尝试回溯失败;==&gt;</li>
<li>正则匹配失败.==&gt;</li>
<li>文本 “123.456” 没有被正则表达式匹配上, 符合预期.</li>
</ol>
<p>相应的流程图如下:</p>
<style>

.fancy-ctn img[src$="regexp02.png"]{height:500px;width:396px;}

</style>

<p><img src="http://louiszhai.github.io/docImages/regexp02.png" alt="正则表达式流程图"></p>
<p>遗憾的是, javaScript, java 和 python中并不支持固化分组的语法, 不过, 它在php和.NET中表现良好. 下面提供了一个php版的固化分组形式的正则表达式, 以供尝试.</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$str</span> = <span class="string">"123.456"</span>;</span><br><span class="line"><span class="keyword">echo</span> preg_replace(<span class="string">"/(\.\d\d(?&gt;[1-9]?))\d+/"</span>,<span class="string">"\\1"</span>,<span class="variable">$str</span>); <span class="comment">//固化分组</span></span><br></pre></td></tr></table></figure>
<p>不仅如此, php还提供了占有量词优先的语法. 如下:</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$str</span> = <span class="string">"123.456"</span>;</span><br><span class="line"><span class="keyword">echo</span> preg_replace(<span class="string">"/(\.\d\d[1-9]?+)\d+/"</span>,<span class="string">"\\1"</span>,<span class="variable">$str</span>); <span class="comment">//占有量词优先</span></span><br></pre></td></tr></table></figure>
<p>虽然java不支持固化分组的语法, 但java也提供了占有量词优先的语法, 同样能够避免正则回溯. 如下: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"123.456"</span>;</span><br><span class="line">System.out.println(str.replaceAll(<span class="string">"(\\.\\d\\d[1-9]?+)\\d+"</span>, <span class="string">"$1"</span>));<span class="comment">// 123.456</span></span><br></pre></td></tr></table></figure>
<p>值得注意的是: java中 replaceAll 方法需要转义反斜杠.</p>
<h3 id="u6B63_u5219_u8868_u8FBE_u5F0F_u9AD8_u9636_u6280_u80FD-_u96F6_u5BBD_u65AD_u8A00"><a href="#u6B63_u5219_u8868_u8FBE_u5F0F_u9AD8_u9636_u6280_u80FD-_u96F6_u5BBD_u65AD_u8A00" class="headerlink" title="正则表达式高阶技能-零宽断言"></a>正则表达式高阶技能-零宽断言</h3><p>如果说正则分组是写轮眼, 那么零宽断言就是万花筒写轮眼终极奥义-须佐能乎(这里借火影忍术打个比方). 合理地使用零宽断言, 能够能分组之不能, 极大地增强正则匹配能力, 它甚至可以帮助你在匹配条件非常模糊的情况下快速地定位文本.</p>
<p>零宽断言, 又叫环视. 环视只进行子表达式的匹配, 匹配到的内容不保存到最终的匹配结果, 由于匹配是零宽度的, 故最终匹配到的只是一个位置. </p>
<p>环视按照方向划分, 有顺序和逆序两种, 按照是否匹配有肯定和否定两种, 组合之, 便有4种环视. 4种环视并不复杂, 如下便是它们的描述.</p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>字符</strong></th>
<th><strong>描述</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">(?:<em>pattern</em>)</td>
<td>非捕获性分组, 匹配pattern的位置, 但不捕获匹配结果.</td>
<td>‘abcd(?:e)匹配’abcde</td>
</tr>
<tr>
<td style="text-align:center">(?=<em>pattern</em>)</td>
<td><strong>顺序肯定环视</strong>, 匹配后面是pattern 的位置, 不捕获匹配结果.</td>
<td>‘Windows (?=2000)’匹配 “Windows2000” 中的 “Windows”; 不匹配 “Windows3.1” 中的 “Windows”</td>
</tr>
<tr>
<td style="text-align:center">(?!<em>pattern</em>)</td>
<td><strong>顺序否定环视</strong>, 匹配后面不是 pattern 的位置, 不捕获匹配结果.</td>
<td>‘Windows (?!2000)’匹配 “Windows3.1” 中的 “Windows”; 不匹配 “Windows2000” 中的 “Windows”</td>
</tr>
<tr>
<td style="text-align:center">(?&lt;=<em>pattern</em>)</td>
<td><strong>逆序肯定环视</strong>, 匹配前面是 pattern 的位置, 不捕获匹配结果.</td>
<td>‘(?&lt;=Office)2000’匹配 “ Office2000” 中的 “2000”; 不匹配 “Windows2000” 中的 “2000”</td>
</tr>
<tr>
<td style="text-align:center">(?&lt;!<em>pattern</em>)</td>
<td><strong>逆序否定环视</strong>, 匹配前面不是 pattern 的位置, 不捕获匹配结果.</td>
<td>‘(?&lt;!Office)2000’匹配 “ Windows2000” 中的 “2000”; 不匹配 “ Office2000” 中的 “2000”</td>
</tr>
</tbody>
</table>
<p>以上4种环视中, 目前 javaScript 中只支持前两种, 也就是只支持 <strong>顺序肯定环视</strong> 和 <strong>顺序否定环视</strong>. 下面我们通过实例来帮助理解下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"123abc789"</span>,s;</span><br><span class="line"><span class="comment">//没有使用环视,abc直接被替换</span></span><br><span class="line">s = str.replace(<span class="regexp">/abc/</span>,<span class="number">456</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s); <span class="comment">//123456789</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用了顺序肯定环视,捕获到了a前面的位置,所以abc没有被替换,只是将3替换成了3456</span></span><br><span class="line">s = str.replace(<span class="regexp">/3(?=abc)/</span>,<span class="number">3456</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s); <span class="comment">//123456abc789</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用了顺序否定环视,由于3后面跟着abc,不满意条件,故捕获失败,所以原字符串没有被替换</span></span><br><span class="line">s = str.replace(<span class="regexp">/3(?!abc)/</span>,<span class="number">3456</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s); <span class="comment">//123abc789</span></span><br></pre></td></tr></table></figure>
<p>下面通过python来演示下 <strong>逆序肯定环视</strong> 和 <strong>逆序否定环视</strong> 的用法.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">data = <span class="string">"123abc789"</span></span><br><span class="line"><span class="comment"># 使用了逆序肯定环视,替换左边为123的连续的小写英文字母,匹配成功,故abc被替换为456</span></span><br><span class="line">regExp = <span class="string">r"(?&lt;=123)[a-z]+"</span></span><br><span class="line">replaceString = <span class="string">"456"</span></span><br><span class="line"><span class="keyword">print</span> re.sub(regExp,replaceString,data) <span class="comment"># 123456789</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用了逆序否定环视,由于英文字母左侧不能为123,故子表达式[a-z]+捕获到bc,最终bc被替换为456</span></span><br><span class="line">regExp = <span class="string">r"(?&lt;!123)[a-z]+"</span></span><br><span class="line">replaceString = <span class="string">"456"</span></span><br><span class="line"><span class="keyword">print</span> re.sub(regExp,replaceString,data) <span class="comment"># 123a456789</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是: python 和 perl 语言中的 <strong>逆序环视</strong> 的子表达式只能使用定长的文本. 比如将上述 “(?&lt;=123)” (逆序肯定环视)子表达式写成 “(?&lt;=[0-9]+)”, python解释器将会报错: “error: look-behind requires fixed-width pattern”.</p>
<h4 id="u573A_u666F_u56DE_u987E"><a href="#u573A_u666F_u56DE_u987E" class="headerlink" title="场景回顾"></a>场景回顾</h4><p>假如现在, js 通过 ajax 获取到一段 html 代码如下:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var responseText = "<span class="tag">&lt;<span class="title">div</span> <span class="attribute">data</span>=<span class="value">'dev.xxx.txt'</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span><span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">'dev.xxx.png'</span> /&gt;</span>";</span><br></pre></td></tr></table></figure>
<p>现我们需要替换img标签的src 属性中的 “dev”字符串 为 “test” 字符串. </p>
<p>① 由于上述 responseText 字符串中包含至少两个子字符串 “dev”, 显然不能直接 replace 字符串 “dev”为 “test”. </p>
<p>② 同时由于 js 中不支持逆序环视, 我们也不能在正则中判断前缀为 “src=’”, 然后再替换”dev”. </p>
<p>③ 我们注意到 img 标签的 src 属性以 “.png” 结尾, 基于此, 就可以使用顺序肯定环视. 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/dev(?=[^']*png)/</span>; <span class="comment">//为了防止匹配到第一个dev, 通配符前面需要排除单引号或者是尖括号</span></span><br><span class="line"><span class="keyword">var</span> str = responseText.replace(reg,<span class="string">"test"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str);<span class="comment">//&lt;div data='dev.xxx'&gt;&lt;/div&gt;&lt;img src='test.xxx.png' /&gt;</span></span><br></pre></td></tr></table></figure>
<p>当然, 以上不止顺序肯定环视一种解法, 捕获性分组同样可以做到. 那么环视高级在哪里呢? 环视高级的地方就在于它通过一次捕获就可以定位到一个位置, 对于复杂的文本替换场景, 常有奇效, 而分组则需要更多的操作.</p>
<h3 id="u6B63_u5219_u8868_u8FBE_u5F0F_u5728JS_u4E2D_u7684_u5E94_u7528"><a href="#u6B63_u5219_u8868_u8FBE_u5F0F_u5728JS_u4E2D_u7684_u5E94_u7528" class="headerlink" title="正则表达式在JS中的应用"></a>正则表达式在JS中的应用</h3><h4 id="ES6_u5BF9_u6B63_u5219_u7684_u6269_u5C55"><a href="#ES6_u5BF9_u6B63_u5219_u7684_u6269_u5C55" class="headerlink" title="ES6对正则的扩展"></a>ES6对正则的扩展</h4><p>ES6对正则扩展了又两种修饰符(其他语言可能不支持):</p>
<ul>
<li>y (粘连sticky修饰符), 与g类似, 也是全局匹配, 并且下一次匹配都是从上一次匹配成功的下一个位置开始, 不同之处在于, g修饰符只要剩余位置中存在匹配即可, 而y修饰符确保匹配必须从剩余的第一个位置开始.</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">"abc_ab_a"</span>;</span><br><span class="line"><span class="keyword">var</span> r1 = <span class="regexp">/[a-z]+/g</span>;</span><br><span class="line"><span class="keyword">var</span> r2 = <span class="regexp">/[a-z]+/y</span>;</span><br><span class="line"><span class="built_in">console</span>.log(r1.exec(s),r1.lastIndex); <span class="comment">// ["abc", index: 0, input: "abc_ab_a"] 3</span></span><br><span class="line"><span class="built_in">console</span>.log(r2.exec(s),r2.lastIndex); <span class="comment">// ["abc", index: 0, input: "abc_ab_a"] 3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(r1.exec(s),r1.lastIndex); <span class="comment">// ["ab", index: 4, input: "abc_ab_a"] 6</span></span><br><span class="line"><span class="built_in">console</span>.log(r2.exec(s),r2.lastIndex); <span class="comment">// null 0</span></span><br></pre></td></tr></table></figure>
<p>如上, 由于第二次匹配的开始位置是下标3,  对应的字符串是 “_”, 而使用y修饰符的正则对象r2, 需要从剩余的第一个位置开始, 所以匹配失败, 返回null.</p>
<p>正则对象的 sticky 属性, 表示是否设置了y修饰符. 这点将会在后面讲到.</p>
<ul>
<li>u 修饰符, 提供了对正则表达式添加4字节码点的支持. 比如 “𝌆” 字符是一个4字节字符, 直接使用正则匹配将会失败, 而使用u修饰符后, 将会等到正确的结果.</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">"𝌆"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/^.$/</span>.test(s));<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/^.$/u</span>.test(s));<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<h5 id="UCS-2_u5B57_u8282_u7801"><a href="#UCS-2_u5B57_u8282_u7801" class="headerlink" title="UCS-2字节码"></a>UCS-2字节码</h5><p>有关字节码点, 稍微提下. javaScript 只能处理UCS-2编码(js于1995年5月被Brendan Eich花费10天设计出来, 比1996年7月发布的编码规范UTF-16早了一年多, 当时只有UCS-2可选). 由于UCS-2先天不足, 造成了所有字符在js中都是2个字节. 如果是4个字节的字符, 将会默认被当作两个双字节字符处理. 因此 js 的字符处理函数都会受到限制, 无法返回正确结果. 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">"𝌆"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(s == <span class="string">"\uD834\uDF06"</span>);<span class="comment">//true 𝌆相当于UTF-16中的0xD834DF06</span></span><br><span class="line"><span class="built_in">console</span>.log(s.length);<span class="comment">//2 长度为2, 表示这是4字节字符</span></span><br></pre></td></tr></table></figure>
<p>幸运的是, ES6可以自动识别4字节的字符.因此遍历字符串可以直接使用for of循环. 同时, js中如果直接使用码点表示Unicode字符, 对于4字节字符, ES5里是没办法识别的. 为此ES6修复了这个问题, 只需将码点放在大括号内即可.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(s === <span class="string">"\u1D306"</span>);<span class="comment">//false   ES5无法识别𝌆</span></span><br><span class="line"><span class="built_in">console</span>.log(s === <span class="string">"\u&#123;1D306&#125;"</span>);<span class="comment">//true  ES6可以借助大括号识别𝌆</span></span><br></pre></td></tr></table></figure>
<h5 id="u9644_3A_ES6_u65B0_u589E_u7684_u5904_u74064_u5B57_u8282_u7801_u7684_u51FD_u6570"><a href="#u9644_3A_ES6_u65B0_u589E_u7684_u5904_u74064_u5B57_u8282_u7801_u7684_u51FD_u6570" class="headerlink" title="附: ES6新增的处理4字节码的函数"></a>附: ES6新增的处理4字节码的函数</h5><ul>
<li><strong>String.fromCodePoint()</strong>：从Unicode码点返回对应字符</li>
<li><strong>String.prototype.codePointAt()</strong>：从字符返回对应的码点</li>
<li><strong>String.prototype.at()</strong>：返回字符串给定位置的字符</li>
</ul>
<p>有关js中的unicode字符集, 请参考阮一峰老师的 <a href="http://www.ruanyifeng.com/blog/2014/12/unicode.html" target="_blank" rel="external"><code>Unicode与JavaScript详解</code></a>.</p>
<p>以上是ES6对正则的扩展. 另一个方面, 从方法上看, javaScript 中与正则表达式有关的方法有: </p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>compile</th>
<th>test</th>
<th>exec</th>
<th>match</th>
<th>search</th>
<th>replace</th>
<th>split</th>
</tr>
</thead>
<tbody>
<tr>
<td>所属对象</td>
<td>RegExp</td>
<td>RegExp</td>
<td>RegExp</td>
<td>String</td>
<td>String</td>
<td>String</td>
<td>String</td>
</tr>
</tbody>
</table>
<p>由上, 一共有7个与js相关的方法, 这些方法分别来自于 RegExp 与 String 对象. 首先我们先来看看js中的正则类 RegExp.</p>
<h4 id="RegExp"><a href="#RegExp" class="headerlink" title="RegExp"></a>RegExp</h4><p>RegExp 对象表示正则表达式, 主要用于对字符串执行模式匹配.</p>
<p>语法: new RegExp(pattern[, flags])</p>
<p>参数 <em>pattern</em> 是一个字符串, 指定了正则表达式字符串或其他的正则表达式对象.</p>
<p>参数 <em>flags</em> 是一个可选的字符串, 包含属性 “g”、”i” 和 “m”, 分别用于指定全局匹配、区分大小写的匹配和多行匹配. 如果<em>pattern</em> 是正则表达式, 而不是字符串, 则必须省略该参数.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pattern = <span class="string">"[0-9]"</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(pattern,<span class="string">"g"</span>);</span><br><span class="line"><span class="comment">// 上述创建正则表达式对象,可以用对象字面量形式代替,也推荐下面这种</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/[0-9]/g</span>;</span><br></pre></td></tr></table></figure>
<p>以上, 通过对象字面量和构造函数创建正则表达式, 有个小插曲.</p>
<p>“对于正则表达式的直接量, ECMAscript 3规定在每次它时都会返回同一个RegExp对象, 因此用直接量创建的正则表达式的会共享一个实例. 直到ECMAScript 5才规定每次返回不同的实例.”</p>
<p>所以, 现在我们基本不用担心这个问题, 只需要注意在低版本的非IE浏览器中尽量使用构造函数创建正则(这点上, IE一直遵守ES5规定, 其他浏览器的低级版本遵循ES3规定).</p>
<p>RegExp 实例对象包含如下属性:</p>
<table>
<thead>
<tr>
<th style="text-align:center">实例属性</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">global</td>
<td style="text-align:center">是否包含全局标志(true/false)</td>
</tr>
<tr>
<td style="text-align:center">ignoreCase</td>
<td style="text-align:center">是否包含区分大小写标志(true/false)</td>
</tr>
<tr>
<td style="text-align:center">multiline</td>
<td style="text-align:center">是否包含多行标志(true/false)</td>
</tr>
<tr>
<td style="text-align:center">source</td>
<td style="text-align:center">返回创建RegExp对象实例时指定的表达式文本字符串形式</td>
</tr>
<tr>
<td style="text-align:center">lastIndex</td>
<td style="text-align:center">表示原字符串中匹配的字符串末尾的后一个位置, 默认为0</td>
</tr>
<tr>
<td style="text-align:center">flags(ES6)</td>
<td style="text-align:center">返回正则表达式的修饰符</td>
</tr>
<tr>
<td style="text-align:center">sticky(ES6)</td>
<td style="text-align:center">是否设置了y(粘连)修饰符(true/false)</td>
</tr>
</tbody>
</table>
<h5 id="compile"><a href="#compile" class="headerlink" title="compile"></a>compile</h5><p>compile 方法用于在执行过程中改变和重新编译正则表达式.</p>
<p>语法: compile(pattern[, flags])</p>
<p>参数介绍请参考上述 RegExp 构造器. 用法如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"abc"</span>, <span class="string">"gi"</span>); </span><br><span class="line"><span class="keyword">var</span> reg2 = reg.compile(<span class="string">"new abc"</span>, <span class="string">"g"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(reg);<span class="comment">// /new abc/g</span></span><br><span class="line"><span class="built_in">console</span>.log(reg2);<span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>可见 compile 方法会改变原正则表达式对象, 并重新编译, 而且它的返回值为空.</p>
<h5 id="test"><a href="#test" class="headerlink" title="test"></a>test</h5><p>test 方法用于检测一个字符串是否匹配某个正则规则, 只要是字符串中含有与正则规则匹配的文本, 该方法就返回true, 否则返回 false.</p>
<p>语法: test(string), 用法如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/[0-9]+/</span>.test(<span class="string">"abc123"</span>));<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/[0-9]+/</span>.test(<span class="string">"abc"</span>));<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>以上, 字符串”abc123” 包含数字, 故 test 方法返回 true; 而 字符串”abc” 不包含数字, 故返回 false.</p>
<p>如果需要使用 test 方法测试字符串是否完成匹配某个正则规则, 那么可以在正则表达式里增加开始(^)和结束($)元字符. 如下: </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/^[0-9]+$/</span>.test(<span class="string">"abc123"</span>));<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>以上, 由于字符串”abc123” 并非以数字开始, 也并非以数字结束, 故 test 方法返回false.</p>
<p>实际上, 如果正则表达式带有全局标志(带有参数g)时, test 方法还受正则对象的lastIndex属性影响,如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/[a-z]+/</span>;<span class="comment">//正则不带全局标志</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">"abc"</span>));<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">"de"</span>));<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/[a-z]+/g</span>;<span class="comment">//正则带有全局标志g</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">"abc"</span>));<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.lastIndex);<span class="comment">//3, 下次运行test时,将从索引为3的位置开始查找</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">"de"</span>));<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>该影响将在exec 方法讲解中予以分析.</p>
<h5 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h5><p>exec 方法用于检测字符串对正则表达式的匹配, 如果找到了匹配的文本, 则返回一个结果数组, 否则返回null.</p>
<p>语法: exec(string)</p>
<p>exec 方法返回的数组中包含两个额外的属性, index 和 input. 并且该数组具有如下特点:</p>
<ul>
<li>第 0 个项表示正则表达式捕获的文本</li>
<li>第 1~n 项表示第 1~n 个反向引用, 依次指向第 1~n 个分组捕获的文本, 可以使用RegExp.$ + “编号1~n”  依次获取分组中的文本</li>
<li>index 表示匹配字符串的初始位置</li>
<li>input 表示正在检索的字符串</li>
</ul>
<p>无论正则表达式有无全局标示”g”, exec 的表现都相同. 但正则表达式对象的表现却有些不同. 下面我们来详细说明下正则表达式对象的表现都有哪些不同.</p>
<p>假设正则表达式对象为 reg , 检测的字符为 string , reg.exec(string) 返回值为 array.</p>
<p>若 reg 包含全局标示”g”, 那么 reg.lastIndex 属性表示原字符串中匹配的字符串末尾的后一个位置, 即下次匹配开始的位置, 此时 reg.lastIndex == array.index(匹配开始的位置) + array[0].length(匹配字符串的长度). 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/([a-z]+)/gi</span>,</span><br><span class="line">    string = <span class="string">"World Internet Conference"</span>;</span><br><span class="line"><span class="keyword">var</span> array = reg.exec(string);</span><br><span class="line"><span class="built_in">console</span>.log(array);<span class="comment">//["World", "World", index: 0, input: "World Internet Conference"]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">1</span>);<span class="comment">//World</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.lastIndex);<span class="comment">//5, 刚好等于 array.index + array[0].length</span></span><br></pre></td></tr></table></figure>
<p>随着检索继续, array.index 的值将往后递增, 也就是说, reg.lastIndex 的值也会同步往后递增. 因此, 我们也可以通过反复调用 exec 方法来遍历字符串中所有的匹配文本. 直到 exec 方法再也匹配不到文本时, 它将返回 null, 并把 reg.lastIndex 属性重置为 0. </p>
<p>接着上述例子, 我们继续执行代码, 看看上面说的对不对, 如下所示:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">array = reg.exec(string);</span><br><span class="line"><span class="built_in">console</span>.log(array);<span class="comment">//["Internet", "Internet", index: 6, input: "World Internet Conference"]</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.lastIndex);<span class="comment">//14</span></span><br><span class="line"></span><br><span class="line">array = reg.exec(string);</span><br><span class="line"><span class="built_in">console</span>.log(array);<span class="comment">//["Conference", "Conference", index: 15, input: "World Internet Conference"]</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.lastIndex);<span class="comment">//25</span></span><br><span class="line"></span><br><span class="line">array = reg.exec(string);</span><br><span class="line"><span class="built_in">console</span>.log(array);<span class="comment">//null</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.lastIndex);<span class="comment">//0</span></span><br></pre></td></tr></table></figure>
<p>以上代码中, 随着反复调用 exec 方法, reg.lastIndex 属性最终被重置为 0.</p>
<p><strong>问题回顾</strong></p>
<p>在 test 方法的讲解中, 我们留下了一个问题. 如果正则表达式带有全局标志g, 以上 test 方法的执行结果将受 reg.lastIndex影响, 不仅如此, exec 方法也一样. 由于 reg.lastIndex 的值并不总是为零, 并且它决定了下次匹配开始的位置, 如果在一个字符串中完成了一次匹配之后要开始检索新的字符串, 那就必须要手动地把 lastIndex 属性重置为 0. 避免出现下面这种错误:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/[0-9]+/g</span>,</span><br><span class="line">    str1 = <span class="string">"123abc"</span>,</span><br><span class="line">    str2 = <span class="string">"123456"</span>;</span><br><span class="line">reg.exec(str1);</span><br><span class="line"><span class="built_in">console</span>.log(reg.lastIndex);<span class="comment">//3</span></span><br><span class="line"><span class="keyword">var</span> array = reg.exec(str2);</span><br><span class="line"><span class="built_in">console</span>.log(array);<span class="comment">//["456", index: 3, input: "123456"]</span></span><br></pre></td></tr></table></figure>
<p>以上代码, 正确执行结果应该是 “123456”,  因此建议在第二次执行 exec 方法前, 增加一句 “reg.lastIndex = 0;”.</p>
<p>若 reg 不包含全局标示”g”, 那么 exec 方法的执行结果(array)将与 string.match(reg) 方法执行结果完全相同.</p>
<h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p>match, search, replace, split 方法请参考 <a href="http://louiszhai.github.io/2016/01/12/js.String/"><code>字符串常用方法</code></a> 中的讲解.</p>
<p>如下展示了使用捕获性分组处理文本模板, 最终生成完整字符串的过程:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="string">"An $&#123;a&#125; a $&#123;b&#125; keeps the $&#123;c&#125; away"</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	a:<span class="string">"apple"</span>,</span><br><span class="line">  	b:<span class="string">"day"</span>,</span><br><span class="line">  	c:<span class="string">"doctor"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tmpl</span>(<span class="params">t,o</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> t.replace(<span class="regexp">/\$&#123;(.)&#125;/g</span>,<span class="function"><span class="keyword">function</span>(<span class="params">m,p</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'m:'</span>+m+<span class="string">' p:'</span>+p);</span><br><span class="line">		<span class="keyword">return</span> o[p];</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line">tmpl(tmp,obj);</span><br></pre></td></tr></table></figure>
<p>上述功能使用ES6可这么实现:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	a:<span class="string">"apple"</span>,</span><br><span class="line">  	b:<span class="string">"day"</span>,</span><br><span class="line">  	c:<span class="string">"doctor"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">with</span>(obj)&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">`An <span class="subst">$&#123;a&#125;</span> a <span class="subst">$&#123;b&#125;</span> keeps the <span class="subst">$&#123;c&#125;</span> away`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u6B63_u5219_u8868_u8FBE_u5F0F_u5728H5_u4E2D_u7684_u5E94_u7528"><a href="#u6B63_u5219_u8868_u8FBE_u5F0F_u5728H5_u4E2D_u7684_u5E94_u7528" class="headerlink" title="正则表达式在H5中的应用"></a>正则表达式在H5中的应用</h3><p>H5中新增了 pattern 属性, 规定了用于验证输入字段的模式, pattern的模式匹配支持正则表达式的书写方式. 默认 pattern 属性是全部匹配, 即无论正则表达式中有无 “^”, “$” 元字符, 它都是匹配所有文本.</p>
<p>注: pattern 适用于以下 input 类型：text, search, url, telephone, email 以及 password. 如果需要取消表单验证, 在form标签上增加 novalidate 属性即可.</p>
<h3 id="u6B63_u5219_u5F15_u64CE"><a href="#u6B63_u5219_u5F15_u64CE" class="headerlink" title="正则引擎"></a>正则引擎</h3><p>目前正则引擎有两种, DFA 和 NFA, NFA又可以分为传统型NFA和POSIX NFA.</p>
<ul>
<li>DFA Deterministic finite automaton 确定型有穷自动机</li>
<li>NFA Non-deterministic finite automaton　非确定型有穷自动机</li>
<li>Traditional NFA</li>
<li>POSIX NFA</li>
</ul>
<p>DFA引擎不支持回溯, 匹配快速, 并且不支持捕获组, 因此也就不支持反向引用. 上述awk, egrep命令均支持 DFA引擎. </p>
<p>POSIX NFA主要指符合POSIX标准的NFA引擎, 像 javaScript, java, php, python, c#等语言均实现了NFA引擎.</p>
<p>有关正则表达式详细的匹配原理, 暂时没在网上看到适合的文章, 建议选读 Jeffrey Friedl 的 &lt;精通正则表达式&gt;[第三版] 中第4章-表达式的匹配原理(p143-p183), Jeffrey Friedl 对正则表达式有着深刻的理解, 相信他能够帮助您更好的学习正则.</p>
<p>有关NFA引擎的简单实现, 可以参考文章 <a href="http://www.cnblogs.com/catch/p/3722082.html" target="_blank" rel="external">基于ε-NFA的正则表达式引擎 - twoon</a>.</p>
<h3 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h3><p>在学习正则的初级阶段, 重在理解 ①贪婪与非贪婪模式, ②分组, ③捕获性与非捕获性分组, ④命名分组, ⑤固化分组, 体会设计的精妙之处. 而高级阶段, 主要在于熟练运用⑥零宽断言(或环视)解决问题, 并且熟悉正则匹配的原理. </p>
<p>实际上, 正则在 javaScript 中的功能不算强大, js 仅仅支持了①贪婪与非贪婪模式, ②分组, ③捕获性与非捕获性分组 以及 ⑥零宽断言中的顺序环视. 如果再稍微熟悉些 js 中7种与正则有关的方法(compile, test, exec, match, search, replace, split), 那么处理文本或字符串将游刃有余.</p>
<p>正则表达式, 在文本处理方面天赋异禀, 它的功能十分强大, 很多时候甚至是唯一解决方案. 正则不局限于js, 当下热门的编辑器(比如Sublime, Atom) 以及 IDE(比如WebStorm, IntelliJ IDEA) 都支持它. 您甚至可以在任何时候任何语言中, 尝试使用正则解决问题, 也许之前不能解决的问题, 现在可以轻松的解决.</p>
<p>附其他语言正则资料:</p>
<ul>
<li><a href="http://wiki.ubuntu.org.cn/Python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97" target="_blank" rel="external">Python正则表达式操作指南</a></li>
<li><a href="http://blog.csdn.net/allwefantasy/article/details/3136570/" target="_blank" rel="external">java正则表达式</a></li>
</ul>
<hr>
<p>本文就讨论这么多内容,大家有什么问题或好的想法欢迎在下方参与<a href="#respond">留言和评论</a>.</p>
<p>本文作者: <a href="https://github.com/Louiszhai" target="_blank" rel="external">louis</a></p>
<p>本文链接: <a href="http://louiszhai.github.io/2016/06/13/regular/">http://louiszhai.github.io/2016/06/13/regular/</a></p>
<p>参考文章</p>
<ul>
<li>Jeffrey Friedl 的 &lt;精通正则表达式&gt;[第三版]</li>
<li><a href="http://blog.csdn.net/fdl19881/article/details/7800877" target="_blank" rel="external">linux shell 正则表达式(BREs,EREs,PREs)差异比较</a></li>
<li><a href="http://www.jb51.net/article/28035.htm" target="_blank" rel="external">正则表达式之捕获组/非捕获组介绍_正则表达式_脚本之家</a></li>
<li><a href="http://www.cnblogs.com/kissdodog/archive/2013/04/22/3036649.html" target="_blank" rel="external">正则表达式(一) – 元字符 - 逆心 - 博客园</a></li>
<li><a href="http://blog.csdn.net/hguisu/article/details/8244560" target="_blank" rel="external">正则表达式详解 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET</a></li>
<li><a href="http://www.cnblogs.com/taek/archive/2012/02/08/2342741.html" target="_blank" rel="external">正则表达式之固化分组 - taek - 博客园</a></li>
<li><a href="http://www.jb51.net/article/31491.htm" target="_blank" rel="external">正则表达式之 贪婪与非贪婪模式详解（概述）_正则表达式_脚本之家</a></li>
<li><a href="http://blog.csdn.net/nebula1982/article/details/6659702" target="_blank" rel="external">JAVASCRIPT 正则表达式学习–&gt;基础与零宽断言（转自司徒正美） - 随风之羽 - 博客频道 - CSDN.NET</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/12/unicode.html" target="_blank" rel="external">Unicode与JavaScript详解 - 阮一峰的网络日志</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[regexp 正则表达式]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[详解IE7以下独有的hasLayout]]></title>
    <link href="http://louiszhai.github.io/2016/03/31/css-hasLayout/"/>
    <id>http://louiszhai.github.io/2016/03/31/css-hasLayout/</id>
    <published>2016-03-31T05:57:56.000Z</published>
    <updated>2016-04-27T01:26:57.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u4EC0_u4E48_u662FhasLayout"><a href="#u4EC0_u4E48_u662FhasLayout" class="headerlink" title="什么是hasLayout"></a>什么是hasLayout</h3><blockquote>
<p>hasLayout property: Gets a value that indicates whether the object has layout.</p>
</blockquote>
<p><strong>hasLayout</strong> 是IE渲染引擎的一个内部实现. IE中, 一个元素要么自己计算大小组织内容(自己渲染), 要么依赖父元素来计算大小和组织内容(依赖祖先元素渲染). 为了区分两者, 渲染引擎采用了 hasLayout 属性, 该属性可以设置为 true 或 false. 若一个元素的 hasLayout 属性值为 true 时, 这个元素便拥有了一个布局(layout), 该元素便不在依赖某个祖先元素进行渲染, 而是它自己就去渲染自己了, 它会负责对自己和可能的子孙元素进行尺寸计算和定位, 这意味着这个元素需要花更多的代价来维护自身和里面的内容; 相反的, 若元素的 hasLayout 属性值为 false时, 它会直接依赖于某个祖先元素来完成这些工作, 最终造成很多的IE bugs.</p>
<a id="more"></a>
<h3 id="u9ED8_u8BA4_u60C5_u51B5_u4E0BhasLayout_3Dtrue_u7684_u5143_u7D20"><a href="#u9ED8_u8BA4_u60C5_u51B5_u4E0BhasLayout_3Dtrue_u7684_u5143_u7D20" class="headerlink" title="默认情况下hasLayout=true的元素"></a>默认情况下hasLayout=true的元素</h3><p>下列元素默认拥有 layout:</p>
<ul>
<li>html body</li>
<li>table tr th td</li>
<li>img</li>
<li>hr</li>
<li>input button file select textarea fieldset</li>
<li>marquee</li>
<li>frameset frame iframe </li>
<li>objects applets embed</li>
</ul>
<h3 id="u600E_u4E48_u89E6_u53D1_u53CA_u6E05_u9664_hasLayout"><a href="#u600E_u4E48_u89E6_u53D1_u53CA_u6E05_u9664_hasLayout" class="headerlink" title="怎么触发及清除 hasLayout"></a>怎么触发及清除 hasLayout</h3><p>以下css样式的设置, 会触发元素的 hasLayout:</p>
<ul>
<li><em>position: absolute</em>(IE5+)</li>
<li><em>float: left|right</em>(IE5+)</li>
<li><em>display: inline-block</em>(IE5+)</li>
<li><em>width|height: “auto”以外的任何值</em>(IE5+; 只对block元素有效)</li>
<li><em>zoom: “normal”以外的任何值</em>(IE5.5+; IE私有属性)</li>
<li><em>writing-mode: tb-rl</em>(IE5+; IE私有属性)</li>
<li><em>overflow: hidden|scroll|auto</em>(IE7; 此属性在IE6及更早版本中不能应用在未触发hasLayout的元素上)</li>
<li><em>overflow-x|-y: hidden|scroll|auto</em>(IE7; 此属性在IE6及更早版本中不触发hasLayout; 此属性在CSS3中才获支持)</li>
<li><em>position: fixed</em>(IE7)</li>
<li><em>min-width: 任何值</em>(IE7; 即使是0)</li>
<li><em>max-width: “none”以外的任何值</em>(IE7)</li>
<li><em>min-height: 任何值</em>(IE7)</li>
<li><em>max-height: “none”以外的任何值</em>(IE7)</li>
<li><em>position: fixed</em>(IE7)</li>
</ul>
<p>以下css样式的设置, 会清除已经触发的 hasLayout:</p>
<ul>
<li><em>position: static</em>(IE5+)</li>
<li><em>float: none</em>(IE5+)</li>
<li><em>display: “inline-block”以外的任何值</em>(IE5+)</li>
<li><em>width|height: “auto”</em>(IE5+; 对inline元素无效)</li>
<li><em>zoom: “normal”</em>(IE5.5+; IE私有属性)</li>
<li><em>writing-mode: 从’tb-rl’到’lr-tb’</em>(IE5+; IE私有属性)</li>
<li><em>max-width|max-height: “none”</em>(IE7)</li>
<li><em>overflow: visible</em>(IE7)</li>
</ul>
<h3 id="hasLayout__u7684_u5F71_u54CD"><a href="#hasLayout__u7684_u5F71_u54CD" class="headerlink" title="hasLayout 的影响"></a>hasLayout 的影响</h3><ol>
<li><strong>浮动元素可以被 layout 元素自动包含</strong>. 一般情况下, 由于浮动元素脱离普通文档流会造成父元素的坍塌. 但是在IE6-7下, 通过触发父元素的 hasLayout, 可以使得父元素自动包含浮动的子元素, 从而修复坍塌问题. 一般我们设置父元素的 *height:1%; 即可, 1%并不会改变实际高度, 只是触发了 hasLayout, 该方法被称为霍莉破解(Holly hack), 需要注意的是, 当这个元素的 overflow 属性被设置为 visible 时, 这个方法就失效了.</li>
<li>正常情况下, 浮动元素旁边的元素, 其内容应该环绕该浮动元素. 如果这个元素拥有 layout, 那么这个元素就会表现为一个矩形, 其内容不会环绕浮动元素.</li>
<li>IE独有的滤镜属性(filter) 只适用于 layout 元素, 若一个div 设置了<strong>filter:alpha(opacity=90)</strong>, 又没有触发该div 的 hasLayout, 那么透明的设置将无效.</li>
<li>hasLayout 影响块级元素鼠标的响应区域, 通常 hasLayout=false时, 只有文字区域才有响应, 而 hasLayout=true 时, 整个块级元素都是可以响应的.</li>
</ol>
<h3 id="hasLayout__u5F15_u8D77_u7684bug"><a href="#hasLayout__u5F15_u8D77_u7684bug" class="headerlink" title="hasLayout 引起的bug"></a>hasLayout 引起的bug</h3><ol>
<li>IE6 及更低版本的双空白边浮动 bug, 修复方案: display:inline;</li>
<li>IE5-6的 3 像素偏移 bug, 修复方案: _height:1%;</li>
<li>IE6 的躲躲猫(peek-a-boo) bug, 修复方案: _height:1%;</li>
<li>IE6-7负margin隐藏Bug, 修复方案: 去掉父元素的hasLayout; 或者赋hasLayout给子元素, 并添加position:relative;</li>
</ol>
<h3 id="u600E_u4E48_u68C0_u6D4BIE_u4E0B_u7684_u67D0_u4E2A_u5143_u7D20_u662F_u5426_u62E5_u6709hasLayout"><a href="#u600E_u4E48_u68C0_u6D4BIE_u4E0B_u7684_u67D0_u4E2A_u5143_u7D20_u662F_u5426_u62E5_u6709hasLayout" class="headerlink" title="怎么检测IE下的某个元素是否拥有hasLayout"></a>怎么检测IE下的某个元素是否拥有hasLayout</h3><p>在 IE Developer Toolbar 下, 拥有 haslayout的元素, 通常显示为 “haslayout = -1”. 也可通过js的方式检测, 如下所示:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(element.currentStyle.hasLayout);<span class="comment">//该方式只能获取值, 而不能设置</span></span><br></pre></td></tr></table></figure>
<p>以下代码可用于在IE6-7下测试某个元素是否拥有hasLayout:</p>
<p>Code example: <a href="http://samples.msdn.microsoft.com/workshop/samples/author/dhtml/refs/hasLayout.htm" target="_blank" rel="external">http://samples.msdn.microsoft.com/workshop/samples/author/dhtml/refs/hasLayout.htm</a></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="title">head</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="title">title</span>&gt;</span>hasLayout Property<span class="tag">&lt;/<span class="title">title</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="title">head</span>&gt;</span> </span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="title">body</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="title">h1</span>&gt;</span>hasLayout Property<span class="tag">&lt;/<span class="title">h1</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="title">p</span>&gt;</span>This example uses the <span class="tag">&lt;<span class="title">strong</span>&gt;</span>hasLayout<span class="tag">&lt;/<span class="title">strong</span>&gt;</span> property of the <span class="tag">&lt;<span class="title">strong</span>&gt;</span>currentStyle<span class="tag">&lt;/<span class="title">strong</span>&gt;</span> object to  </span><br><span class="line">    show that an element has layout when it is absolutely positioned, or when its height and/or width are specified.   </span><br><span class="line">    The <span class="tag">&lt;<span class="title">strong</span>&gt;</span>hasLayout<span class="tag">&lt;/<span class="title">strong</span>&gt;</span> property returns <span class="tag">&lt;<span class="title">strong</span>&gt;</span>true<span class="tag">&lt;/<span class="title">strong</span>&gt;</span> for an object that has layout, and  </span><br><span class="line">    <span class="tag">&lt;<span class="title">strong</span>&gt;</span>false<span class="tag">&lt;/<span class="title">strong</span>&gt;</span> for an object that has no layout.<span class="tag">&lt;/<span class="title">p</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="title">fieldset</span> <span class="attribute">style</span>=<span class="value">"width: 50%; text-align: center;"</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="title">legend</span>&gt;</span><span class="tag">&lt;<span class="title">strong</span>&gt;</span>hasLayout<span class="tag">&lt;/<span class="title">strong</span>&gt;</span> Property<span class="tag">&lt;/<span class="title">legend</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="title">p</span> <span class="attribute">style</span>=<span class="value">"text-align: left;"</span>&gt;</span><span class="tag">&lt;<span class="title">em</span>&gt;</span>Which DIV element has layout?<span class="tag">&lt;/<span class="title">em</span>&gt;</span><span class="tag">&lt;/<span class="title">p</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"oWidthSet"</span> <span class="attribute">style</span>=<span class="value">"width: 100%; text-align: left;"</span>&gt;</span><span class="tag">&lt;<span class="title">strong</span>&gt;</span>DIV<span class="tag">&lt;/<span class="title">strong</span>&gt;</span> element A has its <span class="tag">&lt;<span class="title">strong</span>&gt;</span>width<span class="tag">&lt;/<span class="title">strong</span>&gt;</span> set to <span class="tag">&lt;<span class="title">strong</span>&gt;</span>100%<span class="tag">&lt;/<span class="title">strong</span>&gt;</span>.<span class="tag">&lt;/<span class="title">div</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"oNotSet"</span> <span class="attribute">style</span>=<span class="value">"text-align: left;"</span>&gt;</span><span class="tag">&lt;<span class="title">strong</span>&gt;</span>DIV<span class="tag">&lt;/<span class="title">strong</span>&gt;</span> element B is not positioned, and neither its <span class="tag">&lt;<span class="title">strong</span>&gt;</span>height<span class="tag">&lt;/<span class="title">strong</span>&gt;</span> nor <span class="tag">&lt;<span class="title">strong</span>&gt;</span>width<span class="tag">&lt;/<span class="title">strong</span>&gt;</span> is set.<span class="tag">&lt;/<span class="title">div</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="title">br</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="title">button</span> <span class="attribute">onclick</span>=<span class="value">"document.getElementById('messageBox').textContent = document.getElementById('oWidthSet').currentStyle.hasLayout;"</span>&gt;</span>DIV Element A<span class="tag">&lt;/<span class="title">button</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="title">button</span> <span class="attribute">onclick</span>=<span class="value">"document.getElementById('messageBox').textContent = document.getElementById('oNotSet').currentStyle.hasLayout;"</span>&gt;</span>DIV Element B<span class="tag">&lt;/<span class="title">button</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="title">fieldset</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"messageBox"</span> <span class="attribute">style</span>=<span class="value">"padding-top: 1em; font-weight: bold;"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>另外, 若一个元素没有布局(layout), 那么IE下 clientWidth/clientHeight 总是返回0. 基于这点, 可以使用另一种js的方法检测元素是否拥有hasLayout, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(element.clientHeight==<span class="number">0</span>);<span class="comment">//等于true则表示该元素不拥有hasLayout</span></span><br></pre></td></tr></table></figure>
<h3 id="u9700_u8981_u6CE8_u610F_u7684_u662F"><a href="#u9700_u8981_u6CE8_u610F_u7684_u662F" class="headerlink" title="需要注意的是"></a>需要注意的是</h3><ul>
<li>hasLayout 功能只存在于IE7及低版本的浏览器上, IE8中已删除 hasLayout 功能.</li>
<li>hasLayout 触发后, 没有办法直接设置 hasLayout=false, 只有将那些触发 hasLayout 的 css 属性去除, 才能恢复原样.</li>
</ul>
<hr>
<p>本文就讨论这么多内容,大家有什么问题或好的想法欢迎在下方参与<a href="#respond">留言和评论</a>.</p>
<p>本文作者: <a href="https://github.com/Louiszhai" target="_blank" rel="external">louis</a></p>
<p>本文链接: <a href="http://louiszhai.github.io/2016/03/31/css-hasLayout/">http://louiszhai.github.io/2016/03/31/css-hasLayout/</a></p>
<p>参考文章</p>
<ul>
<li><a href="https://msdn.microsoft.com/library/ms530751(v=vs.85).aspx" target="_blank" rel="external">display property (Internet Explorer)</a></li>
<li><a href="http://blog.csdn.net/hedong37518585/article/details/6639263" target="_blank" rel="external">hasLayout 介绍，以及其触发条件 - 何东狮吼 - 博客频道 - CSDN.NET</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_50502064010135lr.html" target="_blank" rel="external">认识hasLayout——IE6、7浏览器css bug的一大罪恶根源_ICER_JIN_新浪博客</a></li>
<li><a href="https://msdn.microsoft.com/zh-cn/data/ms530764" target="_blank" rel="external">hasLayout property (Internet Explorer)</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[css IE6 IE7 hasLayout]]>
    
    </summary>
    
      <category term="css" scheme="http://louiszhai.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[你不知道的margin属性]]></title>
    <link href="http://louiszhai.github.io/2016/03/23/css-margin/"/>
    <id>http://louiszhai.github.io/2016/03/23/css-margin/</id>
    <published>2016-03-23T12:47:36.000Z</published>
    <updated>2016-04-27T01:26:54.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u5BFC_u8BFB"><a href="#u5BFC_u8BFB" class="headerlink" title="导读"></a>导读</h3><p>margin属性处于盒子模型的最外层, 用以隔开其他元素, 它可以依次设置4个长度值, 分别表示 “上 右 下 左” 的间距, 其中第1个和第3个值相对应, 第2个与第4个相对应, 如果省略前者, 后者将取与前者相同的数值. margin属性共存在以下 4 种表示方式:</p>
<ul>
<li>margin: 10px 1rem 1em 5%; 共 4 个数值, 表示依次设置 上, 右, 下, 左的间距;</li>
<li>margin: 10px 1rem 1em; 共 3 个数值, 省略第4个值, 左间距将取右间距的值, 表示依次设置 上, 左右, 下的间距;</li>
<li>margin: 10px 1rem; 共 2 个数值, 省略第3,4个值, 左间距将取右间距的值, 下间距将取上间距的值, 表示依次设置 上下, 左右的间距;</li>
<li>margin: 10px; 共 1 个数值, 同时省略第2,3,4个值, 表示上下左右的间距均为10px;</li>
</ul>
<p>若是块级元素, 借助 margin:0 auto; 即可实现水平居中.</p>
<p>看到这里, 你可能会觉得这些你都懂了, 这不要紧, 显然本文也不是为了科普margin的基础语法, 请往下看.</p>
<a id="more"></a>
<h3 id="u5782_u76F4_u5916_u8FB9_u8DDD_u5408_u5E76_u95EE_u9898"><a href="#u5782_u76F4_u5916_u8FB9_u8DDD_u5408_u5E76_u95EE_u9898" class="headerlink" title="垂直外边距合并问题"></a>垂直外边距合并问题</h3><p>别被上面这个名词给吓倒了, 简单地说, 外边距合并指的是, 当两个垂直外边距相遇时, 它们将形成一个外边距. 合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者. 你可以查看<a href="http://www.w3school.com.cn/css/css_margin_collapsing.asp" target="_blank" rel="external">W3Shool CSS外边距合并</a>了解这个基本知识.</p>
<p>实际工作中, 垂直外边距合并问题常见于第一个子元素的margin-top会顶开父元素与父元素相邻元素的间距, 而且只在标准浏览器下(FirfFox、Chrome、Opera、Sarfi)产生问题, IE下反而表现良好.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">style</span>&gt;</span><span class="css"></span><br><span class="line">  <span class="class">.outer-box</span><span class="rules">&#123;</span><br><span class="line">  	<span class="rule"><span class="attribute">margin-top</span>:<span class="value"><span class="number">15px</span></span></span>;</span><br><span class="line">  &#125;</span></span><br><span class="line">  <span class="class">.inner-box</span><span class="rules">&#123;</span><br><span class="line">  	<span class="rule"><span class="attribute">margin-top</span>:<span class="value"><span class="number">30px</span></span></span>;</span><br><span class="line">  &#125;</span></span><br><span class="line"></span><span class="tag">&lt;/<span class="title">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"outer-box"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"inner-box"</span>&gt;</span>1234567890<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>打开控制台, 你会发现内部div距离顶部的距离是30px, 而不是45px, 这是因为内部div与外部div的margin-top属性做了合并, 取两者中的最大值, 即 30px.</p>
<p>如果按照CSS规范, IE的“良好表现”其实是一个错误的表现, 因为IE的hasLayout渲染导致了这个“表现良好”的外观. 而其他标准浏览器则会表现出“有问题”的外观. 好了, 如果你读过了上面W3Shcool的CSS外边距合并的文章后, 就很容易讨论这个问题了. 这个问题发生的原因是<strong>根据规范, 一个盒子如果没有上补白(padding-top)和上边框(border-top), 那么这个盒子的上边距会和其内部文档流中的第一个子元素的上边距重叠</strong>.</p>
<p>基于此, 该问题便很好解决了, 给外部div设置一个透明的1像素的border-top即可.</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.outer-box</span><span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">margin-top</span>:<span class="value"><span class="number">15px</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">border-top</span>:<span class="value"><span class="number">1px</span> solid transparent</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="margin_u662F_u5426_u5BF9_u5185_u8054_u5143_u7D20_u751F_u6548_3F"><a href="#margin_u662F_u5426_u5BF9_u5185_u8054_u5143_u7D20_u751F_u6548_3F" class="headerlink" title="margin是否对内联元素生效?"></a>margin是否对内联元素生效?</h3><p>margin也能用于内联元素, 这是规范所允许的, 但是margin-top和margin-bottom对内联元素（对行）的高度没有影响, 并且由于边界效果(margin效果)是透明的, 他也没有任何的视觉影响.</p>
<p>这是因为边界应用于内联元素时不改变元素的行高度，如果你要改变内联元素的行高即类似文本的行间距, 那么你只能使用这三个属性: line-height, fong-size, vertical-align. 请记住, 这个影响内联元素高度的是line-height而不是height, 因为内联元素是一行行的, 定一个height的话, 那这到底是整段inline元素的高呢? 还是inline元素一行的高呢? 这都说不准, 所以统一都给每行定一个高, 只能是line-height了.</p>
<p><strong>margin-top/margin-bottom对内联元素没有实际效果, 不过margin-left/margin-right还是能够对内联元素产生影响的</strong>. 应用margin:10px 20px 30px 40px;, 左边这个css如果写在inline元素上, 他的效果大致是, 上下无效果, 左边离他相邻元素或者文本距离为40px, 右边离他相邻元素或者文本距离为20px.</p>
<h3 id="u6709_u5173margin_u7684_u5E38_u89C1bug"><a href="#u6709_u5173margin_u7684_u5E38_u89C1bug" class="headerlink" title="有关margin的常见bug"></a>有关margin的常见bug</h3><p>下面罗列一下常见的有关margin的bug, 可能不全, 非常欢迎交流探讨, 请在<a href="#respond">回复</a>中补充.</p>
<h4 id="IE6_u4E2D_u6D6E_u52A8_u5143_u7D203px_u95F4_u9694Bug"><a href="#IE6_u4E2D_u6D6E_u52A8_u5143_u7D203px_u95F4_u9694Bug" class="headerlink" title="IE6中浮动元素3px间隔Bug"></a>IE6中浮动元素3px间隔Bug</h4><p>发生场景: 发生在一个元素浮动，然后一个不浮动的元素自然上浮与之靠近会出现的3px的bug.<br>解决方法: 右边元素也一起浮动; 或者为右边元素添加IE6 Hack “_margin-left:-3px;” 从而消除3px间距.<br>原因分析：IE6浏览器缺陷Bug.</p>
<h4 id="inline-block_u5143_u7D20_u4E4B_u95F4_u7A7A_u767DBug"><a href="#inline-block_u5143_u7D20_u4E4B_u95F4_u7A7A_u767DBug" class="headerlink" title="inline-block元素之间空白Bug"></a>inline-block元素之间空白Bug</h4><p>发生场景: IE8+、Chrome、Firefox、Safari等浏览器下的效果, 两个inline-block的元素之间会存在一定的空白间距, 空白间距的宽度与父元素的font-size大小有关.</p>
<p>解决方法: 可以为inline-block元素设置为负的margin-left; 或父元素font-size设置为0, 子元素再重新设置回来, 如需兼容所有浏览器, 请参考 <a href="http://louiszhai.github.io/2016/03/27/css-inline-block/">inline-block空白间距解决方案探讨</a>.</p>
<p>原因分析: HTML 中的换行符、空格符、制表符等合并为空白符, 字体大小不为 0 的情况下, 空白符自然占据一定的宽度, 因此产生了元素间的空隙.</p>
<h4 id="IE6/7_u8D1Fmargin_u9690_u85CFBug"><a href="#IE6/7_u8D1Fmargin_u9690_u85CFBug" class="headerlink" title="IE6/7负margin隐藏Bug"></a>IE6/7负margin隐藏Bug</h4><p>发生场景: 当给一个有hasLayout的父元素内的非hasLayout元素设置负margin时, 超出父元素部分不可见.<br>解决方法: 去掉父元素的hasLayout; 或者赋hasLayout给子元素,并添加position:relative;<br>原理分析: IE6/7独有的hasLayout产生问题.</p>
<h4 id="IE6/7_u4E0Bul/ol_u6807_u8BB0_u6D88_u5931bug"><a href="#IE6/7_u4E0Bul/ol_u6807_u8BB0_u6D88_u5931bug" class="headerlink" title="IE6/7下ul/ol标记消失bug"></a>IE6/7下ul/ol标记消失bug</h4><p>发生场合: 当ul/ol触发了haslayout并且是在ul/ol上写margin-left, 前面默认的ul/ol标记会消失.<br>解决方法: 给li设置margin-left, 而不是给ul/ol设置margin-left.<br>原因分析：IE6/7浏览器Bug.</p>
<h4 id="IE6/7_u4E0Bmargin_u4E0Eabsolute_u5143_u7D20_u91CD_u53E0bug"><a href="#IE6/7_u4E0Bmargin_u4E0Eabsolute_u5143_u7D20_u91CD_u53E0bug" class="headerlink" title="IE6/7下margin与absolute元素重叠bug"></a>IE6/7下margin与absolute元素重叠bug</h4><p>发生场景: 双栏自适应布局中, 左侧元素absolute绝对定位, 右侧的margin撑开距离定位. 在IE6/7下左侧应用了absolute属性的块级元素与右边的自适应的文字内容重叠.<br>解决方法: 把左侧块级元素更改为内联元素, 比如把div更换为span.<br>原因分析: 这是由于IE6-7浏览器将inline水平标签元素和block水平的标签元素没有加以区分一视同仁渲染了. 属于IE6-7浏览器渲染Bug.</p>
<h4 id="IE6/7/8_u4E0Bauto_margin_u5C45_u4E2Dbug"><a href="#IE6/7/8_u4E0Bauto_margin_u5C45_u4E2Dbug" class="headerlink" title="IE6/7/8下auto margin居中bug"></a>IE6/7/8下auto margin居中bug</h4><p>发生场景: 给block元素设置margin auto无法居中<br>解决方法: 出现这种bug的原因通常是没有Doctype, 然后触发了ie的quirks mode, 加上Doctype声明就可以了. 在《打败IE的葵花宝典》里给出的方法是给block元素添加一个width能够解决, 但据测试, 加with此种方法是无效的, 如果没有Doctype即使给元素添加width也无法让block元素居中.<br>原因分析: 缺少Doctype声明.</p>
<h4 id="IE8_u4E0Binput_5Bbutton__7C_submit_5D__u8BBE_u7F6Emargin_3A0_auto_u65E0_u6CD5_u5C45_u4E2D"><a href="#IE8_u4E0Binput_5Bbutton__7C_submit_5D__u8BBE_u7F6Emargin_3A0_auto_u65E0_u6CD5_u5C45_u4E2D" class="headerlink" title="IE8下input[button | submit] 设置margin:0 auto无法居中"></a>IE8下input[button | submit] 设置margin:0 auto无法居中</h4><p>发生场景: ie8下, 如果给像button这样的标签（如button input[type=”button”] input[type=”submit”]）设置{ display: block; margin:0 auto; }如果不设置宽度的话无法居中.<br>解决方法: 可以给为input加上宽度.<br>原因分析: IE8浏览器Bug.</p>
<h4 id="IE8_u767E_u5206_u6BD4padding_u5782_u76F4margin_bug"><a href="#IE8_u767E_u5206_u6BD4padding_u5782_u76F4margin_bug" class="headerlink" title="IE8百分比padding垂直margin bug"></a>IE8百分比padding垂直margin bug</h4><p>发生场景: 当父元素设置了百分比的padding, 子元素有垂直的margin的时候, 就好像父元素被设置了margin一样.<br>解决方法: 给父元素加一个overflow:hidden/auto。<br>原因分析: IE8浏览器Bug.</p>
<hr>
<p>本文就讨论这么多内容,大家有什么问题或好的想法欢迎在下方参与<a href="#respond">留言和评论</a>.</p>
<p>本文作者: <a href="https://github.com/Louiszhai" target="_blank" rel="external">louis</a></p>
<p>本文链接: <a href="http://louiszhai.github.io/2016/03/23/css-margin/">http://louiszhai.github.io/2016/03/23/css-margin/</a></p>
<p>参考文章</p>
<ul>
<li><a href="http://www.hicss.net/do-not-tell-me-you-understand-margin/" target="_blank" rel="external">不要告诉我你懂margin</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[css margin]]>
    
    </summary>
    
      <category term="css" scheme="http://louiszhai.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[16种方法实现水平居中垂直居中]]></title>
    <link href="http://louiszhai.github.io/2016/03/12/css-center/"/>
    <id>http://louiszhai.github.io/2016/03/12/css-center/</id>
    <published>2016-03-12T11:03:04.000Z</published>
    <updated>2016-06-21T04:59:34.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u5BFC_u8BFB"><a href="#u5BFC_u8BFB" class="headerlink" title="导读"></a>导读</h3><p>熟悉水平居中和垂直居中的方法, 不为别的, 就为用的时候能够信手拈来. 下面直接步入正题.</p>
<a id="more"></a>
<h3 id="u6C34_u5E73_u5C45_u4E2D"><a href="#u6C34_u5E73_u5C45_u4E2D" class="headerlink" title="水平居中"></a>水平居中</h3><p>1) 若是行内元素, 给其父元素设置 text-align:center,即可实现行内元素水平居中.</p>
<p>2) 若是块级元素, 该元素设置 margin:0 auto即可.</p>
<p>3) 若子元素包含 float:left 属性, 为了让子元素水平居中, 则可让父元素宽度设置为fit-content,并且配合margin, 作如下设置:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.parent</span><span class="rules">&#123;</span><br><span class="line">  	<span class="rule"><span class="attribute">width</span>:<span class="value"> -moz-fit-content</span></span>;</span><br><span class="line">	<span class="rule"><span class="attribute">width</span>:<span class="value"> -webkit-fit-content</span></span>;</span><br><span class="line">	<span class="rule"><span class="attribute">width</span>:<span class="value">fit-content</span></span>;</span><br><span class="line">	<span class="rule"><span class="attribute">margin</span>:<span class="value"><span class="number">0</span> auto</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>fit-content是CSS3中给width属性新加的一个属性值,它配合margin可以轻松实现水平居中, 目前只支持Chrome 和 Firefox浏览器.</p>
<p>4) 使用flex布局, 可以轻松的实现水平居中, 子元素设置如下:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.son</span><span class="rules">&#123;</span><br><span class="line">	<span class="rule"><span class="attribute">display</span>:<span class="value"> flex</span></span>;</span><br><span class="line">	<span class="rule"><span class="attribute">justify-content</span>:<span class="value"> center</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>5) 使用css3 盒模型, 父元素display: box;box-pack: center;如下设置:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.parent</span> <span class="rules">&#123;</span><br><span class="line">	<span class="rule"><span class="attribute">display</span>:<span class="value"> -webkit-box</span></span>;</span><br><span class="line">	<span class="rule"><span class="attribute">-webkit-box-orient</span>:<span class="value"> horizontal</span></span>;</span><br><span class="line">	<span class="rule"><span class="attribute">-webkit-box-pack</span>:<span class="value"> center</span></span>;</span><br><span class="line">	<span class="rule"><span class="attribute">display</span>:<span class="value"> -moz-box</span></span>;</span><br><span class="line">	<span class="rule"><span class="attribute">-moz-box-orient</span>:<span class="value"> horizontal</span></span>;</span><br><span class="line">	<span class="rule"><span class="attribute">-moz-box-pack</span>:<span class="value"> center</span></span>;</span><br><span class="line">	<span class="rule"><span class="attribute">display</span>:<span class="value"> -o-box</span></span>;</span><br><span class="line">  	<span class="rule"><span class="attribute">-o-box-orient</span>:<span class="value"> horizontal</span></span>;</span><br><span class="line">  	<span class="rule"><span class="attribute">-o-box-pack</span>:<span class="value"> center</span></span>;</span><br><span class="line">  	<span class="rule"><span class="attribute">display</span>:<span class="value"> -ms-box</span></span>;</span><br><span class="line">  	<span class="rule"><span class="attribute">-ms-box-orient</span>:<span class="value"> horizontal</span></span>;</span><br><span class="line">  	<span class="rule"><span class="attribute">-ms-box-pack</span>:<span class="value"> center</span></span>;</span><br><span class="line">  	<span class="rule"><span class="attribute">display</span>:<span class="value"> box</span></span>;</span><br><span class="line">  	<span class="rule"><span class="attribute">box-orient</span>:<span class="value"> horizontal</span></span>;</span><br><span class="line">  	<span class="rule"><span class="attribute">box-pack</span>:<span class="value"> center</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>6) 使用CSS3中新增的transform属性, 子元素设置如下:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.son</span><span class="rules">&#123;</span><br><span class="line">	<span class="rule"><span class="attribute">position</span>:<span class="value">absolute</span></span>;</span><br><span class="line">  	<span class="rule"><span class="attribute">left</span>:<span class="value"><span class="number">50%</span></span></span>;</span><br><span class="line">  	<span class="rule"><span class="attribute">transform</span>:<span class="value"><span class="function">translate</span>(-<span class="number">50%</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>7) 使用绝对定位方式, 以及负值的margin-left, 子元素设置如下:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.son</span><span class="rules">&#123;</span><br><span class="line">	<span class="rule"><span class="attribute">position</span>:<span class="value">absolute</span></span>;</span><br><span class="line">	<span class="rule"><span class="attribute">width</span>:<span class="value">固定</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">left</span>:<span class="value"><span class="number">50%</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">margin-left</span>:<span class="value">-<span class="number">0.5</span>宽度</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>8) 使用绝对定位方式, 以及left:0;right:0;margin:0 auto; 子元素设置如下:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.son</span><span class="rules">&#123;</span><br><span class="line">	<span class="rule"><span class="attribute">position</span>:<span class="value">absolute</span></span>;</span><br><span class="line">	<span class="rule"><span class="attribute">width</span>:<span class="value">固定</span></span>;</span><br><span class="line">	<span class="rule"><span class="attribute">left</span>:<span class="value"><span class="number">0</span></span></span>;</span><br><span class="line">	<span class="rule"><span class="attribute">right</span>:<span class="value"><span class="number">0</span></span></span>;</span><br><span class="line">	<span class="rule"><span class="attribute">margin</span>:<span class="value"><span class="number">0</span> auto</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="u5782_u76F4_u5C45_u4E2D"><a href="#u5782_u76F4_u5C45_u4E2D" class="headerlink" title="垂直居中"></a>垂直居中</h3><h4 id="u5355_u884C_u6587_u672C"><a href="#u5355_u884C_u6587_u672C" class="headerlink" title="单行文本"></a>单行文本</h4><p>1) 若元素是单行文本, 则可设置 line-height 等于父元素高度</p>
<h4 id="u884C_u5185_u5757_u7EA7_u5143_u7D20"><a href="#u884C_u5185_u5757_u7EA7_u5143_u7D20" class="headerlink" title="行内块级元素"></a>行内块级元素</h4><p>2) 若元素是行内块级元素, 基本思想是使用display: inline-block, vertical-align: middle和一个伪元素让内容块处于容器中央.</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.parent</span><span class="pseudo">::after</span>, <span class="class">.son</span><span class="rules">&#123;</span><br><span class="line">	<span class="rule"><span class="attribute">display</span>:<span class="value">inline-block</span></span>;</span><br><span class="line">	<span class="rule"><span class="attribute">vertical-align</span>:<span class="value">middle</span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"><span class="class">.parent</span><span class="pseudo">::after</span><span class="rules">&#123;</span><br><span class="line">	<span class="rule"><span class="attribute">content</span>:<span class="value"><span class="string">''</span></span></span>;</span><br><span class="line">	<span class="rule"><span class="attribute">height</span>:<span class="value"><span class="number">100%</span></span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>这是一种很流行的方法, 也适应IE7.</p>
<h4 id="u5143_u7D20_u9AD8_u5EA6_u4E0D_u5B9A"><a href="#u5143_u7D20_u9AD8_u5EA6_u4E0D_u5B9A" class="headerlink" title="元素高度不定"></a>元素高度不定</h4><p>3) 可用 <strong>vertical-align</strong> 属性, 而vertical-align只有在父层为 td 或者 th 时, 才会生效, 对于其他块级元素, 例如 div、p 等, 默认情况是不支持的. 为了使用vertical-align, 我们需要设置父元素display:table, 子元素 display:table-cell;vertical-align:middle;</p>
<p><strong>优点</strong></p>
<p>元素高度可以动态改变, 不需再CSS中定义, 如果父元素没有足够空间时, 该元素内容也不会被截断.</p>
<p><strong>缺点</strong></p>
<p>IE6~7, 甚至IE8 beta中无效.</p>
<p>4) 可用 <strong>Flex</strong>, 这是CSS布局未来的趋势. Flexbox是CSS3新增属性, 设计初衷是为了解决像垂直居中这样的常见布局问题. 相关的文章如《<a href="http://coding.smashingmagazine.com/2013/05/22/centering-elements-with-flexbox/" target="_blank" rel="external">Centering Elements with Flexbox</a>》</p>
<p>父元素做如下设置即可保证子元素垂直居中:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.parent</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">display</span>:<span class="value"> flex</span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">align-items</span>:<span class="value"> center</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>优点</strong></p>
<ul>
<li>内容块的宽高任意, 优雅的溢出.</li>
</ul>
<ul>
<li>可用于更复杂高级的布局技术中.</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>IE8/IE9不支持</li>
<li>需要浏览器厂商前缀</li>
<li>渲染上可能会有一些问题</li>
</ul>
<p>5) 使用CSS3盒模型</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.parent</span> <span class="rules">&#123;</span><br><span class="line">  	<span class="rule"><span class="attribute">display</span>:<span class="value"> box</span></span>;</span><br><span class="line">  	<span class="rule"><span class="attribute">box-orient</span>:<span class="value"> vertical</span></span>;</span><br><span class="line">  	<span class="rule"><span class="attribute">box-pack</span>:<span class="value"> center</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>优点</strong></p>
<p>实现简单, 扩展性强</p>
<p><strong>缺点</strong></p>
<p>兼容性差, 不支持IE</p>
<p>6) 可用 <strong>transform</strong> , 设置父元素相对定位(position:relative), 子元素如下css样式:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.son</span><span class="rules">&#123;</span><br><span class="line">	<span class="rule"><span class="attribute">position</span>:<span class="value">absolute</span></span>;</span><br><span class="line">	<span class="rule"><span class="attribute">top</span>:<span class="value"><span class="number">50%</span></span></span>;</span><br><span class="line">	<span class="rule"><span class="attribute">-webkit-transform</span>:<span class="value"> <span class="function">translate</span>(-<span class="number">50%</span>,-<span class="number">50%</span>)</span></span>;  </span><br><span class="line">	<span class="rule"><span class="attribute">-ms-transform</span>:<span class="value"> <span class="function">translate</span>(-<span class="number">50%</span>,-<span class="number">50%</span>)</span></span>;</span><br><span class="line">	<span class="rule"><span class="attribute">transform</span>:<span class="value"> <span class="function">translate</span>(-<span class="number">50%</span>,-<span class="number">50%</span>)</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>优点</strong></p>
<p>代码量少</p>
<p><strong>缺点</strong></p>
<p>IE8不支持, 属性需要追加浏览器厂商前缀, 可能干扰其他 transform 效果, 某些情形下会出现文本或元素边界渲染模糊的现象.</p>
<h4 id="u5143_u7D20_u9AD8_u5EA6_u56FA_u5B9A"><a href="#u5143_u7D20_u9AD8_u5EA6_u56FA_u5B9A" class="headerlink" title="元素高度固定"></a>元素高度固定</h4><p>7) 设置父元素相对定位(position:relative), 子元素如下css样式:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.son</span><span class="rules">&#123;</span><br><span class="line">	<span class="rule"><span class="attribute">position</span>:<span class="value">absolute</span></span>;</span><br><span class="line">	<span class="rule"><span class="attribute">top</span>:<span class="value"><span class="number">50%</span></span></span>;</span><br><span class="line">	<span class="rule"><span class="attribute">height</span>:<span class="value">固定</span></span>;</span><br><span class="line">	<span class="rule"><span class="attribute">margin-top</span>:<span class="value">-<span class="number">0.5</span>高度</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>优点</strong></p>
<p>适用于所有浏览器.</p>
<p><strong>缺点</strong></p>
<p>父元素空间不够时, 子元素可能不可见(当浏览器窗口缩小时,滚动条不出现时).如果子元素设置了overflow:auto, 则高度不够时, 会出现滚动条.</p>
<p>8) 设置父元素相对定位(position:relative), 子元素如下css样式:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.son</span><span class="rules">&#123;</span><br><span class="line">	<span class="rule"><span class="attribute">position</span>:<span class="value">absolute</span></span>;</span><br><span class="line">	<span class="rule"><span class="attribute">height</span>:<span class="value">固定</span></span>;</span><br><span class="line">	<span class="rule"><span class="attribute">top</span>:<span class="value"><span class="number">0</span></span></span>;</span><br><span class="line">	<span class="rule"><span class="attribute">bottom</span>:<span class="value"><span class="number">0</span></span></span>;</span><br><span class="line">	<span class="rule"><span class="attribute">margin</span>:<span class="value">auto <span class="number">0</span></span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>优点</strong></p>
<p>简单</p>
<p><strong>缺点</strong></p>
<p>没有足够空间时, 子元素会被截断, 但不会有滚动条.</p>
<h3 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h3><p>水平居中较为简单, 共提供了8种方法, 一般情况下 text-align:center,marin:0 auto; 足矣</p>
<ul>
<li>① text-align:center;</li>
</ul>
<ul>
<li>② margin:0 auto;</li>
<li>③ width:fit-content;</li>
<li>④ flex</li>
<li>⑤ 盒模型</li>
<li>⑥ transform</li>
<li>⑦ ⑧ 两种不同的绝对定位方法</li>
</ul>
<p>垂直居中, 共提供了8种方法.</p>
<ul>
<li>① 单行文本, line-height</li>
<li>② 行内块级元素, 使用 display: inline-block, vertical-align: middle; 加上伪元素辅助实现</li>
<li>③ vertical-align</li>
<li>④ flex</li>
<li>⑤ 盒模型</li>
<li>⑥ transform</li>
<li>⑦ ⑧ 两种不同的绝对定位方法</li>
</ul>
<p>我们发现, flex, 盒模型, transform, 绝对定位, 这几种方法同时适用于水平居中和垂直居中.</p>
<p>希望对大家有所帮助.</p>
<hr>
<p>本问就讨论这么多内容,大家有什么问题或好的想法欢迎在下方参与<a href="#respond">留言和评论</a>.</p>
<p>本文作者: <a href="https://github.com/Louiszhai" target="_blank" rel="external">louis</a></p>
<p>本文链接: <a href="http://louiszhai.github.io/2016/03/12/css-center/">http://louiszhai.github.io/2016/03/12/css-center/</a></p>
<p>参考文章</p>
<ul>
<li><a href="http://blog.csdn.net/freshlover/article/details/11579669" target="_blank" rel="external">盘点8种CSS实现垂直居中水平居中的绝对定位居中技术 - freshlover的专栏 - 博客频道 - CSDN.NET</a></li>
<li><a href="https://www.smashingmagazine.com/2013/05/centering-elements-with-flexbox/" target="_blank" rel="external">Designing CSS Layouts With Flexbox Is As Easy As Pie – Smashing Magazine</a></li>
<li><a href="http://www.w3cplus.com/css/elements-horizontally-center-with-css.html" target="_blank" rel="external">六种实现元素水平居中<em>水平居中, 垂直居中 教程\</em>大漠</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[css 水平居中 垂直居中]]>
    
    </summary>
    
      <category term="CSS" scheme="http://louiszhai.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[float深入分析]]></title>
    <link href="http://louiszhai.github.io/2016/03/12/css-float/"/>
    <id>http://louiszhai.github.io/2016/03/12/css-float/</id>
    <published>2016-03-12T09:55:04.000Z</published>
    <updated>2016-04-27T01:26:58.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u5BFC_u8BFB"><a href="#u5BFC_u8BFB" class="headerlink" title="导读"></a>导读</h3><p>float即浮动, 使用float, 该浮动元素便会脱离正常的文档流, 使其浮动到父元素的行的一端(元素向左或向右移动, 直到碰到浮动元素, 或者达到父元素内容的边界, 不包括padding), 并且其他元素将忽略该浮动元素并填补其原先的空间.</p>
<p>这里需要捋清一个概念, 所谓文档流是什么?</p>
<p><strong>文档流</strong>: 元素按照自上到下, 自左到右的顺序依次排放, 即文档流.</p>
<p>float特别适合这种图文混排, 文字环绕图片的效果, 布局上灵活多变. 但不太适合动画, 因其可能造成reflow性能问题, 此时宜用绝对定位(position:absolute)或者固定定位(position:fixed).</p>
<a id="more"></a>
<h3 id="float_u5BF9_u5E03_u5C40_u7684_u5F71_u54CD"><a href="#float_u5BF9_u5E03_u5C40_u7684_u5F71_u54CD" class="headerlink" title="float对布局的影响"></a>float对布局的影响</h3><h4 id="u5BF9_u884C_u6846_u7684_u5F71_u54CD"><a href="#u5BF9_u884C_u6846_u7684_u5F71_u54CD" class="headerlink" title="对行框的影响"></a>对行框的影响</h4><p>浮动元素旁边的行框被缩短, 从而给浮动框留出空间, 行框围绕浮动框.</p>
<p>因此, 创建浮动框可以使文本围绕图像, 如下:</p>
<p>float01.gif</p>
<p>float02.gif</p>
<h4 id="u5BF9_u7236_u5143_u7D20_u7684_u5F71_u54CD"><a href="#u5BF9_u7236_u5143_u7D20_u7684_u5F71_u54CD" class="headerlink" title="对父元素的影响"></a>对父元素的影响</h4><p>元素浮动后, 会脱离正常文档流, 原文档中, 该浮动元素似乎消失了, 因此它不能撑开父元素, 容易造成父元素的塌陷.</p>
<h4 id="u5BF9_u5144_u5F1F_u5143_u7D20_u7684_u5F71_u54CD"><a href="#u5BF9_u5144_u5F1F_u5143_u7D20_u7684_u5F71_u54CD" class="headerlink" title="对兄弟元素的影响"></a>对兄弟元素的影响</h4><p>若兄弟元素是 <strong>块级元素</strong>.</p>
<p>现代浏览器及IE8+下, 该兄弟元素会忽视浮动元素而占据它的位置, 并且该兄弟元素会处于浮动元素的下层(并且无法通过z-index属性改变他们的层叠关系), 然而它的内容文字和其他行内元将会环绕浮动元素.</p>
<p>对此, IE6,7分别有不同的表现. IE6,7中, 该兄弟元素会紧跟在浮动元素的右侧, 并且IE6中会保留3px的空隙; IE7中则没有空隙.</p>
<p>若兄弟元素是 <strong>内联元素</strong></p>
<p>则内联元素将环绕浮动元素排列.</p>
<h4 id="u5BF9_u5144_u5F1F_u5143_u7D20_28_u6D6E_u52A8_29_u7684_u5F71_u54CD"><a href="#u5BF9_u5144_u5F1F_u5143_u7D20_28_u6D6E_u52A8_29_u7684_u5F71_u54CD" class="headerlink" title="对兄弟元素(浮动)的影响"></a>对兄弟元素(浮动)的影响</h4><p>若兄弟元素是 <strong>同一方向浮动</strong>.</p>
<p>则兄弟元素相对该浮动元素按照从左到右(float:left)或者从右到左(float:right)的顺序依次排列.</p>
<p>若兄弟元素是 <strong>反方向浮动</strong>.</p>
<p>则兄弟元素和浮动元素将组成两个向左或向右的浮动队列, 分别相对浮动方向同时向行中间浮动. 他们尽可能处于同一行, 如果行的宽度不足以容纳这两个队列, 两个队列将错开成两行, DOM结构中处于之前的浮动队列将优先排在上面一行, 另一个浮动队列将排在下一行或者部分排在下一行.</p>
<h4 id="u5BF9_u81EA_u8EAB_u5143_u7D20_u7684_u5F71_u54CD"><a href="#u5BF9_u81EA_u8EAB_u5143_u7D20_u7684_u5F71_u54CD" class="headerlink" title="对自身元素的影响"></a>对自身元素的影响</h4><p>浮动元素默认被视作<strong>块级对象</strong>(block-level).</p>
<h4 id="u5BF9_u5B50_u5143_u7D20_u7684_u5F71_u54CD"><a href="#u5BF9_u5B50_u5143_u7D20_u7684_u5F71_u54CD" class="headerlink" title="对子元素的影响"></a>对子元素的影响</h4><p>浮动元素, 其高度或宽度取浮动子元素和非浮动子元素高度或宽度的最大值.</p>
<h4 id="u5BF9_u7236_u5143_u7D20_u975E_u6D6E_u52A8_u5144_u5F1F_u5143_u7D20_u7684_u5F71_u54CD"><a href="#u5BF9_u7236_u5143_u7D20_u975E_u6D6E_u52A8_u5144_u5F1F_u5143_u7D20_u7684_u5F71_u54CD" class="headerlink" title="对父元素非浮动兄弟元素的影响"></a>对父元素非浮动兄弟元素的影响</h4><p>父元素之外的非浮动元素将会无视该浮动元素, 他们只会相对父元素按照正常文档流去排列.</p>
<h4 id="u5BF9_u7236_u5143_u7D20_u6D6E_u52A8_u5144_u5F1F_u5143_u7D20_u7684_u5F71_u54CD"><a href="#u5BF9_u7236_u5143_u7D20_u6D6E_u52A8_u5144_u5F1F_u5143_u7D20_u7684_u5F71_u54CD" class="headerlink" title="对父元素浮动兄弟元素的影响"></a>对父元素浮动兄弟元素的影响</h4><p>父元素之外的浮动兄弟元素, 会本能的找到该浮动元素, 现象参照 “对兄弟元素(浮动)的影响”.</p>
<h3 id="u6E05_u9664_u6D6E_u52A8_u76842_u79CD_u65B9_u6CD5"><a href="#u6E05_u9664_u6D6E_u52A8_u76842_u79CD_u65B9_u6CD5" class="headerlink" title="清除浮动的2种方法"></a>清除浮动的2种方法</h3><p>如上, float会带来父元素的塌陷, 下面提供两种解决方案, 以弥补float的缺陷.</p>
<p>如下DOM, 由于子元素设置为float:left, 此时父元素并不会被撑大, 高度为0, 背景将无法展示.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">style</span>&gt;</span><span class="css"></span><br><span class="line">	<span class="class">.outer</span><span class="rules">&#123;</span><br><span class="line">		<span class="rule"><span class="attribute">background</span>:<span class="value"><span class="hexcolor">#ccc</span></span></span>;</span><br><span class="line">	&#125;</span></span><br><span class="line">	<span class="class">.inner</span><span class="rules">&#123;</span><br><span class="line">		<span class="rule"><span class="attribute">float</span>:<span class="value">left</span></span>;</span><br><span class="line">		<span class="rule"><span class="attribute">width</span>:<span class="value"><span class="number">150px</span></span></span>;</span><br><span class="line">		<span class="rule"><span class="attribute">height</span>:<span class="value"><span class="number">100px</span></span></span>;</span><br><span class="line">		<span class="rule"><span class="attribute">margin</span>:<span class="value"><span class="number">10px</span></span></span>;</span><br><span class="line">		<span class="rule"><span class="attribute">border</span>:<span class="value"><span class="number">1px</span> solid red</span></span>;</span><br><span class="line">	&#125;</span></span><br><span class="line"></span><span class="tag">&lt;/<span class="title">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"outer"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"inner"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"inner"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"inner"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>IE6~7下可通过设置父元素的样式为zoom:1来清除浮动, 其他浏览器请参考如下两种方法清除浮动.</p>
<h4 id="overflow"><a href="#overflow" class="headerlink" title="overflow"></a>overflow</h4><p>父元素使用overflow:auto|hidden, 切记不可使用overflow:visible.</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.outer</span><span class="rules">&#123;</span><br><span class="line">	<span class="rule"><span class="attribute">overflow</span>:<span class="value">auto|hidden</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="after_u4F2A_u7C7B"><a href="#after_u4F2A_u7C7B" class="headerlink" title="after伪类"></a>after伪类</h4><p>利用clear:both属性, 同时为避免加入dom元素, 使用after伪元素设置如下属性即可:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.outer</span><span class="pseudo">::after</span><span class="rules">&#123;</span><br><span class="line">	<span class="rule"><span class="attribute">content</span>:<span class="value"><span class="string">''</span></span></span>;</span><br><span class="line">	<span class="rule"><span class="attribute">display</span>:<span class="value">block</span></span>;</span><br><span class="line">	<span class="rule"><span class="attribute">clear</span>:<span class="value">both</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<hr>
<p>本文就讨论这么多内容,大家有什么问题或好的想法欢迎在下方参与<a href="#respond">留言和评论</a>.</p>
<p>本文作者: <a href="https://github.com/Louiszhai" target="_blank" rel="external">louis</a></p>
<p>本文链接: <a href="http://louiszhai.github.io/2016/03/12/css-float/">http://louiszhai.github.io/2016/03/12/css-float/</a></p>
<p>参考文章</p>
<ul>
<li><a href="http://www.w3cplus.com/css/float.html" target="_blank" rel="external">float深入剖析_float 教程_w3cplus</a></li>
<li><a href="http://www.wuwenyuan.com/1079.html" target="_blank" rel="external">网站CSS布局：float布局与position优势对比 | 网络营销技巧</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[css float clear:both overflow:auto 文档流]]>
    
    </summary>
    
      <category term="CSS" scheme="http://louiszhai.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[xss攻防]]></title>
    <link href="http://louiszhai.github.io/2016/03/05/xss/"/>
    <id>http://louiszhai.github.io/2016/03/05/xss/</id>
    <published>2016-03-05T01:48:09.000Z</published>
    <updated>2016-04-27T01:26:33.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u5BFC_u8BFB"><a href="#u5BFC_u8BFB" class="headerlink" title="导读"></a>导读</h3><p><strong>XSS</strong> (Cross-Site Script) 攻击又叫跨站脚本攻击, 本质是一种注入攻击. 其原理, 简单的说就是利用各种手段把恶意代码添加到网页中, 并让受害者执行这段脚本. XSS能做用户使用浏览器能做的一切事情. 同源策略无法保证不受XSS攻击，因为此时攻击者就在同源之内.</p>
<a id="more"></a>
<h3 id="xss_u653B_u51FB_u65B9_u5F0F"><a href="#xss_u653B_u51FB_u65B9_u5F0F" class="headerlink" title="xss攻击方式"></a>xss攻击方式</h3><p>从攻击的方式可以分为</p>
<ul>
<li>反射型</li>
<li>存储型</li>
<li>文档型</li>
</ul>
<p>这种分类方式有些过时, 长久以来, 人们认为XSS分类有以上三种, 但实际情况中经常无法区分, 所以更明确的分类方式可以分为以下两类:</p>
<ul>
<li>client(客户端型)</li>
<li>server(服务端型)</li>
</ul>
<p>当一端xss代码是在服务端被插入的, 那么这就是服务端型xss, 同理, 如果代码在客户端插入, 就是客户端型xss.</p>
<h3 id="u9632_u6B62xss_u653B_u51FB"><a href="#u9632_u6B62xss_u653B_u51FB" class="headerlink" title="防止xss攻击"></a>防止xss攻击</h3><h4 id="u8F6C_u4E49"><a href="#u8F6C_u4E49" class="headerlink" title="转义"></a>转义</h4><p>无论是服务端型还是客户端型xss，攻击达成都需要两个条件</p>
<ul>
<li>代码被注入</li>
<li>代码被执行</li>
</ul>
<p>其实只要做好无论任何情况下保证代码不被执行就能完全杜绝xss攻击.</p>
<p>总之, 任何时候都不要把不受信任的数据直接插入到dom中的任何位置, 一定要做转义。</p>
<h5 id="u5BF9_u4E8E_u67D0_u4E9B_u4F4D_u7F6E_2C_u4E0D_u53D7_u4FE1_u4EFB_u7684_u6570_u636E_u505A_u8F6C_u4E49_u5C31_u53EF_u4EE5_u4FDD_u8BC1_u5B89_u5168"><a href="#u5BF9_u4E8E_u67D0_u4E9B_u4F4D_u7F6E_2C_u4E0D_u53D7_u4FE1_u4EFB_u7684_u6570_u636E_u505A_u8F6C_u4E49_u5C31_u53EF_u4EE5_u4FDD_u8BC1_u5B89_u5168" class="headerlink" title="对于某些位置,不受信任的数据做转义就可以保证安全"></a>对于某些位置,不受信任的数据做转义就可以保证安全</h5><ul>
<li>一般的标签属性值</li>
<li>div body 的内部html</li>
</ul>
<h5 id="u5BF9_u4E8E_u67D0_u4E9B_u4F4D_u7F6E_uFF0C_u5373_u4F7F_u505A_u4E86_u8F6C_u4E49_u4F9D_u7136_u4E0D_u5B89_u5168"><a href="#u5BF9_u4E8E_u67D0_u4E9B_u4F4D_u7F6E_uFF0C_u5373_u4F7F_u505A_u4E86_u8F6C_u4E49_u4F9D_u7136_u4E0D_u5B89_u5168" class="headerlink" title="对于某些位置，即使做了转义依然不安全"></a>对于某些位置，即使做了转义依然不安全</h5><ul>
<li><script>中</li>
<li>注释中</li>
<li>表签的属性名名</li>
<li>标签名</li>
<li>css标签中</li>
</ul>
<h5 id="u4F7F_u7528JSON-parse__u800C_u4E0D_u662Feval_2C_request__u7684content-type_u8981_u6307_u5B9A_u662FContent-Type_3A_application/json_3B"><a href="#u4F7F_u7528JSON-parse__u800C_u4E0D_u662Feval_2C_request__u7684content-type_u8981_u6307_u5B9A_u662FContent-Type_3A_application/json_3B" class="headerlink" title="使用JSON.parse 而不是eval, request 的content-type要指定是Content-Type: application/json;"></a>使用JSON.parse 而不是eval, request 的content-type要指定是Content-Type: application/json;</h5><h5 id="u5982_u679C_u94FE_u63A5_u7684URL_u4E2D_u90E8_u5206_u662F_u52A8_u6001_u751F_u6210_u7684_2C__u4E00_u5B9A_u8981_u505A_u8F6C_u4E49"><a href="#u5982_u679C_u94FE_u63A5_u7684URL_u4E2D_u90E8_u5206_u662F_u52A8_u6001_u751F_u6210_u7684_2C__u4E00_u5B9A_u8981_u505A_u8F6C_u4E49" class="headerlink" title="如果链接的URL中部分是动态生成的, 一定要做转义."></a>如果链接的URL中部分是动态生成的, 一定要做转义.</h5><h4 id="u4F7F_u7528_u6D4F_u89C8_u5668_u81EA_u5E26_u7684xss-filter"><a href="#u4F7F_u7528_u6D4F_u89C8_u5668_u81EA_u5E26_u7684xss-filter" class="headerlink" title="使用浏览器自带的xss-filter"></a>使用浏览器自带的xss-filter</h4><p>xss01.png</p>
<p>现代浏览器都对反射型xss有一定的防御力, 其原理是检查url和dom中元素的相关性. 但这并不能完全防止反射型xss. 另外, 浏览器对于存储型xss并没有抵抗力, 原因很简单, 用户的需求是多种多样的. 所以, 抵御xss这件事情不能指望浏览器.</p>
<blockquote>
<p>可以通过http头控制是否打开 xss-filter,当然默认是打开的.X-XSS-Protection</p>
</blockquote>
<h4 id="CSP_28Content_Security_Policy_29"><a href="#CSP_28Content_Security_Policy_29" class="headerlink" title="CSP(Content Security Policy)"></a>CSP(Content Security Policy)</h4><p>为了缓解很大一部分潜在的跨站脚本问题, 浏览器的扩展程序系统引入了内容安全策略(CSP). CSP 管理网站允许加载的内容, 并且使用白名单的机制对网站加载或执行的资源起作用. 在网页中, 这样的策略通过 HTTP 头信息或者 meta 元素定义.</p>
<p>CSP 并不是用来防止 xss 攻击的, 而是最小化 xss 发生后所造成的伤害. 实际上, 除了开发者自己做好 xss 转义, 并没有别的方法可以防止 xss 的发生. CSP 可以说是HTML5给web安全带来的最实惠的东西. 那么如何引入 CSP 呢?</p>
<p>xss02.png</p>
<p>通过response头</p>
<blockquote>
<p>只允许脚本从本源加载Content-Security-Policy: script-src ‘self’</p>
</blockquote>
<p>通过HTML的META标签</p>
<blockquote>
<p>作用同上&lt;meta http-equiv=”Content-Security-Policy” content=”script-src ‘self’”&gt;</p>
</blockquote>
<p>那么CSP 除了限制script-src 之外还能限制什么呢？</p>
<blockquote>
<p>base-uri : 限制这篇文档的uri  </p>
<p>child-src ：限制子窗口的源(iframe,弹窗等),取代frame-src  </p>
<p>connect-src ：限制脚本可以访问的源  </p>
<p>font-src : 限制字体的源  </p>
<p>form-action : 限制表单能够提交到的源  </p>
<p>frame-ancestors : 限制了当前页面可以被哪些页面以iframe,frame,object等方式加载  </p>
<p>frame-src ：deprecated with child-src,限制了当前页面可以加载哪些源，与frame-ancestors对应 </p>
<p>img-src : 限制图片可以从哪些源加载  </p>
<p>media-src : 限制video, audio, source, track 能够从哪些源加载  </p>
<p>object-src ：限制插件可以从哪些源加载  </p>
<p>sandbox ：强制打开沙盒模式</p>
</blockquote>
<p>可以看出, CSP是一个强大的策略, 几乎可以限制了所有能够用到的资源的来源. 使用好CSP可以很大成都降低XSS带来的风险.</p>
<p>另外，CSP还提供一个报告的头 Content-Security-Policy-Report-Only，使用这个头浏览器向服务器报告csp状态，细节先不讨论。</p>
<ul>
<li>Content-Security-Policy-Report-Only: script-src ‘self’;  </li>
<li>report-uri /csp-report-endpoint/</li>
</ul>
<p>CSP 目前有两版，CSP1 和CSP2， 两版的支持状态可以在</p>
<p><a href="http://caniuse.com/#search=csp">http://caniuse.com/#search=csp</a> 中查到.</p>
<h5 id="CSP1"><a href="#CSP1" class="headerlink" title="CSP1"></a>CSP1</h5><p>xss03-csp1.png</p>
<h5 id="CSP2"><a href="#CSP2" class="headerlink" title="CSP2"></a>CSP2</h5><p>xss03-csp2.png</p>
<p>CSP虽然提供了强大的安全保护, 但是他也造成了如下问题: Eval及相关函数被禁用、内嵌的JavaScript代码将不会执行、只能通过白名单来加载远程脚本.</p>
<h4 id="X-Frame-Options"><a href="#X-Frame-Options" class="headerlink" title="X-Frame-Options"></a>X-Frame-Options</h4><p>X-Frame-Options <a href="https://developer.mozilla.org/en/HTTP">HTTP</a> 响应头是用来给浏览器指示允许一个页面可否在 <frame>, <iframe> 或者 <object> 中展现的标记. 网站可以使用此功能, 来确保自己网站的内容没有被嵌到别人的网站中去, 也从而避免了点击劫持 (clickjacking) 的攻击. 但以后可以被CSP的 frame-ancestors取代。目前支持的状态比起 CSP frame-ancestors要好.</p>
<p>X-Frame-Options 共有三个值</p>
<ul>
<li>DENY 表示这个页面不允许被以frame的方式加载 </li>
<li>SAMEORIGIN 表示这个页面只允许被同源页面加载</li>
<li>ALLOW-FROM uri 表示这个页面只能被特定的域加载</li>
</ul>
<p>服务器配置</p>
<p><strong>java代码:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.addHeader(<span class="string">"x-frame-options"</span>,<span class="string">"SAMEORIGIN"</span>);</span><br></pre></td></tr></table></figure>
<p><strong>Nginx配置:</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addheader X-Frame-Options SAMEORIGIN</span><br></pre></td></tr></table></figure>
<p><strong>Apache配置:</strong></p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword"><span class="common">Header</span></span> always append X-Frame-Options SAMEORIGIN</span><br></pre></td></tr></table></figure>
<h5 id="u6D4F_u89C8_u5668_u517C_u5BB9_u6027"><a href="#u6D4F_u89C8_u5668_u517C_u5BB9_u6027" class="headerlink" title="浏览器兼容性"></a>浏览器兼容性</h5><table>
<thead>
<tr>
<th>特性</th>
<th>Chrome</th>
<th>Firefox (Gecko)</th>
<th>Internet Explorer</th>
<th>Opera</th>
<th>Safari</th>
</tr>
</thead>
<tbody>
<tr>
<td>基础支持</td>
<td>4.1.249.1042</td>
<td><a href="https://developer.mozilla.org/en-US/Firefox/Releases/NaN">3.6.9</a> (1.9.2.9)</td>
<td>8.0</td>
<td>10.5</td>
<td>4.0</td>
</tr>
<tr>
<td>ALLOW-FROM 支持</td>
<td>Not supported</td>
<td><a href="https://developer.mozilla.org/en-US/Firefox/Releases/18">18.0</a></td>
<td>8.0?</td>
<td>?</td>
<td>Not supported</td>
</tr>
</tbody>
</table>
<h4 id="Http-Only"><a href="#Http-Only" class="headerlink" title="Http-Only"></a>Http-Only</h4><p>使用 http-only 保护cookie, 可以保证即使发生了xss,用户的cookie也是安全的.使用http-only 保护的cookie是不会被javascript读写的.</p>
<h4 id="iframe__u6C99_u7BB1_u73AF_u5883"><a href="#iframe__u6C99_u7BB1_u73AF_u5883" class="headerlink" title="iframe 沙箱环境"></a>iframe 沙箱环境</h4><p>HTML5为iframe提供了安全属性 sandbox, 进而限制iframe的能力. 如下:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">iframe</span> <span class="attribute">src</span>=<span class="value">"untrusted.html"</span> <span class="attribute">sandbox</span>=<span class="value">"allow-scripts allow-forms"</span>&gt;</span><span class="tag">&lt;/<span class="title">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="u5176_u4ED6_u5B89_u5168_u76F8_u5173_u7684HTTP_u5934"><a href="#u5176_u4ED6_u5B89_u5168_u76F8_u5173_u7684HTTP_u5934" class="headerlink" title="其他安全相关的HTTP头"></a>其他安全相关的HTTP头</h4><h5 id="X-Content-Type-Options"><a href="#X-Content-Type-Options" class="headerlink" title="X-Content-Type-Options"></a>X-Content-Type-Options</h5><p>X-Content-Type-Options 阻止浏览器进行content-type 嗅探, 能够防止类型嗅探攻击.</p>
<p>这个header主要用来防止在IE9、chrome和safari中的MIME类型混淆攻击. 通常浏览器可以通过嗅探内容本身的方法来决定它是什么类型, 而不是看响应中的content-type值. 通过设置 X-Content-Type-Options：如果content-type和期望的类型匹配，则不需要嗅探，只能从外部加载确定类型的资源. 举个例子, 如果加载了一个样式表, 那么资源的MIME类型只能是text/css, 对于IE中的脚本资源, 以下的内容类型是有效的:</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">application</span>/ecmascript  </span><br><span class="line"><span class="type">application</span>/javascript  </span><br><span class="line"><span class="type">application</span>/x-javascript  </span><br><span class="line"><span class="type">text</span>/ecmascript  </span><br><span class="line"><span class="type">text</span>/javascript  </span><br><span class="line"><span class="type">text</span>/jscript  </span><br><span class="line"><span class="type">text</span>/x-javascript  </span><br><span class="line"><span class="type">text</span>/vbs  </span><br><span class="line"><span class="type">text</span>/vbscript</span><br></pre></td></tr></table></figure>
<p>对于chrome, 则支持下面的MIME 类型:</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">text</span>/javascript  </span><br><span class="line"><span class="type">text</span>/ecmascript  </span><br><span class="line"><span class="type">application</span>/javascript  </span><br><span class="line"><span class="type">application</span>/ecmascript  </span><br><span class="line"><span class="type">application</span>/x-javascript  </span><br><span class="line"><span class="type">text</span>/javascript1<span class="number">.1</span>  </span><br><span class="line"><span class="type">text</span>/javascript1<span class="number">.2</span>  </span><br><span class="line"><span class="type">text</span>/javascript1<span class="number">.3</span>  </span><br><span class="line"><span class="type">text</span>/jscript  </span><br><span class="line"><span class="type">text</span>/live <span class="keyword">script</span></span><br></pre></td></tr></table></figure>
<p><strong>正确的设置</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nosniff &#8211; &#36825;&#20010;&#26159;&#21807;&#19968;&#27491;&#30830;&#30340;&#35774;&#32622;.</span><br></pre></td></tr></table></figure>
<p>通常不正确的设置</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#8216;nosniff&#8217; &#8211; &#24341;&#21495;&#26159;&#19981;&#20801;&#35768;&#30340;&#10;: nosniff &#8211; &#20882;&#21495;&#20063;&#26159;&#38169;&#35823;&#30340;</span><br></pre></td></tr></table></figure>
<p><strong>如何检测</strong></p>
<p>在IE和chrome中打开开发者工具，在控制台中观察配置了nosniff和没有配置nosniff的输出有啥区别.</p>
<h5 id="HPKP_28Public_Key_Pinning_29"><a href="#HPKP_28Public_Key_Pinning_29" class="headerlink" title="HPKP(Public Key Pinning)"></a>HPKP(Public Key Pinning)</h5><p>HPKP 是一个response 头, 用来检测一个证书的公钥是否发生了改变, 防止中间人攻击.</p>
<p>我们知道, 受信任的 CA（证书颁发机构）有好几百个, 他们成为整个网站身份认证过程中一个较大的攻击面. 现有的证书信任链机制最大的问题是, 任何一家受信任的 CA 都可以签发任意网站的站点证书, 这些证书在浏览器看来, 都是合法的.</p>
<p>HPKP 技术给予我们主动选择信任 CA 的权利. 它的工作原理是通过响应头或者 <meta> 标签告诉浏览器当前网站的证书指纹, 以及过期时间等其它信息. 未来一段时间内, 浏览器再次访问这个网站必须验证证书链中的证书指纹, 如果跟之前指定的值不匹配, 即便证书本身是合法的, 也必须断开连接.</p>
<p>HPKP 官方文档见 <a href="https://tools.ietf.org/html/rfc7469">RFC7469</a> , 目前 Firefox 35+ 和 Chrome 38+ 已经支持. 它的基本格式如下:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Public-Key-Pins: pin-sha256=&#34;base64==&#34;; max-age=expireTime [; includeSubdomains][; report-uri=&#34;reportURI&#34;]</span><br></pre></td></tr></table></figure>
<h5 id="HSTS__28HTTP_Strict-Transport-Security_29"><a href="#HSTS__28HTTP_Strict-Transport-Security_29" class="headerlink" title="HSTS (HTTP Strict-Transport-Security)"></a>HSTS (HTTP Strict-Transport-Security)</h5><p>HSTS 是国际互联网工程组织IETE正在推行一种新的Web安全协议, 可以用来抵御中间人攻击, 它强制浏览器使用TSL作为数据通道, 即强制使用HTTPS与服务器创建连接.</p>
<p>服务器开启HSTS的方法是, 当客户端通过HTTPS发出请求时, 在服务器返回的超文本传输协议响应头中包含Strict-Transport-Security字段. 非加密传输时设置的HSTS字段无效.</p>
<p>比如, <a href="https://xxx">https://xxx</a> 的响应头含有Strict-Transport-Security: max-age=31536000; includeSubDomains. 这意味着两点:</p>
<p>在接下来的一年（即31536000秒）中, 浏览器只要向xxx或其子域名发送HTTP请求时, 必须采用HTTPS来发起连接. 比如, 用户点击超链接或在地址栏输入 <a href="http://xxx/">http://xxx/</a> , 浏览器应当自动将 http 转写成 https, 然后直接向 <a href="https://xxx/">https://xxx/</a> 发送请求.</p>
<p>在接下来的一年中, 如果 xxx 服务器发送的TLS证书无效, 用户不能忽略浏览器警告继续访问网站.</p>
<p>不足就是, 用户首次访问网址是不受HSTS保护的, 这是因为首次还未收到HSTS. 解决方案有两个, 一是浏览器预置 HSTS域名列表, Google Chrome、Firefox 和 Internet Explorer 实现了这一方案. 二是将HSTS信息加入到域名系统记录中.</p>
<h3 id="u524D_u7AEFxss_u8FC7_u6EE4"><a href="#u524D_u7AEFxss_u8FC7_u6EE4" class="headerlink" title="前端xss过滤"></a>前端xss过滤</h3><p>最后提供一种前端xss过滤的方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">xssCheck</span>(<span class="params">str,reg</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> str ? str.replace(reg || <span class="regexp">/[&amp;&lt;"&gt;'](?:		(amp|lt|quot|gt|#39|nbsp|#\d+);)?/g</span>, <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(b)&#123;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="string">'&lt;'</span>:<span class="string">'&amp;lt;'</span>,</span><br><span class="line">                <span class="string">'&amp;'</span>:<span class="string">'&amp;amp;'</span>,</span><br><span class="line">                <span class="string">'"'</span>:<span class="string">'&amp;quot;'</span>,</span><br><span class="line">                <span class="string">'&gt;'</span>:<span class="string">'&amp;gt;'</span>,</span><br><span class="line">                <span class="string">"'"</span>:<span class="string">'&amp;#39;'</span>,</span><br><span class="line">            &#125;[a]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;) : <span class="string">''</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>本文就讨论这么多内容,大家有什么问题或好的想法欢迎在下方参与<a href="#respond">留言和评论</a>.</p>
<p>本文作者: <a href="https://github.com/Louiszhai">louis</a></p>
<p>本文链接: <a href="http://louiszhai.github.io/2016/03/05/xss/">http://louiszhai.github.io/2016/03/05/xss/</a></p>
<p>参考文章</p>
<ul>
<li><a href="http://drops.wooyun.org/web/13009?hmsr=toutiao.io&amp;utmmedium=toutiao.io&amp;utmsource=toutiao.io">前端防御XSS | WooYun知识库</a></li>
<li><a href="http://www.freebuf.com/articles/web/61268.html">XSS攻击冷门花样玩法总结 - FreeBuf.COM | 关注黑客与极客</a></li>
<li>[关于Web安全，99%的网站都忽略了这些][5]</li>
<li><a href="http://www.tuicool.com/articles/jURNfy">HTTP Public Key Pinning 介绍 - 推酷</a></li>
</ul>
</script></li></ul>]]></content>
    <summary type="html">
    <![CDATA[xss]]>
    
    </summary>
    
      <category term="XSS" scheme="http://louiszhai.github.io/tags/XSS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[字符串常用方法]]></title>
    <link href="http://louiszhai.github.io/2016/01/12/js.String/"/>
    <id>http://louiszhai.github.io/2016/01/12/js.String/</id>
    <published>2016-01-12T12:27:09.000Z</published>
    <updated>2016-06-21T04:58:46.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u5BFC_u8BFB"><a href="#u5BFC_u8BFB" class="headerlink" title="导读"></a>导读</h3><p>javaScript 中, 字符串无处不在, 并且所有的字符串方法均来自 String.prototype, 这一节, 我们走进看一看String内部, 探讨那些常用或不常用的字符串操作方法.</p>
<a id="more"></a>
<h3 id="String-prototype"><a href="#String-prototype" class="headerlink" title="String.prototype"></a>String.prototype</h3><p>String.prototype 属性指向 String 的原型对象. 以下是它的属性特性:</p>
<table>
<thead>
<tr>
<th>writable</th>
<th>false</th>
</tr>
</thead>
<tbody>
<tr>
<td>enumerable</td>
<td>false</td>
</tr>
<tr>
<td>configurable</td>
<td>false</td>
</tr>
</tbody>
</table>
<p>所有的字符串实例都继承自 String.prototype. 因此任何 String.prototype 上的改变都会在字符串上体现出来.</p>
<h4 id="u5C5E_u6027"><a href="#u5C5E_u6027" class="headerlink" title="属性"></a>属性</h4><ul>
<li>String.prototype.constructor 指向构造器(String())</li>
<li>String.prototype.length 表示字符串长度</li>
</ul>
<h4 id="u65B9_u6CD5"><a href="#u65B9_u6CD5" class="headerlink" title="方法"></a>方法</h4><p>字符串方法分为两种, 一种是html无关的方法, 一种是html有关的方法. 我们先看第一种. 但是无论字符串方法如何厉害, 都不至于强大到可以改变原字符串.</p>
<h5 id="HTML_u65E0_u5173_u7684_u65B9_u6CD5"><a href="#HTML_u65E0_u5173_u7684_u65B9_u6CD5" class="headerlink" title="HTML无关的方法"></a>HTML无关的方法</h5><p>常用的方法有, charAt, charCodeAt, concat, indexOf, lastIndexOf, localeCompare, match, replace, search, slice, split, substr, substring, toLocaleLowerCase, toLocaleUpperCase, toLowerCase, toString, toUpperCase, trim, valueof 等ES5支持的, 以及 codePointAt, contains, endsWith, normalize, repeat, startsWith 等ES6支持的, 还包括 quote, toSource, trimLeft, trimRight 等非标准的.</p>
<p>接下来我们将对各个方法分别举例阐述其用法. 若没有特别说明, 该方法将兼容所有目前主流浏览器.</p>
<h6 id="charAt"><a href="#charAt" class="headerlink" title="charAt"></a>charAt</h6><p>charAt() 方法返回字符串中指定位置的字符。</p>
<p>语法: <em>str</em>.charAt(index)</p>
<p>index 为字符串索引(取值从0至length-1), 如果超出该范围, 则返回空串.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"Hello, World"</span>.charAt(<span class="number">8</span>));<span class="comment">//o, 返回下标为8的字符串o</span></span><br></pre></td></tr></table></figure>
<h6 id="charCodeAt"><a href="#charCodeAt" class="headerlink" title="charCodeAt"></a>charCodeAt</h6><p>charCodeAt() 返回指定索引处字符的 Unicode 数值.</p>
<p>语法: str.charCodeAt(index)</p>
<p>index 为一个从0至length-1的整数. 如果不是一个数值，则默认为 0, 如果小于0或者大于字符串长度, 则返回 NaN.</p>
<p>Unicode 编码单元（code points）的范围从 0 到 1,114,111。开头的 128 个 Unicode 编码单元和 ASCII 字符编码一样. </p>
<p>charCodeAt() 总是返回一个小于 65,536 的值. 因为高位编码单元需要由一对字符来表示, 为了查看其编码的完成字符, 需要查看 charCodeAt(i) 以及 charCodeAt(i+1) 的值. 如需更多了解请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/prototype" target="_blank" rel="external">fixedCharCodeAt</a>.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"Hello, World"</span>.charCodeAt(<span class="number">8</span>));<span class="comment">//111</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"前端工程师"</span>.charCodeAt(<span class="number">2</span>));<span class="comment">//24037, 可见也可以查看中文Unicode编码</span></span><br></pre></td></tr></table></figure>
<h6 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h6><p>concat() 方法将一个或多个字符串拼接在一起, 组成新的字符串并返回.</p>
<p>语法: <em>str</em>.concat(string2, string3, …)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"早"</span>.concat(<span class="string">"上"</span>,<span class="string">"好"</span>));<span class="comment">//早上好</span></span><br></pre></td></tr></table></figure>
<p>但是 concat 的性能表现不佳, 强烈推荐使用赋值操作符(+, +=) 代替 concat. “+” 操作符大概快了 concat 几十倍.(数据参考 <a href="http://jsperf.com/concat-vs-plus-vs-join" target="_blank" rel="external">性能测试</a>).</p>
<h6 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h6><h6 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf"></a>lastIndexOf</h6><p>indexOf() 方法用于查找子字符串在字符串中首次出现的位置. 没有则返回 -1. 该方法严格区分大小写, 并且从左往右查找. 而 lastIndexOf 则从右往左查找, 其它与前者一致.</p>
<p>语法: str.indexOf(searchValue [, fromIndex=0])</p>
<p>searchValue 表示被查找的字符串, fromIndex 表示开始查找的位置, 默认为0, 如果小于0, 则查找整个字符串, 若超过字符串长度, 则该方法返回-1, 除非被查找的是空字符串, 此时返回字符串长度.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">""</span>.indexOf(<span class="string">""</span>,<span class="number">100</span>));<span class="comment">//0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"IT改变世界"</span>.indexOf(<span class="string">"世界"</span>));<span class="comment">//4</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"IT改变世界"</span>.lastIndexOf(<span class="string">"世界"</span>));<span class="comment">//4</span></span><br></pre></td></tr></table></figure>
<h6 id="locateCompare"><a href="#locateCompare" class="headerlink" title="locateCompare"></a>locateCompare</h6><p>locateCompare() 方法用来比较字符串, 如果指定字符串在原字符串的前面则返回负数, 否则返回正数或0, 其中0 表示两个字符串相同. 该方法实现依赖具体的本地实现, 不同的语言下可能有不同的返回.</p>
<p>语法: <em>str</em>.localeCompare(str2 [, locales [, options]])</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"apple"</span>;</span><br><span class="line"><span class="keyword">var</span> str2 = <span class="string">"orange"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.localeCompare(str2));<span class="comment">//-1</span></span><br><span class="line"><span class="built_in">console</span>.log(str.localeCompare(<span class="string">"123"</span>));<span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<p>目前 Safari 浏览器暂不支持该方法. Chrome 24, Firefox 29, IE11, Opera 15 已实现了它.</p>
<h6 id="match"><a href="#match" class="headerlink" title="match"></a>match</h6><p>match() 方法用于测试字符串是否支持指定正则表达式的规则, 即使传入的是非正则表达式对象, 它也会隐式地使用 new RegExp(obj) 将其转换为正则表达式对象.</p>
<p>语法: <em>str</em>.match(regexp)</p>
<p>该方法返回包含匹配结果的数组, 如果没有匹配项, 则返回 null.</p>
<p><strong>描述</strong></p>
<ul>
<li>若正则表达式没有 g 标志, 则返回同 RegExp.exec(str) 相同的结果. 而且返回的数组拥有一个额外的 input 属性, 该属性包含原始字符串, 另外该数组还拥有一个 index 属性, 该属性表示匹配字符串在原字符串中索引(从0开始).</li>
<li>若正则表达式包含 g 标志, 则该方法返回一个包含所有匹配结果的数组, 没有匹配到则返回 null.</li>
</ul>
<p><strong>相关 RegExp 方法</strong></p>
<ul>
<li>若需测试字符串是否匹配正则, 请参考 RegExp.test(str).</li>
<li>若只需第一个匹配结果, 请参考 RegExp.exec(str).</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"World Internet Conference"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.match(<span class="regexp">/[a-d]/i</span>));<span class="comment">//["d", index: 4, input: "World Internet Conference"]</span></span><br><span class="line"><span class="built_in">console</span>.log(str.match(<span class="regexp">/[a-d]/gi</span>));<span class="comment">//["d", "C", "c"]</span></span><br><span class="line"><span class="comment">//RegExp 方法如下</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/[a-d]/gi</span>.test(str));<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/[a-d]/gi</span>.exec(str));<span class="comment">//["d", index: 4, input: "World Internet Conference"]</span></span><br></pre></td></tr></table></figure>
<p>由上可知, RegExp.test(str) 方法只要匹配到了一个字符也返回true. 而</p>
<p>RegExp.exec(str) 方法无论正则中有没有包含 g 标志, RegExp.exec将直接返回第一个匹配结果, 且该结果同 str.match(regexp) 方法不包含 g 标志时的返回一致.</p>
<h6 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h6><p>该方法在之前已经讲过, 详细请参考 <a href="http://louiszhai.github.io/2015/12/11/js.replace/"><code>String.prototype.replace高阶技能</code></a> .</p>
<h6 id="search"><a href="#search" class="headerlink" title="search"></a>search</h6><p>search() 方法用于测试字符串对象是否包含某个正则匹配. 相当于正则表达式的 test 方法. 且该方法比 match() 方法更快. 如果匹配成功, search() 返回正则表达式在字符串中首次匹配项的索引, 否则返回-1.</p>
<p>语法: <em>str</em>.search(regexp)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"abcdefg"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.search(<span class="regexp">/[d-g]/</span>));<span class="comment">//3, 匹配到子串"defg",而d在原字符串中的索引为3</span></span><br></pre></td></tr></table></figure>
<p>search() 方法不支持全局匹配(正则中包含g参数), 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(str.search(<span class="regexp">/[d-g]/g</span>));<span class="comment">//3, 与无g参数时,返回相同</span></span><br></pre></td></tr></table></figure>
<h6 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h6><p>slice() 方法提取字符串的一部分, 并返回新的字符串. 该方法有些类似Array.prototype.slice 方法.</p>
<p>语法: <em>str</em>.slice(start, end)</p>
<p>首先 end 参数可选, start可取正值, 也可取负值. </p>
<p>取正值时表示从索引为start的位置截取到end的位置(不包括end所在位置的字符, 如果end省略则截取到字符串末尾).</p>
<p>取负值时表示从索引为 length+start 位置截取到end所在位置的字符.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"It is our choices that show what we truly are, far more than our abilities."</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.slice(<span class="number">0</span>,-<span class="number">30</span>));<span class="comment">//It is our choices that show what we truly are</span></span><br><span class="line"><span class="built_in">console</span>.log(str.slice(-<span class="number">30</span>));<span class="comment">//, far more than our abilities.</span></span><br></pre></td></tr></table></figure>
<h6 id="split"><a href="#split" class="headerlink" title="split"></a>split</h6><p>split() 方法把原字符串分割成子字符串组成数组, 并返回该数组.</p>
<p>语法: <em>str</em>.split(separator, limit)</p>
<p>两个参数均是可选的, 其中 separator 表示分隔符, 它可以是字符串也可以是正则表达式. 如果忽略 separator, 则返回的数组包含一个由原字符串组成的元素. 如果 separator 是一个空串, 则 str 将会被分割成一个由原字符串中字符组成的数组. limit 表示从返回的数组中截取前 limit 个元素, 从而限定返回的数组长度.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"today is a sunny day"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.split());<span class="comment">//["today is a sunny day"]</span></span><br><span class="line"><span class="built_in">console</span>.log(str.split(<span class="string">""</span>));<span class="comment">//["t", "o", "d", "a", "y", " ", "i", "s", " ", "a", " ", "s", "u", "n", "n", "y", " ", "d", "a", "y"]</span></span><br><span class="line"><span class="built_in">console</span>.log(str.split(<span class="string">" "</span>));<span class="comment">//["today", "is", "a", "sunny", "day"]</span></span><br></pre></td></tr></table></figure>
<p>使用limit限定返回的数组大小. 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(str.split(<span class="string">" "</span>));<span class="comment">//["today"]</span></span><br></pre></td></tr></table></figure>
<p>使用正则分隔符(RegExp separator). 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(str.split(<span class="regexp">/\s*is\s*/</span>));<span class="comment">//["today", "a sunny day"]</span></span><br></pre></td></tr></table></figure>
<p>若正则分隔符里包含捕获括号, 则括号匹配的结果将会包含在返回的数组中.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(str.split(<span class="regexp">/(\s*is\s*)/</span>));<span class="comment">//["today", " is ", "a sunny day"]</span></span><br></pre></td></tr></table></figure>
<h6 id="substr"><a href="#substr" class="headerlink" title="substr"></a>substr</h6><p>substr() 方法返回字符串指定位置开始的指定数量的字符.</p>
<p>语法: <em>str</em>.substr(start[, length])</p>
<p>start 表示开始截取字符的位置, 可取正值或负值. 取正值时表示start位置的索引, 取负值时表示 length+start位置的索引.</p>
<p>length 表示截取的字符长度.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"Yesterday is history. Tomorrow is mystery. But today is a gift."</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.substr(<span class="number">47</span>));<span class="comment">//today is a gift.</span></span><br><span class="line"><span class="built_in">console</span>.log(str.substr(-<span class="number">16</span>));<span class="comment">//today is a gift.</span></span><br></pre></td></tr></table></figure>
<p>目前 Microsoft’s JScript 不支持 start 参数取负的索引, 如需在 IE 下支持, 请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/substr#Description" target="_blank" rel="external">Polyfill</a>.</p>
<h6 id="substring"><a href="#substring" class="headerlink" title="substring"></a>substring</h6><p>substring() 方法返回字符串两个索引之间的子串.</p>
<p>语法: <em>str</em>.substring(indexA[, indexB])</p>
<p>indexA, indexB 表示字符串索引, 其中 indexB 可选, 如果省略, 则表示返回从 indexA 到字符串末尾的子串.</p>
<p><strong>描述</strong></p>
<p>substring 要截取的是从 indexA 到 indexB(不包含)之间的字符, 符合以下规律:</p>
<ul>
<li>若 indexA == indexB, 则返回一个空字符串;</li>
<li>若 省略 indexB, 则提取字符一直到字符串末尾;</li>
<li>若 任一参数小于 0 或 NaN, 则被当作 0;</li>
<li>若 任一参数大于 length, 则被当作 length.</li>
</ul>
<p>而 如果 indexA &gt; indexB, 则 substring 的执行效果就像是两个参数调换一般. 比如: str.substring(0,1) == str.substring(1,0)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"Get outside every day. Miracles are waiting everywhere."</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.substring(<span class="number">1</span>,<span class="number">1</span>));<span class="comment">//""</span></span><br><span class="line"><span class="built_in">console</span>.log(str.substring(<span class="number">0</span>));<span class="comment">//Get outside every day. Miracles are waiting everywhere.</span></span><br><span class="line"><span class="built_in">console</span>.log(str.substring(-<span class="number">1</span>));<span class="comment">//Get outside every day. Miracles are waiting everywhere.</span></span><br><span class="line"><span class="built_in">console</span>.log(str.substring(<span class="number">0</span>,<span class="number">100</span>));<span class="comment">//Get outside every day. Miracles are waiting everywhere.</span></span><br><span class="line"><span class="built_in">console</span>.log(str.substring(<span class="number">22</span>,<span class="literal">NaN</span>));<span class="comment">//Get outside every day.</span></span><br></pre></td></tr></table></figure>
<h6 id="toLocaleLowerCase"><a href="#toLocaleLowerCase" class="headerlink" title="toLocaleLowerCase"></a>toLocaleLowerCase</h6><h6 id="toLocaleUpperCase"><a href="#toLocaleUpperCase" class="headerlink" title="toLocaleUpperCase"></a>toLocaleUpperCase</h6><p>toLocaleLowerCase() 方法返回调用该方法的字符串被转换成小写的值, 转换规则根据本地化的大小写映射. 而 toLocaleUpperCase() 方法则是转换成大写的值.</p>
<p>语法: <em>str</em>.toLocaleLowerCase(), <em>str</em>.toLocaleUpperCase()</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'ABCDEFG'</span>.toLocaleLowerCase());<span class="comment">//abcdefg</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'abcdefg'</span>.toLocaleUpperCase());<span class="comment">//ABCDEFG</span></span><br></pre></td></tr></table></figure>
<h6 id="toLowerCase"><a href="#toLowerCase" class="headerlink" title="toLowerCase"></a>toLowerCase</h6><h6 id="toUpperCase"><a href="#toUpperCase" class="headerlink" title="toUpperCase"></a>toUpperCase</h6><p>这两个方法分别表示将字符串转换为相应的小写,大写形式, 并返回. 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'ABCDEFG'</span>.toLowerCase());<span class="comment">//abcdefg</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'abcdefg'</span>.toUpperCase());<span class="comment">//ABCDEFG</span></span><br></pre></td></tr></table></figure>
<h6 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h6><h6 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf"></a>valueOf</h6><p>这两个方法都是返回指定对象的字符串形式.</p>
<p>语法: <em>str</em>.toString(), <em>str</em>.valueOf()</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"abc"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.toString());<span class="comment">//abc</span></span><br><span class="line"><span class="built_in">console</span>.log(str.toString()==str.valueOf());<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>尽管他们是如此的相似, 但仍能抓住他们之间细微的差别, 请尝试运行以下一段代码:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = &#123;</span><br><span class="line">    toString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">"test"</span>; &#125;,</span><br><span class="line">    valueOf: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">123</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">alert(x); <span class="comment">// test</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"x="</span> + x); <span class="comment">// "x=123"</span></span><br><span class="line"><span class="built_in">console</span>.log(x + <span class="string">"=x"</span>); <span class="comment">// "123=x"</span></span><br><span class="line"><span class="built_in">console</span>.log(x + <span class="string">"1"</span>); <span class="comment">// 1231</span></span><br><span class="line"><span class="built_in">console</span>.log(x + <span class="number">1</span>); <span class="comment">// 124</span></span><br><span class="line"><span class="built_in">console</span>.log([<span class="string">"x="</span>, x].join(<span class="string">""</span>)); <span class="comment">// "x=test"</span></span><br></pre></td></tr></table></figure>
<p>我们发现当 “+” 操作符存在时, x趋向于转换为数字, 表达式会优先调用 valueOf 方法, 如果调用数组的 join 方法, x趋向于转换为字符串, 表达式会优先调用 toString 方法.</p>
<h6 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h6><p>trim() 方法清除字符串首尾的空白并返回.</p>
<p>语法: <em>str</em>.trim()</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"    abc    "</span>.trim());<span class="comment">//abc</span></span><br></pre></td></tr></table></figure>
<p>trim() 方法是 ECMAScript 5.1 标准加入的, 它并不支持IE9以下的低版本IE浏览器, 如需支持, 请参考以下兼容写法:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!<span class="built_in">String</span>.prototype.trim) &#123;</span><br><span class="line">  <span class="built_in">String</span>.prototype.trim = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.replace(<span class="regexp">/^\s+|\s+$/g</span>,<span class="string">''</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="codePointAt"><a href="#codePointAt" class="headerlink" title="codePointAt"></a>codePointAt</h6><p>codePointAt() 方法返回使用UTF-16编码的给定位置的值的非负整数. 该方法遵循 ES6标准, 并非所有浏览器都支持.</p>
<p>语法: <em>str</em>.codePointAt(position)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"a"</span>.codePointAt(<span class="number">0</span>));<span class="comment">//97</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"\u4f60\u597d"</span>.codePointAt(<span class="number">0</span>));<span class="comment">//20320</span></span><br></pre></td></tr></table></figure>
<p>codePointAt 符合 ES6 标准, 如需支持, 请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/codePointAt#Polyfill" target="_blank" rel="external">Polyfill</a> .</p>
<h6 id="contains"><a href="#contains" class="headerlink" title="contains"></a>contains</h6><p>contains() 方法尚处于 ES6 规范的草案中, 它用来判断一个字符串是否属于另一个字符, 如果是, 则返回true, 如果不是, 则返回false.</p>
<p>语法: <em>str</em>.contains(subString [, position])</p>
<p>subString 表示要搜索的字符串, position 表示从当前字符串的哪个位置开始搜索字符串, 默认值为0.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"Practice makes perfect."</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.contains(<span class="string">"perfect"</span>));<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(str.contains(<span class="string">"perfect"</span>,<span class="number">100</span>));<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>实际上, 目前只有 Firefox 17及之后的版本实现了该方法.</p>
<h6 id="endsWith"><a href="#endsWith" class="headerlink" title="endsWith"></a>endsWith</h6><p>endsWith() 方法基本与 contains() 功能相同, 不同的是, 它用来判断一个字符串是否是原字符串的结尾. 若是则返回true, 否则返回false.</p>
<p>语法: <em>str</em>.endsWith(substring [, position])</p>
<p>与contains 方法不同, position 参数的默认值为字符串长度.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"Learn and live."</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.endsWith(<span class="string">"live."</span>));<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(str.endsWith(<span class="string">"Learn"</span>,<span class="number">5</span>));<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>同样目前只有 Firefox 17版本及之后的版本实现了该方法. 其他浏览器请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith#Polyfill" target="_blank" rel="external">Polyfill</a>.</p>
<h6 id="normalize"><a href="#normalize" class="headerlink" title="normalize"></a>normalize</h6><p>normalize() 方法尚处于 ES6 规范的草案中, 它会按照指定的 Unicode 正规形式将原字符串正规化.</p>
<p>语法: <em>str</em>.normalize([form])</p>
<p>form 参数可省略, 目前有四种 Unicode 正规形式, 即 “NFC”, “NFD”, “NFKC” 以及 “NFKD”, form的默认值为 “NFC”. 如果form 传入了非法的参数值, 则会抛出 RangeError 异常.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"\u4f60\u597d"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.normalize());<span class="comment">//你好</span></span><br><span class="line"><span class="built_in">console</span>.log(str.normalize(<span class="string">"NFC"</span>));<span class="comment">//你好</span></span><br><span class="line"><span class="built_in">console</span>.log(str.normalize(<span class="string">"NFD"</span>));<span class="comment">//你好</span></span><br><span class="line"><span class="built_in">console</span>.log(str.normalize(<span class="string">"NFKC"</span>));<span class="comment">//你好</span></span><br><span class="line"><span class="built_in">console</span>.log(str.normalize(<span class="string">"NFKD"</span>));<span class="comment">//你好</span></span><br></pre></td></tr></table></figure>
<p>目前只有 Chrome, Firefox 浏览器实现了该方法.</p>
<h6 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h6><p>repeat() 方法尚处于 ES6 规范的草案中, 它返回重复原字符串多次的新字符串.</p>
<p>语法: <em>str</em>.repeat(count)</p>
<p>count 参数只能取大于等于0 的数字, 若该数字不为整数, 将自动转换为整数形式. 如果取负数或者其他值将报错</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"A still tongue makes a wise head."</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.repeat(<span class="number">0</span>));<span class="comment">//""</span></span><br><span class="line"><span class="built_in">console</span>.log(str.repeat(<span class="number">1</span>));<span class="comment">//A still tongue makes a wise head.</span></span><br><span class="line"><span class="built_in">console</span>.log(str.repeat(<span class="number">1.5</span>));<span class="comment">//A still tongue makes a wise head.</span></span><br><span class="line"><span class="built_in">console</span>.log(str.repeat(-<span class="number">1</span>));<span class="comment">//RangeError:Invalid count value</span></span><br></pre></td></tr></table></figure>
<p>目前只有 Chrome 41, Firefox 24版本浏览器实现了该方法. 其他浏览器请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/repeat#Polyfill" target="_blank" rel="external">Polyfill</a>.</p>
<h6 id="startsWith"><a href="#startsWith" class="headerlink" title="startsWith"></a>startsWith</h6><p>startsWith() 方法用来判断当前字符串是否是以给定字符串开始的, 若是则返回true, 否则返回false.</p>
<p>语法: <em>str</em>.startsWith(subString [, position])</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"Where there is a will, there is a way."</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.startsWith(<span class="string">"Where"</span>));<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(str.startsWith(<span class="string">"there"</span>,<span class="number">6</span>));<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>目前只有 Firefox 17 版本实现了该方法, 其他浏览器请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith#Polyfill" target="_blank" rel="external">Polyfill</a>.</p>
<p>其它非标准的方法暂时不作介绍. 如需了解请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/prototype" target="_blank" rel="external">String.prototype - JavaScript | MDN</a> 中标注为感叹号的方法.</p>
<h5 id="HTML_u6709_u5173_u7684_u65B9_u6CD5"><a href="#HTML_u6709_u5173_u7684_u65B9_u6CD5" class="headerlink" title="HTML有关的方法"></a>HTML有关的方法</h5><p>常用的方法有 anchor, link 其它方法如 big, blink, bold, fixed, fontcolor, fontsize, italics, small, strike, sub, sup均已废除.</p>
<p>接下来我们将介绍 anchor和link 两个方法, 其他废除方法不作介绍.</p>
<h6 id="anchor"><a href="#anchor" class="headerlink" title="anchor"></a>anchor</h6><p>anchor() 方法创建一个锚标签.</p>
<p>语法: <em>str</em>.anchor(name)</p>
<p>name 指定被创建的a标签的name属性, 使用该方法创建的锚点, 将会成为 document.anchors 数组的元素.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"this is a anchor tag"</span>;</span><br><span class="line"><span class="built_in">document</span>.body.innerHTML = <span class="built_in">document</span>.body.innerHTML + str.anchor(<span class="string">"anchor1"</span>);<span class="comment">//body末尾将会追加这些内容 &lt;a name="anchor1"&gt;this is a anchor tag&lt;/a&gt;</span></span><br></pre></td></tr></table></figure>
<h6 id="link"><a href="#link" class="headerlink" title="link"></a>link</h6><p>link() 方法同样创建一个a标签.</p>
<p>语法: <em>str</em>.link(url)</p>
<p>url 指定被创建的a标签的href属性, 如果url中包含特殊字符, 将自动进行编码. 例如 &amp;会被转义为 &amp;, “ 会被转义为 “ &amp;\quot; 使用该方法创建的a标签, 将会成为 document.links 数组中的元素.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"百度"</span>;</span><br><span class="line"><span class="built_in">document</span>.write(str.link(<span class="string">"https://www.baidu.com"</span>));<span class="comment">//&lt;a href="https://www.baidu.com"&gt;百度&lt;/a&gt;</span></span><br></pre></td></tr></table></figure>
<hr>
<p>实际上 String.prototype 中, 常用的方法就charAt, indexOf, lastIndexOf, match, replace, search, slice, split, substr, substring, toLowerCase, toUpperCase, trim, valueof 等这些. 熟悉它们的语法规则就能熟练地驾驭字符串.</p>
<hr>
<p>本文就讨论这么多内容,大家有什么问题或好的想法欢迎在下方参与<a href="#respond">留言和评论</a>.</p>
<p>本文作者: <a href="https://github.com/Louiszhai" target="_blank" rel="external">louis</a></p>
<p>本文链接: <a href="http://louiszhai.github.io/2016/01/12/js.String/">http://louiszhai.github.io/2016/01/12/js.String/</a></p>
<p>参考文章</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/prototype" target="_blank" rel="external">String.prototype - JavaScript | MDN</a></li>
<li><a href="http://stackoverflow.com/questions/2485632/valueof-vs-tostring-in-javascript" target="_blank" rel="external">valueOf() vs. toString() in Javascript - Stack Overflow</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[JavaScript String String.prototype]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://louiszhai.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Function.prototype.bind方法指南]]></title>
    <link href="http://louiszhai.github.io/2016/01/11/bind/"/>
    <id>http://louiszhai.github.io/2016/01/11/bind/</id>
    <published>2016-01-11T00:01:33.000Z</published>
    <updated>2016-05-17T01:07:43.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u5BFC_u8BFB"><a href="#u5BFC_u8BFB" class="headerlink" title="导读"></a>导读</h3><p>ES5新增了 Function.prototype.bind 方法, 该方法不同于jquery的bind 方法, 它主要用于固定 this 作用域, 避免各种由于上下文切换造成的语义问题. 常用在 setTimeout, for循环等内部.</p>
<a id="more"></a>
<h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p>语法: func.bind(thisArg, arg1, arg2, ….)</p>
<p>bind() 方法会返回一个新函数, 又叫绑定函数, 当调用这个绑定函数时, 绑定函数会以创建它时传入 bind() 方法的第一个参数作为当前的上下文, 即this, 传入 bind() 方法的第二个及之后的参数加上绑定函数运行时自身的参数按照顺序作为原函数的参数来调用原函数.</p>
<p>绑定函数也能使用new操作符创建对象; 这就好比把原函数当做构造器. 此时提供的this将被忽略, this之后的参数将依然前置到运行时的参数列表中.</p>
<h4 id="u57FA_u672C_u7528_u6CD5"><a href="#u57FA_u672C_u7528_u6CD5" class="headerlink" title="基本用法"></a>基本用法</h4><p>下面我们来看看bind 的基本用法.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  x: <span class="number">10</span>,</span><br><span class="line">  getX: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  	<span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> f = o.getX;</span><br><span class="line">f();<span class="comment">//8, 由于没有绑定执行时的上下文, this默认指向window, 打印了全局变量x的值</span></span><br><span class="line"><span class="keyword">var</span> g = f.bind(o);</span><br><span class="line">g();<span class="comment">//10, 绑定this后, 成功的打印了o对象的x属性的值.</span></span><br></pre></td></tr></table></figure>
<h4 id="u5206_u79BB_u53C2_u6570"><a href="#u5206_u79BB_u53C2_u6570" class="headerlink" title="分离参数"></a>分离参数</h4><p>bind() 方法还可以设置函数拥有的初始参数. 这些参数作为bind() 的第2,3…个参数跟在this(或其他对象的后面), 调用绑定函数时, 这些参数将插入到参数列表的最开始位置, 而传递给绑定函数的参数将跟在他们后面.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印十个斐波那契数</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">n1, n2, length</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">arguments</span>.length&lt;<span class="number">3</span>) <span class="built_in">console</span>.log(<span class="string">'参数不够...'</span>);</span><br><span class="line">  <span class="keyword">var</span> array = [n1, n2];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">2</span>;i&lt;length;i++)&#123;</span><br><span class="line">  	array[i] = array[i-<span class="number">2</span>] + array[i-<span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = f.bind(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(g(<span class="number">10</span>));<span class="comment">//[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]</span></span><br></pre></td></tr></table></figure>
<h4 id="u7ED1_u5B9A_u53C2_u6570"><a href="#u7ED1_u5B9A_u53C2_u6570" class="headerlink" title="绑定参数"></a>绑定参数</h4><p>如果使用new 操作符去构造绑定函数的实例时, 原来提供的this 将被忽略, this之后的参数将依然前置到构造函数的参数列表中. 此时 bind() 方法便具备了保留参数的能力, 我们可以此达到类似柯里化的效果.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">arguments</span>.length!=<span class="number">0</span>)</span><br><span class="line">  	<span class="keyword">this</span>.sum = <span class="built_in">Array</span>.prototype.reduce.call(<span class="built_in">arguments</span>,<span class="function"><span class="keyword">function</span>(<span class="params">prev,item</span>)</span>&#123;<span class="comment">//对传入参数求和</span></span><br><span class="line"> 		<span class="keyword">return</span> prev + item;</span><br><span class="line">	&#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.join.call(<span class="built_in">arguments</span>);<span class="comment">// 返回传入参数的字符串形式</span></span><br><span class="line">&#125;</span><br><span class="line">f.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = f.bind(<span class="literal">null</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> g(<span class="number">8</span>);</span><br><span class="line"><span class="built_in">console</span>.log(x.toString());<span class="comment">//10, 可见x被绑定了2+8=10</span></span><br><span class="line"><span class="built_in">console</span>.log(g(<span class="number">8</span>));<span class="comment">//2,8 这告诉我们绑定的两个参数正是2和8</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x <span class="keyword">instanceof</span> g);<span class="comment">//true, 可见通过new创建的x继承了g</span></span><br><span class="line"><span class="built_in">console</span>.log(x <span class="keyword">instanceof</span> f);<span class="comment">//true, 可见x也继承了f</span></span><br><span class="line"><span class="built_in">console</span>.log(g <span class="keyword">instanceof</span> <span class="built_in">Function</span>);<span class="comment">//true, 可见bind f()方法之后, 返回了一个新的函数g</span></span><br><span class="line"><span class="comment">//函数g可用于求和,如下:</span></span><br><span class="line"><span class="built_in">console</span>.log(g(<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>));<span class="comment">//27 2+1+3+5+7+9=27</span></span><br></pre></td></tr></table></figure>
<h4 id="u5FEB_u6377_u8C03_u7528"><a href="#u5FEB_u6377_u8C03_u7528" class="headerlink" title="快捷调用"></a>快捷调用</h4><p>使用Array.prototype的方法处理类数组对象时(鸭式辨型), 不可避免的需要借用call 或者 apply 方法, 使用 bind() 方法, 我们可以简化这个过程. 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _slice = <span class="built_in">Array</span>.prototype.slice;</span><br><span class="line"><span class="keyword">var</span> slice = <span class="built_in">Function</span>.prototype.call.bind(_slice);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> slice(<span class="built_in">arguments</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);<span class="comment">//[2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>
<p>下面的实例将解释 bind() 方法做了一件什么事情:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _slice = <span class="built_in">Array</span>.prototype.slice;</span><br><span class="line"><span class="keyword">var</span> slice = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> _slice.apply(<span class="built_in">arguments</span>[<span class="number">0</span>],_slice.call(<span class="built_in">arguments</span>,<span class="number">1</span>));</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> slice(<span class="built_in">arguments</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);<span class="comment">//[2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>
<p>如下, 是bind() 方法的简单实现.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">thisArg,argN</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _this = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> _arg = _slice.call(<span class="built_in">arguments</span>,<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   	<span class="keyword">var</span> arg = _slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    arg = _arg.concat(arg);</span><br><span class="line">  	<span class="keyword">return</span> _this.apply(thisArg,arg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出来, 使用 bind() 方法后, 代码优雅得多.</p>
<p>注: 作为ES5标准加入的bind方法显然不支持 IE9之前的低版本IE, 如需使用, 请参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind#Compatibility" target="_blank" rel="external">Polyfill</a>.</p>
<hr>
<p>本文就讨论这么多内容,大家有什么问题或好的想法欢迎在下方参与<a href="#respond">留言和评论</a>.</p>
<p>本文作者: <a href="https://github.com/Louiszhai" target="_blank" rel="external">louis</a></p>
<p>本文链接: <a href="http://louiszhai.github.io/2016/01/11/bind/">http://louiszhai.github.io/2016/01/11/bind/</a></p>
<p>参考文章</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="external">Function.prototype.bind() - JavaScript | MDN</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[JavaScript bind Function.prototype.bind]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://louiszhai.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[由同源策略到前端跨域]]></title>
    <link href="http://louiszhai.github.io/2016/01/11/cross-domain/"/>
    <id>http://louiszhai.github.io/2016/01/11/cross-domain/</id>
    <published>2016-01-11T00:01:33.000Z</published>
    <updated>2016-05-17T01:07:43.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u5BFC_u8BFB"><a href="#u5BFC_u8BFB" class="headerlink" title="导读"></a>导读</h3><p>同源策略 (Same-Origin Policy) 最早由 Netscape 公司提出, 所谓同源就是要求, 域名, 协议, 端口相同. 非同源的脚本不能访问或者操作其他域的页面对象(如DOM等). 作为著名的安全策略, 虽然它只是一个规范, 并不强制要求,  但现在所有支持 javaScript 的浏览器都会使用这个策略. 以至于该策略成为浏览器最核心最基本的安全功能, 如果缺少了同源策略, web的安全将无从谈起.</p>
<a id="more"></a>
<h3 id="u540C_u6E90_u7B56_u7565_u7684_u9650_u5236"><a href="#u540C_u6E90_u7B56_u7565_u7684_u9650_u5236" class="headerlink" title="同源策略的限制"></a>同源策略的限制</h3><p>同源策略下的web世界, 域的壁垒高筑, 从而保证各个网页相互独立, 互相之间不能直接访问, iframe, ajax 均受其限制, 而script标签不受此限制.</p>
<h4 id="iframe_u9650_u5236"><a href="#iframe_u9650_u5236" class="headerlink" title="iframe限制"></a>iframe限制</h4><ul>
<li>可以访问同域资源, 可读写;</li>
<li>访问跨域页面时, 只读.</li>
</ul>
<h4 id="Ajax_u9650_u5236"><a href="#Ajax_u9650_u5236" class="headerlink" title="Ajax限制"></a>Ajax限制</h4><p>Ajax 的限制比 iframe 限制更严.</p>
<ul>
<li>同域资源可读写;</li>
<li>跨域请求会直接被浏览器拦截.</li>
</ul>
<h4 id="Script_u9650_u5236"><a href="#Script_u9650_u5236" class="headerlink" title="Script限制"></a>Script限制</h4><p>script并无限制, 因为script标签引入的文件不能够被客户端的 js 获取到, 不会影响到原页面的安全, 因此script标签引入的文件没必要遵循浏览器的同源策略. 相反, ajax 加载的文件内容可被客户端 js 获取到, 引入的文件内容可能会泄漏或者影响原页面安全, 故, ajax必须遵循同源策略.</p>
<h4 id="u6CE8_u610F"><a href="#u6CE8_u610F" class="headerlink" title="注意"></a>注意</h4><p>同源策略要求三同, 即: <strong>同域</strong>, <strong>同协议</strong>, <strong>同端口</strong>.</p>
<ul>
<li>同域即host相同, 顶级域名, 一级域名, 二级域名, 三级域名等必须相同, 且域名不能与 ip 对应;</li>
<li>同协议要求, http与https协议必须保持一致;</li>
<li>同端口要求, 端口号必须相同.</li>
</ul>
<p>IE有些例外, 它仅仅只是验证主机名以及访问协议，而忽略了端口号.</p>
<p>这里需要澄清一个概念, 所谓的域, 跟 js 等资源的存放服务器没有关系, 比如你到 baidu.com 使用 script 标签请求了 google.com 下的js, 那么该 js 所在域是 baidu.com, 而不是 google.com. 换言之, 它能操作baidu.com的页面对象, 却不能操作google.com的页面对象.</p>
<h3 id="u8DE8_u57DF_u8BBF_u95EE"><a href="#u8DE8_u57DF_u8BBF_u95EE" class="headerlink" title="跨域访问"></a>跨域访问</h3><p>实际上, 我们又不可避免地需要做一些跨域的请求, 下面提供几种方案去绕过同源策略:</p>
<h4 id="u4F7F_u7528_u4EE3_u7406"><a href="#u4F7F_u7528_u4EE3_u7406" class="headerlink" title="使用代理"></a>使用代理</h4><p>虽然ajax和iframe受同源策略限制, 但服务器端代码请求, 却不受此限制, 我们可以基于此去伪造一个同源请求, 实现跨域的访问. </p>
<ol>
<li>请求同域下的web服务器;</li>
<li>web服务器像代理一样去请求真正的第三方服务器;</li>
<li>代理拿到数据过后, 直接返回给客户端ajax.</li>
</ol>
<p>这样, 我们便拿到了跨域数据.</p>
<h4 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h4><p>由上, script标签并不受同源策略约束, 基于script 标签可做 jsonp 形式的访问, 可以通过第三方服务器生成动态的js代码来回调本地的js方法，而方法中的参数则由第三方服务器在后台获取，并以JSON的形式填充到JS方法当中. 即 JSON with Padding. 具体如下:</p>
<p>1) 可用js生成以下html 代码, 去做jsonp的请求.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span> <span class="attribute">src</span>=<span class="value">"https://www.targetDomain.com/jsonp?callback=callbackName"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用 jquery, 即</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jQuery.getJSON(</span><br><span class="line">  <span class="string">"https://www.yourdomain.com/jsonp?callback=?"</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"name: "</span> + data.name);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>其中回调函数名 “callback” 为 “?”, 即不需要用户指定，而是由jquery生成.</p>
<p>2) 服务器端,以 java 为例, 参考如下: </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">  //获取JSON数据</span><br><span class="line">  String jsonData = "&#123;\"name\":\"jsonp\""&#125;";</span><br><span class="line">  //获取回调函数名</span><br><span class="line">  String callback = req.getParameter("callback");  </span><br><span class="line">  //拼接动态JS代码</span><br><span class="line">  String output = callback + "(" + jsonData + ");</span><br><span class="line">    resp.setContentType("text/javascript");</span><br><span class="line">  PrintWriter out = resp.getWriter();</span><br><span class="line">  out.println(output);</span><br><span class="line">  // 响应为 callbackName(&#123;\"name\":\"jsonp\""&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage"></a>postMessage</h4><p>ES5新增的 postMessage() 方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递.</p>
<p>语法: postMessage(data,origin)</p>
<p><strong>data</strong>: 要传递的数据，html5规范中提到该参数可以是JavaScript的任意基本类型或可复制的对象，然而并不是所有浏览器都做到了这点儿，部分浏览器只能处理字符串参数，所以我们在传递参数的时候需要使用JSON.stringify()方法对对象参数序列化，在低版本IE中引用json2.js可以实现类似效果.</p>
<p><strong>origin</strong>：字符串参数，指明目标窗口的源，协议+主机+端口号[+URL]，URL会被忽略，所以可以不写，这个参数是为了安全考虑，postMessage()方法只会将message传递给指定窗口，当然如果愿意也可以建参数设置为”*”，这样可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/“。</p>
<p>父页面发送消息: </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.frames[<span class="number">0</span>].postMessage(<span class="string">'message'</span>, origin)</span><br></pre></td></tr></table></figure>
<p>iframe接受消息: </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(e.source!=<span class="built_in">window</span>.parent) <span class="keyword">return</span>;<span class="comment">//判断消息源是不是父页面</span></span><br><span class="line">  	<span class="comment">//TODO ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>其中 e 对象有三个重要的属性​    </p>
<ul>
<li>data, 表示父页面传递过来的message</li>
<li>source, 表示发送消息的窗口对象</li>
<li>origin, 表示发送消息窗口的源(协议+主机+端口号)</li>
</ul>
<h4 id="CORS__u8DE8_u57DF_u8BBF_u95EE"><a href="#CORS__u8DE8_u57DF_u8BBF_u95EE" class="headerlink" title="CORS 跨域访问"></a>CORS 跨域访问</h4><p>HTML5带来了一种新的跨域请求的方式 — CORS, 即 <a href="https://en.wikipedia.org/wiki/Cross-originresourcesharing" target="_blank" rel="external">Cross-origin resource sharing</a>. 它更加安全, 上述的 JSONP, postMessage 等, 资源本身没有能力保证自己不被滥用. CORS的目标是保护资源只被可信的访问源以正确的方式访问. </p>
<p>目前, 主流的浏览器都支持此协议, 可以在caniuse.com 中查到<a href="http://caniuse.com/#search=cors" target="_blank" rel="external">http://caniuse.com/#search=cors</a>.</p>
<p>简而言之, 浏览器不再一味禁止跨域访问, 而是需要检查目的站点返回的消息的头域, 要检查该响应是否允许当前站点访问. 通过HTTP头域的方式来通知浏览器:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Response headers[edit]</span><br><span class="line">Access-Control-Allow-Origin</span><br><span class="line">Access-Control-Allow-Credentials</span><br><span class="line">Access-Control-Expose-Headers</span><br><span class="line">Access-Control-Max-Age</span><br><span class="line">Access-Control-Allow-Methods</span><br><span class="line">Access-Control-Allow-Headers</span><br></pre></td></tr></table></figure>
<p>CORS的解决办法是在服务端Response的HTTP头域加入资源的访问权限信息. 如: A站只需要在response头中加一个字段就能让B站跨站访问.</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">access</span>-control-allow-origin:*</span><br></pre></td></tr></table></figure>
<p>其中<code>*</code> 表示通配, 所有的域都能访问此资源, 如果严谨一些只允许B站访问:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">access-control-allow-origin:<span class="tag">&lt;<span class="title">B-DOMAIN</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样B站就可以直接访问此资源, 不需要JSONP 也不需要iframe了.</p>
<p>CORS还可以约束只允许某种METHOD访问, 比如:</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Access-Control-Allow-Methods</span>: <span class="string">POST, GET, OPTIONS</span></span><br></pre></td></tr></table></figure>
<p>CORS为安全考据在跨站ajax访问的时候是不带cookie的, 但这点同样可以改变, 只需要加这个头, 浏览器就会把cookie 奉上!</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-<span class="string">Credentials:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>在访问资源前，浏览器会先发出OPTIONS请求，获取这些权限信息，并比对当前站点的脚本是否有权限，然后再将实际的脚本的数据请求发出. 发现权限不允许, 则不会发出请求. 逻辑流程图为:</p>
<p><img src="/docImages/cross-domain01.jpg" alt=""></p>
<p>浏览器也可以直接将GET请求发出，数据和权限同时到达浏览器端，但是数据是否交给脚本处理需要浏览器检查权限对比后作出决定。</p>
<p>一次具体的跨域访问的流程为：</p>
<p><img src="/docImages/cross-domain02.jpg" alt=""></p>
<p>因此权限控制交给了服务端，服务端一般也会提供对资源的CORS的配置.</p>
<h4 id="document-domain"><a href="#document-domain" class="headerlink" title="document.domain"></a>document.domain</h4><p>通过修改document的domain属性，我们可以在域和子域或者不同的子域之间通信(即它们必须在同一个一级域名下)。同域策略认为域和子域隶属于不同的域，比如a.com和 script.a.com是不同的域，这时，我们无法在a.com下的页面中调用script.a.com中定义的JavaScript方法。但是当我们把它们document的domain属性都修改为a.com，浏览器就会认为它们处于同一个域下，那么我们就可以互相获取对方数据或者操作对方DOM了。</p>
<p>比如, 我们在 www.a.com/a.html 下, 现在想获取 www.script.a.com/b.html, 即主域名相同, 二级域名不同. 那么可以这么做:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.domain = <span class="string">'a.com'</span>;</span><br><span class="line"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span><br><span class="line">iframe.src = <span class="string">'http://www.script.a.com/b.html'</span>;</span><br><span class="line">iframe.style.display = <span class="string">'none'</span>;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(iframe);</span><br><span class="line">iframe.addEventListener(<span class="string">'load'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="comment">//TODO 载入完成时做的事情</span></span><br><span class="line">	<span class="comment">//var _document = iframe.contentWindow.document;</span></span><br><span class="line"> 	<span class="comment">//...</span></span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>注意: </p>
<ul>
<li>2个页面都要设置, 哪怕 a.html 页已处于 <em>a.com</em> 域名下, 也必须显式设置.</li>
<li>document.domain只能设置为一级域名，比如这里a页不能设置为<em>www.a.com</em> (二级域名).</li>
</ul>
<p>利用domain属性跨域具有以下局限性:</p>
<ul>
<li>两个页面要在同一个一级域名下, 且必须同协议, 同端口, 即子域互跨;</li>
<li>只适用于iframe.</li>
</ul>
<h5 id="Internet_Explorer_u540C_u6E90_u7B56_u7565_u7ED5_u8FC7"><a href="#Internet_Explorer_u540C_u6E90_u7B56_u7565_u7ED5_u8FC7" class="headerlink" title="Internet Explorer同源策略绕过"></a>Internet Explorer同源策略绕过</h5><p>Internet Explorer8以及前面的版本很容易通过document.domain实现同源策略绕过，通过重写文档对象，域属性这个问题可以十分轻松的被利用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">document</span>;</span><br><span class="line"><span class="built_in">document</span> = &#123;&#125;;</span><br><span class="line"><span class="built_in">document</span>.domain = ‘http:<span class="comment">//www.a.com';</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.domain);</span><br></pre></td></tr></table></figure>
<p>如果你在最新的浏览器中运行这段代码，可能在JavaScript控制台会显示一个同源策略绕过错误。</p>
<h4 id="window-name"><a href="#window-name" class="headerlink" title="window.name"></a>window.name</h4><p>window 对象的name属性是一个很特别的属性，当该window的location变化，然后重新加载，它的name属性可以依然保持不变。那么我们可以在页面 A中用iframe加载其他域的页面B，而页面B中用JavaScript把需要传递的数据赋值给window.name，iframe加载完成之后（iframe.onload），页面A修改iframe的地址，将其变成同域的一个地址，然后就可以读出iframe的window.name的值了（因为A中的window.name和iframe中的window.name互相独立的，所以不能直接在A中获取window.name，而要通过iframe获取其window.name）。这个方式非常适合单向的数据请求，而且协议简单、安全。不会像JSONP那样不做限制地执行外部脚本。</p>
<h4 id="location-hash"><a href="#location-hash" class="headerlink" title="location.hash"></a>location.hash</h4><p><strong>location.hash（两个iframe之间），又称FIM，Fragment Identitier Messaging的简写</strong>.</p>
<p>因为父窗口可以对iframe进行URL读写，iframe也可以读写父窗口的URL，URL有一部分被称为hash，就是#号及其后面的字符，它一般用于浏览器锚点定位，Server端并不关心这部分，应该说HTTP请求过程中不会携带hash，所以这部分的修改不会产生HTTP请求，但是会产生浏览器历史记录。此方法的原理就是改变URL的hash部分来进行双向通信。每个window通过改变其他 window的location来发送消息（由于两个页面不在同一个域下IE、Chrome不允许修改parent.location.hash的值，所以要借助于父窗口域名下的一个代理iframe），并通过监听自己的URL的变化来接收消息。这个方式的通信会造成一些不必要的浏览器历史记录，而且有些浏览器不支持onhashchange事件，需要轮询来获知URL的改变，最后，这样做也存在缺点，诸如数据直接暴露在了url中，数据容量和类型都有限等。</p>
<h4 id="Access_Control"><a href="#Access_Control" class="headerlink" title="Access Control"></a>Access Control</h4><p>此跨域方法目前只在很少的浏览器中得以支持，这些浏览器可以发送一个跨域的HTTP请求（Firefox, Google Chrome等通过XMLHTTPRequest实现，IE8下通过XDomainRequest实现），请求的响应必须包含一个Access- Control-Allow-Origin的HTTP响应头，该响应头声明了请求域的可访问权限。例如baidu.com对google.com下的getUsers.php发送了一个跨域的HTTP请求（通过ajax），那么getUsers.php必须加入如下的响应头：</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">header(<span class="string">"Access-Control-Allow-Origin: http://www.baidu.com"</span>);<span class="comment">//表示允许baidu.com跨域请求本文件</span></span><br></pre></td></tr></table></figure>
<h4 id="flash_URLLoder"><a href="#flash_URLLoder" class="headerlink" title="flash URLLoder"></a>flash URLLoder</h4><p>flash有自己的一套安全策略, 服务器可以通过crossdomain.xml文件来声明能被哪些域的SWF文件访问, SWF也可以通过API来确定自身能被哪些域的SWF加载. 当跨域访问资源时, 例如从域 a.com 请求域 b.com上的数据, 我们可以借助flash来发送HTTP请求. </p>
<ul>
<li>首先, 修改域 b.com上的 crossdomain.xml(一般存放在根目录, 如果没有需要手动创建) , 把 a.com 加入到白名单;</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">cross-domain-policy</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">site-control</span> <span class="attribute">permitted-cross-domain-policies</span>=<span class="value">"by-content-type"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">allow-access-from</span> <span class="attribute">domain</span>=<span class="value">"a.com"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">cross-domain-policy</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>其次, 通过Flash URLLoader发送HTTP请求, 拿到请求后并返回;</li>
<li>最后, 通过Flash API把响应结果传递给JavaScript.</li>
</ul>
<p>Flash URLLoader是一种很普遍的跨域解决方案，不过需要支持iOS的话，这个方案就不可行了.</p>
<h4 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h4><p>在WebSocket出现之前, 很多网站为了实现实时推送技术, 通常采用的方案是轮询(Polling)和Comet技术, Comet又可细分为两种实现方式, 一种是长轮询机制, 一种称为流技术, 这两种方式实际上是对轮询技术的改进, 这些方案带来很明显的缺点, 需要由浏览器对服务器发出HTTP request, 大量消耗服务器带宽和资源. 面对这种状况, HTML5定义了WebSocket协议, 能更好的节省服务器资源和带宽并实现真正意义上的实时推送.</p>
<p>WebSocket 本质上是一个基于TCP的协议, 它的目标是在一个单独的持久链接上提供全双工(full-duplex), 双向通信, 以基于事件的方式, 赋予浏览器实时通信能力. 既然是双向通信, 就意味着服务器端和客户端可以同时发送并响应请求, 而不再像HTTP的请求和响应. (同源策略对 web sockets 不适用)</p>
<p>原理: 为了建立一个WebSocket连接，客户端浏览器首先要向服务器发起一个HTTP请求, 这个请求和通常的HTTP请求不同, 包含了一些附加头信息, 其中附加头信息”Upgrade: WebSocket”表明这是一个申请协议升级的HTTP请求, 服务器端解析这些附加的头信息然后产生应答信息返回给客户端, 客户端和服务器端的WebSocket连接就建立起来了, 双方就可以通过这个连接通道自由的传递信息, 并且这个连接会持续存在直到客户端或者服务器端的某一方主动的关闭连接.</p>
<p><em>一个典型WebSocket客户端请求头：</em></p>
<p><img src="/docImages/cross-domain03.jpg" alt=""></p>
<hr>
<p>本问就讨论这么多内容,大家有什么问题或好的想法欢迎在下方参与<a href="#respond">留言和评论</a>.</p>
<p>本文作者: <a href="https://github.com/Louiszhai" target="_blank" rel="external">louis</a></p>
<p>本文链接: <a href="http://louiszhai.github.io/2016/03/02/cross-domain/">http://louiszhai.github.io/2016/03/02/cross-domain/</a></p>
<p>参考文章</p>
<ul>
<li>[学习总结 前端跨域请求的解决办法——JSONP-哥墨迹的iteye-ITeye技术网站][3]</li>
<li><a href="http://www.cnblogs.com/dolphinX/p/3464056.html" target="_blank" rel="external">html5 postMessage解决跨域、跨窗口消息传递-Samaritans-博客园</a></li>
<li>[深入理解前端跨域方法和原理-kongjiea笔记-博客频道-CSDN.NET][5]</li>
<li>[跨域访问和防盗链基本原理-WEB前端-伯乐在线][6]</li>
<li><a href="http://unicorn-kid.com/fe-node/2014/08/07/JavaScript%20%E8%B7%A8%E5%9F%9F%20%E4%B9%8B%E4%B8%80%20%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5.html" target="_blank" rel="external">Javascript 跨域 之一 同源策略 - KID</a></li>
<li><a href="http://www.freebuf.com/articles/web/65468.html" target="_blank" rel="external">同源策略详解及绕过（Part1） - FreeBuf.COM | 关注黑客与极客</a></li>
<li><a href="http://www.plhwin.com/2014/05/28/nodejs-socketio/" target="_blank" rel="external">使用Node.js+Socket.IO搭建WebSocket实时应用 | 潘良虎的随想录</a></li>
<li><a href="http://blog.jackxy.com/cross-origin-123/" target="_blank" rel="external">跨域资源访问的几种方式</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[JavaScript Same-Origin 同源策略 跨域]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://louiszhai.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[setTimeout & setInterval]]></title>
    <link href="http://louiszhai.github.io/2016/01/10/js.timer/"/>
    <id>http://louiszhai.github.io/2016/01/10/js.timer/</id>
    <published>2016-01-10T05:52:11.000Z</published>
    <updated>2016-04-27T01:26:45.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u5BFC_u8BFB"><a href="#u5BFC_u8BFB" class="headerlink" title="导读"></a>导读</h3><p>设置web定时器应当是一个相当常见的需求, 实际上, 我们也有两大工具函数可以任意调用: setTimeout, setInterval. 然而 js 里却没有java的那种wait(), 定时又未必准时, 要想写个定时器还须得深入理解 setTimeout 和 setInterval 的运行原理才行.</p>
<a id="more"></a>
<h3 id="u8FD0_u884C_u539F_u7406"><a href="#u8FD0_u884C_u539F_u7406" class="headerlink" title="运行原理"></a>运行原理</h3><p>setTimeout 和 setInterval 并非异步调用, 所谓的”异步调用”, 只是因它们都往 js 引擎的代码执行队列里插入代码, 看起来像”异步调用”而已.</p>
<p>那么如何计算插入的时间点呢? 自然要用到我们通常所说的 timer (也叫计时器), 当执行 setTimeout 和 setInterval 函数的时候, timer会根据设定好的时间点找到代码的插入点, 返回timer callback, 也就是我们设定的回调函数.</p>
<h3 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h3><p>语法1: setTimeout(func, millisec, [param1, param2, …])</p>
<p>语法2: setTimeout(code, millisec)</p>
<p>setTimeout() 方法在指定的时间后, 执行一次传入的函数. 可通过 window.clearTimeout 函数取消 setTimeout 操作.</p>
<h4 id="u57FA_u672C_u7528_u6CD5"><a href="#u57FA_u672C_u7528_u6CD5" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(+<span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(fn, <span class="number">1000</span>);<span class="comment">//1452405077119, 延迟1s后打印了当前的时间戳</span></span><br><span class="line">setTimeout(<span class="string">"console.log(+new Date())"</span>, <span class="number">1000</span>);<span class="comment">//1452405077120, 延迟1s后执行了字符串中的语句</span></span><br></pre></td></tr></table></figure>
<h4 id="js_u5F15_u64CE_u7684_u6392_u961F_u673A_u5236"><a href="#js_u5F15_u64CE_u7684_u6392_u961F_u673A_u5236" class="headerlink" title="js引擎的排队机制"></a>js引擎的排队机制</h4><p>javaScript的世界里只有一个线程, 从来就没有同时做两件事的能力, 因此setTimeout只是一种委托机制. 它告诉js 引擎, 帮它在指定的时间点将一段代码插入到 js 引擎的代码执行队列最后面, 插入的代码并不能立即执行, 至少也要等到队列前面的代码全部执行完毕(如果队列刚好为空, 则是指定时间立即执行, 否则要等待队列前面的代码顺序执行完毕).</p>
<p>下面我们来通过栗子感受一下setTimeout是怎么排队的.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假如我们要在输入框失去焦点时, 做一些事情, 然后重新获取焦点</span></span><br><span class="line">$(<span class="string">'input'</span>).blur(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//To do something...</span></span><br><span class="line">  $(<span class="keyword">this</span>).focus();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>像上面这种写法在IE下是没有什么问题, 输入框失去焦点后马上就能获取焦点, 然而Firefox就没那么幸运了, 因为Firefox的focus只能出现在blur之后. 利用 setTimeout 的排队特点, 我们可以像下面这样实现:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'input'</span>).blur(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//To do something...</span></span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="keyword">this</span>).focus();</span><br><span class="line">  &#125;,<span class="number">0</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>虽然 setTimeout 延时为0, 但获取焦点的语句并不会立即执行, 原因就在于 setTimeout 只是将获取焦点的语句插入到 js 引擎的代码队列的最后面, 它需要等待整个 blur 完全执行完才能发挥作用, 这样就保证了 focus 事件在 blur 事件之后发生了.</p>
<h4 id="u5145_u5F53_u5B9A_u65F6_u5668"><a href="#u5145_u5F53_u5B9A_u65F6_u5668" class="headerlink" title="充当定时器"></a>充当定时器</h4><p>setTimeout 原本只能延迟一段时间执行一段代码, 如果我们将 setTimeout 写在函数内部, 并在 setTimeout 里调用函数本身, 这样就完成了简单的定时器. 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!i) i = <span class="number">0</span>;</span><br><span class="line">  ++i;</span><br><span class="line">  <span class="keyword">if</span>(i&lt;<span class="number">10</span>) setTimeout(fn,<span class="number">100</span>,i);</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line">fn();<span class="comment">//10, fn每隔100ms执行一次, 直到第10次, 因不符合条件(i=10), 退出定时器, 从而输出10</span></span><br></pre></td></tr></table></figure>
<h4 id="this_u5E26_u6765_u7684_u95EE_u9898"><a href="#this_u5E26_u6765_u7684_u95EE_u9898" class="headerlink" title="this带来的问题"></a>this带来的问题</h4><p>由setTimeout()调用的代码运行在与所在函数完全分离的执行环境上. 这会导致,这些代码中包含的 <code>this</code> 关键字会指向 <code>window</code> (或<code>全局</code>)对象. </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;fruit: <span class="string">"apple"</span>&#125;;</span><br><span class="line">o.shareFruit = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.fruit);</span><br><span class="line">&#125;</span><br><span class="line">o.shareFruit();<span class="comment">//apple</span></span><br><span class="line">setTimeout(o.shareFruit,<span class="number">1000</span>);<span class="comment">//undefined</span></span><br><span class="line">setTimeout.call(o,o.shareFruit,<span class="number">1000</span>);<span class="comment">//Illegal operation on WrappedNative prototype object</span></span><br></pre></td></tr></table></figure>
<p>甚至连 call 方法都没有办法改变当前作用域, 使用中要特别注意避免这个问题. 可参考如下方案: </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(o.shareFruit.bind(o), <span class="number">1000</span>);<span class="comment">//apple</span></span><br></pre></td></tr></table></figure>
<h4 id="u89E3_u51B3_u65B9_u6848"><a href="#u89E3_u51B3_u65B9_u6848" class="headerlink" title="解决方案"></a>解决方案</h4><p>下面我们来使用两个非原生的 setTimeout 和 setInterval 全局函数代替原生的, 使得它们能够借用 call 方法激活正确的作用域.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Enable the passage of the 'this' object through the JavaScript timers</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> __nativeST__ = <span class="built_in">window</span>.setTimeout, __nativeSI__ = <span class="built_in">window</span>.setInterval;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.setTimeout = <span class="function"><span class="keyword">function</span> (<span class="params">vCallback, nDelay <span class="comment">/*, argumentToPass1, argumentToPass2, etc. */</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> oThis = <span class="keyword">this</span>, aArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">return</span> __nativeST__(vCallback <span class="keyword">instanceof</span> <span class="built_in">Function</span> ? <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    vCallback.apply(oThis, aArgs);</span><br><span class="line">  &#125; : vCallback, nDelay);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.setInterval = <span class="function"><span class="keyword">function</span> (<span class="params">vCallback, nDelay <span class="comment">/*, argumentToPass1, argumentToPass2, etc. */</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> oThis = <span class="keyword">this</span>, aArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">return</span> __nativeSI__(vCallback <span class="keyword">instanceof</span> <span class="built_in">Function</span> ? <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    vCallback.apply(oThis, aArgs);</span><br><span class="line">  &#125; : vCallback, nDelay);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//再运行以下代码将能正确执行</span></span><br><span class="line">setTimeout(o.shareFruit,<span class="number">1000</span>);<span class="comment">//apple</span></span><br></pre></td></tr></table></figure>
<h3 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval"></a>setInterval</h3><p>语法1: setInterval(func, millisec, [param1, param2, …])</p>
<p>语法2: setInterval(code, millisec)</p>
<p>setInterval() 方法按照指定的周期(以毫秒为单位)来调用函数或表达式. 可通过 window.clearInterval 函数取消 setInterval 操作.</p>
<h4 id="u57FA_u672C_u7528_u6CD5-1"><a href="#u57FA_u672C_u7528_u6CD5-1" class="headerlink" title="基本用法"></a>基本用法</h4><p>setInterval 与 setTimeout 不同, 它会周期性的去调用函数或者表达式, 直到它本身被取消. 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  ++i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> timer = setInterval(fn,<span class="number">100</span>);<span class="comment">//设置了一个定时器, 每100ms执行一次fn函数</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">window</span>.clearInterval(timer);</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;,<span class="number">2000</span>);<span class="comment">//两秒后清除定时器, 并打印i的值</span></span><br><span class="line"><span class="comment">//20, 可见2s后fn刚好被执行了20次</span></span><br></pre></td></tr></table></figure>
<h4 id="u5B83_u771F_u7684_u53EF_u4EE5_u4F5C_u4E3A_u5B9A_u65F6_u5668_u5417"><a href="#u5B83_u771F_u7684_u53EF_u4EE5_u4F5C_u4E3A_u5B9A_u65F6_u5668_u5417" class="headerlink" title="它真的可以作为定时器吗"></a>它真的可以作为定时器吗</h4><p>实际上 setInterval 真的能作为定时器, 准确无误的在指定间隔时间内执行函数 fn 吗?</p>
<p>答案是 no. 请看下面栗子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  ++i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> timer = setInterval(fn,<span class="number">2</span>);<span class="comment">//设置了一个定时器, 将时间间隔减少至2ms</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">window</span>.clearInterval(timer);</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;,<span class="number">2000</span>);<span class="comment">//两秒后清除定时器, 并打印i的值</span></span><br><span class="line"><span class="comment">//501, 可见2s后fn只是被执行了501次(为什么不是1000次?)</span></span><br></pre></td></tr></table></figure>
<p>以上 fn 应该被执行 2000 次, 实际上才执行501次, 这是为什么呢?</p>
<p>原来, 往 js 引擎在指定时间点插入代码这种技术有个特点, js引擎只允许有一份未执行的process代码(相当于fn), 对上述代码为而言, 每当1ms来临时, js引擎先判断队列中有没有process代码, 如果 fn 函数执行时间大于1ms, 这就意味着fn尚未被执行完, 定时就来了, 然后定时候着, 静静地等待 fn的执行, 这种情况下引擎队列中就可能存在尚未执行的process代码, 如果有则本次插入的时间点就被无情的跳过. </p>
<p>由此可见, 上述代码中, fn 函数被无情的跳过了499次. 我们也可以据此计算出运行一次 fn 函数大致需要2000/501~ = 4ms. 而当我们将上述 timer 的时间间隔设置为4ms时, fn 刚好被执行了 500 次.</p>
<p>因此上面的这段代码并不可靠, 下面我们来看一个更为可靠的版本:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>,timer;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(++i &gt;= <span class="number">1000</span>)&#123;<span class="comment">//fn调用1000次后自动退出</span></span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  timer = setTimeout(<span class="built_in">arguments</span>.callee, <span class="number">2</span>);<span class="comment">//设置延时2ms后执行自身</span></span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i)</span><br><span class="line">  <span class="built_in">window</span>.clearTimeout(timer);</span><br><span class="line">&#125;,<span class="number">2000</span>);<span class="comment">//384</span></span><br></pre></td></tr></table></figure>
<p>可见, 2s之后取消定时器时, fn被执行了384次,如果仅仅希望fn被执行1000次后退出, 删除最后一个setTimeout即可. 此时, 本次fn调用 与 下次调用, 间隔时间将大于或者等于2ms. 这样既保证了调用次数, 又基本保证了调用间隔.</p>
<p>注: IE9 及更早版本的IE 浏览器不支持它们第一个语法中的向回调函数中传参数的功能. 如需支持, 请参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/setTimeout#回调参数" target="_blank" rel="external">兼容写法</a>, 或者借用 Function.prototype.bind 函数, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params">arg1</span>)</span>&#123;&#125;.bind(<span class="literal">undefined</span>, <span class="number">10</span>), <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<hr>
<p>本文就讨论这么多内容,大家有什么问题或好的想法欢迎在下方参与<a href="#respond">留言和评论</a>.</p>
<p>本文作者: <a href="https://github.com/Louiszhai" target="_blank" rel="external">louis</a></p>
<p>本文链接: <a href="http://louiszhai.github.io/2016/01/10/js.timer/">http://louiszhai.github.io/2016/01/10/js.timer/</a></p>
<p>参考文章</p>
<ul>
<li><a href="http://www.jb51.net/article/26679.htm" target="_blank" rel="external">setTimeout和setInterval的区别你真的了解吗?_javascript技巧_脚本之家</a></li>
<li><a href="http://www.jb51.net/article/42971.htm" target="_blank" rel="external">setTimeout和setInterval的深入理解_基础知识_脚本之家</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/setTimeout" target="_blank" rel="external">window.setTimeout - Web API 接口 | MDN</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[JavaScript setTimeout setInterval 轮询]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://louiszhai.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[捋一捋JS的数组]]></title>
    <link href="http://louiszhai.github.io/2015/12/29/array/"/>
    <id>http://louiszhai.github.io/2015/12/29/array/</id>
    <published>2015-12-29T01:00:17.000Z</published>
    <updated>2016-08-04T01:01:59.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u5BFC_u8BFB"><a href="#u5BFC_u8BFB" class="headerlink" title="导读"></a>导读</h3><p>数组是一种非常重要的数据类型, 它语法简单, 灵活,高效, 在多数编程语言中, 数组都充当着至关重要的角色, 以至于很难想象没有数组的编程语言会是什么样子. 这期我们就来侃侃JavaScript的数组, 趴趴它的那点破事儿. 这篇博客从2015年写到了2016年, 权当是跨年的总结吧, 祝大家新年快乐, 2016更好, 未来更好!</p>
<a id="more"></a>
<p>声明: 以下未特别标明的方法均为ES5已实现的方法.</p>
<h3 id="u539F_u578B"><a href="#u539F_u578B" class="headerlink" title="原型"></a>原型</h3><p>js中所有的数组方法均来自于Array.prototype, 和其他构造函数一样, 你可以通过扩展 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Array" target="_blank" rel="external"><code>Array</code></a> 的 <code>prototype</code> 属性上的方法来给所有数组实例增加方法.</p>
<p>值得一说的是, Array.prototype本身就是一个数组.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.isArray(<span class="built_in">Array</span>.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.length);<span class="comment">//0</span></span><br></pre></td></tr></table></figure>
<p>很明显, 数组的原型是一个空数组, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log([].__proto__.length);<span class="comment">//0</span></span><br><span class="line"><span class="built_in">console</span>.log([].__proto__);<span class="comment">//[Symbol(Symbol.unscopables): Object]</span></span><br></pre></td></tr></table></figure>
<p>有关Symbol(Symbol.unscopables)的知识, 这里不做详述, 具体请移步后续章节.</p>
<h3 id="u65B9_u6CD5"><a href="#u65B9_u6CD5" class="headerlink" title="方法"></a>方法</h3><p>Array.prototype的方法包含三种, 一种是会改变自身值的, 一种是不会改变自身值的, 另外一种是遍历方法.</p>
<p>由于 Array.prototype 的某些属性被设置为[[DontEnum]], 因此不能用一般的方法进行遍历, 我们可以通过如下方式获取 Array.prototype 的所有方法:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(<span class="built_in">Array</span>.prototype);<span class="comment">//["length", "constructor", "toString", "toLocaleString", "join", "pop", "push", "reverse", "shift", "unshift", "slice", "splice", "sort", "filter", "forEach", "some", "every", "map", "indexOf", "lastIndexOf", "reduce", "reduceRight", "copyWithin", "find", "findIndex", "fill", "includes", "entries", "keys", "concat"]</span></span><br></pre></td></tr></table></figure>
<h4 id="u6539_u53D8_u81EA_u8EAB_u503C_u7684_u65B9_u6CD5_289_u4E2A_29"><a href="#u6539_u53D8_u81EA_u8EAB_u503C_u7684_u65B9_u6CD5_289_u4E2A_29" class="headerlink" title="改变自身值的方法(9个)"></a>改变自身值的方法(9个)</h4><p>基于ES6, 改变自身值的方法一共有9个, 分别为pop, push, reverse, shift, sort, splice, unshift, 以及两个ES6新增的方法copyWithin, fill.</p>
<h5 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h5><p>pop() 方法删除一个数组中的最后的一个元素，并且返回这个元素.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">"cat"</span>, <span class="string">"dog"</span>, <span class="string">"cow"</span>, <span class="string">"chicken"</span>, <span class="string">"mouse"</span>];</span><br><span class="line"><span class="keyword">var</span> item = array.pop();</span><br><span class="line"><span class="built_in">console</span>.log(array);<span class="comment">//["cat", "dog", "cow", "chicken"]</span></span><br><span class="line"><span class="built_in">console</span>.log(item);<span class="comment">//mouse</span></span><br></pre></td></tr></table></figure>
<p>由于设计上的巧妙, pop方法可以应用在类数组对象上, 即 <code>鸭式辨型</code>. 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="string">"cat"</span>, <span class="number">1</span>:<span class="string">"dog"</span>, <span class="number">2</span>:<span class="string">"cow"</span>, <span class="number">3</span>:<span class="string">"chicken"</span>, <span class="number">4</span>:<span class="string">"mouse"</span>, length:<span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">var</span> item = <span class="built_in">Array</span>.prototype.pop.call(o);</span><br><span class="line"><span class="built_in">console</span>.log(array);<span class="comment">//Object &#123;0: "cat", 1: "dog", 2: "cow", 3: "chicken", length: 4&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(item);<span class="comment">//mouse</span></span><br></pre></td></tr></table></figure>
<p>但如果类数组对象不具有length属性, 那么该对象将被创建length属性, length值为0, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="string">"cat"</span>, <span class="number">1</span>:<span class="string">"dog"</span>, <span class="number">2</span>:<span class="string">"cow"</span>, <span class="number">3</span>:<span class="string">"chicken"</span>, <span class="number">4</span>:<span class="string">"mouse"</span>&#125;</span><br><span class="line"><span class="keyword">var</span> item = <span class="built_in">Array</span>.prototype.pop.call(o);</span><br><span class="line"><span class="built_in">console</span>.log(array);<span class="comment">//Object &#123;0: "cat", 1: "dog", 2: "cow", 3: "chicken", 4: "mouse", length: 0&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(item);<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<h5 id="push"><a href="#push" class="headerlink" title="push"></a>push</h5><p>push()方法添加一个或者多个元素到数组末尾, 并且返回数组新的长度.</p>
<p>语法: arr.push(element1, …, elementN)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">"football"</span>, <span class="string">"basketball"</span>, <span class="string">"volleyball"</span>, <span class="string">"Table tennis"</span>, <span class="string">"badminton"</span>];</span><br><span class="line"><span class="keyword">var</span> i = array.push(<span class="string">"golfball"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(array);<span class="comment">//["football", "basketball", "volleyball", "Table tennis", "badminton", "golfball"]</span></span><br><span class="line"><span class="built_in">console</span>.log(i);<span class="comment">//6</span></span><br></pre></td></tr></table></figure>
<p>同pop方法一样, push方法也可以应用到类数组对象上, 如果length不能被转成一个数值或者不存在length属性时, 则插入的元素索引为0, 且length属性不存在时, 将会创建它.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="string">"football"</span>, <span class="number">1</span>:<span class="string">"basketball"</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> i = <span class="built_in">Array</span>.prototype.push.call(o, <span class="string">"golfball"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(o);<span class="comment">//Object &#123;0: "golfball", 1: "basketball", length: 1&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(i);<span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<p>实际上, push方法是根据length属性来决定从哪里开始插入给定的值.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="string">"football"</span>, <span class="number">1</span>:<span class="string">"basketball"</span>,length:<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> i = <span class="built_in">Array</span>.prototype.push.call(o,<span class="string">"golfball"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(o);<span class="comment">//Object &#123;0: "football", 1: "golfball", length: 2&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(i);<span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>利用push根据length属性插入元素这个特点, 可以实现数组的合并, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">"football"</span>, <span class="string">"basketball"</span>];</span><br><span class="line"><span class="keyword">var</span> array2 = [<span class="string">"volleyball"</span>, <span class="string">"golfball"</span>];</span><br><span class="line"><span class="keyword">var</span> i = <span class="built_in">Array</span>.prototype.push.apply(array,array2);</span><br><span class="line"><span class="built_in">console</span>.log(array);<span class="comment">//["football", "basketball", "volleyball", "golfball"]</span></span><br><span class="line"><span class="built_in">console</span>.log(i);<span class="comment">//4</span></span><br></pre></td></tr></table></figure>
<h5 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h5><p>reverse()方法颠倒数组中元素的位置, 第一个会成为最后一个, 最后一个会成为第一个, 该方法返回对数组的引用.</p>
<p>语法:arr.reverse()</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> array2 = array.reverse();</span><br><span class="line"><span class="built_in">console</span>.log(array);<span class="comment">//[5,4,3,2,1]</span></span><br><span class="line"><span class="built_in">console</span>.log(array2===array);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>同上, reverse 也是鸭式辨型的受益者, 颠倒元素的范围受length属性制约, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="string">"a"</span>, <span class="number">1</span>:<span class="string">"b"</span>, <span class="number">2</span>:<span class="string">"c"</span>, length:<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="built_in">Array</span>.prototype.reverse.call(o);</span><br><span class="line"><span class="built_in">console</span>.log(o);<span class="comment">//Object &#123;0: "b", 1: "a", 2: "c", length: 2&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(o === o2);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>如果 length 属性小于2 或者 length 属性不为数值, 那么原类数组对象将没有变化. 即使 length 属性不存在, 该对象也不会去创建 length 属性. 特别的是, 当 length 属性较大时, 类数组对象的”索引”会尽可能的向 length 看齐. 如下: </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="string">"a"</span>, <span class="number">1</span>:<span class="string">"b"</span>, <span class="number">2</span>:<span class="string">"c"</span>,length:<span class="number">100</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="built_in">Array</span>.prototype.reverse.call(o);</span><br><span class="line"><span class="built_in">console</span>.log(o);<span class="comment">//Object &#123;97: "c", 98: "b", 99: "a", length: 100&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(o === o2);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<h5 id="shift"><a href="#shift" class="headerlink" title="shift"></a>shift</h5><p>shift()方法删除数组的第一个元素, 并返回这个元素.</p>
<p>语法: arr.shift()</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> item = array.shift();</span><br><span class="line"><span class="built_in">console</span>.log(array);<span class="comment">//[2,3,4,5]</span></span><br><span class="line"><span class="built_in">console</span>.log(item);<span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<p>同样受益于鸭式辨型, 对于类数组对象, shift仍然能够处理, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="string">"a"</span>, <span class="number">1</span>:<span class="string">"b"</span>, <span class="number">2</span>:<span class="string">"c"</span>, length:<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> item = <span class="built_in">Array</span>.prototype.shift.call(o);</span><br><span class="line"><span class="built_in">console</span>.log(o);<span class="comment">//Object &#123;0: "b", 1: "c", length: 2&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(item);<span class="comment">//a</span></span><br></pre></td></tr></table></figure>
<p>如果类数组对象length属性不存在, 将添加length属性, 并初始化为0,如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="string">"a"</span>, <span class="number">1</span>:<span class="string">"b"</span>, <span class="number">2</span>:<span class="string">"c"</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> item = <span class="built_in">Array</span>.prototype.shift.call(o);</span><br><span class="line"><span class="built_in">console</span>.log(o);<span class="comment">//Object &#123;0: "a", 1: "b", 2:"c" length: 0&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(item);<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<h5 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h5><p>sort()方法对数组元素进行排序, 并返回这个数组.</p>
<p>语法: arr.sort([comparefn]), comparefn是可选的, 如果省略, 数组元素将按照各自转换为字符串的Unicode(万国码)位点顺序排序, 例如”boy”将排到”Apple”之前. 当对数字排序的时候, 25将会排到8之前, 因为转换为字符串后, “25”将比”8”靠前. 例如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">"Apple"</span>,<span class="string">"boy"</span>,<span class="string">"Cat"</span>,<span class="string">"dog"</span>];</span><br><span class="line"><span class="keyword">var</span> array2 = array.sort();</span><br><span class="line"><span class="built_in">console</span>.log(array);<span class="comment">//["Apple", "Cat", "boy", "dog"]</span></span><br><span class="line"><span class="built_in">console</span>.log(array2 == array);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">array = [<span class="number">10</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">20</span>];</span><br><span class="line"><span class="keyword">var</span> array3 = array.sort();</span><br><span class="line"><span class="built_in">console</span>.log(array3);<span class="comment">//[1, 10, 20, 3]</span></span><br></pre></td></tr></table></figure>
<p>如果指明了comparefn, 数组将按照调用该函数的返回值来排序. 若 a 和 b 是两个将要比较的元素:</p>
<ul>
<li>若 comparefn(a, b) &lt; 0 , 那么a 将排到 b 前面;</li>
<li>若 comparefn(a, b) = 0 , 那么a 和 b 相对位置不变;</li>
<li>若 comparefn(a, b) &gt; 0 , 那么a , b 将调换位置;</li>
</ul>
<p>如果数组元素为数字, 则排序函数comparefn格式如下所示:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果数组元素为非ASCII字符的字符串(如包含类似 e, é, è, a, ä 或中文字符等非英文字符的字符串), 则需要使用String.localeCompare. 下面这个函数将排到正确的顺序.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">'互'</span>,<span class="string">'联'</span>,<span class="string">'网'</span>,<span class="string">'改'</span>,<span class="string">'变'</span>,<span class="string">'世'</span>,<span class="string">'界'</span>];</span><br><span class="line"><span class="keyword">var</span> array2 = array.sort();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> array = [<span class="string">'互'</span>,<span class="string">'联'</span>,<span class="string">'网'</span>,<span class="string">'改'</span>,<span class="string">'变'</span>,<span class="string">'世'</span>,<span class="string">'界'</span>];<span class="comment">//重新赋值,避免干扰array2</span></span><br><span class="line"><span class="keyword">var</span> array3 = array.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a.localeCompare(b);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(array2);<span class="comment">//["世", "互", "变", "改", "界", "网", "联"]</span></span><br><span class="line"><span class="built_in">console</span>.log(array3);<span class="comment">//["变", "改", "互", "界", "联", "世", "网"]</span></span><br></pre></td></tr></table></figure>
<p>如上, “互联网改变世界” 这个数组, sort函数默认按照数组元素unicode字符串形式进行排序, 然而实际上, 我们期望的是按照拼音先后顺序进行排序, 显然String.localeCompare 帮助我们达到了这个目的.</p>
<p>为什么上面测试中需要重新给array赋值呢, 这是因为sort每次排序时改变的是数组本身, 并且返回数组引用. 如果不这么做, 经过连续两次排序后, array2 和 array3 将指向同一个数组, 最终影响我们测试. array重新赋值后就断开了对原数组的引用.</p>
<p>同上, sort一样受益于鸭式辨型, 比如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="string">'互'</span>,<span class="number">1</span>:<span class="string">'联'</span>,<span class="number">2</span>:<span class="string">'网'</span>,<span class="number">3</span>:<span class="string">'改'</span>,<span class="number">4</span>:<span class="string">'变'</span>,<span class="number">5</span>:<span class="string">'世'</span>,<span class="number">6</span>:<span class="string">'界'</span>,length:<span class="number">7</span>&#125;;</span><br><span class="line"><span class="built_in">Array</span>.prototype.sort.call(o,<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a.localeCompare(b);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(o);<span class="comment">//Object &#123;0: "变", 1: "改", 2: "互", 3: "界", 4: "联", 5: "世", 6: "网", length: 7&#125;, 可见同上述排序结果一致</span></span><br></pre></td></tr></table></figure>
<p>注意: 使用sort的鸭式辨型特性时, 若类数组对象不具有length属性,它并不会进行排序, 也不会为其添加length属性.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="string">'互'</span>,<span class="number">1</span>:<span class="string">'联'</span>,<span class="number">2</span>:<span class="string">'网'</span>,<span class="number">3</span>:<span class="string">'改'</span>,<span class="number">4</span>:<span class="string">'变'</span>,<span class="number">5</span>:<span class="string">'世'</span>,<span class="number">6</span>:<span class="string">'界'</span>&#125;;</span><br><span class="line"><span class="built_in">Array</span>.prototype.sort.call(o,<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a.localeCompare(b);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(o);<span class="comment">//Object &#123;0: "互", 1: "联", 2: "网", 3: "改", 4: "变", 5: "世", 6: "界"&#125;, 可见并未添加length属性</span></span><br></pre></td></tr></table></figure>
<h6 id="u4F7F_u7528_u6620_u5C04_u6539_u5584_u6392_u5E8F"><a href="#u4F7F_u7528_u6620_u5C04_u6539_u5584_u6392_u5E8F" class="headerlink" title="使用映射改善排序"></a>使用映射改善排序</h6><p>comparefn 如果需要对数组元素多次转换以实现排序, 那么使用map辅助排序将是个不错的选择. 基本思想就是将数组中的每个元素实际比较的值取出来, 排序后再将数组恢复.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要被排序的数组</span></span><br><span class="line"><span class="keyword">var</span> array = [<span class="string">'dog'</span>, <span class="string">'Cat'</span>, <span class="string">'Boy'</span>, <span class="string">'apple'</span>];</span><br><span class="line"><span class="comment">// 对需要排序的数字和位置的临时存储</span></span><br><span class="line"><span class="keyword">var</span> mapped = array.map(<span class="function"><span class="keyword">function</span>(<span class="params">el, i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; index: i, value: el.toLowerCase() &#125;;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 按照多个值排序数组</span></span><br><span class="line">mapped.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> +(a.value &gt; b.value) || +(a.value === b.value) - <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 根据索引得到排序的结果</span></span><br><span class="line"><span class="keyword">var</span> result = mapped.map(<span class="function"><span class="keyword">function</span>(<span class="params">el</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> array[el.index];</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(result);<span class="comment">//["apple", "Boy", "Cat", "dog"]</span></span><br></pre></td></tr></table></figure>
<h6 id="u5947_u602A_u7684chrome"><a href="#u5947_u602A_u7684chrome" class="headerlink" title="奇怪的chrome"></a>奇怪的chrome</h6><p>实际上, ECMAscript规范中并未规定具体的sort算法, 这就势必导致各个浏览器不尽相同的sort算法, 请看sort方法在Chrome浏览器下表现:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [&#123; n: <span class="string">"a"</span>, v: <span class="number">1</span> &#125;, &#123; n: <span class="string">"b"</span>, v: <span class="number">1</span> &#125;, &#123; n: <span class="string">"c"</span>, v: <span class="number">1</span> &#125;, &#123; n: <span class="string">"d"</span>, v: <span class="number">1</span> &#125;, &#123; n: <span class="string">"e"</span>, v: <span class="number">1</span> &#125;, &#123; n: <span class="string">"f"</span>, v: <span class="number">1</span> &#125;, &#123; n: <span class="string">"g"</span>, v: <span class="number">1</span> &#125;, &#123; n: <span class="string">"h"</span>, v: <span class="number">1</span> &#125;, &#123; n: <span class="string">"i"</span>, v: <span class="number">1</span> &#125;, &#123; n: <span class="string">"j"</span>, v: <span class="number">1</span> &#125;, &#123; n: <span class="string">"k"</span>, v: <span class="number">1</span> &#125;, ];</span><br><span class="line">array.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.v - b.v;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>,len = array.length; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(array[i].n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//f a c d e b g h i j k</span></span><br></pre></td></tr></table></figure>
<p>由于v值相等, array数组排序前后应该不变, 然而Chrome却表现异常, 而其他浏览器(如IE 或 Firefox) 表现正常.</p>
<p>这是因为v8引擎为了高效排序(采用了不稳定排序). 即数组长度超过10条时, 会调用另一种排序方法(快速排序); 而10条及以下采用的是插入算法,此时结果将是稳定的, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [&#123; n: <span class="string">"a"</span>, v: <span class="number">1</span> &#125;, &#123; n: <span class="string">"b"</span>, v: <span class="number">1</span> &#125;, &#123; n: <span class="string">"c"</span>, v: <span class="number">1</span> &#125;, &#123; n: <span class="string">"d"</span>, v: <span class="number">1</span> &#125;, &#123; n: <span class="string">"e"</span>, v: <span class="number">1</span> &#125;, &#123; n: <span class="string">"f"</span>, v: <span class="number">1</span> &#125;, &#123; n: <span class="string">"g"</span>, v: <span class="number">1</span> &#125;, &#123; n: <span class="string">"h"</span>, v: <span class="number">1</span> &#125;, &#123; n: <span class="string">"i"</span>, v: <span class="number">1</span> &#125;, &#123; n: <span class="string">"j"</span>, v: <span class="number">1</span> &#125;,];</span><br><span class="line">array.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.v - b.v;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>,len = array.length; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(array[i].n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//a b c d e f g h i j</span></span><br></pre></td></tr></table></figure>
<p>从a 到 j 刚好10条数据.</p>
<p>那么我们该如何规避Chrome浏览器的这种”bug”呢? 其实很简单, 只需略动手脚, 改变排序方法的返回值即可, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.v - b.v || array.indexOf(a)-array.indexOf(b);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>使用数组的sort方法需要注意一点: 各浏览器的针对sort方法内部算法实现不尽相同, 排序函数尽量只返回-1, 0, 1三种不同的值, 不要尝试返回true或false等其它数值, 因为可能导致不可靠的排序结果.</p>
<h6 id="u95EE_u9898_u5206_u6790"><a href="#u95EE_u9898_u5206_u6790" class="headerlink" title="问题分析"></a>问题分析</h6><p>sort方法传入的排序函数如果返回布尔值会导致什么样的结果呢?</p>
<p>以下是常见的浏览器以及脚本引擎:</p>
<table>
<thead>
<tr>
<th>Browser Name</th>
<th>ECMAScript Engine</th>
</tr>
</thead>
<tbody>
<tr>
<td>Internet Explorer 6 - 8</td>
<td>JScript</td>
</tr>
<tr>
<td>Internet Explorer 9 - 10</td>
<td>Chakra</td>
</tr>
<tr>
<td>Firefox</td>
<td>IonMonkey(Monkey系列引擎), TraceMonkey, Gecko</td>
</tr>
<tr>
<td>Chrome</td>
<td>V8</td>
</tr>
<tr>
<td>Safair</td>
<td>JavaScriptCore(SquirrelFish Extreme)</td>
</tr>
<tr>
<td>Opera</td>
<td>Carakan</td>
</tr>
</tbody>
</table>
<p>分析以下代码，预期将数组元素进行升序排序：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line"><span class="keyword">var</span> comparefn = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x &gt; y;</span><br><span class="line">&#125;;</span><br><span class="line">array.sort(comparefn);</span><br></pre></td></tr></table></figure>
<p>代码中，comparefn 函数返回值为 bool 类型，并非为规范规定的 -1、0、1 值。那么执行此代码，各 JS 脚本引擎实现情况如何？</p>
<table>
<thead>
<tr>
<th></th>
<th>输出结果</th>
<th>是否符合预期</th>
</tr>
</thead>
<tbody>
<tr>
<td>JScript</td>
<td>[2, 3, 5, 1, 4, 6, 7, 0, 8, 9]</td>
<td>否</td>
</tr>
<tr>
<td>Carakan</td>
<td>[0, 1, 3, 8, 2, 4, 9, 5, 6, 7]</td>
<td>否</td>
</tr>
<tr>
<td>Chakra &amp; JavaScriptCore</td>
<td>[7, 6, 5, 4, 3, 2, 1, 0, 8, 9]</td>
<td>否</td>
</tr>
<tr>
<td>IonMonkey</td>
<td>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</td>
<td>是</td>
</tr>
<tr>
<td>V8</td>
<td>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</td>
<td>是</td>
</tr>
</tbody>
</table>
<p><strong>根据表中数据可见，当数组内元素个数小于等于 10 时:</strong></p>
<ul>
<li>JScript &amp; Carakan 排序结果有误</li>
<li>Chakra &amp; JavaScriptCore 看起来没有进行排序</li>
<li>IonMonkey 返回了预期的正确结果</li>
<li>V8 暂时看起来排序正确</li>
</ul>
<p><strong>将数组元素扩大至 11 位:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>];</span><br><span class="line"><span class="keyword">var</span> comparefn = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x &gt; y;</span><br><span class="line">&#125;;</span><br><span class="line">array.sort(comparefn);</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th></th>
<th>输出结果</th>
<th>是否符合预期</th>
</tr>
</thead>
<tbody>
<tr>
<td>JScript</td>
<td>[2, 3, 5, 1, 4, 6, 7, 0, 8, 9, 10]</td>
<td>否</td>
</tr>
<tr>
<td>Carakan</td>
<td>[0, 1, 3, 8, 2, 4, 9, 5, 10, 6, 7]</td>
<td>否</td>
</tr>
<tr>
<td>Chakra &amp; JavaScriptCore</td>
<td>[7, 6, 5, 4, 3, 2, 1, 0, 10, 8, 9]</td>
<td>否</td>
</tr>
<tr>
<td>IonMonkey</td>
<td>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</td>
<td>是</td>
</tr>
<tr>
<td>V8</td>
<td>[5, 0, 1, 2, 3, 4, 6, 7, 8, 9, 10]</td>
<td>否</td>
</tr>
</tbody>
</table>
<p><strong>根据表中数据可见，当数组内元素个数大于 10 时：</strong></p>
<ul>
<li>JScript &amp; Carakan 排序结果有误</li>
<li>Chakra &amp; JavaScriptCore 看起来没有进行排序</li>
<li>IonMonkey 返回了预期的正确结果</li>
<li>V8 <strong>排序结果由正确转为不正确</strong></li>
</ul>
<h5 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h5><p>splice()方法用新元素替换旧元素的方式来修改数组.</p>
<p>语法: arr.splice(start,deleteCount[, item1[, item2[, …]]])</p>
<p>start 指定从哪一位开始修改内容. 如果超过了数组长度, 则从数组末尾开始添加内容; 如果是负值, 则其指定的索引位置等同于 length+start (length为数组的长度), 表示从数组末尾开始的第 -start 位.</p>
<p>deleteCount 指定要删除的元素个数, 若等于0 ,则不删除. 这种情况下, 至少应该添加一位新元素. 若大于start之后的元素总和, 则start及之后的元素都将被删除.</p>
<p>itemN 指定新增的元素, 如果缺省, 则该方法只删除数组元素.</p>
<p>返回值 由原数组中被删除元素组成的数组,如果没有删除, 则返回一个空数组.</p>
<p>下面来举栗子说明:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">"apple"</span>,<span class="string">"boy"</span>];</span><br><span class="line"><span class="keyword">var</span> splices = array.splice(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(array);<span class="comment">//["apple"]</span></span><br><span class="line"><span class="built_in">console</span>.log(splices);<span class="comment">//["boy"] ,可见是从数组下标为1的元素开始删除,并且删除一个元素,由于itemN缺省,故此时该方法只删除元素</span></span><br><span class="line"></span><br><span class="line">array = [<span class="string">"apple"</span>,<span class="string">"boy"</span>];</span><br><span class="line">splices = array.splice(<span class="number">2</span>,<span class="number">1</span>,<span class="string">"cat"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(array);<span class="comment">//["apple", "boy", "cat"]</span></span><br><span class="line"><span class="built_in">console</span>.log(splices);<span class="comment">//[], 可见由于start超过数组长度,此时从数组末尾开始添加元素,并且原数组不会发生删除行为</span></span><br><span class="line"></span><br><span class="line">array = [<span class="string">"apple"</span>,<span class="string">"boy"</span>];</span><br><span class="line">splices = array.splice(-<span class="number">2</span>,<span class="number">1</span>,<span class="string">"cat"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(array);<span class="comment">//["cat", "boy"]</span></span><br><span class="line"><span class="built_in">console</span>.log(splices);<span class="comment">//["apple"], 可见当start为负值时,是从数组末尾开始的第-start位开始删除,删除一个元素,并且从此处插入了一个元素</span></span><br><span class="line"></span><br><span class="line">array = [<span class="string">"apple"</span>,<span class="string">"boy"</span>];</span><br><span class="line">splices = array.splice(-<span class="number">3</span>,<span class="number">1</span>,<span class="string">"cat"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(array);<span class="comment">//["cat", "boy"]</span></span><br><span class="line"><span class="built_in">console</span>.log(splices);<span class="comment">//["apple"], 可见即使-start超出数组长度,数组默认从首位开始删除</span></span><br><span class="line"></span><br><span class="line">array = [<span class="string">"apple"</span>,<span class="string">"boy"</span>];</span><br><span class="line">splices = array.splice(<span class="number">0</span>,<span class="number">3</span>,<span class="string">"cat"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(array);<span class="comment">//["cat"]</span></span><br><span class="line"><span class="built_in">console</span>.log(splices);<span class="comment">//["apple", "boy"], 可见当deleteCount大于数组start之后的元素总和时,start及之后的元素都将被删除</span></span><br></pre></td></tr></table></figure>
<p>同上, splice一样受益于鸭式辨型, 比如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="string">"apple"</span>,<span class="number">1</span>:<span class="string">"boy"</span>,length:<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> splices = <span class="built_in">Array</span>.prototype.splice.call(o,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(o);<span class="comment">//Object &#123;0: "apple", length: 1&#125;, 可见对象o删除了一个属性,并且length-1</span></span><br><span class="line"><span class="built_in">console</span>.log(splices);<span class="comment">//["boy"]</span></span><br></pre></td></tr></table></figure>
<p>注: 如果类数组对象没有length属性, splice将为该类数组对象添加length属性,并初始化为0. 此处栗子忽略. 如果需要请在<a href="https://github.com/Louiszhai" target="_blank" rel="external">评论</a>里反馈.</p>
<p>如果需要删除数组中一个已存在的元素, 可参考如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>];</span><br><span class="line">array.splice(array.indexOf(<span class="string">'b'</span>),<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h5 id="unshift"><a href="#unshift" class="headerlink" title="unshift"></a>unshift</h5><p>unshift() 方法用于在数组开始处插入一些元素(感觉像栈底插入), 并返回数组新的长度.</p>
<p>语法: arr.unshift(element1, …, elementN)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>];</span><br><span class="line"><span class="keyword">var</span> length = array.unshift(<span class="string">"yellow"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(array);<span class="comment">//["yellow", "red", "green", "blue"]</span></span><br><span class="line"><span class="built_in">console</span>.log(length);<span class="comment">//4</span></span><br></pre></td></tr></table></figure>
<p>如果给unshift方法传入一个数组呢?</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>];</span><br><span class="line"><span class="keyword">var</span> length = array.unshift([<span class="string">"yellow"</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(array);<span class="comment">//[["yellow"], "red", "green", "blue"]</span></span><br><span class="line"><span class="built_in">console</span>.log(length);<span class="comment">//4, 可见数组也能成功插入</span></span><br></pre></td></tr></table></figure>
<p>同上, unshift也受益于鸭式辨型, 呈上栗子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="string">"red"</span>, <span class="number">1</span>:<span class="string">"green"</span>, <span class="number">2</span>:<span class="string">"blue"</span>,length:<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> length = <span class="built_in">Array</span>.prototype.unshift.call(o,<span class="string">"gray"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(o);<span class="comment">//Object &#123;0: "gray", 1: "red", 2: "green", 3: "blue", length: 4&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(length);<span class="comment">//4</span></span><br></pre></td></tr></table></figure>
<p>注: 如果类数组对象不指定length属性, 则返回结果是这样的 Object {0: “gray”, 1: “green”, 2: “blue”, length: 1}, shift会认为数组长度为0, 此时将从对象下标为0的位置开始插入, 相应位置属性将被替换, 此时初始化类数组对象的length属性为插入元素个数.</p>
<h5 id="copyWithin"><a href="#copyWithin" class="headerlink" title="copyWithin"></a>copyWithin</h5><p>copyWithin() 方法用于数组内的元素替换, 即替换元素和被替换元素均是数组内的元素.</p>
<p>语法: arr.copyWithin(target, start[, end = this.length])</p>
<p>taget 指定被替换元素的索引, start 指定替换元素起始的索引, end 可选, 指的是替换元素结束位置的索引.</p>
<p>如果start为负，则其指定的索引位置等同于length+start，length为数组的长度。end也是如此.</p>
<p>注: 目前只有Firefox(版本32及其以上版本)实现了该方法.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]; </span><br><span class="line"><span class="keyword">var</span> array2 = array.copyWithin(<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(array===array2,array2);<span class="comment">// true [4, 5, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]; </span><br><span class="line"><span class="built_in">console</span>.log(array.copyWithin(<span class="number">0</span>,<span class="number">3</span>,<span class="number">4</span>));<span class="comment">// [4, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]; </span><br><span class="line"><span class="built_in">console</span>.log(array.copyWithin(<span class="number">0</span>,-<span class="number">2</span>,-<span class="number">1</span>));<span class="comment">// [4, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>
<p>同上, copyWithin一样受益于鸭式辨型, 例如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="number">1</span>, <span class="number">1</span>:<span class="number">2</span>, <span class="number">2</span>:<span class="number">3</span>, <span class="number">3</span>:<span class="number">4</span>, <span class="number">4</span>:<span class="number">5</span>,length:<span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="built_in">Array</span>.prototype.copyWithin.call(o,<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(o===o2,o2);<span class="comment">//true Object &#123; 0=4,  1=5,  2=3,  更多...&#125;</span></span><br></pre></td></tr></table></figure>
<p>如需在Firefox之外的浏览器使用copyWithin方法,请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin#Polyfill" target="_blank" rel="external">Polyfill</a>.</p>
<h5 id="fill"><a href="#fill" class="headerlink" title="fill"></a>fill</h5><p>fill() 方法同样用于数组元素替换, 它可将数组指定区间内的元素替换为某个值.</p>
<p>语法: <em>arr</em>.fill(value, start[, end = this.length])</p>
<p>value 指定被替换的值, start 指定替换元素起始的索引, end 可选, 指的是替换元素结束位置的索引.</p>
<p>如果start为负，则其指定的索引位置等同于length+start，length为数组的长度。end也是如此.</p>
<p>注: 目前只有Firefox(版本31及其以上版本)实现了该方法.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> array2 = array.fill(<span class="number">10</span>,<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(array===array2,array2);<span class="comment">// true [10, 10, 10, 4, 5], 可见数组区间[0,3]的元素全部替换为10</span></span><br><span class="line"><span class="comment">//其他的举例请参考copyWithin</span></span><br></pre></td></tr></table></figure>
<p>同上, fill 一样受益于鸭式辨型, 例如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="number">1</span>, <span class="number">1</span>:<span class="number">2</span>, <span class="number">2</span>:<span class="number">3</span>, <span class="number">3</span>:<span class="number">4</span>, <span class="number">4</span>:<span class="number">5</span>,length:<span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="built_in">Array</span>.prototype.fill.call(o,<span class="number">10</span>,<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(o===o2,o2); <span class="literal">true</span> <span class="built_in">Object</span> &#123; <span class="number">0</span>=<span class="number">10</span>,  <span class="number">1</span>=<span class="number">10</span>,  <span class="number">2</span>=<span class="number">3</span>,  更多...&#125;</span><br></pre></td></tr></table></figure>
<p>如需在Firefox之外的浏览器使用copyWithin方法,请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/fill#Compatibility" target="_blank" rel="external">Polyfill</a>.</p>
<h4 id="u4E0D_u4F1A_u6539_u53D8_u81EA_u8EAB_u7684_u65B9_u6CD5_289_u4E2A_29"><a href="#u4E0D_u4F1A_u6539_u53D8_u81EA_u8EAB_u7684_u65B9_u6CD5_289_u4E2A_29" class="headerlink" title="不会改变自身的方法(9个)"></a>不会改变自身的方法(9个)</h4><p>基于ES7, 不会改变自身的方法一共有9个, 分别为concat, join, slice, toString, toLocateString, indexOf, lastIndexOf, 未标准的toSource, 以及ES7新增的方法includes.z</p>
<h5 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h5><p>concat() 方法将传入的数组或者元素与原数组合并, 组成一个新的数组并返回.</p>
<p>语法: <em>arr</em>.concat(<em>value1</em>, <em>value2</em>, …, <em>valueN</em>)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> array2 = array.concat(<span class="number">4</span>,[<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(array2);<span class="comment">//[1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"><span class="built_in">console</span>.log(array);<span class="comment">//[1, 2, 3], 可见原数组并未被修改</span></span><br></pre></td></tr></table></figure>
<p>同上, concat 一样受益于鸭式辨型, 但其效果可能达不到我们的期望, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="string">"a"</span>, <span class="number">1</span>:<span class="string">"b"</span>, <span class="number">2</span>:<span class="string">"c"</span>,length:<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="built_in">Array</span>.prototype.concat.call(o,<span class="string">'d'</span>,&#123;<span class="number">3</span>:<span class="string">'e'</span>,<span class="number">4</span>:<span class="string">'f'</span>,length:<span class="number">2</span>&#125;,[<span class="string">'g'</span>,<span class="string">'h'</span>,<span class="string">'i'</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(o2);<span class="comment">//[&#123;0:"a", 1:"b", 2:"c", length:3&#125;, 'd', &#123;3:'e', 4:'f', length:2&#125;, 'g', 'h', 'i']</span></span><br></pre></td></tr></table></figure>
<p>可见, 类数组对象合并后返回的是依然是数组, 并不是我们期望的对象.</p>
<h5 id="join"><a href="#join" class="headerlink" title="join"></a>join</h5><p>join() 方法将数组中的所有元素连接成一个字符串.</p>
<p>语法: str = arr.join([separator = ‘,’]) separator可选, 缺省默认为逗号</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">'We'</span>, <span class="string">'are'</span>, <span class="string">'Chinese'</span>];</span><br><span class="line"><span class="built_in">console</span>.log(array.join());<span class="comment">//We,are,Chinese</span></span><br><span class="line"><span class="built_in">console</span>.log(array.join(<span class="string">'+'</span>));<span class="comment">//We+are+Chinese</span></span><br><span class="line"><span class="built_in">console</span>.log(array.join(<span class="string">''</span>));<span class="comment">//WeareChinese</span></span><br></pre></td></tr></table></figure>
<p>同上, join 一样受益于鸭式辨型, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="string">"We"</span>, <span class="number">1</span>:<span class="string">"are"</span>, <span class="number">2</span>:<span class="string">"Chinese"</span>, length:<span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.join.call(o,<span class="string">'+'</span>));<span class="comment">//We+are+Chinese</span></span><br></pre></td></tr></table></figure>
<h5 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h5><p>slice() 方法将数组中一部分元素浅复制存入新的数组对象, 并且返回这个数组对象.</p>
<p>语法: arr.slice(start[, end])</p>
<p>参数 start 指定复制开始位置的索引, end如果有值则表示复制结束位置的索引(不包括此位置).</p>
<p>如果 start 的值为负数, 假如数组长度为 length, 则表示从 length+start 的位置开始复制, 此时参数 end 如果有值, 只能是比 start 大的负数, 否则将返回空数组.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>,<span class="string">"four"</span>, <span class="string">"five"</span>];</span><br><span class="line"><span class="keyword">var</span> array2 = array.slice(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(array2);<span class="comment">//["three"]</span></span><br></pre></td></tr></table></figure>
<p><em>浅复制</em> 是指当对象的被复制时, 只是复制了对象的引用, 指向的依然是同一个对象. 下面来说明slice为什么是浅复制.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [&#123;color:<span class="string">"yellow"</span>&#125;, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> array2 = array.slice(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(array2);<span class="comment">//[&#123;color:"yellow"&#125;]</span></span><br><span class="line">array[<span class="number">0</span>][<span class="string">"color"</span>] = <span class="string">"blue"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(array2);<span class="comment">//[&#123;color:"bule"&#125;]</span></span><br></pre></td></tr></table></figure>
<p>由于slice是浅复制, 复制到的对象只是一个引用, 改变原数组array的值, array2也随之改变.</p>
<p>同时, 稍微利用下 slice 方法第一个参数为负数时的特性, 我们可以非常方便的拿到数组的最后一项元素, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].slice(-<span class="number">1</span>));<span class="comment">//[3]</span></span><br></pre></td></tr></table></figure>
<p>同上, slice 一样受益于鸭式辨型, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:&#123;<span class="string">"color"</span>:<span class="string">"yellow"</span>&#125;, <span class="number">1</span>:<span class="number">2</span>, <span class="number">2</span>:<span class="number">3</span>, length:<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="built_in">Array</span>.prototype.slice.call(o,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(o2);<span class="comment">//[&#123;color:"yellow"&#125;] ,毫无违和感...</span></span><br></pre></td></tr></table></figure>
<p>鉴于IE9以下版本对于该方法支持性并不是很好, 如需更好的支持低版本IE浏览器, 请参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/slice#更可靠地跨浏览器" target="_blank" rel="external">更可靠地跨浏览器</a></p>
<h5 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h5><p>toString() 方法返回数组的字符串形式, 该字符串由数组中的每个元素的 <code>toString()</code> 返回值经调用 <code>join()</code> 方法连接（由逗号隔开）组成.</p>
<p>语法: <em>arr</em>.toString()</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">'Jan'</span>, <span class="string">'Feb'</span>, <span class="string">'Mar'</span>, <span class="string">'Apr'</span>];</span><br><span class="line"><span class="keyword">var</span> str = array.toString();</span><br><span class="line"><span class="built_in">console</span>.log(str);<span class="comment">//Jan,Feb,Mar,Apr</span></span><br></pre></td></tr></table></figure>
<p>当数组直接和字符串作连接操作时, 将会自动调用其toString() 方法.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = [<span class="string">'Jan'</span>, <span class="string">'Feb'</span>, <span class="string">'Mar'</span>, <span class="string">'Apr'</span>] + <span class="string">',May'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str);<span class="comment">//Jan,Feb,Mar,Apr,May</span></span><br><span class="line"><span class="comment">//下面我们来试试鸭式辨型</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="string">'Jan'</span>, <span class="number">1</span>:<span class="string">'Feb'</span>, <span class="number">2</span>:<span class="string">'Mar'</span>, length:<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="built_in">Array</span>.prototype.toString.call(o);</span><br><span class="line"><span class="built_in">console</span>.log(o2);<span class="comment">//[object Object]</span></span><br><span class="line"><span class="built_in">console</span>.log(o.toString()==o2);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>可见, Array.prototype.toString()方法处理类数组对象时, 跟类数组对象直接调用Object.prototype.toString() 方法结果完全一致, 说好的鸭式辨型呢?</p>
<p>根据ES5语义, toString() 方法是通用的, 可被用于任何对象, 如果对象有一个join() 方法, 将会被调用, 其返回值将被返回, 没有则调用Object.prototype.toString(), 为此, 我们给o对象添加一个join方法, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  <span class="number">0</span>:<span class="string">'Jan'</span>, </span><br><span class="line">  <span class="number">1</span>:<span class="string">'Feb'</span>, </span><br><span class="line">  <span class="number">2</span>:<span class="string">'Mar'</span>, </span><br><span class="line">  length:<span class="number">3</span>, </span><br><span class="line">  join:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.join.call(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.toString.call(o));<span class="comment">//Jan,Feb,Mar</span></span><br></pre></td></tr></table></figure>
<h5 id="toLocaleString-NaN"><a href="#toLocaleString-NaN" class="headerlink" title="toLocaleString"></a>toLocaleString</h5><p>toLocaleString() 类似toString()的变体, 该字符串由数组中的每个元素的 <code>toLocaleString()</code> 返回值经调用 <code>join()</code> 方法连接（由逗号隔开）组成.</p>
<p>语法: <em>arr</em>.toLocaleString()</p>
<p>数组中的元素将调用各自的 toLocaleString 方法:</p>
<ul>
<li><code>Object</code>: <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toLocaleString" target="_blank" rel="external"><code>Object.prototype.toLocaleString()</code></a></li>
<li><code>Number</code>: <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString" target="_blank" rel="external"><code>Number.prototype.toLocaleString()</code></a></li>
<li><code>Date</code>: <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/toLocaleString" target="_blank" rel="external"><code>Date.prototype.toLocaleString()</code></a></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array= [&#123;name:<span class="string">'zz'</span>&#125;, <span class="number">123</span>, <span class="string">"abc"</span>, <span class="keyword">new</span> <span class="built_in">Date</span>()];</span><br><span class="line"><span class="keyword">var</span> str = array.toLocaleString();</span><br><span class="line"><span class="built_in">console</span>.log(str);<span class="comment">//[object Object],123,abc,2016/1/5 下午1:06:23</span></span><br></pre></td></tr></table></figure>
<p>其鸭式辨型的写法也同toString 保持一致, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  <span class="number">0</span>:<span class="number">123</span>, </span><br><span class="line">  <span class="number">1</span>:<span class="string">'abc'</span>, </span><br><span class="line">  <span class="number">2</span>:<span class="keyword">new</span> <span class="built_in">Date</span>(), </span><br><span class="line">  length:<span class="number">3</span>, </span><br><span class="line">  join:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.join.call(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.toLocaleString.call(o));<span class="comment">//123,abc,2016/1/5 下午1:16:50</span></span><br></pre></td></tr></table></figure>
<h5 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h5><p>indexOf() 方法用于查找元素在数组中第一次出现时的索引, 如果没有, 则返回-1.</p>
<p>语法: <em>arr</em>.indexOf(element, fromIndex=0)</p>
<p>element 为需要查找的元素</p>
<p>fromIndex 为开始查找的位置, 缺省默认为0. 如果超出数组长度, 则返回-1. 如果为负值, 假设数组长度为length, 则从数组的第 length + fromIndex项开始往数组末尾查找, 如果length + fromIndex&lt;0 则整个数组都会被查找.</p>
<p>indexOf使用严格相等(即使用 === 去匹配数组中的元素)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">'abc'</span>, <span class="string">'def'</span>, <span class="string">'ghi'</span>,<span class="string">'123'</span>];</span><br><span class="line"><span class="built_in">console</span>.log(array.indexOf(<span class="string">'def'</span>));<span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(array.indexOf(<span class="string">'def'</span>,-<span class="number">1</span>));<span class="comment">//1 此时表示从最后一个元素往后查找,因此查找失败返回-1</span></span><br><span class="line"><span class="built_in">console</span>.log(array.indexOf(<span class="string">'def'</span>,-<span class="number">4</span>));<span class="comment">//1 由于4大于数组长度,此时将查找整个数组,因此返回1</span></span><br><span class="line"><span class="built_in">console</span>.log(array.indexOf(<span class="number">123</span>));<span class="comment">//-1, 由于是严格匹配,因此并不会匹配到字符串'123'</span></span><br></pre></td></tr></table></figure>
<p>得益于鸭式辨型, indexOf 可以处理类数组对象, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="string">'abc'</span>, <span class="number">1</span>:<span class="string">'def'</span>, <span class="number">2</span>:<span class="string">'ghi'</span>, length:<span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.indexOf.call(o,<span class="string">'ghi'</span>,-<span class="number">4</span>));<span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>然而该方法并不支持IE9以下版本, 如需更好的支持低版本IE浏览器(IE6~8), 请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf#Polyfill" target="_blank" rel="external">Polyfill</a>.</p>
<h5 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf"></a>lastIndexOf</h5><p>lastIndexOf() 方法用于查找元素在数组中最后一次出现时的索引, 如果没有, 则返回-1. 并且它是indexOf的逆向查找, 即从数组最后一个往前查找.</p>
<p>语法: <em>arr</em>.lastIndexOf(element, fromIndex=length-1)</p>
<p>element 为需要查找的元素</p>
<p>fromIndex 为开始查找的位置, 缺省默认为数组长度length-1. 如果超出数组长度, 由于是逆向查找, 则查找整个数组. 如果为负值, 则从数组的第 length + fromIndex项开始往数组开头查找, 如果length + fromIndex&lt;0 则数组不会被查找.</p>
<p>同 indexOf 一样, lastIndexOf 也是严格匹配数组元素.</p>
<p>栗子参考 <code>indexOf</code> , 不再详述, 兼容低版本IE浏览器(IE6~8), 请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf#Compatibility" target="_blank" rel="external">Polyfill</a>.</p>
<h5 id="includes_28ES6_29"><a href="#includes_28ES6_29" class="headerlink" title="includes(ES6)"></a>includes(ES6)</h5><p>includes() 方法基于<strong>ECMAScript 2015（ES6）规范</strong>, 它用来判断当前数组是否包含某个指定的值, 如果是, 则返回 true, 否则返回 false.</p>
<p>语法: <em>arr</em>.includes(element, fromIndex=0)</p>
<p>element 为需要查找的元素</p>
<p>fromIndex 表示从该索引位置开始查找 element, 缺省为0, 它是正向查找, 即从索引处往数组末尾查找.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="literal">NaN</span>];</span><br><span class="line"><span class="built_in">console</span>.log(array.includes(<span class="number">1</span>));<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(array.includes(<span class="literal">NaN</span>));<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(array.includes(<span class="number">2</span>,-<span class="number">4</span>));<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>该方法同样受益于鸭式辨型. 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="string">'a'</span>, <span class="number">1</span>:<span class="string">'b'</span>, <span class="number">2</span>:<span class="string">'c'</span>, length:<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> bool = <span class="built_in">Array</span>.prototype.includes.call(o, <span class="string">'a'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(bool);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>该方法只有在Chrome 47, opera 34, Safari 9版本及其更高版本中才予以实现. 如需支持其他浏览器, 请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/includes#Polyfill" target="_blank" rel="external">Polyfill</a>.</p>
<h5 id="startsWith"><a href="#startsWith" class="headerlink" title="startsWith"></a>startsWith</h5><p>startsWith() 方法基于<strong>ECMAScript 2015（ES6）规范</strong>, 它用来判断当前数组是否包含某个指定的值, 如果是, 则返回 true, 否则返回 false.</p>
<p>语法: <em>arr</em>.includes(element, fromIndex=0)</p>
<h5 id="endsWith"><a href="#endsWith" class="headerlink" title="endsWith"></a>endsWith</h5><h5 id="toSource"><a href="#toSource" class="headerlink" title="toSource"></a>toSource</h5><p>toSource() 方法是非标准的, 该方法返回数组的源代码, 目前只有 Firefox 实现了它.</p>
<p>语法: <em>arr</em>.toSource()</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="built_in">console</span>.log(array.toSource());<span class="comment">//["a", "b", "c"]</span></span><br><span class="line"><span class="comment">//测试鸭式辨型</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="string">'a'</span>, <span class="number">1</span>:<span class="string">'b'</span>, <span class="number">2</span>:<span class="string">'c'</span>, length:<span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.toSource.call(o));<span class="comment">//["a","b","c"]</span></span><br></pre></td></tr></table></figure>
<h4 id="u904D_u5386_u65B9_u6CD5_2812_u4E2A_29"><a href="#u904D_u5386_u65B9_u6CD5_2812_u4E2A_29" class="headerlink" title="遍历方法(12个)"></a>遍历方法(12个)</h4><p>基于ES6, 不会改变自身的方法一共有12个, 分别为forEach, every, some, filter, map, reduce, reduceRight, 以及ES6新增的方法entries, find, findIndex, keys, values.</p>
<h5 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h5><p>forEach() 方法指定数组的每项元素都执行一次传入的函数, 返回值为undefined.</p>
<p>语法: <em>arr</em>.forEach(fn, thisArg)</p>
<p>fn 表示在数组每一项上执行的函数, 接受三个参数:</p>
<ul>
<li>value 当前正在被处理的元素的值</li>
<li>index 当前元素的数组索引</li>
<li>array 数组本身</li>
</ul>
<p>thisArg 可选, 用来当做fn函数内的this对象(context 上下文).</p>
<p>forEach 将为数组中每一项执行一次 fn 函数, 那些已删除, 新增或者从未赋值的项将被跳过(但不包括值为 undefined 的项). 遍历过程中, fn会被传入上述三个参数.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> obj = &#123;name:<span class="string">'cc'</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> sReturn = array.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value, index, array</span>)</span>&#123;</span><br><span class="line">  array[index] = value * value;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);<span class="comment">//cc被打印了三次</span></span><br><span class="line">&#125;,obj);</span><br><span class="line"><span class="built_in">console</span>.log(array);<span class="comment">//[1, 9, 25], 可见原数组改变了</span></span><br><span class="line"><span class="built_in">console</span>.log(sReturn);<span class="comment">//undefined, 可见返回值为undefined</span></span><br></pre></td></tr></table></figure>
<p>得益于鸭式辨型, 虽然forEach不能直接遍历对象, 但它可以通过call方式遍历类数组对象. 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="number">1</span>, <span class="number">1</span>:<span class="number">3</span>, <span class="number">2</span>:<span class="number">5</span>, length:<span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">Array</span>.prototype.forEach.call(o,<span class="function"><span class="keyword">function</span>(<span class="params">value, index, obj</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value,index,obj);</span><br><span class="line">  obj[index] = value * value;</span><br><span class="line">&#125;,o);</span><br><span class="line"><span class="comment">//1 0 Object &#123;0: 1, 1: 3, 2: 5, length: 3&#125;</span></span><br><span class="line"><span class="comment">//3 1 Object &#123;0: 1, 1: 3, 2: 5, length: 3&#125;</span></span><br><span class="line"><span class="comment">//5 2 Object &#123;0: 1, 1: 9, 2: 5, length: 3&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(o);<span class="comment">//Object &#123;0: 1, 1: 9, 2: 25, length: 3&#125;</span></span><br></pre></td></tr></table></figure>
<p>参考前面的文章 <a href="http://louiszhai.github.io/2015/12/18/traverse/#forEach"><code>详解JS遍历</code></a> 中 forEach的讲解, 我们知道, forEach无法直接退出循环, 只能使用return 来达到for循环中continue的效果, 并且forEach不能在低版本IE(6~8)中使用, 兼容写法请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach#兼容旧环境（Polyfill）" target="_blank" rel="external">Polyfill</a> .</p>
<h5 id="every"><a href="#every" class="headerlink" title="every"></a>every</h5><p>every() 方法使用传入的函数测试所有元素, 只要其中有一个函数返回值为 false, 那么该方法的结果为 false; 如果全部返回 true, 那么该方法的结果才为 true. 因此 every 方法存在如下规律:</p>
<ul>
<li>若需检测数组中存在元素大于100 (即, one &gt; 100), 那么我们需要在传入的函数中构造 “false” 返回值 (即, 返回 item &lt;= 100), 同时整个方法结果为 false 才表示数组存在元素满足条件; (简单理解为, 若是单项判断, 可用 one false ===&gt; false)</li>
</ul>
<ul>
<li>若需检测数组中是否所有元素都大于100 (即, all &gt; 100),  那么我们需要在传入的函数中构造 “true” 返回值 (即, 返回 item &gt; 100), 同时整个方法结果为 true 才表示数组所有元素均满足条件. (简单理解为, 若是全部判断, 可用 all true ===&gt; true)</li>
</ul>
<p>语法同上述forEach, 具体还可以参考 <a href="http://louiszhai.github.io/2015/12/18/traverse/#every"><code>详解JS遍历</code></a> 中every的讲解.</p>
<p>以下是鸭式辨型的写法:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="number">10</span>, <span class="number">1</span>:<span class="number">8</span>, <span class="number">2</span>:<span class="number">25</span>, length:<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> bool = <span class="built_in">Array</span>.prototype.every.call(o,<span class="function"><span class="keyword">function</span>(<span class="params">value, index, obj</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value &gt;= <span class="number">8</span>;</span><br><span class="line">&#125;,o);</span><br><span class="line"><span class="built_in">console</span>.log(bool);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>every 一样不能在低版本IE(6~8)中使用, 兼容写法请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/every#Compatibility" target="_blank" rel="external">Polyfill</a> .</p>
<h5 id="some"><a href="#some" class="headerlink" title="some"></a>some</h5><p>some() 方法刚好同 every() 方法相反, some 测试数组元素时, 只要有一个函数返回值为 true, 则该方法返回 true, 若全部返回 false, 则该方法返回 false. 因此 some 方法存在如下规律:</p>
<ul>
<li>若需检测数组中存在元素大于100 (即, one &gt; 100), 那么我们需要在传入的函数中构造 “true” 返回值 (即, 返回 item &gt; 100), 同时整个方法结果为 true 才表示数组存在元素满足条件; (简单理解为, 若是单项判断, 可用 one true ===&gt; true)</li>
</ul>
<ul>
<li>若需检测数组中是否所有元素都大于100 (即, all &gt; 100),  那么我们需要在传入的函数中构造 “false” 返回值 (即, 返回 item &lt;= 100), 同时整个方法结果为 false 才表示数组所有元素均满足条件. (简单理解为, 若是全部判断, 可用 all false ===&gt; false)</li>
</ul>
<p>some 的鸭式辨型写法可以参照every,  同样它也不能在低版本IE(6~8)中使用, 兼容写法请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/some#Compatibility" target="_blank" rel="external">Polyfill</a> .</p>
<h5 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h5><p>filter() 方法使用传入的函数测试所有元素, 并返回所有通过测试的元素组成的新数组.</p>
<p>语法: <em>arr</em>.filter(fn, thisArg)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">18</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">35</span>, <span class="number">80</span>];</span><br><span class="line"><span class="keyword">var</span> array2 = array.filter(<span class="function"><span class="keyword">function</span>(<span class="params">value, index, array</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value &gt; <span class="number">20</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(array2);<span class="comment">//[35, 80]</span></span><br></pre></td></tr></table></figure>
<p>filter一样支持鸭式辨型, 具体请参考every方法鸭式辨型写法. 其在低版本IE(6~8) 的兼容写法请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/filter#Compatibility" target="_blank" rel="external">Polyfill</a> .</p>
<h5 id="map"><a href="#map" class="headerlink" title="map"></a>map</h5><p>map() 方法遍历数组, 使用传入函数处理每个元素, 并返回函数的返回值组成的新数组.</p>
<p>语法: <em>arr</em>.map(fn, thisArg)</p>
<p>参数介绍同 forEach 方法的参数介绍.</p>
<p>具体用法请参考 <a href="http://louiszhai.github.io/2015/12/18/traverse/#map"><code>详解JS遍历</code></a> 中 map 的讲解.</p>
<p>map 一样支持鸭式辨型, 具体请参考every方法鸭式辨型写法.</p>
<p>其在低版本IE(6~8) 的兼容写法请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map#Compatibility" target="_blank" rel="external">Polyfill</a> .</p>
<h5 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h5><p>reduce() 方法接收一个方法作为累加器, 数组中的每个值(从左至右) 开始合并, 最终为一个值.</p>
<p>语法: <em>arr</em>.reduce(fn, initialValue)</p>
<p>fn 表示在数组每一项上执行的函数, 接受四个参数:</p>
<ul>
<li>previousValue 上一次调用回调返回的值, 或者是提供的初始值</li>
<li>value 数组中当前被处理元素的值</li>
<li>index 当前元素在数组中的索引</li>
<li>array 数组自身</li>
</ul>
<p>initialValue 指定第一次调用 fn 的第一个参数.</p>
<p>当 fn 第一次执行时, </p>
<ul>
<li>如果 initialValue 在调用 reduce 时被提供, 那么第一个 previousValue 将等于 initialValue, 此时 item 等于数组中的第一个值;</li>
<li>如果 initialValue 未被提供, 那么 previousVaule 等于数组中的第一个值, item 等于数组中的第二个值. 此时如果数组为空, 那么将抛出 TypeError.</li>
<li>如果数组仅有一个元素, 并且没有提供 initialValue, 或提供了 initialValue 但数组为空, 那么fn不会被执行, 数组的唯一值将被返回.</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> s = array.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">previousValue, value, index, array</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> previousValue * value;</span><br><span class="line">&#125;,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s);<span class="comment">//24</span></span><br></pre></td></tr></table></figure>
<p>以上回调被调用4次, 每次的参数和返回见下表:</p>
<table>
<thead>
<tr>
<th style="text-align:center">callback</th>
<th style="text-align:center">previousValue</th>
<th style="text-align:center">currentValue</th>
<th style="text-align:center">index</th>
<th style="text-align:center">array</th>
<th style="text-align:center">return value</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">第1次</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">[1,2,3,4]</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">第2次</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">[1,2,3,4]</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">第3次</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
<td style="text-align:center">[1,2,3,4]</td>
<td style="text-align:center">6</td>
</tr>
<tr>
<td style="text-align:center">第4次</td>
<td style="text-align:center">6</td>
<td style="text-align:center">4</td>
<td style="text-align:center">4</td>
<td style="text-align:center">[1,2,3,4]</td>
<td style="text-align:center">24</td>
</tr>
</tbody>
</table>
<p>reduce 一样支持鸭式辨型, 具体请参考every方法鸭式辨型写法.</p>
<p>其在低版本IE(6~8) 的兼容写法请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#兼容旧环境（Polyfill）" target="_blank" rel="external">Polyfill</a> .</p>
<h5 id="reduceRight"><a href="#reduceRight" class="headerlink" title="reduceRight"></a>reduceRight</h5><p>reduceRight() 方法接收一个方法作为累加器, 数组中的每个值(从右至左) 开始合并, 最终为一个值. 除了与reduce执行方向相反外, 其他完全与其一致, 请参考上述 reduce 方法介绍.</p>
<p>其在低版本IE(6~8) 的兼容写法请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight#.E5.85.BC.E5.AE.B9.E6.80.A7.E6.97.A7.E7.8E.AF.E5.A2.83.EF.BC.88Polyfill.EF.BC.89" target="_blank" rel="external">Polyfill</a> .</p>
<h5 id="entries_28ES6_29"><a href="#entries_28ES6_29" class="headerlink" title="entries(ES6)"></a>entries(ES6)</h5><p>entries() 方法基于<strong>ECMAScript 2015（ES6）规范</strong>, 返回一个数组迭代器对象, 该对象包含数组中每个索引的键值对.</p>
<p>语法: <em>arr</em>.entries()</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>];</span><br><span class="line"><span class="keyword">var</span> iterator = array.entries();</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value);<span class="comment">//[0, "a"]</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value);<span class="comment">//[1, "b"]</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value);<span class="comment">//[2, "c"]</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value);<span class="comment">//undefined, 迭代器处于数组末尾时, 再迭代就会返回undefined</span></span><br></pre></td></tr></table></figure>
<p>很明显, entries 也受益于鸭式辨型, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="string">"a"</span>, <span class="number">1</span>:<span class="string">"b"</span>, <span class="number">2</span>:<span class="string">"c"</span>, length:<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> iterator = <span class="built_in">Array</span>.prototype.entries.call(o);</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value);<span class="comment">//[0, "a"]</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value);<span class="comment">//[1, "b"]</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value);<span class="comment">//[2, "c"]</span></span><br></pre></td></tr></table></figure>
<p>由于该方法基于ES6, 因此目前并不支持所有浏览器, 以下是各浏览器支持版本:</p>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Chrome</th>
<th>Firefox (Gecko)</th>
<th>Internet Explorer</th>
<th>Opera</th>
<th>Safari</th>
</tr>
</thead>
<tbody>
<tr>
<td>Basic support</td>
<td>38</td>
<td><a href="https://developer.mozilla.org/en-US/Firefox/Releases/28" target="_blank" rel="external">28</a> (28)</td>
<td>未实现</td>
<td>25</td>
<td>7.1</td>
</tr>
</tbody>
</table>
<h5 id="find_26amp_3BfindIndex_28ES6_29"><a href="#find_26amp_3BfindIndex_28ES6_29" class="headerlink" title="find&amp;findIndex(ES6)"></a>find&amp;findIndex(ES6)</h5><p>find() 方法基于<strong>ECMAScript 2015（ES6）规范</strong>, 返回数组中第一个满足条件的元素(如果有的话), 如果没有, 则返回undefined.</p>
<p>findIndex() 方法则返回数组中第一个满足条件的元素的索引(如果有的话), 否则返回-1.</p>
<p>语法: <em>arr</em>.find(fn, thisArg), <em>arr</em>.findIndex(fn, thisArg)</p>
<p>我们发现它们的语法与forEach等十分相似, 其实不光语法, find(或findIndex) 在参数及其使用注意事项上, 均与forEach一致. 因此此处将略去 find(或findIndex) 的参数介绍. 下面我们来看个栗子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">value, index, array</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value%<span class="number">2</span>==<span class="number">0</span>;<span class="comment">//返回偶数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params">value, index, array</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value &gt; <span class="number">20</span>;<span class="comment">//返回大于20的数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(array.find(f));<span class="comment">//8</span></span><br><span class="line"><span class="built_in">console</span>.log(array.find(f2));<span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(array.findIndex(f));<span class="comment">//4</span></span><br><span class="line"><span class="built_in">console</span>.log(array.findIndex(f2));<span class="comment">//-1</span></span><br></pre></td></tr></table></figure>
<p>由于其鸭式辨型写法也与forEach方法一致, 故此处略去. </p>
<p>兼容性上我没有详测, 可以知道的是, 最新版的Chrome(47), 以及Firefox的版本25均实现了它们.</p>
<h5 id="keys_28ES6_29"><a href="#keys_28ES6_29" class="headerlink" title="keys(ES6)"></a>keys(ES6)</h5><p>keys() 方法基于<strong>ECMAScript 2015（ES6）规范</strong>,返回一个数组索引的迭代器. (实际实现可能会有调整)</p>
<p>语法: <em>arr</em>.keys()</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">"abc"</span>, <span class="string">"xyz"</span>];</span><br><span class="line"><span class="keyword">var</span> iterator = array.keys();</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());<span class="comment">//Object &#123;value: 0, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());<span class="comment">//Object &#123;value: 1, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());<span class="comment">//Object &#123;value: undefined, done: false&#125;</span></span><br></pre></td></tr></table></figure>
<p>索引迭代器会包含那些没有对应元素的索引, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">"abc"</span>, , <span class="string">"xyz"</span>];</span><br><span class="line"><span class="keyword">var</span> sparseKeys = <span class="built_in">Object</span>.keys(arr);</span><br><span class="line"><span class="keyword">var</span> denseKeys = [...arr.keys()];</span><br><span class="line"><span class="built_in">console</span>.log(sparseKeys); <span class="comment">// ["0", "2"]</span></span><br><span class="line"><span class="built_in">console</span>.log(denseKeys);  <span class="comment">// [0, 1, 2]</span></span><br></pre></td></tr></table></figure>
<p>其鸭式辨型写法请参考上述 entries 方法.</p>
<p>由于该方法基于ES6, 并未完全支持, 以下是各浏览器支持版本:</p>
<table>
<thead>
<tr>
<th style="text-align:center">Feature</th>
<th style="text-align:center">Chrome</th>
<th style="text-align:center">Firefox (Gecko)</th>
<th style="text-align:center">Internet Explorer</th>
<th style="text-align:center">Opera</th>
<th style="text-align:center">Safari</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Basic support</td>
<td style="text-align:center">38</td>
<td style="text-align:center"><a href="https://developer.mozilla.org/en-US/Firefox/Releases/28" target="_blank" rel="external">28</a> (28)</td>
<td style="text-align:center">未实现</td>
<td style="text-align:center">25</td>
<td style="text-align:center">7.1</td>
</tr>
</tbody>
</table>
<h5 id="values_28ES6_29"><a href="#values_28ES6_29" class="headerlink" title="values(ES6)"></a>values(ES6)</h5><p>values() 方法基于<strong>ECMAScript 2015（ES6）规范</strong>, 返回一个数组迭代器对象, 该对象包含数组中每个索引的值. 其用法基本与上述 entries 方法一致.</p>
<p>语法: <em>arr</em>.values()</p>
<p>遗憾的是, 现在没有浏览器实现了该方法, 因此下面将就着看看吧.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">"abc"</span>, <span class="string">"xyz"</span>];</span><br><span class="line"><span class="keyword">var</span> iterator = array.values();</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value);<span class="comment">//abc</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value);<span class="comment">//xyz</span></span><br></pre></td></tr></table></figure>
<h5 id="Symbol-iterator_28ES6_29"><a href="#Symbol-iterator_28ES6_29" class="headerlink" title="Symbol.iterator(ES6)"></a>Symbol.iterator(ES6)</h5><p>该方法基于<strong>ECMAScript 2015（ES6）规范</strong>, 同 values 方法功能相同.</p>
<p>语法: <em>arr</em>[Symbol.iterator]()</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">"abc"</span>, <span class="string">"xyz"</span>];</span><br><span class="line"><span class="keyword">var</span> iterator = array[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value);<span class="comment">//abc</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value);<span class="comment">//xyz</span></span><br></pre></td></tr></table></figure>
<p>其鸭式辨型写法请参考上述 entries 方法.</p>
<p>由于该方法基于ES6, 并未完全支持, 以下是各浏览器支持版本:</p>
<table>
<thead>
<tr>
<th style="text-align:center">Feature</th>
<th style="text-align:center">Chrome</th>
<th style="text-align:center">Firefox (Gecko)</th>
<th style="text-align:center">Internet Explorer</th>
<th style="text-align:center">Opera</th>
<th style="text-align:center">Safari</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Basic support</td>
<td style="text-align:center">38</td>
<td style="text-align:center"><a href="https://developer.mozilla.org/en-US/Firefox/Releases/36" target="_blank" rel="external">36</a> (36) <a href="#respond">1</a></td>
<td style="text-align:center">未实现</td>
<td style="text-align:center">25</td>
<td style="text-align:center">未实现</td>
</tr>
</tbody>
</table>
<h3 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h3><p>以上, Array.prototype 的各方法 基本介绍完毕, 这些方法之间存在很多共性. 比如:</p>
<ul>
<li>所有插入元素的方法, 比如 push, unshift, 一律返回数组新的长度;</li>
<li>所有删除元素的方法, 比如 pop, shift, splice 一律返回删除的元素, 或者返回删除的多个元素组成的数组;</li>
<li><p>部分遍历方法, 比如 forEach, every, some, filter, map, find, findIndex, 它们都接 function(value,index,array){} 和 thisArg 这样两个参数.</p>
<p>Array.prototype 的所有方法均具有鸭式辨型这种神奇的特性. 它们不止可以用来处理数组对象, 还可以处理类数组对象. </p>
</li>
</ul>
<p>例如 javascript 中一个纯天然的类数组对象字符串(String), 像join 方法就完全适用, 可惜的是 Array.prototype 中很多的方法均会去试图修改当前对象的 length 属性, 比如说 pop, push, shift, unshift 方法, 操作 String 对象时, 它就会报错.</p>
<p>还记得么, Array.prototype本身就是一个数组, 并且它的长度为0.</p>
<p>后续章节我们将继续探索Array的一些事情. 感谢您的阅读! </p>
<p>同时, 以下话题将会逐步去探讨, 敬请关注:</p>
<ul>
<li><code>unicode编码表</code></li>
</ul>
<ul>
<li><code>快速排序</code></li>
</ul>
<ul>
<li><code>插入排序</code></li>
</ul>
<hr>
<p>本问就讨论这么多内容,大家有什么问题或好的想法欢迎在下方参与<a href="#respond">留言和评论</a>.</p>
<p>本文作者: <a href="https://github.com/Louiszhai" target="_blank" rel="external">louis</a></p>
<p>本文链接: <a href="http://louiszhai.github.io/2015/12/29/array/">http://louiszhai.github.io/2015/12/29/array/</a></p>
<p>参考文章</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/prototype" target="_blank" rel="external">Array.prototype - JavaScript | MDN</a></li>
<li><a href="http://www.tuicool.com/articles/YjUBNbN" target="_blank" rel="external">Chrome谷歌浏览器中js代码Array.sort排序的bug乱序解决办法 - yzeng - 推酷</a></li>
<li><a href="http://www.w3help.org/zh-cn/causes/SJ9013" target="_blank" rel="external">SJ9013: Array.prototype.sort当使用了 comparefn 后返回值不为 -1、0、1时，各引擎实现排序结果不一致 - W3Help</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[JavaScript Array isArray map filter forEach every some push shift unshift sort indexOf]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://louiszhai.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[详解JS作用域链及闭包]]></title>
    <link href="http://louiszhai.github.io/2015/12/22/scopeChain/"/>
    <id>http://louiszhai.github.io/2015/12/22/scopeChain/</id>
    <published>2015-12-22T00:06:13.000Z</published>
    <updated>2016-05-17T01:07:43.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u5BFC_u8BFB"><a href="#u5BFC_u8BFB" class="headerlink" title="导读"></a>导读</h3><p>上一篇我们讲到for和while循环效率之低, 令人发指. 那么本篇我们将揭晓它们低效率的原因, 并给出优化建议. 欢迎阅读本篇<strong><code>详解JS作用域链及闭包</code></strong>.</p>
<a id="more"></a>
<h3 id="u56DE_u987E_u4E0A_u7BC7"><a href="#u56DE_u987E_u4E0A_u7BC7" class="headerlink" title="回顾上篇"></a>回顾上篇</h3><p>请先看上一篇中提到的for循环代码:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [];</span><br><span class="line">array.length = <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t1 = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>,length=array.length;i&lt;length;i++)&#123;</span><br><span class="line">  <span class="comment">//array.push(i);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> t2 = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="built_in">console</span>.log(t2-t1);</span><br><span class="line"><span class="comment">//由于此时CPU空闲较多,此时效率有些许提升,以下是连续5次的运行时间:</span></span><br><span class="line"><span class="comment">//4091+4038+4202+4415+4507 = 21253(ms)</span></span><br></pre></td></tr></table></figure>
<p>我们再看下面一段代码:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t1 = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//闭包</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>,length=array.length;i&lt;length;i++)&#123;</span><br><span class="line">  	<span class="comment">//array.push(i);</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">var</span> t2 = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="built_in">console</span>.log(t2-t1);</span><br><span class="line"><span class="comment">//以下是连续5次的运行时间:</span></span><br><span class="line"><span class="comment">//17+19+17+20+18 = 91(ms)</span></span><br></pre></td></tr></table></figure>
<p>计算一下: 21253/91 = 233 效率提升两百多倍, 为什么呢?</p>
<p>我们注意到两段代码最大的区别就是, 第二段代码使用了匿名函数包裹for循环. 我们将在后面讲到, 请耐心阅读.</p>
<h3 id="u4F5C_u7528_u57DF"><a href="#u4F5C_u7528_u57DF" class="headerlink" title="作用域"></a>作用域</h3><p>所谓作用域, <a href="http://blog.csdn.net/yueguanghaidao" target="_blank" rel="external">Skycrab</a> 有句解释还不错, 指的是, 变量在声明它们的函数体以及这个函数体嵌套的任意函数体内都是有定义的.</p>
<h4 id="js_u4E2D_u53EA_u6709_u51FD_u6570_u4F5C_u7528_u57DF"><a href="#js_u4E2D_u53EA_u6709_u51FD_u6570_u4F5C_u7528_u57DF" class="headerlink" title="js中只有函数作用域"></a>js中只有函数作用域</h4><p>众所周知, JS中并没有块作用域, 只有函数作用域. 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">  ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i);<span class="comment">//10</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line">f();</span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">//a is not defined</span></span><br></pre></td></tr></table></figure>
<p>因此 js 中只有一种局部作用域, 即函数作用域.</p>
<h4 id="u4F7F_u7528_var__u58F0_u660E_u53D8_u91CF"><a href="#u4F7F_u7528_var__u58F0_u660E_u53D8_u91CF" class="headerlink" title="使用 var 声明变量"></a>使用 var 声明变量</h4><p>通常我们知道, js 作为一种弱类型语言, 声明一个变量只需要var保留字, 如果在函数中不使用 var 声明变量, 该变量将提升为全局变量, 进而脱离函数作用域, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  b = <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line">f();</span><br><span class="line"><span class="built_in">console</span>.log(b);<span class="comment">//123</span></span><br></pre></td></tr></table></figure>
<p>此时相对于前面使用var声明的 a 变量, b 变量被提升为全局变量, 在函数作用域外依然可以访问.</p>
<p>既然在函数作用域内不使用 var 声明变量, 会将变量提升为全局变量, 那么在全局下, 不使用var, 会怎么样呢?</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局下不使用var声明,该变量依然是全局变量</span></span><br><span class="line">c = <span class="string">"hello scope"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(c);<span class="comment">//hello scope</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.c);<span class="comment">//hello scope</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查看c变量的属性</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(<span class="built_in">window</span>, <span class="string">'c'</span>));<span class="comment">//Object &#123;value: "hello scope", writable: true, enumerable: true, configurable: true&#125; ,此时c变量可赋值,可列举,可配置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//试着删除c变量</span></span><br><span class="line"><span class="keyword">delete</span> c;<span class="comment">//true 表示c变量被成功删除</span></span><br><span class="line"><span class="built_in">console</span>.log(c);<span class="comment">//c is not defined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.c);<span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用var声明后再删除d变量</span></span><br><span class="line"><span class="keyword">var</span> d = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(<span class="built_in">window</span>, <span class="string">'d'</span>));<span class="comment">//Object &#123;value: 1, writable: true, enumerable: true, configurable: false&#125; ,此时d变量可赋值,可列举,但不可配置</span></span><br><span class="line"><span class="keyword">delete</span> d;<span class="comment">//false 表示d变量删除失败</span></span><br><span class="line"><span class="built_in">console</span>.log(d);<span class="comment">//1 </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.d);<span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<p>综上, 有如下规律:</p>
<ul>
<li>不使用var保留字声明变量, 变量提升为全局变量, 而不论变量处于哪种作用域;</li>
<li>如果不使用var声明,  该变量便可配置, 即可被 delete 保留字删除, 删除后该变量便不可访问; 如果使用var声明, 该变量便不可配置, 即不能被 delete 保留字删除;</li>
<li>只要是全局变量都可以直接访问, 也可使用 “window.变量名” 来访问, 不管该变量是不是通过var来声明的;</li>
</ul>
<h3 id="JS_u4E2D_u7684_u4F5C_u7528_u57DF_u94FE"><a href="#JS_u4E2D_u7684_u4F5C_u7528_u57DF_u94FE" class="headerlink" title="JS中的作用域链"></a>JS中的作用域链</h3><p>函数对象和其它对象一样，拥有可以通过代码访问的属性和一系列仅供JavaScript引擎访问的内部属性。其中一个内部属性是[[Scope]]，由ECMA-262标准第三版定义，该内部属性包含了函数被创建的作用域中对象的集合，这个集合被称为函数的作用域链，它决定了哪些数据能被函数访问。</p>
<p>我们先看一个栗子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> e = <span class="string">"hello"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  e = <span class="string">"scope chain"</span>;</span><br><span class="line">  <span class="keyword">var</span> g = = <span class="string">"good"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上作用域链的图如下所示:</p>
<p><img src="/doc_images/scopeChain01.png" alt=""></p>
<p>函数执行时, 在函数 f 内部会生成一个 active object 和 scope chain. JavaScript引擎内部对象会放入 active object中, 外部的 e 变量处于scope chain的第二层, index=1, 而内部的g变量处于scope chain的顶层, index=0, 因此访问g变量总比访问e变量来的快些.</p>
<h3 id="u95ED_u5305"><a href="#u95ED_u5305" class="headerlink" title="闭包"></a>闭包</h3><p>聊到作用域, 就不得不说闭包, 那么, 什么是闭包?</p>
<p>“官方”的解释是：闭包是一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。</p>
<p>这是什么意思呢, 其实我也不懂.</p>
<p>通俗的讲就是: 闭包是一个函数, 并且这个函数可以访问其他函数内的局部变量.</p>
<p>可是我们都知道函数作用域是局部作用域, 为了做到让另一个函数访问它内部的变量, 恐怕只能将另一个函数放入它的内部, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> h = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  	<span class="keyword">var</span> j = <span class="number">3</span> + i + h;</span><br><span class="line">    <span class="built_in">console</span>.log(j);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ff = f();</span><br><span class="line">ff();<span class="comment">//6</span></span><br></pre></td></tr></table></figure>
<p>由于 f2 处于 f 的内部, 因此 f2 内可以访问到 f 的局部作用域, 这样通过返回 f2 就能保证在 f 函数外部也能访问到 i 变量.</p>
<p>当f2执行时, 变量 j 处于scope chain的 index0的位置上, 变量 i 和变量 h 分别处于 scope chain 的 index1 index2 的位置上. 因此 j 的赋值过程其实就是沿着 scope chain 第二层 第三层 依次找到 i 和 h 的值, 然后将它们和3一起求和, 最终赋值给 j .</p>
<p>浏览器沿着 scope chain 寻找变量总是需要耗费CPU时间, 越是 scope chain 的 外层(或者离f2越远的变量), 浏览器查找起来越是需要时间, 因为 scope chain 需要历经更多次遍历. 因此全局变量(window)总是需要最多的访问时间.</p>
<h4 id="u95ED_u5305_u5185_u7684_u5FAE_u89C2_u4E16_u754C"><a href="#u95ED_u5305_u5185_u7684_u5FAE_u89C2_u4E16_u754C" class="headerlink" title="闭包内的微观世界"></a>闭包内的微观世界</h4><p>　　如果要更加深入的了解闭包以及函数 f 和嵌套函数 f2 的关系，我们需要引入另外几个概念：函数的执行环境(excution context)、活动对象(call object)、作用域(scope)、作用域链(scope chain)。以函数a从定义到执行的过程为例阐述这几个概念。</p>
<ol>
<li>当<strong>定义</strong>函数 f 的时候，js解释器会将函数a的<strong>作用域链(scope chain)</strong>设置为<strong>定义 f 时 a 所在的“环境”</strong>，如果 f 是一个全局函数，则scope chain中只有window对象。</li>
<li>当<strong>执行</strong>函数 f 的时候，f 会进入相应的<strong>执行环境(excution context)</strong>。</li>
<li>在创建执行环境的过程中，首先会为 f 添加一个scope属性，即a的<strong>作用域</strong>，其值就为第1步中的scope chain。即a.scope=f 的作用域链。</li>
<li>然后执行环境会创建一个<strong>活动对象(call object)</strong>。活动对象也是一个拥有属性的对象，但它不具有原型而且不能通过JavaScript代码直接访问。创建完活动对象后，把活动对象添加到 f 的作用域链的最顶端。此时a的作用域链包含了两个对象：f 的活动对象和window对象。</li>
<li>下一步是在活动对象上添加一个arguments属性，它保存着调用函数 f 时所传递的参数。</li>
<li>最后把所有函数 f 的形参和内部的函数 f2 的引用也添加到 f 的活动对象上。在这一步中，完成了函数 f2 的定义，因此如同第3步，函数 f2 的作用域链被设置为 f2 所被定义的环境，即 f 的作用域。</li>
</ol>
<p>到此，整个函数 f 从定义到执行的步骤就完成了。此时 f 返回函数 f2 的引用给 ff，又函数 f2 的作用域链包含了对函数 f 的活动对象的引用，也就是说 f2 可以访问到 f 中定义的所有变量和函数。函数 f2 被 ff 引用，函数 f2又依赖函数 f ，因此函数 f 在返回后不会被GC回收。</p>
<p>当函数 f2 执行的时候亦会像以上步骤一样。因此，执行时 f2 的作用域链包含了3个对象：f2 的活动对象、f 的活动对象和window对象，如下图所示：</p>
<p><img src="/doc_images/scopeChain02.jpg" alt=""></p>
<p>如图所示，当在函数 f2 中访问一个变量的时候，搜索顺序是：</p>
<ol>
<li>先搜索自身的活动对象，如果存在则返回，如果不存在将继续搜索函数 f 的活动对象，依次查找，直到找到为止。</li>
<li>如果函数 f2 存在prototype原型对象，则在查找完自身的活动对象后先查找自身的原型对象，再继续查找。这就是Javascript中的变量查找机制。</li>
<li>如果整个作用域链上都无法找到，则返回undefined。</li>
</ol>
<p>小结，本段中提到了两个重要的词语：函数的<strong>定义</strong>与<strong>执行</strong>。文中提到函数的作用域是在定义函数时候就已经确定，而不是在执行的时候确定（参看步骤1和3）。用一段代码来说明这个问题：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">var</span> g = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">  <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> h = f(<span class="number">1</span>);</span><br><span class="line">alert(h());</span><br></pre></td></tr></table></figure>
<p>这段代码中变量h指向了f中的那个匿名函数(由g返回)。</p>
<ul>
<li>假设函数h的作用域是在执行alert(h())确定的，那么此时h的作用域链是：h的活动对象-&gt;alert的活动对象-&gt;window对象。</li>
<li>假设函数h的作用域是在定义时确定的，就是说h指向的那个匿名函数在定义的时候就已经确定了作用域。那么在执行的时候，h的作用域链为：h的活动对象-&gt;f的活动对象-&gt;window对象。</li>
</ul>
<p>如果第一种假设成立，那输出值就是undefined；如果第二种假设成立，输出值则为1。</p>
<p>运行结果证明了第2个假设是正确的，说明函数的作用域确实是在定义这个函数的时候就已经确定了。</p>
<h4 id="u95ED_u5305_u6709_u53EF_u80FD_u5BFC_u81F4IE_u6D4F_u89C8_u5668_u5185_u5B58_u6CC4_u6F0F"><a href="#u95ED_u5305_u6709_u53EF_u80FD_u5BFC_u81F4IE_u6D4F_u89C8_u5668_u5185_u5B58_u6CC4_u6F0F" class="headerlink" title="闭包有可能导致IE浏览器内存泄漏"></a>闭包有可能导致IE浏览器内存泄漏</h4><p>先看一个栗子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);   </span><br><span class="line">  div.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述div的click事件就是一个闭包, 由于该闭包的存在使得 f 函数内部的 div 变量对DOM元素的引用将一直存在.</p>
<p>而早期IE浏览器( IE9之前 ) js 对象和 DOM 对象使用不同的垃圾收集方法, DOM对象使用计数垃圾回收机制, 只要匿名函数( 比如说onclick事件 )存在, DOM对象的引用便至少为1,因此它所占用的内存就永远不会被销毁.</p>
<p>有趣的是,不同的IE版本将导致不同的现象:</p>
<ul>
<li>如果是IE 6, 内存泄漏，直到关闭IE进程为止;</li>
<li>如果是IE 7，内存泄漏， 直到离开当前页面为止;</li>
<li>如果是IE 8， GC回收器回收他们的内存，无论当前是不是compatibility模式.</li>
</ul>
<p>总结一下, 闭包的优点: 共享函数作用域, 便于开放一些接口或变量供外部使用;</p>
<p>注意事项: 由于闭包可能会使得函数中变量被长期保存在内存中, 从而大量消耗内存, 影响页面性能, 因此不能滥用, 并且在IE浏览中可能导致内存泄露. 解决方法是，在退出函数之前，将不使用的局部变量全部删除.</p>
<h3 id="for_u5FAA_u73AF_u95EE_u9898_u5206_u6790"><a href="#for_u5FAA_u73AF_u95EE_u9898_u5206_u6790" class="headerlink" title="for循环问题分析"></a>for循环问题分析</h3><p>我们再来看看开篇的for循环问题, 增加匿名函数后, for循环内部的变量便处于匿名函数的局部作用域下, 此时访问 length 属性, 或者访问 i 属性, 都只需要在匿名函数作用域内查找即可, 因此查询效率大大提升(测试数据发现提升有两百多倍).</p>
<p>使用匿名函数后, 不止是作用域查询更快, 作用域内的变量还与外部隔离, 避免了像 i , length 这样的变量对后续代码产生影响. 可谓一举两得.</p>
<h3 id="u8E29_u4E2A_u4F5C_u7528_u57DF_u7684_u5751"><a href="#u8E29_u4E2A_u4F5C_u7528_u57DF_u7684_u5751" class="headerlink" title="踩个作用域的坑"></a>踩个作用域的坑</h3><p>下面我们来踩一个作用域经典的坑.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"div"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>,len=div.length;i&lt;len;i++)&#123;</span><br><span class="line">  div[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  	<span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码的本意是每次点击div, 打印div的索引, 实际上打印的却是 len 的值. 我们来分析下原因.</p>
<p>点击div时, 将会执行 console.log(i) 语句, 显然 i 变量不在 click 事件的局部作用域内, 浏览器将沿着 scope chain 寻找 i 变量, 在 index1 的地方, 即 for循环开始的地方, 此处定义了一个 i 变量, 又 js 没有块作用域, 故 i 变量并不会在 for循环块执行完成后被销毁,又 i的最后一次自加使得 i = len, 于是浏览器在scope chain index=1索引的地方停下来了, 返回了i的值, 即len的值.</p>
<p>为了解决这个问题, 我们将根据症结, 对症下药, 从作用域入手, 改变click事件的局部作用域, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"div"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>,len=div.length;i&lt;len;i++)&#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">  	div[n].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(n);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 click 事件被闭包包裹, 并且闭包自执行, 因此闭包内 n 变量的值每次都不一样, 点击div时, 浏览器将沿着 scope chain 寻找 n 变量, 最终会找到闭包内的 n 变量, 并且打印出div 的索引.</p>
<h3 id="this_u4F5C_u7528_u57DF"><a href="#this_u4F5C_u7528_u57DF" class="headerlink" title="this作用域"></a>this作用域</h3><p>前面我们学习了作用域链, 闭包等基础知识, 下面我们来聊聊神秘莫测的this作用域.</p>
<p>熟悉OOP的开发人员都知道, this是对象实例的引用, 始终指向对象实例. 然而 js 的世界里, this随着它的执行环境改变而改变, 并且它总是指向它所在方法的对象. 如下,</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line">o.func = f;</span><br><span class="line">f();<span class="comment">//[object Window]</span></span><br><span class="line">o.func();<span class="comment">//[object Object]</span></span><br><span class="line"><span class="built_in">console</span>.log(f===<span class="built_in">window</span>.f);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>当f单独执行时, 其内部this指向window对象, 但是当f成为o对象的属性func时, this指向的是o对象, 又f === window.f, 故它们实际上指向的都是this所在方法的对象.</p>
<p>下面我们来应用下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.slice.call([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],<span class="number">1</span>);<span class="comment">//[2,3],正确用法</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.slice([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],<span class="number">1</span>);<span class="comment">//[], 错误用法,此时slice内部this仍然指向Array.prototype</span></span><br><span class="line"><span class="keyword">var</span> slice = <span class="built_in">Array</span>.prototype.slice;</span><br><span class="line">slice([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],<span class="number">1</span>);<span class="comment">//Uncaught TypeError: Array.prototype.slice called on null or undefined</span></span><br><span class="line"><span class="comment">//此时slice内部this指向的是window对象,离开了原来的Array.prototype对象作用域,故报错~~</span></span><br></pre></td></tr></table></figure>
<p>总结下, this的使用只需要注意一点:</p>
<blockquote>
<p>this 总是指向它所在方法的对象.</p>
</blockquote>
<h3 id="with_u8BED_u53E5"><a href="#with_u8BED_u53E5" class="headerlink" title="with语句"></a>with语句</h3><p>聊到作用域链就不得不说with语句了, with语句可以用来临时改变作用域, 将语句中的对象添加到作用域的顶部.</p>
<p>语法: with (expression){statement} 例如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> k = &#123;name:<span class="string">"daicy"</span>&#125;;</span><br><span class="line"><span class="keyword">with</span>(k)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name);<span class="comment">//daicy</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(name);<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<p>with 语句用于对象 k, 作用域第一层为 k 对象内部作用域, 故能直接打印出 name 的值, 在with之外的语句不受此影响. </p>
<p>再看一个栗子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> l = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">with</span>(l) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(map(<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">  	<span class="keyword">return</span> i*i;</span><br><span class="line">  &#125;));<span class="comment">//[1,4,9]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，with 语句用于数组，所以在调用 map() 方法时，解释程序将检查该方法是否是本地函数。如果不是，它将检查伪对象 l，看它是否为该对象的方法, 又map是Array对象的方法, 数组l继承了该方法, 故能正确执行.</p>
<p>注意: with语句容易引起歧义, 由于需要强制改变作用域链, 它将带来更多的cpu消耗, 建议慎用 with 语句.</p>
<hr>
<p>本问就讨论这么多内容,大家有什么问题或好的想法欢迎在下方参与<a href="#respond">留言和评论</a>.</p>
<p>本文作者: <a href="https://github.com/Louiszhai" target="_blank" rel="external">louis</a></p>
<p>本文链接: <a href="http://louiszhai.github.io/2015/12/22/scopeChain/">http://louiszhai.github.io/2015/12/22/scopeChain/</a></p>
<p>参考文章</p>
<ul>
<li><a href="http://rainsilence.iteye.com/blog/2012209" target="_blank" rel="external">Jquery的each循环和原生循环及html5foreach循环的效率比较 - rainsilence - ITeye技术网站</a></li>
<li><a href="http://blog.csdn.net/lmj623565791/article/details/25076713" target="_blank" rel="external">Javascript 进阶 作用域 作用域链 - Hongyang - 博客频道 - CSDN.NET</a></li>
<li><a href="http://blog.csdn.net/yueguanghaidao/article/details/9568071" target="_blank" rel="external">Js作用域与作用域链详解 - Skycrab - 博客频道 - CSDN.NET</a></li>
<li><a href="http://www.w3school.com.cn/js/pro_js_statements_with.asp" target="_blank" rel="external">ECMAScript with 语句</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/with" target="_blank" rel="external">with - JavaScript | MDN</a></li>
<li><a href="http://www.cnblogs.com/lufy/archive/2012/05/18/2507536.html" target="_blank" rel="external">Javascript–闭包引起的IE内存泄露 - 船长op - 博客园</a></li>
<li><a href="http://www.jb51.net/article/24101.htm" target="_blank" rel="external">javascript深入理解js闭包_javascript技巧_脚本之家</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[JavaScript scope chain for while 作用域链 闭包 var]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://louiszhai.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[详解JS遍历]]></title>
    <link href="http://louiszhai.github.io/2015/12/18/traverse/"/>
    <id>http://louiszhai.github.io/2015/12/18/traverse/</id>
    <published>2015-12-18T02:54:48.000Z</published>
    <updated>2016-04-27T01:26:36.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u5BFC_u8BFB"><a href="#u5BFC_u8BFB" class="headerlink" title="导读"></a>导读</h3><p>遍历数组或对象是一名程序员的基本素养之一. 然而遍历却不是一件简单的事, 优秀的程序员知道怎么去选择合适的遍历方法, 优化遍历效率. 本篇将带你走进JavaScript遍历的世界, 享受分析JS循环的快感. 本篇所有代码都可以直接运行, 希望您通读本篇后, 不止是浏览, 最好是亲手去实践下.</p>
<a id="more"></a>
<h3 id="u6982_u8FF0"><a href="#u6982_u8FF0" class="headerlink" title="概述"></a>概述</h3><p>js有如下两种数据需要经常遍历</p>
<ul>
<li>数组(Array)</li>
<li>对象(Object)</li>
</ul>
<p>同时又提供了如下8种方法方便我们遍历元素</p>
<ul>
<li>for</li>
<li>while(或do~while)</li>
<li>forEach</li>
<li>for in</li>
<li>$.each</li>
<li>$(selecter).each</li>
<li>map</li>
<li>every</li>
</ul>
<p>最终我们将分析遍历效率选出最佳遍历选手.</p>
<p>本文将针对如下两种数据进行详细的分析和举栗. 下面举栗中如果不加特殊说明将会用到如下数据.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">"囚徒"</span>,<span class="string">"过客"</span>,<span class="string">"领袖"</span>];<span class="comment">//职场3种人</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="string">"linda"</span>,<span class="number">1</span>:<span class="string">"style"</span>,<span class="number">2</span>:<span class="string">"nick"</span>,length:<span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><p>语法: for(初始化; 循环执行条件; 每遍历一个元素后做的事情;){}</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//循环置于闭包之内</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>,length=array.length;i&lt;length;i++)&#123;<span class="comment">//缓存数组长度</span></span><br><span class="line">  	<span class="built_in">console</span>.log(array[i]);<span class="comment">//内部方法若有可能相互影响,也要置于闭包之内</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>for循环只能遍历数组, 不能遍历对象. 写for循环时有两点需要注意.</p>
<ul>
<li>其一, 为了避免遍历时执行多遍计算数组长度的操作, 影响效率,  建议在循环开始以变量的形式缓存下数组长度, 若在循环内部有可能改变数组长度, 请务必慎重处理, 避免数组越界.</li>
<li>JavaScript中并没有类似java的块级作用域, for循环内部定义的变量会直接暴露在外(如 i,循环退出后,i变量将等于数组长度, 后续代码将能访问到 i 变量的值), 因此建议将for循环置于闭包内. 特别要注意的是: <strong>如果在循环内部, 前一个元素的遍历有可能影响到后一个元素的遍历, 那么for循环内部方法也需要置于闭包之内.</strong></li>
</ul>
<h3 id="do/while"><a href="#do/while" class="headerlink" title="do/while"></a>do/while</h3><p>语法: do{…}while(true);</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">do</span> <span class="keyword">while</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span>,</span><br><span class="line">        len = array.length;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 循环被终止, 此处如果是continue就会造成循环无法退出</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'array['</span>+ i +<span class="string">']:'</span> + array[i]);</span><br><span class="line">        i++;<span class="comment">//此句建议放置循环while头部</span></span><br><span class="line">    &#125; <span class="keyword">while</span>(i&lt;len);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>do/while的语法简化了循环的实现, 只保留对循环条件的判断, 所以我们要在循环内部构造出循环退出的条件, 否则有可能造成死循环. 特别要注意的是: <strong>使用 continue 跳出本次遍历时, 要保证循环能够自动进入到下一次遍历, 因此保证循环走到下一次遍历的语句需要放到 continue 前面执行, 建议置于循环头部</strong>.(如上, i++ 语句最好放置循环头部)</p>
<p>do/while 循环与for循环大体差不多,只支持数组遍历, 多用于对循环退出条件不是很明确的场景. 一般来说不建议使用这种方式遍历数组.</p>
<h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><p>语法: array.forEach(function(item){}), 参数item表示数组每一项的元素</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">array.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(item==<span class="string">"囚徒"</span>)</span><br><span class="line">    <span class="keyword">return</span>;<span class="comment">//这里只能使用return跳过当前元素处理</span></span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>forEach的语法特点和 java的for each有些类似, 都丢掉了数组的索引信息.</p>
<p>使用forEach循环有几点需要特别注意:</p>
<ul>
<li>forEach无法遍历对象</li>
<li>forEach无法在IE中使用，只是在firefox和chrome中实现了该方法</li>
<li>forEach无法使用break，continue跳出循环，使用return时，效果和在for循环中使用continue一致</li>
</ul>
<h3 id="for_in"><a href="#for_in" class="headerlink" title="for in"></a>for in</h3><p>语法: for(var item in array){}</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> item <span class="keyword">in</span> array)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;<span class="comment">//0 1 2</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> item <span class="keyword">in</span> o)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;<span class="comment">//0 1 2 length</span></span><br></pre></td></tr></table></figure>
<p>for in 可用于遍历数组和对象, 但它输出的只是数组的索引和对象的key, 我们可以通过索引和key取到对应的值. 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> item <span class="keyword">in</span> array)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(array[item]);</span><br><span class="line">&#125;<span class="comment">//"囚徒" "过客" "领袖"</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> item <span class="keyword">in</span> o)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(o[item]);</span><br><span class="line">&#125;<span class="comment">//"linda" "style" "nick" "length"</span></span><br></pre></td></tr></table></figure>
<h3 id="24-each"><a href="#24-each" class="headerlink" title="$.each"></a>$.each</h3><p>语法: $.each(array|o, function(i, ele){}) 支持数组和对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$.each(array, <span class="function"><span class="keyword">function</span>(<span class="params">i, ele</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i,ele,<span class="keyword">this</span>==ele);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//0 "囚徒" true</span></span><br><span class="line"><span class="comment">//1 "过客" true</span></span><br><span class="line"><span class="comment">//2 "领袖" true</span></span><br><span class="line">$.each(o, <span class="function"><span class="keyword">function</span>(<span class="params">i, ele</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i,ele,<span class="keyword">this</span>==ele);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//0 "linda" true</span></span><br><span class="line"><span class="comment">//1 "style" true</span></span><br><span class="line"><span class="comment">//2 "nick" true</span></span><br></pre></td></tr></table></figure>
<p>这里我们注意到 <strong>this对象 指向当前属性的值</strong>,这是因为:</p>
<p>参考jQuery api:</p>
<blockquote>
<p><code>$.each()</code> 方法会迭代jQuery对象中的每一个DOM元素。每次回调函数执行时，会传递当前循环次数作为参数(从0开始计数)。更重要的是，回调函数是在当前DOM元素为上下文的语境中触发的。因此关键字 <code>this</code> 总是指向这个元素。</p>
</blockquote>
<p>同时,上述遍历时, o 对象的属性中有一个length属性并没有被输出. 这是为什么呢? 请耐心往下看.</p>
<p>首先, 我们来看看遍历对象o时, 当前的this对象到底是什么?</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$.each(o, <span class="function"><span class="keyword">function</span>(<span class="params">i, ele</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>==<span class="string">"linda"</span>)&#123;<span class="comment">//我们随机选取第一个属性</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>,<span class="keyword">this</span>==ele);</span><br><span class="line">    $.each(<span class="keyword">this</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e, ele2</span>) </span>&#123;</span><br><span class="line">    	<span class="built_in">console</span>.log(e, ele2);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//String &#123;0: "l", 1: "i", 2: "n", 3: "d", 4: "a", length: 5, [[PrimitiveValue]]: "linda"&#125; true</span></span><br><span class="line"><span class="comment">//0 "l"</span></span><br><span class="line"><span class="comment">//1 "i"</span></span><br><span class="line"><span class="comment">//2 "n"</span></span><br><span class="line"><span class="comment">//3 "d"</span></span><br><span class="line"><span class="comment">//4 "a"</span></span><br></pre></td></tr></table></figure>
<p>我们发现, this对象等于回调函数的第二个形参, 是一个字符串.且它的 length 属性和 [[PrimitiveValue]] 属性并没有被打印出来, 为此我们来查看下length的内部属性.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$.each(o, <span class="function"><span class="keyword">function</span>(<span class="params">i, ele</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>==<span class="string">"linda"</span>)<span class="comment">//我们还是随机选取第一个属性(这还是随机吗?)</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(<span class="keyword">this</span>, <span class="string">'length'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//Object &#123;value: 5, writable: false, enumerable: false, configurable: false&#125;</span></span><br></pre></td></tr></table></figure>
<p>可见, this对象的length属性的 enumerable 属性被设置成了false, 这表示该对象不能被列举或遍历, 同时还不能被配置(configurable: false), 也不能被赋值(writable: false).</p>
<p>此时, 前面遍历 o 对象时,它的 length 属性没有被打印出来的疑问似乎有解了. 让我们来看看 o.length 的内部属性吧.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(o, <span class="string">'length'</span>));</span><br><span class="line"><span class="comment">//Object &#123;value: 3, writable: true, enumerable: true, configurable: true&#125;</span></span><br></pre></td></tr></table></figure>
<p>o.length 值为3, 可赋值, 可列举, 可配置. 这可不对, 刚刚不是说 enumerable 属性被设置成了false 才不会被遍历吗. 现在该值为 true, 并且还不可遍历. 这不合常理, 自然该有别的原因. 我们接着往下看.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="string">"linda"</span>,<span class="number">1</span>:<span class="string">"style"</span>,<span class="number">2</span>:<span class="string">"nick"</span>,length:<span class="number">1</span>&#125;; <span class="comment">// 试着改变length的值</span></span><br><span class="line">$.each(o, <span class="function"><span class="keyword">function</span>(<span class="params">i, ele</span>)</span>&#123;<span class="comment">//再遍历一次</span></span><br><span class="line">  <span class="built_in">console</span>.log(i,ele);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//0 "linda"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="string">"linda"</span>,<span class="number">1</span>:<span class="string">"style"</span>,<span class="number">2</span>:<span class="string">"nick"</span>,length:<span class="number">5</span>&#125;; <span class="comment">// 坚持改变length的值</span></span><br><span class="line">$.each(o, <span class="function"><span class="keyword">function</span>(<span class="params">i, ele</span>)</span>&#123;<span class="comment">//再遍历一次</span></span><br><span class="line">  <span class="built_in">console</span>.log(i,ele);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 0 linda</span></span><br><span class="line"><span class="comment">// 1 style</span></span><br><span class="line"><span class="comment">// 2 nick</span></span><br><span class="line"><span class="comment">// length 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="string">"linda"</span>,<span class="number">1</span>:<span class="string">"style"</span>,<span class="number">2</span>:<span class="string">"nick"</span>&#125;; <span class="comment">// 试试去掉length属性</span></span><br><span class="line">$.each(o, <span class="function"><span class="keyword">function</span>(<span class="params">i, ele</span>)</span>&#123;<span class="comment">//再遍历一次</span></span><br><span class="line">  <span class="built_in">console</span>.log(i,ele);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 0 linda</span></span><br><span class="line"><span class="comment">// 1 style</span></span><br><span class="line"><span class="comment">// 2 nick</span></span><br></pre></td></tr></table></figure>
<p>现象明了, 结合jquery源码, 当对象中存在length属性时, $.each 内部使用for循环去遍历对象, 否则它将使用for in循环去遍历, 因此$.each遍历对象遵循如下规律:</p>
<ul>
<li>如果对象中存在 length 属性, 遍历深度以length属性为准, 即length多大, 遍历多少个元素.</li>
<li>如果对象中不存在 length 属性, 遍历深度以实际内部属性个数为准.</li>
</ul>
<p>不仅如此, $.each的具体使用过程中还有以下几点需要注意:</p>
<ul>
<li>使用 <code>return</code> 或者 <code>return true</code> 为跳过一个元素，继续执行后面的循环;</li>
<li>使用 <code>return false</code> 为终止循环的执行，但是并不终止函数执行, 这是因为在 jquery.each 中, 若返回值指定为false, 才跳出循环, 如果感兴趣请翻看 jquery.each 源码;</li>
<li>无法使用 break 与 continue 来跳过循环.</li>
</ul>
<h3 id="24_28selecter_29-each"><a href="#24_28selecter_29-each" class="headerlink" title="$(selecter).each"></a>$(selecter).each</h3><p>语法: $(selecter|array|o).each(function(i, ele){})  支持数组和对象, 该方法基本上与$.each方法相同.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'div'</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params">i,ele</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>,i,<span class="keyword">this</span> == ele);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//dom... 0 dom.... true</span></span><br><span class="line">$(array).each(<span class="function"><span class="keyword">function</span>(<span class="params">i,ele</span>)</span>&#123;<span class="comment">//处理数组</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span> == <span class="string">"领袖"</span>)</span><br><span class="line">  	<span class="built_in">console</span>.log(<span class="keyword">this</span>,i,<span class="keyword">this</span> == ele);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//String &#123;0: "领", 1: "袖", length: 2, [[PrimitiveValue]]: "领袖"&#125; 2 true</span></span><br><span class="line">$(o).each(<span class="function"><span class="keyword">function</span>(<span class="params">i,ele</span>)</span>&#123;<span class="comment">//处理对象</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span> == <span class="string">"nick"</span>)</span><br><span class="line">  	<span class="built_in">console</span>.log(<span class="keyword">this</span>,i,<span class="keyword">this</span> == ele);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//String &#123;0: "n", 1: "i", 2: "c", 3: "k", length: 4, [[PrimitiveValue]]: "nick"&#125; 2 true</span></span><br></pre></td></tr></table></figure>
<p>dom表示div元素, 由于this恒等ele, 说明this也表示div元素, 所以this并不是jquery对象, 而是普通的<a href="https://developer.mozilla.org/en-US/docs/Using_Web_Standards_in_your_Web_Pages/Using_the_W3C_DOM" target="_blank" rel="external"><code>DOM对象</code></a>(可以在this上随意使用DOM方法). 使用$(selecter).each方法,请注意以下几点:</p>
<ul>
<li>i: 即序列值 ele: 表示当前被遍历的DOM元素</li>
<li>this 表示当前被遍历的DOM元素，不能调用jQuery方法, 如需调用jquery方法需要用$符号包裹.如, $(this)</li>
</ul>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>即 Array.prototype.map,该方法只支持数组</p>
<p>语法: array.map(callback[,thisArg]) map方法使用其提供函数的每次返回结果生成一个新的数组.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>];</span><br><span class="line"><span class="keyword">var</span> roots = array.map(<span class="built_in">Math</span>.sqrt);<span class="comment">//map包裹方法名</span></span><br><span class="line"><span class="comment">// roots is now [1, 2, 3], array is still [1, 4, 9]</span></span><br><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>];</span><br><span class="line"><span class="keyword">var</span> doubles = array.map(<span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;<span class="comment">//map包裹方法实体</span></span><br><span class="line">  <span class="keyword">return</span> num * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// doubles is now [2, 8, 18]. array is still [1, 4, 9]</span></span><br></pre></td></tr></table></figure>
<p>实际上,由于map方法被设计成支持 [<code>鸭式辨型</code>][] , 该方法也可以用来处理形似数组的对象, 例如 NodeList.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elems = <span class="built_in">document</span>.querySelectorAll(<span class="string">'select option:checked'</span>);</span><br><span class="line"><span class="keyword">var</span> values = <span class="built_in">Array</span>.prototype.map.call(elems, <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj.value;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>甚至还可以用来处理字符串, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="built_in">Array</span>.prototype.map;</span><br><span class="line"><span class="keyword">var</span> array = map.call(<span class="string">'Hello 中国'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> x.charCodeAt(<span class="number">0</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(array);</span><br><span class="line"><span class="comment">//[72, 101, 108, 108, 111, 32, 20013, 22269]</span></span><br></pre></td></tr></table></figure>
<p>map处理字符串的方式多种多样, 例如 反转等.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'12345'</span>;</span><br><span class="line"><span class="keyword">var</span> output = <span class="built_in">Array</span>.prototype.map.call(str, <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;).reverse().join(<span class="string">''</span>);</span><br><span class="line"><span class="built_in">console</span>.log(output);<span class="comment">//54321</span></span><br></pre></td></tr></table></figure>
<p>例如 将字符串数组转换为数字数组, 只需一条语句, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log([<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>].map(<span class="built_in">Number</span>));<span class="comment">//[1,2,3]</span></span><br></pre></td></tr></table></figure>
<p>目前map方法支持大部分浏览器, 除了IE 6,7,8.</p>
<h3 id="every"><a href="#every" class="headerlink" title="every"></a>every</h3><p>即 Array.prototype.every, 该方法同上述map方法也只支持数组</p>
<p>语法: arr.every(callback[, thisArg]) every 方法用于检验数组中的每一项是否符合某个条件, 若符合则放回true, 反之则返回false.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isBigEnough</span>(<span class="params">element, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> element &gt;= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">[<span class="number">12</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">130</span>, <span class="number">44</span>].every(isBigEnough);   <span class="comment">// false</span></span><br><span class="line">[<span class="number">12</span>, <span class="number">54</span>, <span class="number">18</span>, <span class="number">130</span>, <span class="number">44</span>].every(isBigEnough); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>该方法还有简写方式, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">12</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">130</span>, <span class="number">44</span>].every(elem =&gt; elem &gt;= <span class="number">10</span>); <span class="comment">// false</span></span><br><span class="line">[<span class="number">12</span>, <span class="number">54</span>, <span class="number">18</span>, <span class="number">130</span>, <span class="number">44</span>].every(elem =&gt; elem &gt;= <span class="number">10</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>以上, 遍历数组和对象的8种方法简单的介绍完, 总结如下:</p>
<ul>
<li>for in , $.each , $().each 既支持对象也支持数组遍历;</li>
<li>for , do/while , forEach 只支持数组;</li>
<li>Array.prototype.map, Array.prototype.every 只支持数组和形似数组的对象;</li>
<li>forEach不能退出循环,只能通过return来进入到下一个元素的遍历中(相当于for循环的continue), 且在IE没有实现该方法, 尽量避免使用它;</li>
<li>$.each和$().each循环只能通过return false 来退出循环, 使用return 或 return true 将跳过一个元素, 继续执行后面的循环.</li>
</ul>
<h3 id="u6D4B_u8BD5_u5404_u65B9_u6CD5_u6548_u7387"><a href="#u6D4B_u8BD5_u5404_u65B9_u6CD5_u6548_u7387" class="headerlink" title="测试各方法效率"></a>测试各方法效率</h3><p>下面我们来测试下上述方法的效率.</p>
<p>注: array数组默认为空, 初始长度为100 0000, 每个方法将进行5次测试, 取测试时间总和作为比较对象, 时间单位为ms.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [];</span><br><span class="line">array.length = <span class="number">1000000</span>;<span class="comment">//(一百万)</span></span><br><span class="line"><span class="comment">//-------------------------for</span></span><br><span class="line"><span class="keyword">var</span> t1 = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>,length=array.length;i&lt;length;i++)&#123;</span><br><span class="line">  <span class="comment">//array.push(i);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> t2 = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="built_in">console</span>.log(t2-t1);</span><br><span class="line"><span class="comment">//6677+7025+7356+6948+7246 = 35252(ms)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------do/while</span></span><br><span class="line"><span class="keyword">var</span> t1 = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>,</span><br><span class="line">    length = array.length;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    i++;</span><br><span class="line">&#125; <span class="keyword">while</span>(i&lt;length);</span><br><span class="line"><span class="keyword">var</span> t2 = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="built_in">console</span>.log(t2-t1);</span><br><span class="line"><span class="comment">//8123+8342+8296+8368+8774 = 41903(ms)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------forEach</span></span><br><span class="line"><span class="keyword">var</span> t1 = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">array.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;&#125;);</span><br><span class="line"><span class="keyword">var</span> t2 = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="built_in">console</span>.log(t2-t1);</span><br><span class="line"><span class="comment">//322+273+260+301+285 = 1441(ms)</span></span><br><span class="line"><span class="comment">//2678+2540+2625+2490+2553 = 12886(ms) 基于数组长度为1000 0000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------for in</span></span><br><span class="line"><span class="keyword">var</span> t1 = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> item <span class="keyword">in</span> array)&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> t2 = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="built_in">console</span>.log(t2-t1);</span><br><span class="line"><span class="comment">//6+2+3+3+2 = 16(ms)</span></span><br><span class="line"><span class="comment">//17+17+20+22+19 = 95(ms) 基于数组长度为1000 0000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------- $.each</span></span><br><span class="line"><span class="keyword">var</span> t1 = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">$.each(array, <span class="function"><span class="keyword">function</span>(<span class="params">i, ele</span>)</span>&#123;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> t2 = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="built_in">console</span>.log(t2-t1);</span><br><span class="line"><span class="comment">//29+32+29+29+32 = 151(ms)</span></span><br><span class="line"><span class="comment">//278+294+285+278+300 = 1435(ms) 基于数组长度为1000 0000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------$().each</span></span><br><span class="line"><span class="keyword">var</span> t1 = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">$(array).each(<span class="function"><span class="keyword">function</span>(<span class="params">i,ele</span>)</span>&#123;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> t2 = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="built_in">console</span>.log(t2-t1);</span><br><span class="line"><span class="comment">//96+94+97+87+106 = 480(ms)</span></span><br><span class="line"><span class="comment">//1108+1222+997+858+1007 = 5192(ms) 基于数组长度为1000 0000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------map</span></span><br><span class="line"><span class="keyword">var</span> t1 = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">array.map(<span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> t2 = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="built_in">console</span>.log(t2-t1);</span><br><span class="line"><span class="comment">//284+290+254+271+264 = 1363(ms)</span></span><br><span class="line"><span class="comment">//2549+2513+2493+2441+2468 = 12464(ms) 基于数组长度为1000 0000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------every</span></span><br><span class="line"><span class="keyword">var</span> t1 = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">array.every(<span class="function"><span class="keyword">function</span>(<span class="params">e,i,arr</span>)</span>&#123;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> t2 = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="built_in">console</span>.log(t2-t1);</span><br><span class="line"><span class="comment">//286+264+268+271+295 = 1384(ms)</span></span><br><span class="line"><span class="comment">//2728+2815+2514+2594+2529 = 13180(ms) 基于数组长度为1000 0000</span></span><br></pre></td></tr></table></figure>
<h3 id="u5206_u6790_u603B_u7ED3"><a href="#u5206_u6790_u603B_u7ED3" class="headerlink" title="分析总结"></a>分析总结</h3><p>通过以上测试, 发现在数组长度为100 0000时, 各方法运行五次分别需要的时间排序如下:</p>
<p>for in (16ms) &lt; $().each (151ms) &lt; $.each (480ms) &lt; forEach (1441ms) &lt; map (1363ms) &lt; every (1384ms) &lt;&lt; for (35252ms) &lt; do/while (36665ms)</p>
<p>其中中间3个数据过于接近, 因此将数组长度重新设置为 1000 0000, 重新统计他们的运行时间:</p>
<p>for in (95ms) &lt; $().each (1435ms) &lt; $.each (5129ms) &lt; forEach (12886) ~ map (12464ms) ~ every (13180ms) , 其中for和do/while由于时间太长未做测试</p>
<p>根据统计数据, 可得这8个方法的运行速度排序为:</p>
<ol>
<li>for in</li>
<li>$.each</li>
<li>$().each</li>
<li>forEach map every (这3个不相上下,可认为运行速度差不多)</li>
<li>for</li>
<li>do/while</li>
</ol>
<p>我们翻看jquery代码就会知道, $.each方法内部通过调用for循环来实现 ( for循环自身为啥那么慢? ), 而$().each是先用jquery包裹数组对象, 然后再调用for循环, 因此后者效率略低于前者;</p>
<p>那么问题就来了, 据以上测试结果反映: 作为for循环本身和do/while循环却作为耗时最长的遍历被排在了以上所有方法的末尾. 可以肯定的是: for循环和do/while循环正确的位置应该在 for in之后以及$.each之前, 想知道具体原因, 推荐您阅读下页 <a href="http://louiszhai.github.io/2015/12/22/scopeChain/"><strong>《scope chain》</strong></a>.</p>
<p>综上, 最佳遍历选手是 for in 循环, 推荐大家优先考虑使用它, 一般情况下, 最好不使用forEach. ( Firefox浏览器由于对forEach循环做了底层优化, 效率接近native,不在我们考虑范围内 ).</p>
<p>声明: 本文测试使用的浏览器为<code>Google Chrome</code>的47.0.2526.80 (64-bit)版本. 如果发现本文测试数据不对, 欢迎批评指正.</p>
<hr>
<p>本文就讨论这么多内容,大家有什么问题或好的想法欢迎在下方参与<a href="#respond">留言和评论</a>.</p>
<p>本文作者: <a href="https://github.com/Louiszhai" target="_blank" rel="external">louis</a></p>
<p>本文链接: <a href="http://louiszhai.github.io/2015/12/18/traverse/">http://louiszhai.github.io/2015/12/18/traverse/</a></p>
<p>参考文章</p>
<ul>
<li><a href="http://info.9iphp.com/javascript-loop-functions-detail/" target="_blank" rel="external">JavaScript 各种遍历方式详解，有你不知道的黑科技 | Coder | 程序员资源网</a></li>
<li><a href="http://www.bubuko.com/infodetail-663058.html" target="_blank" rel="external">js,jquery遍历数组,对象-布布扣</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" target="_blank" rel="external">Array.prototype.map() - JavaScript | MDN</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every" target="_blank" rel="external">Array.prototype.every() - JavaScript | MDN</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[JavaScript traverse 遍历 数组 对象 map every forEach forin $.each for while]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://louiszhai.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[详解prototype与__proto__]]></title>
    <link href="http://louiszhai.github.io/2015/12/17/prototype/"/>
    <id>http://louiszhai.github.io/2015/12/17/prototype/</id>
    <published>2015-12-17T01:34:36.000Z</published>
    <updated>2016-04-27T01:26:44.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u6982_u5FF5"><a href="#u6982_u5FF5" class="headerlink" title="概念"></a>概念</h3><ol>
<li><strong>prototype</strong> 是函数(function) 的一个属性, 它指向函数的原型.</li>
<li><strong>__proto__</strong>   是对象的内部属性, 它指向构造器的原型, 对象依赖它进行原型链查询.</li>
</ol>
<p>由上, <strong>prototype</strong> 只有函数才有, 其他(非函数)对象不具有该属性. 而 <strong>__proto__</strong> 是对象的内部属性, 任何对象都拥有该属性. </p>
<a id="more"></a>
<h3 id="u6817_u5B50"><a href="#u6817_u5B50" class="headerlink" title="栗子"></a>栗子</h3><p>下面我们来吃个栗子帮助消化下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'louis'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype);<span class="comment">//Person原型 &#123;constructor: Person(name),__proto__: Object&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.prototype);<span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Person.__proto__);<span class="comment">//空函数, function()&#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.__proto__ == Person.prototype);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>吃栗子时我们发现, Person.prototype(原型) 默认拥有两个属性:</p>
<ul>
<li>constructor 属性, 指向构造器, 即Person本身</li>
<li>__proto__ 属性, 指向一个空的Object 对象</li>
</ul>
<p>而p1作为非函数对象, 自然就没有 prototype 属性; 此处佐证了<code>概念1</code></p>
<p>下面来看看__proto__属性:</p>
<p>Person.__proto__ 属性 指向的是一个空函数( function(){} ), 待会儿我们再来研究这个空函数.</p>
<p>p1.__proto__ 属性 指向的是 构造器(Person) 的原型, 即 Person.prototype. 此处佐证了<code>概念2</code></p>
<p>这里我们发现: 原型链查询时, 正是通过这个属性(__proto__) 链接到构造器的原型, 从而实现查询的层层深入.</p>
<p>对 <code>概念1</code> 不太理解的同学, 说明你们不会吃栗子, 咱们忽略他们. 对 <code>概念2</code> 不太理解的同学, 我们来多吃几个栗子, 边吃边想:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;name: <span class="string">'jack'</span>&#125;,</span><br><span class="line">	arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">	reg = <span class="regexp">/hello/g</span>,</span><br><span class="line">	date = <span class="keyword">new</span> <span class="built_in">Date</span>,</span><br><span class="line">	err = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'exception'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.__proto__  === <span class="built_in">Object</span>.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.__proto__  === <span class="built_in">Array</span>.prototype);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.__proto__  === <span class="built_in">RegExp</span>.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(date.__proto__ === <span class="built_in">Date</span>.prototype);   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(err.__proto__  === <span class="built_in">Error</span>.prototype);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>可见, 以上通过 <code>对象字面量</code> 和 new + JS引擎内置构造器() 创建的对象, 无一例外, 它们的__proto__ 属性全部指向构造器的原型(prototype). 充分佐证了 <code>概念2</code> .</p>
<h3 id="proto"><a href="#proto" class="headerlink" title="__proto__"></a>__proto__</h3><p>刚才留下了一个问题: Person.__proto__ 指向的是一个空函数, 下面我们来看看这个空函数究竟是什么.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Person.__proto__ === <span class="built_in">Function</span>.prototype);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>Person 是构造器也是函数(function), Person的__proto__ 属性自然就指向 函数(function)的原型, 即 Function.prototype.</p>
<p>这说明了什么呢?</p>
<p>我们由 “特殊” 联想到 “通用” , 由Person构造器联想一般的构造器.</p>
<p>这说明 <strong>所有的构造器都继承于Function.prototype</strong> (此处我们只是由特殊总结出了普适规律, 并没有给出证明, 请耐心看到后面) , 甚至包括根构造器Object及Function自身。所有构造器都继承了Function.prototype的属性及方法。如length、call、apply、bind（ES5）等. 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.__proto__   === <span class="built_in">Function</span>.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>.__proto__  === <span class="built_in">Function</span>.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.__proto__   === <span class="built_in">Function</span>.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.__proto__   === <span class="built_in">Function</span>.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.__proto__ === <span class="built_in">Function</span>.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.__proto__    === <span class="built_in">Function</span>.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.__proto__   === <span class="built_in">Function</span>.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Error</span>.__proto__    === <span class="built_in">Function</span>.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Date</span>.__proto__     === <span class="built_in">Function</span>.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>JavaScript中有内置(build-in)构造器/对象共计13个（<a href="http://kangax.github.com/es5-compat-table/" target="_blank" rel="external">ES5</a>中新加了JSON），这里列举了可访问的9个构造器。剩下如Global不能直接访问，Arguments仅在函数调用时由JS引擎创建，Math，JSON是以对象形式存在的，无需new。由于任何对象都拥有 __proto__ 属性指向构造器的原型. 即它们的 __proto__ 指向Object对象的原型(Object.prototype)。如下所示:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.__proto__ === <span class="built_in">Object</span>.prototype);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.__proto__ === <span class="built_in">Object</span>.prototype);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>如上所述, 既然所有的构造器都来自于Function.prototype, 那么Function.prototype 到底是什么呢?</p>
<h3 id="Function-prototype"><a href="#Function-prototype" class="headerlink" title="Function.prototype"></a>Function.prototype</h3><p>我们借用 typeof 运算符来看看它的类型. </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Function</span>.prototype) <span class="comment">// "function"</span></span><br></pre></td></tr></table></figure>
<p>实际上, Function.prototype也是唯一一个typeof XXX.prototype为 “function”的prototype。其它的构造器的prototype都是一个对象。如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Number</span>.prototype)   <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Boolean</span>.prototype)  <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">String</span>.prototype)   <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Object</span>.prototype)   <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Array</span>.prototype)    <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">RegExp</span>.prototype)   <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Error</span>.prototype)    <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Date</span>.prototype)     <span class="comment">// object</span></span><br></pre></td></tr></table></figure>
<h3 id="JS_u4E2D_u51FD_u6570_u662F_u4E00_u7B49_u516C_u6C11"><a href="#JS_u4E2D_u51FD_u6570_u662F_u4E00_u7B49_u516C_u6C11" class="headerlink" title="JS中函数是一等公民"></a>JS中函数是一等公民</h3><p>既然Function.prototype 的类型是函数, 那么它会拥有 __proto__ 属性吗, Function.prototype.__proto__ 会指向哪里呢? 会指向对象的原型吗? 请看下方:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>透过上方代码, 且我们了解到: Function.prototype 的类型是函数, 也就意味着一个函数拥有 __proto__ 属性, 并且该属性指向了对象(Object)构造器的原型. 这意味着啥?</p>
<p>根据我们在 <code>概念2</code> 中了解到的: <strong>__proto__</strong>   是对象的内部属性, 它指向构造器的原型.</p>
<p>这意味着 Function.prototype 函数 拥有了一个对象的内部属性, 并且该属性还恰好指向对象构造器的原型. 它是一个对象吗? 是的, 它一定是对象. 它必须是. </p>
<p>实际上, JavaScript的世界观里, 函数也是对象, 函数是一等公民.</p>
<p>这说明所有的构造器既是<code>函数</code>也是一个普通JS<code>对象</code>，可以给构造器添加/删除属性等。同时它也继承了Object.prototype上的所有方法：toString、valueOf、hasOwnProperty等。</p>
<h3 id="Object-prototype"><a href="#Object-prototype" class="headerlink" title="Object.prototype"></a>Object.prototype</h3><p>函数的 __proto__ 属性指向 Function.prototype, 如: Person.__proto__ —&gt; Function.prototype</p>
<p>Function.prototype 函数的 __proto__ 属性指向 Object.prototype, 如: Function.prototype.__proto__ —&gt; Object.prototype.</p>
<p>那么Object.prototype.__proto__ 指向什么呢? </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>由于已经到顶, JS世界的源头一片荒芜, 竟然什么都没有! 令人嗟叹不已.</p>
<p>都说一图胜千言, 我也不能免俗. 下面附一张 <a href="http://stackoverflow.com/" target="_blank" rel="external">stackoverflow</a> 上的图:</p>
<p><img src="/docImages/prototype.png" alt=""></p>
<p>这张图也指出: </p>
<ul>
<li>Object.__proto__ == Function.prototype,</li>
</ul>
<ul>
<li>Function.__proto__ == Function.prototype.</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//虽然上面做过测试, 我们还是再次测试下</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.__proto__   == <span class="built_in">Function</span>.prototype);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.__proto__ == <span class="built_in">Function</span>.prototype);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>由于对象构造器 (Object) 也是构造器, 又构造器都是函数, 又函数是一等公民, 函数也是对象.</p>
<p>故, 对象构造器 (Object) 拥有<strong>3</strong>种身份:</p>
<ul>
<li><code>构造器</code></li>
<li><code>函数</code></li>
<li><code>对象</code></li>
</ul>
<p>推而广之, 所有构造器都拥有上述3种身份.</p>
<p>由于构造器是 <code>对象</code> (身份3), 理所当然拥有 __proto__ 属性, 且该属性一定指向其构造器的原型, 也就是指向 <code>函数</code> (身份2) 构造器(Function)的原型, 即 Function.prototype. 于是我们证明了上面那句 <strong>所有的构造器都继承于Function.prototype</strong> (身份1).</p>
<p>注: 上面代码中用到的 __proto__ 目前在IE6/7/8/9中并不支持。IE9中可以使用<a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/GetPrototypeOf" target="_blank" rel="external">Object.getPrototypeOf</a>(ES5)获取对象的内部原型。</p>
<hr>
<p>本文就讨论这么多内容,大家有什么问题或好的想法欢迎在下方参与<a href="#respond">留言和评论</a>.</p>
<p>本文作者: <a href="https://github.com/Louiszhai" target="_blank" rel="external">louis</a></p>
<p>本文链接: <a href="http://louiszhai.github.io/2015/12/17/prototype/">http://louiszhai.github.io/2015/12/17/prototype/</a></p>
<p>参考文章</p>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/prototype" target="_blank" rel="external">Function.prototype - JavaScript | MDN</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/prototype" target="_blank" rel="external">Object.prototype - JavaScript | MDN</a></li>
<li><a href="http://www.cnblogs.com/snandy/archive/2012/09/01/2664134.html" target="_blank" rel="external">JavaScript中__proto__与prototype的关系 - snandy - 博客园</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[JavaScript prototype __proto__ 原型 内部原型 new]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://louiszhai.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Currying]]></title>
    <link href="http://louiszhai.github.io/2015/12/16/currying/"/>
    <id>http://louiszhai.github.io/2015/12/16/currying/</id>
    <published>2015-12-16T00:57:06.000Z</published>
    <updated>2016-04-27T01:26:52.000Z</updated>
    <content type="html"><![CDATA[<p>Currying是函数式编程的一个特性，将多个参数的处理转化成单个参数的处理，类似链式调用。</p>
<h3 id="u67EF_u91CC_u5316_28Currying_29"><a href="#u67EF_u91CC_u5316_28Currying_29" class="headerlink" title="柯里化(Currying)"></a>柯里化(Currying)</h3><p>柯里化有3个常见作用：1. 参数复用；2. 提前返回；3. 延迟计算/运行。</p>
<p>通俗的柯里化函数原型如下:</p>
<a id="more"></a>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> currying = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">var</span> newArgs = args.concat([].slice.call(<span class="built_in">arguments</span>));</span><br><span class="line">          <span class="keyword">return</span> fn.apply(<span class="literal">null</span>, newArgs);</span><br><span class="line">     &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="u67EF_u91CC_u5316_u7684_u901A_u7528_u5B9E_u73B0"><a href="#u67EF_u91CC_u5316_u7684_u901A_u7528_u5B9E_u73B0" class="headerlink" title="柯里化的通用实现"></a>柯里化的通用实现</h4><p>我们来定义一个比较通用的currying函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个参数为要应用的function，第二个参数是需要传入的最少参数个数 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">func, minArgs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minArgs == <span class="literal">undefined</span>) &#123;</span><br><span class="line">        minArgs = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">frozenargs</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 优化处理，如果调用时没有参数，返回该函数本身 </span></span><br><span class="line">	        <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>); </span><br><span class="line">	        <span class="keyword">var</span> newArgs = frozenargs.concat(args); </span><br><span class="line">	        <span class="keyword">if</span> (newArgs.length &gt;= minArgs) &#123; </span><br><span class="line">	        	<span class="keyword">return</span> func.apply(<span class="keyword">this</span>, newArgs); </span><br><span class="line">	        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">	        	<span class="keyword">return</span> A(newArgs); </span><br><span class="line">	        &#125; </span><br><span class="line">	    &#125;; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> A([]); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u67EF_u91CC_u5316_u7684_u6817_u5B50"><a href="#u67EF_u91CC_u5316_u7684_u6817_u5B50" class="headerlink" title="柯里化的栗子"></a>柯里化的栗子</h4><p>这样，我们就可以随意定义我们的业务行为了，比如定义加法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> plus = curry(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; ++i) &#123;</span><br><span class="line">    	result += <span class="built_in">arguments</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;, <span class="number">2</span>);</span><br><span class="line">plus(<span class="number">3</span>, <span class="number">2</span>); <span class="comment">// 正常调用,返回 5</span></span><br><span class="line">plus(<span class="number">3</span>); <span class="comment">// 偏应用，返回一个函数（返回值为3+参数值） </span></span><br><span class="line">plus(<span class="number">3</span>)(<span class="number">2</span>); <span class="comment">// 完整应用（返回5） </span></span><br><span class="line">plus()(<span class="number">3</span>)()()(<span class="number">2</span>); <span class="comment">// 返回 5 </span></span><br><span class="line">plus(<span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>); <span class="comment">// 可以接收多个参数,返回 14</span></span><br><span class="line">plus(<span class="number">3</span>)(<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>); <span class="comment">// 同理,返回13</span></span><br></pre></td></tr></table></figure>
<p>如下是减法的例子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> minus = curry(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="built_in">arguments</span>.length; ++i) &#123;</span><br><span class="line">        result -= <span class="built_in">arguments</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;, <span class="number">2</span>);</span><br><span class="line">minus(<span class="number">5</span>,<span class="number">3</span>);<span class="comment">//正常调用,返回 2</span></span><br><span class="line">minus(<span class="number">5</span>)(<span class="number">3</span>);<span class="comment">//完整应用,返回 2</span></span><br><span class="line">minus()(<span class="number">3</span>)()()(<span class="number">2</span>);<span class="comment">//返回 1</span></span><br><span class="line">minus(<span class="number">8</span>)(<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>);<span class="comment">// 接受多个参数,返回 -2</span></span><br></pre></td></tr></table></figure>
<h4 id="u591A_u6B21_u67EF_u91CC_u5316"><a href="#u591A_u6B21_u67EF_u91CC_u5316" class="headerlink" title="多次柯里化"></a>多次柯里化</h4><p>或者如果你想交换参数的顺序，你可以这样定义:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> flip = curry(<span class="function"><span class="keyword">function</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> curry(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> f(b, a);</span><br><span class="line">    &#125;, <span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> flip_minus = flip()(minus);<span class="comment">//返回一个具有柯里化能力的函数</span></span><br><span class="line">flip_minus(<span class="number">2</span>)(<span class="number">10</span>);<span class="comment">//8</span></span><br><span class="line">flip_minus()(<span class="number">1</span>)()(<span class="number">6</span>);<span class="comment">//5</span></span><br></pre></td></tr></table></figure>
<p>这里为什么要调用两次 curry 呢, 第一次调用是为了固定 func ,返回了curry 内部的A的内部方法,即返回:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;	<span class="comment">//该函数即flip,以下将称作`方法①`</span></span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>); </span><br><span class="line">  <span class="keyword">var</span> newArgs = frozenargs.concat(args); </span><br><span class="line">  <span class="keyword">if</span> (newArgs.length &gt;= minArgs) &#123; </span><br><span class="line">    <span class="keyword">return</span> func.apply(<span class="keyword">this</span>, newArgs);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> A(newArgs); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其中func指的是curry传入的第一个参数,表示一个方法,即如下:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">f</span>) </span>&#123;<span class="comment">//该方法表示上述func,以下将称作`方法②`</span></span><br><span class="line">    <span class="keyword">return</span> curry(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> f(b, a);</span><br><span class="line">    &#125;, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析</p>
<ul>
<li>此时调用 flip(minus) , 实际上是执行了一遍 “方法①” , 由于实参长度等于minArgs(即1), 因此返回 func.apply(this, newArgs); </li>
<li>由于 newArgs=[ minus ], 然后将执行 “方法②” ;</li>
<li>由于 f=minus, 在 “方法②” 中将第二次执行curry, 最终返回交换参数后的minus.</li>
</ul>
<p>因此 flip 是一个柯里化后的方法, 具有柯里化的典型特征: 能够将多个参数的处理转化成单个参数的处理. 不仅如此, flip 可以连续两次柯里化参数.</p>
<p>如上述栗子, 第一次柯里化的参数是方法 minus, 由于长度未做限制, 默认为1, 即至少要向 flip 传递一个方法后才能返回一个柯里化的 flip_minus, 同样, 返回的 flip_minus 也具备柯里化的能力.flip_minus()(1)()(6) 等的执行结果充分说明了这点. </p>
<h3 id="u53CD_u67EF_u91CC_u5316_28unCurrying_29"><a href="#u53CD_u67EF_u91CC_u5316_28unCurrying_29" class="headerlink" title="反柯里化(unCurrying)"></a>反柯里化(unCurrying)</h3><p>函数柯里化，是固定部分参数，返回一个接受剩余参数的函数，也称为部分计算函数，目的是为了固定参数, 延迟计算等。</p>
<p>那么反柯里化函数，从字面讲，意义和用法跟函数柯里化相比正好相反，扩大适用范围，创建一个应用范围更广的函数。使得本来只有特定对象才适用的方法，扩展到更多的对象。</p>
<h4 id="u53CD_u67EF_u91CC_u5316_u7684_u4E09_u79CD_u5B9E_u73B0"><a href="#u53CD_u67EF_u91CC_u5316_u7684_u4E09_u79CD_u5B9E_u73B0" class="headerlink" title="反柯里化的三种实现"></a>反柯里化的三种实现</h4><p>看一下通用函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.unCurrying = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Function</span>.prototype.call.apply(that, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上这段代码做了3件事:</p>
<ul>
<li>在Function原型上增加 unCurrying 方法, 方便所有方法继承;</li>
<li>返回方法, 即暴露方法对外的接口;</li>
<li>借用call, call 的参数由 apply提供;</li>
</ul>
<p>上述代码先后调用了call, apply 方法 来保证参数传递正常. 自然也可以直接调用apply(因arguments类似数组,调用apply较为方便). 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.unCurrying = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> a = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">return</span> that.apply(a[<span class="number">0</span>], [].slice.call(a, <span class="number">1</span>));分割<span class="built_in">arguments</span>,方便apply传参</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当然, 还可以利用<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="external">Function.prototype.bind()</a>方法返回一个新函数.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.unCurrying = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.call.bind(<span class="keyword">this</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>bind() 方法会创建一个新函数, 称为绑定函数, 当调用这个绑定函数时, 绑定函数会以创建它时传入bind() 方法的第一个参数作为this ,也就是说, 传入的this将成为最终的上下文, 从第二个参数开始的参数, 将按照顺序作为原函数的参数来调用原函数. </p>
<p>也就是说, 谁(假设为方法f)调用 unCurrying 方法, 将返回一个如下的方法.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">Function</span>.prototype.call.apply(f, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原理都相同，最终就是把 this.method 转化成 method(this,arg1,arg2….) 以实现方法借用和this的泛化。</p>
<h4 id="u53CD_u67EF_u91CC_u5316_u7684_u524D_u56E0"><a href="#u53CD_u67EF_u91CC_u5316_u7684_u524D_u56E0" class="headerlink" title="反柯里化的前因"></a>反柯里化的前因</h4><p>接下来我们来回顾下前一篇文章&lt;<a href="http://louiszhai.github.io/2015/12/15/arguments/">详解JS之Arguments对象</a>&gt;中所讲到的<a href="http://louiszhai.github.io/2015/12/15/arguments/#u9E2D_u5F0F_u8FA9_u578B">鸭式辩型</a>: 如果一个对象可以像鸭子一样走路,游泳,并且嘎嘎叫,就认为这个对象是鸭子,哪怕它并不是从鸭子对象继承过来的。</p>
<p>Array构造器和String构造器的prototype上的方法就被特意设计成了鸭子类型。这些方法不对this的数据类型做任何校验。这也就是为什么arguments能冒充array调用push方法.</p>
<p>下面我们来看下v8引擎里面 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/push" target="_blank" rel="external">Array.prototype.push</a> 的代码:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ArrayPush</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> n = TO_UINT32(<span class="keyword">this</span>.length);</span><br><span class="line">    <span class="keyword">var</span> m = % _ArgumentsLength();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">this</span>[i + n] = % _Arguments(i); <span class="comment">//属性拷贝 </span></span><br><span class="line">        <span class="keyword">this</span>.length = n + m; <span class="comment">//修正length </span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.length; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Array.prototype.push 方法并没有去判断调用对象是不是数组, 这给对象冒充提供了天然条件, 基于此函数反柯里化(unCurrying) 才具有可行性. </p>
<h4 id="u53CD_u67EF_u91CC_u5316_u7684_u6817_u5B50"><a href="#u53CD_u67EF_u91CC_u5316_u7684_u6817_u5B50" class="headerlink" title="反柯里化的栗子"></a>反柯里化的栗子</h4><p>下面我们让普通对象具有push方法的能力:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> push = <span class="built_in">Array</span>.prototype.push.unCurrying(),</span><br><span class="line">obj = &#123;&#125;;</span><br><span class="line">push(obj, <span class="string">'123'</span>, <span class="string">'456'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">//Object &#123;0: "123", 1: "456", length: 2&#125;</span></span><br></pre></td></tr></table></figure>
<p>obj本来是一个空对象, 它被push了两个元素 “123” 和 “456”, 并且拥有了 length 属性. obj实际上已经变成了一个数组(即[ “123”, “456” ]). </p>
<p>下面我们来看看更多的例子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*反柯里化toUpperCase*/</span></span><br><span class="line"><span class="keyword">var</span> toUpperCase = <span class="built_in">String</span>.prototype.toUpperCase.unCurrying(); <span class="built_in">console</span>.log(toUpperCase(<span class="string">'abc'</span>)); <span class="comment">// ABC</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*反柯里化toLowerCase*/</span></span><br><span class="line"><span class="keyword">var</span> toLowerCase = <span class="built_in">String</span>.prototype.toLowerCase.unCurrying();</span><br><span class="line"><span class="built_in">console</span>.log(toLowerCase(<span class="string">'DEF'</span>)); <span class="comment">// def</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*反柯里化call*/</span></span><br><span class="line"><span class="keyword">var</span> call = <span class="built_in">Function</span>.prototype.call.unCurrying();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">action</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name+<span class="string">" is "</span>+action);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name:<span class="string">'louis'</span></span><br><span class="line">&#125;;</span><br><span class="line">call(f,obj,<span class="string">'working.'</span>);<span class="comment">//call的3个参数分别为 函数, 上下文对象, 形参</span></span><br></pre></td></tr></table></figure>
<p>其中反柯里化 call 可能不大好理解, 它表示 obj 对象借用方法 f , 替换了其中的this(上下文).</p>
<h4 id="u53CD_u67EF_u91CC_u5316_u81EA_u8EAB"><a href="#u53CD_u67EF_u91CC_u5316_u81EA_u8EAB" class="headerlink" title="反柯里化自身"></a>反柯里化自身</h4><p>更有趣的是, unCurrying本身也是方法, 它同样可以被反柯里化, 这就是反柯里化的值得玩味的地方.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> unCurrying = <span class="built_in">Function</span>.prototype.unCurrying.unCurrying();</span><br><span class="line"><span class="keyword">var</span> sort = unCurrying(<span class="built_in">Array</span>.prototype.sort);</span><br><span class="line"><span class="keyword">var</span> array = sort([<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>],<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(array);<span class="comment">//[1,2,3,4,5]</span></span><br></pre></td></tr></table></figure>
<p>以上是关于 <code>javaScript</code> 柯里化与反柯里化的一些理解. </p>
<p>柯里化体现的思想是”归一”, 多个参数化为一个参数, 然后逐个处理, 便于产生偏函数, 实现链式调用; 反柯里化体现的思想是”延伸”, 通过拓展方法的作用域, 使得它变得更通用, 提高了代码的复用性. 它们都提升了代码的优雅性.</p>
<hr>
<p>本文就讨论这么多内容,大家有什么问题或好的想法欢迎在下方参与<a href="#respond">留言和评论</a>.</p>
<p>本文作者: <a href="https://github.com/Louiszhai" target="_blank" rel="external">louis</a></p>
<p>本文链接: <a href="http://louiszhai.github.io/2015/12/16/currying/">http://louiszhai.github.io/2015/12/16/currying/</a></p>
<p>参考文章</p>
<ul>
<li><a href="http://www.cnblogs.com/TomXu/archive/2012/07/23/2580701.html" target="_blank" rel="external">深入理解JavaScript系列（49）：Function模式（上篇） - 汤姆大叔 - 博客园</a></li>
<li><a href="http://www.cnblogs.com/pigtail/p/3450852.html" target="_blank" rel="external">前端开发者进阶之函数反柯里化unCurrying - 穆乙 - 博客园</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[柯里化 反柯里化 Currying unCurrying 固定参数 扩大使用范围]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://louiszhai.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[详解JS之Arguments对象]]></title>
    <link href="http://louiszhai.github.io/2015/12/15/arguments/"/>
    <id>http://louiszhai.github.io/2015/12/15/arguments/</id>
    <published>2015-12-15T12:44:51.000Z</published>
    <updated>2016-04-27T01:27:02.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u6982_u8FF0"><a href="#u6982_u8FF0" class="headerlink" title="概述"></a>概述</h3><p><strong>Arguments</strong> 对象已经不再是函数的属性了, 它是函数内部的本地变量,  包括如下属性：</p>
<ol>
<li>callee — 指向当前函数的引用</li>
<li>length — 真正传递的参数个数</li>
<li>properties-indexes (字符串类型的整数) 属性的值就是函数的参数值(按参数列表从左到右排列)。 properties-indexes内部元素的个数等于arguments.length. properties-indexes 的值和实际传递进来的参数之间是<strong>共享</strong>的。</li>
</ol>
<a id="more"></a>
<h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><h4 id="arguments-callee"><a href="#arguments-callee" class="headerlink" title="arguments.callee"></a>arguments.callee</h4><p>我们可以利用 <strong>callee</strong> 引用来写几个常见的递归, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求阶乘n! 即,1x2x3x4x5x......xn</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">n</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> i &lt; <span class="number">2</span> ? <span class="number">1</span> : i*<span class="built_in">arguments</span>.callee(i-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求1+2+3......+n</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">p</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> i &lt; <span class="number">2</span> ? <span class="number">1</span> : i+<span class="built_in">arguments</span>.callee(i-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//斐波那契数列, 1,1,2,3,5,8,13,......</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _f = <span class="built_in">arguments</span>.callee;</span><br><span class="line">  <span class="keyword">return</span> i &lt; <span class="number">3</span> ? <span class="number">1</span> : _f(i-<span class="number">1</span>) + _f(i-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">n(<span class="number">5</span>);<span class="comment">//120</span></span><br><span class="line">p(<span class="number">5</span>);<span class="comment">//15</span></span><br><span class="line">f(<span class="number">5</span>);<span class="comment">//5</span></span><br></pre></td></tr></table></figure>
<p>遗憾的是: 严格模式(“<em>use</em> <em>strict</em>“)下,  <strong>arguments.callee</strong> 并不可用.</p>
<h4 id="arguments-length"><a href="#arguments-length" class="headerlink" title="arguments.length"></a>arguments.length</h4><p>js方法中形参个数并不能实际反映实参个数, 所幸的是 <strong>arguments.length</strong> 可以取得实参个数, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">a,b,c</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'实参个数:'</span> + <span class="built_in">arguments</span>.length);</span><br><span class="line">&#125;</span><br><span class="line">a(<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//实参个数:2</span></span><br></pre></td></tr></table></figure>
<h4 id="arguments_5B_5D"><a href="#arguments_5B_5D" class="headerlink" title="arguments[]"></a>arguments[]</h4><p>这个共享其实不是真正的共享一个内存地址，而是2个不同的内存地址，使用JavaScript引擎来保证2个值是随时一样的，当然这也有一个前提， 那就是这个索引值要小于你传入的参数个数，也就是说如果你只传入2个参数，而还继续使用arguments[2]赋值的话，就会不一致(索引值从 0 开始)，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">arguments</span>[<span class="number">2</span>] = <span class="number">10</span>;<span class="comment">//参数可以被重新赋值</span></span><br><span class="line">    <span class="built_in">console</span>.log(z);</span><br><span class="line">&#125;</span><br><span class="line">b(<span class="number">1</span>, <span class="number">2</span>);<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<p>这时候因为没传递第三个参数z，所以赋值10以后，console.log(z)的结果依然是undefined，而不是10. </p>
<h4 id="u9E2D_u5F0F_u8FA9_u578B"><a href="#u9E2D_u5F0F_u8FA9_u578B" class="headerlink" title="鸭式辩型"></a>鸭式辩型</h4><p><code>arguments</code> 对象并不是一个真正的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Array" target="_blank" rel="external"><code>Array</code></a>。它类似于数组，但没有数组所特有的属性和方法，除了 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments/length" target="_blank" rel="external">length</a>。例如，它没有 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/pop" target="_blank" rel="external">pop</a> 方法。不过可以将其转换成数组.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);<span class="comment">//args为数组</span></span><br></pre></td></tr></table></figure>
<p>像上面这中arguments虽然不是数组, 但我们把它当做数组处理, 这种现象叫做 <strong><code>鸭式辩型</code></strong> . </p>
<blockquote>
<p>如果一个对象可以像鸭子一样走路,游泳,并且嘎嘎叫,就认为这个对象是鸭子,哪怕它并不是从鸭子对象继承过来的。</p>
</blockquote>
<p>在javascript里面，很多函数都不做对象的类型检测，而是只关心这些对象能做什么. 因此我们尽可利用鸭式辨型的便利, 以下就充分演示了把arguments当做一个数组来处理.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//合并参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myConcat</span>(<span class="params">separator</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);<span class="comment">//相当于arguments调用了Array的slice方法</span></span><br><span class="line">  <span class="keyword">return</span> args.join(separator);</span><br><span class="line">&#125;</span><br><span class="line">myConcat(<span class="string">", "</span>, <span class="string">"red"</span>, <span class="string">"orange"</span>, <span class="string">"blue"</span>);<span class="comment">//"red, orange, blue"</span></span><br></pre></td></tr></table></figure>
<p>警告: 此处不应在 arguments 对象上使用 slice 方法，这会阻碍 JavaScript 引擎的优化 (比如 V8 引擎)。作为替代，应通过遍历 arguments 对象的方式来构建一个新的数组。<a href="https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments" target="_blank" rel="external">更多信息</a>。</p>
<p>如果 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#Array_generic_methods" target="_blank" rel="external">Array generics</a> 可用的话，下面的代码则可以作为替代:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> args = <span class="built_in">Array</span>.slice(<span class="built_in">arguments</span>);<span class="comment">//注意,arguments对象仅在函数内部有效</span></span><br></pre></td></tr></table></figure>
<hr>
<p>本文就讨论这么多内容,大家有什么问题或好的想法欢迎在下方参与<a href="#respond">留言和评论</a>.</p>
<p>本文作者: <a href="https://github.com/Louiszhai" target="_blank" rel="external">louis</a></p>
<p>本文链接: <a href="http://louiszhai.github.io/2015/12/15/arguments/">http://louiszhai.github.io/2015/12/15/arguments/</a></p>
<p>参考文章</p>
<ul>
<li><a href="http://www.cnblogs.com/vnii/archive/2011/12/23/2299636.html" target="_blank" rel="external">几个简单递归js 实现 - 忧郁的匹格 - 博客园</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/arguments" target="_blank" rel="external">arguments - JavaScript | MDN</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u6982_u8FF0"><a href="#u6982_u8FF0" class="headerlink" title="概述"></a>概述</h3><p><strong>Arguments</strong> 对象已经不再是函数的属性了, 它是函数内部的本地变量,  包括如下属性：</p>
<ol>
<li>callee — 指向当前函数的引用</li>
<li>length — 真正传递的参数个数</li>
<li>properties-indexes (字符串类型的整数) 属性的值就是函数的参数值(按参数列表从左到右排列)。 properties-indexes内部元素的个数等于arguments.length. properties-indexes 的值和实际传递进来的参数之间是<strong>共享</strong>的。</li>
</ol>]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://louiszhai.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[详解JS原型链]]></title>
    <link href="http://louiszhai.github.io/2015/12/15/prototypeChain/"/>
    <id>http://louiszhai.github.io/2015/12/15/prototypeChain/</id>
    <published>2015-12-15T01:26:28.000Z</published>
    <updated>2016-06-22T09:26:30.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u6458_u81EAJavaScript_u9AD8_u7EA7_u7A0B_u5E8F_u8BBE_u8BA1_3A"><a href="#u6458_u81EAJavaScript_u9AD8_u7EA7_u7A0B_u5E8F_u8BBE_u8BA1_3A" class="headerlink" title="摘自JavaScript高级程序设计:"></a>摘自JavaScript高级程序设计:</h3><p>继承是OO语言中的一个最为人津津乐道的概念.许多OO语言都支持两种继承方式: <strong>接口继承</strong> 和 <strong>实现继承</strong> .接口继承只继承方法签名,而实现继承则继承实际的方法.由于js中方法没有签名,在ECMAScript中无法实现接口继承.ECMAScript只支持实现继承,而且其 <code>实现继承</code> 主要是依靠原型链来实现的.</p>
<a id="more"></a> 
<h3 id="u6982_u5FF5"><a href="#u6982_u5FF5" class="headerlink" title="概念"></a>概念</h3><p>简单回顾下构造函数,原型和实例的关系:</p>
<blockquote>
<p>每个构造函数(constructor)都有一个原型对象(prototype),原型对象都包含一个指向构造函数的指针,而实例(instance)都包含一个指向原型对象的内部指针.</p>
</blockquote>
<p>JS对象的圈子里有这么个游戏规则:</p>
<blockquote>
<p>如果试图引用对象(实例instance)的某个属性,会首先在对象内部寻找该属性,直至找不到,然后才在该对象的原型(instance.prototype)里去找这个属性.</p>
</blockquote>
<p>如果让原型对象指向另一个类型的实例…..有趣的事情便发生了.</p>
<p>即: constructor1.prototype = instance2</p>
<p>鉴于上述游戏规则生效,如果试图引用constructor1构造的实例instance1的某个属性p1:</p>
<p>1).首先会在instance1内部属性中找一遍;</p>
<p>2).接着会在instance1.__proto__(constructor1.prototype)中找一遍,而constructor1.prototype 实际上是instance2, 也就是说在instance2中寻找该属性p1;</p>
<p>3).如果instance2中还是没有,此时程序不会灰心,它会继续在instance2.__proto__(constructor2.prototype)中寻找…直至Object的原型对象</p>
<blockquote>
<p>搜索轨迹: instance1–&gt; instance2 –&gt; constructor2.prototype…–&gt;Object.prototype</p>
</blockquote>
<p>这种搜索的轨迹,形似一条长链, 又因prototype在这个游戏规则中充当链接的作用,于是我们把这种实例与原型的链条称作 <strong>原型链</strong> . 下面有个例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.getFatherValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.property;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.sonProperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继承 Father</span></span><br><span class="line">Son.prototype = <span class="keyword">new</span> Father();<span class="comment">//Son.prototype被重写,导致Son.prototype.constructor也一同被重写</span></span><br><span class="line">Son.prototype.getSonVaule = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.sonProperty;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> Son();</span><br><span class="line">alert(instance.getFatherValue());<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>instance实例通过原型链找到了Father原型中的getFatherValue方法.</p>
<p>注意: 此时instance.constructor指向的是Father,这是因为Son.prototype中的constructor被重写的缘故.</p>
<p>以上我们弄清楚了何为原型链,如有不清楚请尽量在下方<a href="#respond">给我留言</a></p>
<hr>
<h3 id="u786E_u5B9A_u539F_u578B_u548C_u5B9E_u4F8B_u7684_u5173_u7CFB"><a href="#u786E_u5B9A_u539F_u578B_u548C_u5B9E_u4F8B_u7684_u5173_u7CFB" class="headerlink" title="确定原型和实例的关系"></a>确定原型和实例的关系</h3><p>使用原型链后, 我们怎么去判断原型和实例的这种继承关系呢? 方法一般有两种.</p>
<blockquote>
<p>第一种是使用 <strong>instanceof</strong> 操作符, 只要用这个操作符来测试实例(instance)与原型链中出现过的构造函数,结果就会返回true. 以下几行代码就说明了这点.</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert(instance <span class="keyword">instanceof</span> <span class="built_in">Object</span>);<span class="comment">//true</span></span><br><span class="line">alert(instance <span class="keyword">instanceof</span> Father);<span class="comment">//true</span></span><br><span class="line">alert(instance <span class="keyword">instanceof</span> Son);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>由于原型链的关系, 我们可以说instance 是 Object, Father 或 Son中任何一个类型的实例. 因此, 这三个构造函数的结果都返回了true.</p>
<blockquote>
<p>第二种是使用 <strong>isPrototypeOf()</strong> 方法, 同样只要是原型链中出现过的原型,isPrototypeOf() 方法就会返回true, 如下所示.</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="built_in">Object</span>.prototype.isPrototypeOf(instance));<span class="comment">//true</span></span><br><span class="line">alert(Father.prototype.isPrototypeOf(instance));<span class="comment">//true</span></span><br><span class="line">alert(Son.prototype.isPrototypeOf(instance));<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>原理同上.</p>
<h3 id="u539F_u578B_u94FE_u7684_u95EE_u9898"><a href="#u539F_u578B_u94FE_u7684_u95EE_u9898" class="headerlink" title="原型链的问题"></a>原型链的问题</h3><p>原型链并非十分完美, 它包含如下两个问题.</p>
<blockquote>
<p>问题一: 当原型链中包含引用类型值的原型时,该引用类型值会被所有实例共享;</p>
<p>问题二: 在创建子类型(例如创建Son的实例)时,不能向超类型(例如Father)的构造函数中传递参数. </p>
</blockquote>
<p>有鉴于此, 实践中很少会单独使用原型链.</p>
<p>为此,下面将有一些尝试以弥补原型链的不足.</p>
<h3 id="u501F_u7528_u6784_u9020_u51FD_u6570"><a href="#u501F_u7528_u6784_u9020_u51FD_u6570" class="headerlink" title="借用构造函数"></a>借用构造函数</h3><p>为解决原型链中上述两个问题, 我们开始使用一种叫做<strong>借用构造函数</strong>(constructor stealing)的技术(也叫经典继承).</p>
<blockquote>
<p>基本思想:即在子类型构造函数的内部调用超类型构造函数.</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.colors = [<span class="string">"red"</span>,<span class="string">"blue"</span>,<span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	Father.call(<span class="keyword">this</span>);<span class="comment">//继承了Father,且向父类型传递参数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Son();</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);<span class="comment">//"red,blue,green,black"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> Son();</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors);<span class="comment">//"red,blue,green" 可见引用类型值是独立的</span></span><br></pre></td></tr></table></figure>
<p>很明显,借用构造函数一举解决了原型链的两大问题:</p>
<p>其一, 保证了原型链中引用类型值的独立,不再被所有实例共享;</p>
<p>其二, 子类型创建时也能够向父类型传递参数.</p>
<p>随之而来的是, 如果仅仅借用构造函数,那么将无法避免构造函数模式存在的问题–方法都在构造函数中定义, 因此函数复用也就不可用了.而且超类型(如Father)中定义的方法,对子类型而言也是不可见的. 考虑此,借用构造函数的技术也很少单独使用.</p>
<h3 id="u7EC4_u5408_u7EE7_u627F"><a href="#u7EC4_u5408_u7EE7_u627F" class="headerlink" title="组合继承"></a>组合继承</h3><p>组合继承, 有时候也叫做伪经典继承,指的是将原型链和借用构造函数的技术组合到一块,从而发挥两者之长的一种继承模式.</p>
<blockquote>
<p>基本思路: 使用原型链实现对原型属性和方法的继承,通过借用构造函数来实现对实例属性的继承.</p>
</blockquote>
<p>这样,既通过在原型上定义方法实现了函数复用,又能保证每个实例都有它自己的属性. 如下所示.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.colors = [<span class="string">"red"</span>,<span class="string">"blue"</span>,<span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">	Father.call(<span class="keyword">this</span>,name);<span class="comment">//继承实例属性，第一次调用Father()</span></span><br><span class="line">	<span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Son.prototype = <span class="keyword">new</span> Father();<span class="comment">//继承父类方法,第二次调用Father()</span></span><br><span class="line">Son.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Son(<span class="string">"louis"</span>,<span class="number">5</span>);</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);<span class="comment">//"red,blue,green,black"</span></span><br><span class="line">instance1.sayName();<span class="comment">//louis</span></span><br><span class="line">instance1.sayAge();<span class="comment">//5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Son(<span class="string">"zhai"</span>,<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);<span class="comment">//"red,blue,green"</span></span><br><span class="line">instance1.sayName();<span class="comment">//zhai</span></span><br><span class="line">instance1.sayAge();<span class="comment">//10</span></span><br></pre></td></tr></table></figure>
<p>组合继承避免了原型链和借用构造函数的缺陷,融合了它们的优点,成为 JavaScript 中最常用的继承模式. 而且, instanceof 和 isPrototypeOf( )也能用于识别基于组合继承创建的对象.</p>
<p>同时我们还注意到组合继承其实调用了两次父类构造函数, 造成了不必要的消耗, 那么怎样才能避免这种不必要的消耗呢, 这个我们将在后面讲到.</p>
<h3 id="u539F_u578B_u7EE7_u627F"><a href="#u539F_u578B_u7EE7_u627F" class="headerlink" title="原型继承"></a>原型继承</h3><p>该方法最初由道格拉斯·克罗克福德于2006年在一篇题为 《Prototypal Inheritance in JavaScript》(JavaScript中的原型式继承) 的文章中提出. 他的想法是借助原型可以基于已有的对象创建新对象， 同时还不必因此创建自定义类型. 大意如下:</p>
<blockquote>
<p>在object()函数内部, 先创建一个临时性的构造函数, 然后将传入的对象作为这个构造函数的原型,最后返回了这个临时类型的一个新实例. </p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">	F.prototype = o;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从本质上讲, object() 对传入其中的对象执行了一次浅复制. 下面我们来看看为什么是浅复制.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">	friends : [<span class="string">"Van"</span>,<span class="string">"Louis"</span>,<span class="string">"Nick"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> anotherPerson = object(person);</span><br><span class="line">anotherPerson.friends.push(<span class="string">"Rob"</span>);</span><br><span class="line"><span class="keyword">var</span> yetAnotherPerson = object(person);</span><br><span class="line">yetAnotherPerson.friends.push(<span class="string">"Style"</span>);</span><br><span class="line">alert(person.friends);<span class="comment">//"Van,Louis,Nick,Rob,Style"</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中,可以作为另一个对象基础的是person对象,于是我们把它传入到object()函数中,然后该函数就会返回一个新对象. 这个新对象将person作为原型,因此它的原型中就包含引用类型值属性. 这意味着person.friends不仅属于person所有,而且也会被anotherPerson以及yetAnotherPerson共享.</p>
<p>在 ECMAScript5 中,通过新增 <strong>object.create()</strong> 方法规范化了上面的原型式继承.</p>
<p><strong>object.create()</strong> 接收两个参数:</p>
<ul>
<li>一个用作新对象原型的对象</li>
<li>(可选的)一个为新对象定义额外属性的对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">	friends : [<span class="string">"Van"</span>,<span class="string">"Louis"</span>,<span class="string">"Nick"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> anotherPerson = <span class="built_in">Object</span>.create(person);</span><br><span class="line">anotherPerson.friends.push(<span class="string">"Rob"</span>);</span><br><span class="line"><span class="keyword">var</span> yetAnotherPerson = <span class="built_in">Object</span>.create(person);</span><br><span class="line">yetAnotherPerson.friends.push(<span class="string">"Style"</span>);</span><br><span class="line">alert(person.friends);<span class="comment">//"Van,Louis,Nick,Rob,Style"</span></span><br></pre></td></tr></table></figure>
<p><strong>object.create()</strong> 只有一个参数时功能与上述object方法相同, 它的第二个参数与Object.defineProperties()方法的第二个参数格式相同: 每个属性都是通过自己的描述符定义的.以这种方式指定的任何属性都会覆盖原型对象上的同名属性.例如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">	name : <span class="string">"Van"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> anotherPerson = <span class="built_in">Object</span>.create(person, &#123;</span><br><span class="line">	name : &#123;</span><br><span class="line">		value : <span class="string">"Louis"</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line">alert(anotherPerson.name);<span class="comment">//"Louis"</span></span><br></pre></td></tr></table></figure>
<p>目前支持 <strong>Object.create()</strong> 的浏览器有 IE9+, Firefox 4+, Safari 5+, Opera 12+ 和 Chrome.</p>
<p><strong>提醒:</strong> 原型式继承中, 包含引用类型值的属性始终都会共享相应的值, 就像使用原型模式一样.</p>
<h3 id="u5BC4_u751F_u5F0F_u7EE7_u627F"><a href="#u5BC4_u751F_u5F0F_u7EE7_u627F" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><p>寄生式继承是与原型式继承紧密相关的一种思路， 同样是克罗克福德推而广之.</p>
<blockquote>
<p>寄生式继承的思路与(寄生)构造函数和工厂模式类似, 即创建一个仅用于封装继承过程的函数,该函数在内部以某种方式来增强对象,最后再像真的是它做了所有工作一样返回对象. 如下.</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> clone = object(original);<span class="comment">//通过调用object函数创建一个新对象</span></span><br><span class="line">	clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//以某种方式来增强这个对象</span></span><br><span class="line">		alert(<span class="string">"hi"</span>);</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">return</span> clone;<span class="comment">//返回这个对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子中的代码基于person返回了一个新对象–anotherPerson. 新对象不仅具有 person 的所有属性和方法, 而且还被增强了, 拥有了sayH()方法. </p>
<p><strong>注意:</strong> 使用寄生式继承来为对象添加函数, 会由于不能做到函数复用而降低效率;这一点与构造函数模式类似.</p>
<h3 id="u5BC4_u751F_u7EC4_u5408_u5F0F_u7EE7_u627F"><a href="#u5BC4_u751F_u7EC4_u5408_u5F0F_u7EE7_u627F" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3><p>前面讲过,组合继承是 JavaScript 最常用的继承模式; 不过, 它也有自己的不足. 组合继承最大的问题就是无论什么情况下,都会调用两次父类构造函数: 一次是在创建子类型原型的时候, 另一次是在子类型构造函数内部. <strong>寄生组合式继承就是为了降低调用父类构造函数的开销而出现的</strong> .</p>
<blockquote>
<p>其背后的基本思路是: 不必为了指定子类型的原型而调用超类型的构造函数</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">subClass,superClass</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> prototype = object(superClass.prototype);<span class="comment">//创建对象</span></span><br><span class="line">	prototype.constructor = subClass;<span class="comment">//增强对象</span></span><br><span class="line">	subClass.prototype = prototype;<span class="comment">//指定对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>extend的高效率体现在它没有调用superClass构造函数,因此避免了在subClass.prototype上面创建不必要,多余的属性. 于此同时,原型链还能保持不变; 因此还能正常使用 instanceof 和 isPrototypeOf() 方法.</p>
<p>以上,寄生组合式继承,集寄生式继承和组合继承的优点于一身,是实现基于类型继承的最有效方法.</p>
<hr>
<p>下面我们来看下extend的另一种更为有效的扩展.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">subClass, superClass</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  F.prototype = superClass.prototype;</span><br><span class="line">  subClass.prototype = <span class="keyword">new</span> F(); </span><br><span class="line">  subClass.prototype.constructor = subClass;</span><br><span class="line"></span><br><span class="line">  subClass.superclass = superClass.prototype;</span><br><span class="line">  <span class="keyword">if</span>(superClass.prototype.constructor == <span class="built_in">Object</span>.prototype.constructor) &#123;</span><br><span class="line">    superClass.prototype.constructor = superClass;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我一直不太明白的是为什么要 “<strong>new F()</strong>“, 既然extend的目的是将子类型的 prototype 指向超类型的 prototype,为什么不直接做如下操作呢?</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subClass.prototype = superClass.prototype;<span class="comment">//直接指向超类型prototype</span></span><br></pre></td></tr></table></figure>
<p>显然, 基于如上操作, 子类型原型将与超类型原型共用, 根本就没有继承关系.</p>
<h3 id="new__u8FD0_u7B97_u7B26"><a href="#new__u8FD0_u7B97_u7B26" class="headerlink" title="new 运算符"></a>new 运算符</h3><p>为了追本溯源, 我顺便研究了new运算符具体干了什么?发现其实很简单，就干了三件事情.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj  = &#123;&#125;;</span><br><span class="line">obj.__proto__ = F.prototype;</span><br><span class="line">F.call(obj);</span><br></pre></td></tr></table></figure>
<p>第一行，我们创建了一个空对象obj;</p>
<p>第二行，我们将这个空对象的<strong>proto</strong>成员指向了F函数对象prototype成员对象;</p>
<p>第三行，我们将F函数对象的this指针替换成obj，然后再调用F函数.</p>
<p>我们可以这么理解: 以 new 操作符调用构造函数的时候，函数内部实际上发生以下变化：</p>
<p>  1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。</p>
<p>  2、属性和方法被加入到 this 引用的对象中。</p>
<p>  3、新创建的对象由 this 所引用，并且最后隐式的返回 this.</p>
<h3 id="proto____u5C5E_u6027_u662F_u6307_u5B9A_u539F_u578B_u7684_u5173_u952E"><a href="#proto____u5C5E_u6027_u662F_u6307_u5B9A_u539F_u578B_u7684_u5173_u952E" class="headerlink" title="__proto__ 属性是指定原型的关键"></a>__proto__ 属性是指定原型的关键</h3><p>以上, 通过设置 __proto__ 属性继承了父类, 如果去掉new 操作, 直接参考如下写法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subClass.prototype = superClass.prototype;<span class="comment">//直接指向超类型prototype</span></span><br></pre></td></tr></table></figure>
<p>那么, 使用 instanceof 方法判断对象是否是构造器的实例时, 将会出现紊乱.</p>
<p>假如参考如上写法, 那么extend代码应该为</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">subClass, superClass</span>) </span>&#123;</span><br><span class="line">  subClass.prototype = superClass.prototype;</span><br><span class="line"></span><br><span class="line">  subClass.superclass = superClass.prototype;</span><br><span class="line">  <span class="keyword">if</span>(superClass.prototype.constructor == <span class="built_in">Object</span>.prototype.constructor) &#123;</span><br><span class="line">    superClass.prototype.constructor = superClass;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时, 请看如下测试:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">extend(b,a);</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> a()&#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(c <span class="keyword">instanceof</span> a);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(c <span class="keyword">instanceof</span> b);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>c被认为是a的实例可以理解, 也是对的; 但c却被认为也是b的实例, 这就不对了. 究其原因, instanceof 操作符比较的应该是 c.__proto__ 与 构造器.prototype(即 b.prototype 或 a.prototype) 这两者是否相等, 又extend(b,a); 则b.prototype === a.prototype, 故这才打印出上述不合理的输出.</p>
<hr>
<p>那么最终,原型链继承可以这么实现,例如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.colors = [<span class="string">"red"</span>,<span class="string">"blue"</span>,<span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">	Father.call(<span class="keyword">this</span>,name);<span class="comment">//继承实例属性，第一次调用Father()</span></span><br><span class="line">	<span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">extend(Son,Father)<span class="comment">//继承父类方法,此处并不会第二次调用Father()</span></span><br><span class="line">Son.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Son(<span class="string">"louis"</span>,<span class="number">5</span>);</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);<span class="comment">//"red,blue,green,black"</span></span><br><span class="line">instance1.sayName();<span class="comment">//louis</span></span><br><span class="line">instance1.sayAge();<span class="comment">//5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Son(<span class="string">"zhai"</span>,<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);<span class="comment">//"red,blue,green"</span></span><br><span class="line">instance1.sayName();<span class="comment">//zhai</span></span><br><span class="line">instance1.sayAge();<span class="comment">//10</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="u6269_u5C55_3A"><a href="#u6269_u5C55_3A" class="headerlink" title="扩展:"></a>扩展:</h3><h4 id="u5C5E_u6027_u67E5_u627E"><a href="#u5C5E_u6027_u67E5_u627E" class="headerlink" title="属性查找"></a>属性查找</h4><p>​    使用了原型链后, 当查找一个对象的属性时，JavaScript 会向上遍历原型链，直到找到给定名称的属性为止，到查找到达原型链的顶部 - 也就是 Object.prototype - 但是仍然没有找到指定的属性，就会返回 undefined. 此时若想避免原型链查找, 建议使用 <strong>hasOwnProperty</strong> 方法. 因为 <strong>hasOwnProperty</strong> 是 JavaScript 中唯一一个处理属性但是不查找原型链的函数. 如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(instance1.hasOwnProperty(<span class="string">'age'</span>));<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>对比: <strong>isPrototypeOf</strong> 则是用来判断该方法所属的对象是不是参数的原型对象，是则返回true，否则返回false。如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Father.prototype.isPrototypeOf(instance1));<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<h4 id="instanceof__26amp_3B_26amp_3B_typeof"><a href="#instanceof__26amp_3B_26amp_3B_typeof" class="headerlink" title="instanceof &amp;&amp; typeof"></a>instanceof &amp;&amp; typeof</h4><p>上面提到几次提到 instanceof 运算符. 那么到底它是怎么玩的呢? 下面让我们来趴一趴它的使用场景.</p>
<p><strong>instanceof</strong> 运算符是用来在运行时指出对象是否是构造器的一个实例, 例如漏写了new运算符去调用某个构造器, 此时构造器内部可以通过 instanceof 来判断.(java中功能类似)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span> <span class="keyword">instanceof</span> <span class="built_in">arguments</span>.callee)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'此处作为构造函数被调用'</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'此处作为普通函数被调用'</span>);</span><br><span class="line">&#125;</span><br><span class="line">f();<span class="comment">//此处作为构造函数被调用</span></span><br><span class="line"><span class="keyword">new</span> f();<span class="comment">//此处作为普通函数被调用</span></span><br></pre></td></tr></table></figure>
<p>以上, this instanceof <a href="http://louiszhai.github.io/2015/12/15/arguments/"><code>arguments</code></a>.callee 的值如果为 true 表示是作为构造函数被调用的,如果为 false 则表示是作为普通函数被调用的。</p>
<p>对比: <strong>typeof</strong> 则用以获取一个变量或者表达式的类型, 一般只能返回如下几个结果:</p>
<p>number,boolean,string,function（函数）,object（NULL,数组，对象）,undefined。</p>
<h4 id="new_u8FD0_u7B97_u7B26"><a href="#new_u8FD0_u7B97_u7B26" class="headerlink" title="new运算符"></a>new运算符</h4><p>此处引用 艾伦的 <a href="http://www.cnblogs.com/aaronjs/archive/2012/07/04/2575570.html" target="_blank" rel="external">JS 对象机制深剖——new 运算符</a></p>
<p>接着上述对new运算符的研究, 我们来考察 ECMAScript 语言规范中 <strong>new</strong> 运算符的定义：</p>
<p>The new Operator</p>
<blockquote>
<p>The production <em>NewExpression : new NewExpression</em> is evaluated as follows:Evaluate NewExpression.Call GetValue(Result(1)).If Type(Result(2)) is not Object, throw a TypeError exception.If Result(2) does not implement the internal <a href="http://www.pushiming.com/blog/2009/10/the-new-operator/#appendix" target="_blank" rel="external">[[Construc]]</a> method, throw a TypeError exception.Call the [[Construct]] method on Result(2), providing no arguments (that is, an empty list of arguments).Return Result(5).</p>
</blockquote>
<p>其大意是，new 后必须跟一个对象并且此对象必须有一个名为 [[Construct]] 的内部方法（其实这种对象就是构造器），否则会抛出异常</p>
<p>根据这些内容，我们完全可以构造一个伪 [[Construct]] 方法来模拟此流程</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyObject</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyObject.construct = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = &#123;&#125;, Constructor = MyObject;</span><br><span class="line">    o.__proto__ = Constructor.prototype;</span><br><span class="line">    <span class="comment">// FF 支持用户引用内部属性 [[Prototype]]</span></span><br><span class="line">    Constructor.apply(o, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = <span class="keyword">new</span> MyObject(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">var</span> obj2 = MyObject.construct(<span class="number">10</span>);</span><br><span class="line">alert(obj2 <span class="keyword">instanceof</span> MyObject);<span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<hr>
<p>不知不觉本文已经写了3天, 其实还有很多引申的东西没有讲出来, 大家有什么问题或好的想法欢迎在下方参与<a href="#respond">留言和评论</a>.</p>
<p>本文作者: <a href="https://github.com/Louiszhai" target="_blank" rel="external">louis</a></p>
<p>本文链接: <a href="http://louiszhai.github.io/2015/12/15/prototypeChain/">http://louiszhai.github.io/2015/12/15/prototypeChain/</a></p>
<p>参考:</p>
<ul>
<li>《JavaScript高级程序设计》</li>
<li><a href="http://www.infoq.com/cn/articles/javascript-instantiation-and-inheritance/" target="_blank" rel="external">JavaScript的实例化与继承：请停止使用new关键字</a></li>
<li><a href="http://www.cnblogs.com/TomXu/archive/2012/01/05/2305453.html" target="_blank" rel="external">深入理解JavaScript系列（5）：强大的原型和原型链 - 汤姆大叔 - 博客园</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[JavaScript 原型链 prototype instanceof typeof  hasOwnProperty new  借用构造函数 组合继承 寄生式继承 寄生组合式继承]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://louiszhai.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JS布尔值(Boolean)转换规则]]></title>
    <link href="http://louiszhai.github.io/2015/12/11/js.boolean/"/>
    <id>http://louiszhai.github.io/2015/12/11/js.boolean/</id>
    <published>2015-12-11T03:37:00.000Z</published>
    <updated>2016-04-27T01:26:49.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u8BED_u6CD5"><a href="#u8BED_u6CD5" class="headerlink" title="语法"></a>语法</h3><p>众所周知, JavaScript有五个基本的值类型：<strong>number</strong>、<strong>string</strong>、<strong>boolean</strong>、<strong>null</strong>和<strong>undefined。</strong>除了null和undefined以外，其他三个具有所谓的基本包装对象。可以使用内置构造函数Number()、String()、Boolean()创建包装对象。</p>
<blockquote>
<p>boolean是JS的6种数据类型(number,string,object,boolean,null,undefined)之一,有且只有两种值:true和false</p>
</blockquote>
<a id="more"></a>
<p>1.使用Boolean(value)方法可以强制转换任意值为boolean类型,除了以下六个值，其他都是自动转为true：</p>
<ul>
<li>undefined</li>
<li>null</li>
<li>-0</li>
<li>+0</li>
<li>NaN</li>
<li>‘’（空字符串）</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>(<span class="literal">undefined</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">null</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="number">0</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">NaN</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="string">''</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>2.对象的转换规则</p>
<blockquote>
<p>所有对象的布尔值都是true，甚至连false对应的布尔对象也是true。</p>
<p>请注意，空对象{}和空数组[]也会被转成true。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>(<span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>))<span class="comment">// Boolean对象会转成true</span></span><br><span class="line"><span class="built_in">Boolean</span>([]) <span class="comment">// 空数组会转成true</span></span><br><span class="line"><span class="built_in">Boolean</span>(&#123;&#125;) <span class="comment">// 空对象会转成true</span></span><br></pre></td></tr></table></figure>
<p>3.其中有一些让人困惑的地方</p>
<blockquote>
<p><strong>&amp;&amp;</strong> 表达式从第一个开始,遇到值为false的表达式,则返回表达式本身,否则返回最后一个表达式</p>
<p><strong>||</strong> 和 <strong>!</strong> 逻辑运算符原理类似</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj &amp;&amp; <span class="literal">true</span>);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> &amp;&amp; obj);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>因此,第二个console实际上打印的是obj对象的值,即false</p>
<hr>
<p>本文就讨论这么多内容,大家有什么问题或好的想法欢迎在下方参与<a href="#respond">留言和评论</a>.</p>
<p>本文作者: <a href="https://github.com/Louiszhai" target="_blank" rel="external">louis</a></p>
<p>本文链接: <a href="http://louiszhai.github.io/2015/12/11/js.boolean/">http://louiszhai.github.io/2015/12/11/js.boolean/</a></p>
<p>参考文章</p>
<ul>
<li><a href="http://blog.csdn.net/gudanyehai/article/details/6089255" target="_blank" rel="external">js中的boolean原始类型和Boolean引用类型 - 孤单夜海 - 博客频道 - CSDN.NET</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[JavaScript boolean]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://louiszhai.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[String.prototype.replace高阶技能]]></title>
    <link href="http://louiszhai.github.io/2015/12/11/js.replace/"/>
    <id>http://louiszhai.github.io/2015/12/11/js.replace/</id>
    <published>2015-12-11T02:02:47.000Z</published>
    <updated>2016-05-13T13:27:09.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u5BFC_u8BFB"><a href="#u5BFC_u8BFB" class="headerlink" title="导读"></a>导读</h3><p>String.prototype.replace 方法虽然其貌不扬, 然混迹于江湖, 经常活跃于各大代码角落, 终于自学所成4招, 谋得一些名气. 下面我们基于它的几招, 实现一个简易的js模板引擎.</p>
<a id="more"></a>
<h3 id="u8BED_u6CD5"><a href="#u8BED_u6CD5" class="headerlink" title="语法"></a>语法</h3><p><strong>str.replace( regexp | substr, newSubStr | function[, flags] )</strong></p>
<h3 id="u53C2_u6570"><a href="#u53C2_u6570" class="headerlink" title="参数"></a>参数</h3><ul>
<li><strong>regexp:</strong> 一个 RegExp 对象. 该正则所匹配的内容会被第二个参数的返回值替换掉。</li>
<li><strong>substr:</strong> 一个要被 newSubStr 替换的字符串.</li>
<li><strong>newSubStr:</strong> 替换掉第一个参数在原字符串中的匹配部分. 该字符串中可以内插一些特殊的变量名.</li>
<li><strong>function:</strong> 一个用来创建新子字符串的函数, 该函数的返回值将替换掉第一个参数匹配到的结果. 该函数的参数描述请参考 指定一个函数作为参数 小节.</li>
<li><strong>flags:</strong> 注意：flags 参数在 v8 内核（Chrome and NodeJs）中不起作用. 方法中使用 flags 参数不是符合标准的并且不赞成这样做.</li>
</ul>
<blockquote>
<p>简单概括,replace拥有两个参数,第一个是需要替换的字符串或者正则表达式;</p>
<p>第二个是新的字符串或者一个function,这样参数便有四种组合.</p>
</blockquote>
<h3 id="u63CF_u8FF0"><a href="#u63CF_u8FF0" class="headerlink" title="描述"></a>描述</h3><p>该方法并不改变调用它的字符串本身，而只是返回替换后的字符串.</p>
<h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p>1.一般来说我们使用JS String对象的replace方法的姿势是这个样子:</p>
<blockquote>
<p>match1:    String–&gt;String</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">"what is this? before"</span>;</span><br><span class="line"><span class="keyword">var</span> b = a.replace(<span class="string">"before"</span>,<span class="string">"after"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(b);	<span class="comment">// "what is this? after"</span></span><br></pre></td></tr></table></figure>
<p>仅仅用到了文本替换为文本的功能.</p>
<p>2.更高级些还可以摆出这样的姿势,如果第一个参数是正则表达式,新的字符串中可以用$符号取正则中匹配的子串(也就是正则中被括号包裹的部分):</p>
<blockquote>
<p>match2:    Regexp–&gt;String</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">"what is this? before"</span>;</span><br><span class="line"><span class="keyword">var</span> b = a.replace(<span class="regexp">/(^\w+).*?(\w+)$/</span>,<span class="string">"$2 $1"</span>);<span class="comment">//括号分割的部分依次为子串1....n</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// "before what"</span></span><br></pre></td></tr></table></figure>
<p>3.依照语法,第二个参数其实可为一个function,最终字符串将以function的返回值作为replace的返回值,以下是该function的形参:<br>function(match,p1…,offset,string),可见至少包含三个形参(即arguments.length&gt;=3)</p>
<blockquote>
<p>match3:    Regexp–&gt;Function</p>
</blockquote>
<ul>
<li>match表示第一个参数(整个正则表达式)匹配的字符串</li>
<li>p1至pn表示第1..n个括号匹配的字符串,如果没有括号则不存在该项</li>
<li>offset表示匹配的起点在原字符串中的偏移</li>
<li>string表示原字符串</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">replacer</span>(<span class="params">match,p1,p2,offset,string</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//此时p1=" is",p2=" this"</span></span><br><span class="line">    <span class="keyword">return</span> p1+<span class="string">" that"</span>;<span class="comment">//如果返回为空串,则匹配内容替换为空,如果不返回,则匹配内容替换为undefined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">"what is this? before"</span>;</span><br><span class="line"><span class="keyword">var</span> b = a.replace(<span class="regexp">/(\s\w+)(\s\w+)/</span>,replacer);</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// "what is that? before"</span></span><br></pre></td></tr></table></figure>
<p>4.这里还有一种搭配,str.replace( substr, function[, flags] )</p>
<blockquote>
<p>match4:    String–&gt;Function</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">replacer</span>(<span class="params">match,offset,string</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//由于字符串中不会有括号进行分组,此时没有子串</span></span><br><span class="line">    <span class="keyword">return</span> offset+<span class="string">" that"</span>;<span class="comment">//偏移为4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">"what is this? before"</span>;</span><br><span class="line"><span class="keyword">var</span> b = a.replace(<span class="string">" is this"</span>,replacer);</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// "what4 that? before"</span></span><br></pre></td></tr></table></figure>
<p>以上4种replace使用方法可以满足大部分的操作字符串场景,特别是function的引入,极大的增强了replace的实力,从而使得我们操作字符游刃有余.</p>
<h3 id="u7B80_u6613_u7684_u5B57_u7B26_u4E32_u6A21_u677F_u5F15_u64CE"><a href="#u7B80_u6613_u7684_u5B57_u7B26_u4E32_u6A21_u677F_u5F15_u64CE" class="headerlink" title="简易的字符串模板引擎"></a>简易的字符串模板引擎</h3><p>基于 replace 方法的第三个用法, 我们可以实现一个tmpl方法,  输入一个模板字符串, 输入一个key-value对象, 即可生成新的字符串.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> template = <span class="string">"one &#123;a&#125; two &#123;b&#125; &#123;c&#125;"</span>,</span><br><span class="line">	obj = &#123;a:<span class="string">"apple"</span>,b:<span class="string">"orange"</span>,c:<span class="string">"..."</span>&#125;,</span><br><span class="line">	_array = [];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tmpl</span>(<span class="params">template,obj</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> retu = template.replace(<span class="regexp">/([^&#123;&#125;]*)&#123;(.)&#125;/g</span>,<span class="function"><span class="keyword">function</span>(<span class="params">match,p1,p2,offset,string</span>)</span>&#123;</span><br><span class="line">		_array.push(&#123;<span class="string">'match'</span>:match, <span class="string">'p1'</span>:p1, <span class="string">'p2'</span>:p2, <span class="string">'offset'</span>:offset, <span class="string">'string'</span>:string&#125;);</span><br><span class="line">      	<span class="keyword">return</span> p1+obj[p2];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.table &amp;&amp; <span class="built_in">console</span>.table(_array);</span><br><span class="line">  	!<span class="built_in">console</span>.table &amp;&amp; <span class="built_in">console</span>.log(_array);</span><br><span class="line">  	<span class="built_in">console</span>.log(retu);</span><br><span class="line">&#125;</span><br><span class="line">tmpl(template,obj);</span><br></pre></td></tr></table></figure>
<p>最终输出如下这张图:</p>
<p><img src="/docImages/replace01.png" alt=""></p>
<hr>
<p>本文就讨论这么多内容,大家有什么问题或好的想法欢迎在下方参与<a href="http://louiszhai.github.io/2015/12/11/js.replace/#respond">留言和评论</a>.<br>本文作者: <a href="https://github.com/Louiszhai" target="_blank" rel="external">louis</a><br>本文链接: <a href="http://louiszhai.github.io/2015/12/11/js.replace/">http://louiszhai.github.io/2015/12/11/js.replace/</a></p>
<p>参考文章</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace" target="_blank" rel="external">String.prototype.replace() - JavaScript | MDN</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[JavaScript string replace]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://louiszhai.github.io/tags/JavaScript/"/>
    
  </entry>
  
</feed>
