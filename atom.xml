<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[louis blog]]></title>
  <subtitle><![CDATA[程序猿 前端攻城师]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://louiszhai.github.io/"/>
  <updated>2016-01-17T12:29:58.000Z</updated>
  <id>http://louiszhai.github.io/</id>
  
  <author>
    <name><![CDATA[louis]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[字符串常用方法]]></title>
    <link href="http://louiszhai.github.io/2016/01/12/js.String/"/>
    <id>http://louiszhai.github.io/2016/01/12/js.String/</id>
    <published>2016-01-12T12:27:09.000Z</published>
    <updated>2016-01-17T12:29:58.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u5BFC_u8BFB"><a href="#u5BFC_u8BFB" class="headerlink" title="导读"></a>导读</h3><p>javaScript 中, 字符串无处不在, 并且所有的字符串方法均来自 String.prototype, 这一节, 我们走进看一看String内部, 探讨那些常用或不常用的字符串操作方法.</p>
<a id="more"></a>
<h3 id="String-prototype"><a href="#String-prototype" class="headerlink" title="String.prototype"></a>String.prototype</h3><p>String.prototype 属性指向 String 的原型对象. 以下是它的属性特性:</p>
<table>
<thead>
<tr>
<th>writable</th>
<th>false</th>
</tr>
</thead>
<tbody>
<tr>
<td>enumerable</td>
<td>false</td>
</tr>
<tr>
<td>configurable</td>
<td>false</td>
</tr>
</tbody>
</table>
<p>所有的字符串实例都继承自 String.prototype. 因此任何 String.prototype 上的改变都会在字符串上体现出来.</p>
<h4 id="u5C5E_u6027"><a href="#u5C5E_u6027" class="headerlink" title="属性"></a>属性</h4><ul>
<li>String.prototype.constructor 指向构造器(String())</li>
<li>String.prototype.length 表示字符串长度</li>
</ul>
<h4 id="u65B9_u6CD5"><a href="#u65B9_u6CD5" class="headerlink" title="方法"></a>方法</h4><p>字符串方法分为两种, 一种是html无关的方法, 一种是html有关的方法. 我们先看第一种. 无论字符串方法如何厉害, 都不至于强大到可以改变原字符串.</p>
<h5 id="HTML_u65E0_u5173_u7684_u65B9_u6CD5"><a href="#HTML_u65E0_u5173_u7684_u65B9_u6CD5" class="headerlink" title="HTML无关的方法"></a>HTML无关的方法</h5><p>常用的方法有, charAt, charCodeAt, concat, indexOf, lastIndexOf, localeCompare, match, replace, search, slice, split, substr, substring, toLocaleLowerCase, toLocaleUpperCase, toLowerCase, toString, toUpperCase, trim, valueof 等ES5支持的, 以及 codePointAt, contains, endsWith, normalize, repeat, startsWith 等ES6支持的, 还包括 quote, toSource, trimLeft, trimRight 等非标准的.</p>
<p>接下来我们将对各个方法分别举例阐述其用法. 若没有特别说明, 该方法将兼容所有目前主流浏览器.</p>
<h6 id="charAt"><a href="#charAt" class="headerlink" title="charAt"></a>charAt</h6><p>charAt() 方法返回字符串中指定位置的字符。</p>
<p>语法: <em>str</em>.charAt(index)</p>
<p>index 为字符串索引(取值从0至length-1), 如果超出该范围, 则返回空串.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"Hello, World"</span>.charAt(<span class="number">8</span>));<span class="comment">//o, 返回下标为8的字符串o</span></span><br></pre></td></tr></table></figure>
<h6 id="charCodeAt"><a href="#charCodeAt" class="headerlink" title="charCodeAt"></a>charCodeAt</h6><p>charCodeAt() 返回指定索引处字符的 Unicode 数值.</p>
<p>语法: str.charCodeAt(index)</p>
<p>index 为一个从0至length-1的整数. 如果不是一个数值，则默认为 0, 如果小于0或者大于字符串长度, 则返回 NaN.</p>
<p>Unicode 编码单元（code points）的范围从 0 到 1,114,111。开头的 128 个 Unicode 编码单元和 ASCII 字符编码一样. </p>
<p>charCodeAt() 总是返回一个小于 65,536 的值. 因为高位编码单元需要由一对字符来表示, 为了查看其编码的完成字符, 需要查看 charCodeAt(i) 以及 charCodeAt(i+1) 的值. 如需更多了解请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/prototype" target="_blank" rel="external">fixedCharCodeAt</a>.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"Hello, World"</span>.charCodeAt(<span class="number">8</span>));<span class="comment">//111</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"前端工程师"</span>.charCodeAt(<span class="number">2</span>));<span class="comment">//24037, 可见也可以查看中文Unicode编码</span></span><br></pre></td></tr></table></figure>
<h6 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h6><p>concat() 方法将一个或多个字符串拼接在一起, 组成新的字符串并返回.</p>
<p>语法: <em>str</em>.concat(string2, string3, …)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"早"</span>.concat(<span class="string">"上"</span>,<span class="string">"好"</span>,<span class="string">"各位"</span>));<span class="comment">//早上好各位</span></span><br></pre></td></tr></table></figure>
<p>但是 concat 的性能表现不佳, 强烈推荐使用赋值操作符(+, +=) 代替 concat. “+” 操作符大概快了 concat 几十倍.(数据参考 <a href="http://jsperf.com/concat-vs-plus-vs-join" target="_blank" rel="external">性能测试</a>).</p>
<h6 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h6><h6 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf"></a>lastIndexOf</h6><p>indexOf() 方法用于查找子字符串在字符串中首次出现的位置. 没有则返回 -1. 该方法严格区分大小写, 并且从左往右查找. 而 lastIndexOf 则从右往左查找, 其它与前者一致.</p>
<p>语法: str.indexOf(searchValue [, fromIndex=0])</p>
<p>searchValue 表示被查找的字符串, fromIndex 表示开始查找的位置, 默认为0, 如果小于0, 则查找整个字符串, 若超过字符串长度, 则该方法返回-1, 除非被查找的是空字符串, 此时返回字符串长度.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">""</span>.indexOf(<span class="string">""</span>,<span class="number">100</span>));<span class="comment">//0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"IT改变世界"</span>.indexOf(<span class="string">"世界"</span>));<span class="comment">//4</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"IT改变世界"</span>.lastIndexOf(<span class="string">"世界"</span>));<span class="comment">//4</span></span><br></pre></td></tr></table></figure>
<h6 id="locateCompare"><a href="#locateCompare" class="headerlink" title="locateCompare"></a>locateCompare</h6><p>locateCompare() 方法用来比较字符串, 如果指定字符串在原字符串的前面则返回负数, 否则返回正数或0, 其中0 表示两个字符串相同. 该方法实现依赖具体的本地实现, 不同的语言下可能有不同的返回.</p>
<p>语法: <em>str</em>.localeCompare(str2 [, locales [, options]])</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"apple"</span>;</span><br><span class="line"><span class="keyword">var</span> str2 = <span class="string">"orange"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.localeCompare(str2));<span class="comment">//-1</span></span><br><span class="line"><span class="built_in">console</span>.log(str.localeCompare(<span class="string">"123"</span>));<span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<p>目前 Safari 浏览器暂不支持该方法. Chrome 24, Firefox 29, IE11, Opera 15 已实现了它.</p>
<h6 id="match"><a href="#match" class="headerlink" title="match"></a>match</h6><p>match() 方法用于测试字符串是否支持指定正则表达式的规则, 即使传入的是非正则表达式对象, 它也会隐式地使用 new RegExp(obj) 将其转换为正则表达式对象.</p>
<p>语法: <em>str</em>.match(regexp)</p>
<p>该方法返回包含匹配结果的数组, 如果没有匹配项, 则返回 null.</p>
<p><strong>描述</strong></p>
<ul>
<li>若正则表达式没有 g 标志, 则返回同 RegExp.exec(str) 相同的结果. 而且返回的数组拥有一个额外的 input 属性, 该属性包含原始字符串, 另外该数组还拥有一个 index 属性, 该属性表示匹配字符串在原字符串中索引(从0开始).</li>
<li>若正则表达式包含 g 标志, 则该方法返回一个包含所有匹配结果的数组, 没有匹配到则返回 null.</li>
</ul>
<p><strong>相关 RegExp 方法</strong></p>
<ul>
<li>若需测试字符串是否匹配正则, 请参考 RegExp.test(str).</li>
<li>若只需第一个匹配结果, 请参考 RegExp.exec(str).</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"World Internet Conference"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.match(<span class="regexp">/[a-d]/i</span>));<span class="comment">//["d", index: 4, input: "World Internet Conference"]</span></span><br><span class="line"><span class="built_in">console</span>.log(str.match(<span class="regexp">/[a-d]/gi</span>));<span class="comment">//["d", "C", "c"]</span></span><br><span class="line"><span class="comment">//RegExp 方法如下</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/[a-d]/gi</span>.test(str));<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/[a-d]/gi</span>.exec(str));<span class="comment">//["d", index: 4, input: "World Internet Conference"],</span></span><br></pre></td></tr></table></figure>
<p>由上可知, RegExp.test(str) 方法只要匹配到了一个字符也返回true. 而</p>
<p>RegExp.exec(str) 方法无论正则中有没有包含 g 标志, RegExp.exec将直接返回第一个匹配结果, 且该结果同 str.match(regexp) 方法不包含 g 标志时的返回一致.</p>
<h6 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h6><p>该方法在之前已经讲过, 详细请参考 <a href="http://louiszhai.github.io/2015/12/11/js.replace/"><code>详解ECMAScript String.replace</code></a> .</p>
<h6 id="search"><a href="#search" class="headerlink" title="search"></a>search</h6><p>search() 方法用于测试字符串对象是否包含某个正则匹配. 相当于正则表达式的 test 方法. 且该方法比 match() 方法更快. 如果匹配成功, search() 返回正则表达式在字符串中首次匹配项的索引, 否则返回-1.</p>
<p>语法: <em>str</em>.search(regexp)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"abcdefg"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.search(<span class="regexp">/[d-g]/</span>));<span class="comment">//3, 匹配到子串"defg",而d在原字符串中的索引为3</span></span><br></pre></td></tr></table></figure>
<h6 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h6><p>slice() 方法提取字符串的一部分, 并返回新的字符串. 该方法有些类似Array.prototype.slice 方法.</p>
<p>语法: <em>str</em>.slice(start, end)</p>
<p>首先 end 参数可选, start可取正值, 也可取负值. </p>
<p>取正值时表示从索引为start的位置截取到end的位置(不包括end所在位置的字符, 如果end省略则截取到字符串末尾).</p>
<p>取负值时表示从索引为 length+start 位置截取到end所在位置的字符.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"It is our choices that show what we truly are, far more than our abilities."</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.slice(<span class="number">0</span>,-<span class="number">30</span>));<span class="comment">//It is our choices that show what we truly are</span></span><br><span class="line"><span class="built_in">console</span>.log(str.slice(-<span class="number">30</span>));<span class="comment">//, far more than our abilities.</span></span><br></pre></td></tr></table></figure>
<h6 id="split"><a href="#split" class="headerlink" title="split"></a>split</h6><p>split() 方法把原字符串分割成子字符串组成数组, 并返回该数组.</p>
<p>语法: <em>str</em>.split(separator, limit)</p>
<p>两个参数均是可选的, 其中 separator 表示分隔符, 它可以是字符串也可以是正则表达式. 如果忽略 separator, 则返回的数组包含一个由原字符串组成的元素. 如果 separator 是一个空串, 则 str 将会被分割成一个由原字符串中字符组成的数组. limit 表示从返回的数组中截取前 limit 个元素, 从而限定返回的数组长度.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"today is a sunny day"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.split());<span class="comment">//["today is a sunny day"]</span></span><br><span class="line"><span class="built_in">console</span>.log(str.split(<span class="string">""</span>));<span class="comment">//["t", "o", "d", "a", "y", " ", "i", "s", " ", "a", " ", "s", "u", "n", "n", "y", " ", "d", "a", "y"]</span></span><br><span class="line"><span class="built_in">console</span>.log(str.split(<span class="string">" "</span>));<span class="comment">//["today", "is", "a", "sunny", "day"]</span></span><br></pre></td></tr></table></figure>
<p>使用limit限定返回的数组大小. 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(str.split(<span class="string">" "</span>));<span class="comment">//["today"]</span></span><br></pre></td></tr></table></figure>
<p>使用正则分隔符(RegExp separator). 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(str.split(<span class="regexp">/\s*is\s*/</span>));<span class="comment">//["today", "a sunny day"]</span></span><br></pre></td></tr></table></figure>
<p>若正则分隔符里包含捕获括号, 则括号匹配的结果将会包含在返回的数组中.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(str.split(<span class="regexp">/(\s*is\s*)/</span>));<span class="comment">//["today", " is ", "a sunny day"]</span></span><br></pre></td></tr></table></figure>
<h6 id="substr"><a href="#substr" class="headerlink" title="substr"></a>substr</h6><p>substr() 方法返回字符串指定位置开始的指定数量的字符.</p>
<p>语法: <em>str</em>.substr(start[, length])</p>
<p>start 表示开始截取字符的位置, 可取正值或负值. 取正值时表示start位置的索引, 取负值时表示 length+start位置的索引.</p>
<p>length 表示截取的字符长度.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"Yesterday is history. Tomorrow is mystery. But today is a gift."</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.substr(<span class="number">47</span>));<span class="comment">//today is a gift.</span></span><br><span class="line"><span class="built_in">console</span>.log(str.substr(-<span class="number">16</span>));<span class="comment">//today is a gift.</span></span><br></pre></td></tr></table></figure>
<p>目前 Microsoft’s JScript 不支持 start 参数取负的索引, 如需在 IE 下支持, 请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/substr#Description" target="_blank" rel="external">Polyfill</a>.</p>
<h6 id="substring"><a href="#substring" class="headerlink" title="substring"></a>substring</h6><p>substring() 方法返回字符串两个索引之间的子串.</p>
<p>语法: <em>str</em>.substring(indexA[, indexB])</p>
<p>indexA, indexB 表示字符串索引, 其中 indexB 可选, 如果省略, 则表示返回从 indexA 到字符串末尾的子串.</p>
<p><strong>描述</strong></p>
<p>substring 要截取的是从 indexA 到 indexB(不包含)之间的字符, 符合以下规律:</p>
<ul>
<li>若 indexA == indexB, 则返回一个空字符串;</li>
<li>若 省略 indexB, 则提取字符一直到字符串末尾;</li>
<li>若 任一参数小于 0 或 NaN, 则被当作 0;</li>
<li>若 任一参数大于 length, 则被当作 length.</li>
</ul>
<p>而 如果 indexA &gt; indexB, 则 substring 的执行效果就像是两个参数调换一般. 比如: str.substring(0,1) == str.substring(1,0)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"Get outside every day. Miracles are waiting everywhere."</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.substring(<span class="number">1</span>,<span class="number">1</span>));<span class="comment">//""</span></span><br><span class="line"><span class="built_in">console</span>.log(str.substring(<span class="number">0</span>));<span class="comment">//Get outside every day. Miracles are waiting everywhere.</span></span><br><span class="line"><span class="built_in">console</span>.log(str.substring(-<span class="number">1</span>));<span class="comment">//Get outside every day. Miracles are waiting everywhere.</span></span><br><span class="line"><span class="built_in">console</span>.log(str.substring(<span class="number">0</span>,<span class="number">100</span>));<span class="comment">//Get outside every day. Miracles are waiting everywhere.</span></span><br><span class="line"><span class="built_in">console</span>.log(str.substring(<span class="number">22</span>,<span class="literal">NaN</span>));<span class="comment">//Get outside every day.</span></span><br></pre></td></tr></table></figure>
<h6 id="toLocaleLowerCase"><a href="#toLocaleLowerCase" class="headerlink" title="toLocaleLowerCase"></a>toLocaleLowerCase</h6><h6 id="toLocaleUpperCase"><a href="#toLocaleUpperCase" class="headerlink" title="toLocaleUpperCase"></a>toLocaleUpperCase</h6><p>toLocaleLowerCase() 方法返回调用该方法的字符串被转换成小写的值, 转换规则根据本地化的大小写映射. 而 toLocaleUpperCase() 方法则是转换成大写的值.</p>
<p>语法: <em>str</em>.toLocaleLowerCase(), <em>str</em>.toLocaleUpperCase()</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'ABCDEFG'</span>.toLocaleLowerCase());<span class="comment">//abcdefg</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'abcdefg'</span>.toLocaleUpperCase());<span class="comment">//ABCDEFG</span></span><br></pre></td></tr></table></figure>
<h6 id="toLowerCase"><a href="#toLowerCase" class="headerlink" title="toLowerCase"></a>toLowerCase</h6><h6 id="toUpperCase"><a href="#toUpperCase" class="headerlink" title="toUpperCase"></a>toUpperCase</h6><p>这两个方法分别表示将字符串转换为相应的小写,大写形式, 并返回. 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'ABCDEFG'</span>.toLowerCase());<span class="comment">//abcdefg</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'abcdefg'</span>.toUpperCase());<span class="comment">//ABCDEFG</span></span><br></pre></td></tr></table></figure>
<h6 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h6><h6 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf"></a>valueOf</h6><p>这两个方法都是返回指定对象的字符串形式.</p>
<p>语法: <em>str</em>.toString(), <em>str</em>.valueOf()</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"abc"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.toString());<span class="comment">//abc</span></span><br><span class="line"><span class="built_in">console</span>.log(str.toString()==str.valueOf());<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<h6 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h6><p>trim() 方法清除字符串首尾的空白并返回.</p>
<p>语法: <em>str</em>.trim()</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"    abc    "</span>.trim());<span class="comment">//abc</span></span><br></pre></td></tr></table></figure>
<p>trim() 方法是 ECMAScript 5 标准加入的, 它并不支持IE9以下的低版本IE浏览器, 如需支持, 请参考以下兼容写法:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!<span class="built_in">String</span>.prototype.trim) &#123;</span><br><span class="line">  <span class="built_in">String</span>.prototype.trim = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.replace(<span class="regexp">/^\s+|\s+$/g</span>,<span class="string">''</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="codePointAt"><a href="#codePointAt" class="headerlink" title="codePointAt"></a>codePointAt</h6><p>codePointAt() 方法返回使用UTF-16编码的给定位置的值的非负整数. 该方法遵循 ES6标准, 并非所有浏览器都支持.</p>
<p>语法: <em>str</em>.codePointAt(position)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"a"</span>.codePointAt(<span class="number">0</span>));<span class="comment">//97</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"\u4f60\u597d"</span>.codePointAt(<span class="number">0</span>));<span class="comment">//20320</span></span><br></pre></td></tr></table></figure>
<p>codePointAt 符合 ES6 标准, 如需支持, 请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/codePointAt#Polyfill" target="_blank" rel="external">Polyfill</a> .</p>
<h6 id="contains"><a href="#contains" class="headerlink" title="contains"></a>contains</h6><p>contains() 方法尚处于 ES6 规范的草案中, 它用来判断一个字符串是否属于另一个字符, 如果是, 则返回true, 如果不是, 则返回false.</p>
<p>语法: <em>str</em>.contains(subString [, position])</p>
<p>subString 表示要搜索的字符串, position 表示从当前字符串的哪个位置开始搜索字符串, 默认值为0.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"Practice makes perfect."</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.contains(<span class="string">"perfect"</span>));<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(str.contains(<span class="string">"perfect"</span>,<span class="number">100</span>));<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>实际上, 目前只有 Firefox 17及之后的版本实现了该方法.</p>
<h6 id="endsWith"><a href="#endsWith" class="headerlink" title="endsWith"></a>endsWith</h6><p>endsWith() 方法基本与 contains() 功能相同, 不同的是, 它用来判断一个字符串是否是原字符串的结尾. 若是则返回true, 否则返回false.</p>
<p>语法: <em>str</em>.endsWith(substring [, position])</p>
<p>与contains 方法不同, position 参数的默认值为字符串长度.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"Learn and live."</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.endsWith(<span class="string">"live."</span>));<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(str.endsWith(<span class="string">"Learn"</span>,<span class="number">5</span>));<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>同样目前只有 Firefox 17版本及之后的版本实现了该方法. 其他浏览器请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith#Polyfill" target="_blank" rel="external">Polyfill</a>.</p>
<h6 id="normalize"><a href="#normalize" class="headerlink" title="normalize"></a>normalize</h6><p>normalize() 方法尚处于 ES6 规范的草案中, 它会按照指定的 Unicode 正规形式将原字符串正规化.</p>
<p>语法: <em>str</em>.normalize([form])</p>
<p>form 参数可省略, 目前有四种 Unicode 正规形式, 即 “NFC”, “NFD”, “NFKC” 以及 “NFKD”, form的默认值为 “NFC”. 如果form 传入了非法的参数值, 则会抛出 RangeError 异常.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"\u4f60\u597d"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.normalize());<span class="comment">//你好</span></span><br><span class="line"><span class="built_in">console</span>.log(str.normalize(<span class="string">"NFC"</span>));<span class="comment">//你好</span></span><br><span class="line"><span class="built_in">console</span>.log(str.normalize(<span class="string">"NFD"</span>));<span class="comment">//你好</span></span><br><span class="line"><span class="built_in">console</span>.log(str.normalize(<span class="string">"NFKC"</span>));<span class="comment">//你好</span></span><br><span class="line"><span class="built_in">console</span>.log(str.normalize(<span class="string">"NFKD"</span>));<span class="comment">//你好</span></span><br></pre></td></tr></table></figure>
<p>目前只有 Chrome, Firefox 浏览器实现了该方法.</p>
<h6 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h6><p>repeat() 方法尚处于 ES6 规范的草案中, 它返回重复原字符串多次的新字符串.</p>
<p>语法: <em>str</em>.repeat(count)</p>
<p>count 参数只能取大于等于0 的数字, 若该数字不为整数, 将自动转换为整数形式. 如果取负数或者其他值将报错</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"A still tongue makes a wise head."</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.repeat(<span class="number">0</span>));<span class="comment">//""</span></span><br><span class="line"><span class="built_in">console</span>.log(str.repeat(<span class="number">1</span>));<span class="comment">//A still tongue makes a wise head.</span></span><br><span class="line"><span class="built_in">console</span>.log(str.repeat(<span class="number">1.5</span>));<span class="comment">//A still tongue makes a wise head.</span></span><br><span class="line"><span class="built_in">console</span>.log(str.repeat(-<span class="number">1</span>));<span class="comment">//RangeError:Invalid count value</span></span><br></pre></td></tr></table></figure>
<p>目前只有 Chrome 41, Firefox 24版本浏览器实现了该方法. 其他浏览器请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/repeat#Polyfill" target="_blank" rel="external">Polyfill</a>.</p>
<h6 id="startsWith"><a href="#startsWith" class="headerlink" title="startsWith"></a>startsWith</h6><p>startsWith() 方法用来判断当前字符串是否是以给定字符串开始的, 若是则返回true, 否则返回false.</p>
<p>语法: <em>str</em>.startsWith(subString [, position])</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"Where there is a will, there is a way."</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.startsWith(<span class="string">"Where"</span>));<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(str.startsWith(<span class="string">"there"</span>,<span class="number">6</span>));<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>目前只有 Firefox 17 版本实现了该方法, 其他浏览器请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith#Polyfill" target="_blank" rel="external">Polyfill</a>.</p>
<p>其它非标准的方法暂时不作介绍. 如需了解请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/prototype" target="_blank" rel="external">String.prototype - JavaScript | MDN</a> 中标注为感叹号的方法.</p>
<h6 id="HTML_u6709_u5173_u7684_u65B9_u6CD5"><a href="#HTML_u6709_u5173_u7684_u65B9_u6CD5" class="headerlink" title="HTML有关的方法"></a>HTML有关的方法</h6><p>常用的方法有 anchor, link 其它方法如 big, blink, bold, fixed, fontcolor, fontsize, italics, small, strike, sub, sup均已废除.</p>
<p>接下来我们将介绍 anchor和link 两个方法, 其他废除方法不作介绍.</p>
<h6 id="anchor"><a href="#anchor" class="headerlink" title="anchor"></a>anchor</h6><p>anchor() 方法创建一个锚标签.</p>
<p>语法: <em>str</em>.anchor(name)</p>
<p>name 指定被创建的a标签的name属性, 使用该方法创建的锚点, 将会成为 document.anchors 数组的元素.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"this is a anchor tag"</span>;</span><br><span class="line"><span class="built_in">document</span>.body.innerHTML = <span class="built_in">document</span>.body.innerHTML + str.anchor(<span class="string">"anchor1"</span>);<span class="comment">//body末尾将会追加这些内容 &lt;a name="anchor1"&gt;this is a anchor tag&lt;/a&gt;</span></span><br></pre></td></tr></table></figure>
<h6 id="link"><a href="#link" class="headerlink" title="link"></a>link</h6><p>link() 方法同样创建一个a标签.</p>
<p>语法: <em>str</em>.link(url)</p>
<p>url 指定被创建的a标签的href属性, 如果url中包含特殊字符, 将自动进行编码. 例如 &amp;会被转义为 &amp;, “ 会被转义为 “ &amp;\quot; 使用该方法创建的a标签, 将会成为 document.links 数组中的元素.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"百度"</span>;</span><br><span class="line"><span class="built_in">document</span>.write(str.link(<span class="string">"https://www.baidu.com"</span>));<span class="comment">//&lt;a href="https://www.baidu.com"&gt;百度&lt;/a&gt;</span></span><br></pre></td></tr></table></figure>
<hr>
<p>实际上 String.prototype 中, 常用的方法就charAt, indexOf, lastIndexOf, match, replace, search, slice, split, substr, substring, toLowerCase, toUpperCase, trim, valueof 等这些. 熟悉它们的语法规则就能熟练地驾驭字符串.</p>
<hr>
<p>本问就讨论这么多内容,大家有什么问题或好的想法欢迎在下方参与<a href="#respond">留言和评论</a>.</p>
<p>本文作者: <a href="https://github.com/Louiszhai" target="_blank" rel="external">louis</a></p>
<p>本文链接: <a href="http://louiszhai.github.io/2016/01/12/js.String/">http://louiszhai.github.io/2016/01/12/js.String/</a></p>
<p>参考文章</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/prototype" target="_blank" rel="external">String.prototype - JavaScript | MDN</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[JavaScript String String.prototype]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://louiszhai.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Function.prototype.bind]]></title>
    <link href="http://louiszhai.github.io/2016/01/11/bind/"/>
    <id>http://louiszhai.github.io/2016/01/11/bind/</id>
    <published>2016-01-11T00:01:33.000Z</published>
    <updated>2016-01-17T12:29:49.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u5BFC_u8BFB"><a href="#u5BFC_u8BFB" class="headerlink" title="导读"></a>导读</h3><p>ES5新增了 Function.prototype.bind 方法, 该方法不同于jquery的bind 方法, 它主要用于固定 this 作用域, 避免各种由于上下文切换造成的语义问题. 常用在 setTimeout, for循环等内部.</p>
<a id="more"></a>
<h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p>语法: func.bind(thisArg, arg1, arg2, ….)</p>
<p>bind() 方法会返回一个新函数, 又叫绑定函数, 当调用这个绑定函数时, 绑定函数会以创建它时传入 bind() 方法的第一个参数作为当前的上下文, 即this, 传入 bind() 方法的第二个及之后的参数加上绑定函数运行时自身的参数按照顺序作为原函数的参数来调用原函数.</p>
<p>绑定函数也能使用new操作符创建对象; 这就好比把原函数当做构造器. 此时提供的this将被忽略, this之后的参数将依然前置到运行时的参数列表中.</p>
<h4 id="u57FA_u672C_u7528_u6CD5"><a href="#u57FA_u672C_u7528_u6CD5" class="headerlink" title="基本用法"></a>基本用法</h4><p>下面我们来看看bind 的基本用法.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  x: <span class="number">10</span>,</span><br><span class="line">  getX: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  	<span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> f = o.getX;</span><br><span class="line">f();<span class="comment">//8, 由于没有绑定执行时的上下文, this默认指向window, 打印了全局变量x的值</span></span><br><span class="line"><span class="keyword">var</span> g = f.bind(o);</span><br><span class="line">g();<span class="comment">//10, 绑定this后, 成功的打印了o对象的x属性的值.</span></span><br></pre></td></tr></table></figure>
<h4 id="u5206_u79BB_u53C2_u6570"><a href="#u5206_u79BB_u53C2_u6570" class="headerlink" title="分离参数"></a>分离参数</h4><p>bind() 方法还可以设置函数拥有的初始参数. 这些参数作为bind() 的第2,3…个参数跟在this(或其他对象的后面), 调用绑定函数时, 这些参数将插入到参数列表的最开始位置, 而传递给绑定函数的参数将跟在他们后面.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印十个斐波那契数</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">n1, n2, length</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">arguments</span>.length&lt;<span class="number">3</span>) <span class="built_in">console</span>.log(<span class="string">'参数不够...'</span>);</span><br><span class="line">  <span class="keyword">var</span> array = [n1, n2];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">2</span>;i&lt;length;i++)&#123;</span><br><span class="line">  	array[i] = array[i-<span class="number">2</span>] + array[i-<span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = f.bind(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(g(<span class="number">10</span>));<span class="comment">//[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]</span></span><br></pre></td></tr></table></figure>
<h4 id="u7ED1_u5B9A_u53C2_u6570"><a href="#u7ED1_u5B9A_u53C2_u6570" class="headerlink" title="绑定参数"></a>绑定参数</h4><p>如果使用new 操作符去构造绑定函数的实例时, 原来提供的this 将被忽略, this之后的参数将依然前置到构造函数的参数列表中. 此时 bind() 方法便具备了保留参数的能力, 我们可以此达到类似柯里化的效果.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">arguments</span>.length!=<span class="number">0</span>)</span><br><span class="line">  	<span class="keyword">this</span>.sum = <span class="built_in">Array</span>.prototype.reduce.call(<span class="built_in">arguments</span>,<span class="function"><span class="keyword">function</span>(<span class="params">prev,item</span>)</span>&#123;<span class="comment">//对传入参数求和</span></span><br><span class="line"> 		<span class="keyword">return</span> prev + item;</span><br><span class="line">	&#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.join.call(<span class="built_in">arguments</span>);<span class="comment">// 返回传入参数的字符串形式</span></span><br><span class="line">&#125;</span><br><span class="line">f.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = f.bind(<span class="literal">null</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> g(<span class="number">8</span>);</span><br><span class="line"><span class="built_in">console</span>.log(x.toString());<span class="comment">//10, 可见x被绑定了2+8=10</span></span><br><span class="line"><span class="built_in">console</span>.log(g(<span class="number">8</span>));<span class="comment">//2,8 这告诉我们绑定的两个参数正是2和8</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x <span class="keyword">instanceof</span> g);<span class="comment">//true, 可见通过new创建的x继承了g</span></span><br><span class="line"><span class="built_in">console</span>.log(x <span class="keyword">instanceof</span> f);<span class="comment">//true, 可见x也继承了f</span></span><br><span class="line"><span class="built_in">console</span>.log(g <span class="keyword">instanceof</span> <span class="built_in">Function</span>);<span class="comment">//true, 可见bind f()方法之后, 返回了一个新的函数g</span></span><br><span class="line"><span class="comment">//函数g可用于求和,如下:</span></span><br><span class="line"><span class="built_in">console</span>.log(g(<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>));<span class="comment">//27 2+1+3+5+7+9=27</span></span><br></pre></td></tr></table></figure>
<h4 id="u5FEB_u6377_u8C03_u7528"><a href="#u5FEB_u6377_u8C03_u7528" class="headerlink" title="快捷调用"></a>快捷调用</h4><p>使用Array.prototype的方法处理类数组对象时(鸭式辨型), 不可避免的需要借用call 或者 apply 方法, 使用 bind() 方法, 我们可以简化这个过程. 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _slice = <span class="built_in">Array</span>.prototype.slice;</span><br><span class="line"><span class="keyword">var</span> slice = <span class="built_in">Function</span>.prototype.call.bind(_slice);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> slice(<span class="built_in">arguments</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);<span class="comment">//[2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>
<p>下面的实例将解释 bind() 方法做了一件什么事情:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _slice = <span class="built_in">Array</span>.prototype.slice;</span><br><span class="line"><span class="keyword">var</span> slice = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> _slice.apply(<span class="built_in">arguments</span>[<span class="number">0</span>],_slice.call(<span class="built_in">arguments</span>,<span class="number">1</span>));</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> slice(<span class="built_in">arguments</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);<span class="comment">//[2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>
<p>如下, 是bind() 方法的简单实现.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">thisArg,argN</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _this = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> _arg = _slice.call(<span class="built_in">arguments</span>,<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   	<span class="keyword">var</span> arg = _slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    arg = _arg.concat(arg);</span><br><span class="line">  	<span class="keyword">return</span> _this.apply(thisArg,arg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出来, 使用 bind() 方法后, 代码优雅得多.</p>
<p>注: 作为ES5标准加入的bind方法显然不支持 IE9之前的低版本IE, 如需使用, 请参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind#Compatibility" target="_blank" rel="external">Polyfill</a>.</p>
<hr>
<p>本问就讨论这么多内容,大家有什么问题或好的想法欢迎在下方参与<a href="#respond">留言和评论</a>.</p>
<p>本文作者: <a href="https://github.com/Louiszhai" target="_blank" rel="external">louis</a></p>
<p>本文链接: <a href="http://louiszhai.github.io/2016/01/11/bind/">http://louiszhai.github.io/2016/01/11/bind/</a></p>
<p>参考文章</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="external">Function.prototype.bind() - JavaScript | MDN</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[JavaScript bind Function.prototype.bind]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://louiszhai.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[setTimeout & setInterval]]></title>
    <link href="http://louiszhai.github.io/2016/01/10/js.timer/"/>
    <id>http://louiszhai.github.io/2016/01/10/js.timer/</id>
    <published>2016-01-10T05:52:11.000Z</published>
    <updated>2016-01-10T13:13:39.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u5BFC_u8BFB"><a href="#u5BFC_u8BFB" class="headerlink" title="导读"></a>导读</h3><p>设置web定时器应当是一个相当常见的需求, 实际上, 我们也有两大工具函数可以任意调用: setTimeout, setInterval. 然而 js 里却没有java的那种wait(), 定时又未必准时, 要想写个定时器还须得深入理解 setTimeout 和 setInterval 的运行原理才行.</p>
<a id="more"></a>
<h3 id="u8FD0_u884C_u539F_u7406"><a href="#u8FD0_u884C_u539F_u7406" class="headerlink" title="运行原理"></a>运行原理</h3><p>setTimeout 和 setInterval 并非异步调用, 所谓的”异步调用”, 只是因它们都往 js 引擎的代码执行队列里插入代码, 看起来像”异步调用”而已.</p>
<p>那么如何计算插入的时间点呢? 自然要用到我们通常所说的 timer (也叫计时器), 当执行 setTimeout 和 setInterval 函数的时候, timer会根据设定好的时间点找到代码的插入点, 返回timer callback, 也就是我们设定的回调函数.</p>
<h3 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h3><p>语法1: setTimeout(func, millisec, [param1, param2, …])</p>
<p>语法2: setTimeout(code, millisec)</p>
<p>setTimeout() 方法在指定的时间后, 执行一次传入的函数. 可通过 window.clearTimeout 函数取消 setTimeout 操作.</p>
<h4 id="u57FA_u672C_u7528_u6CD5"><a href="#u57FA_u672C_u7528_u6CD5" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(+<span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(fn, <span class="number">1000</span>);<span class="comment">//1452405077119, 延迟1s后打印了当前的时间戳</span></span><br><span class="line">setTimeout(<span class="string">"console.log(+new Date())"</span>, <span class="number">1000</span>);<span class="comment">//1452405077120, 延迟1s后执行了字符串中的语句</span></span><br></pre></td></tr></table></figure>
<h4 id="js_u5F15_u64CE_u7684_u6392_u961F_u673A_u5236"><a href="#js_u5F15_u64CE_u7684_u6392_u961F_u673A_u5236" class="headerlink" title="js引擎的排队机制"></a>js引擎的排队机制</h4><p>javaScript的世界里只有一个线程, 从来就没有同时做两件事的能力, 因此setTimeout只是一种委托机制. 它告诉js 引擎, 帮它在指定的时间点将一段代码插入到 js 引擎的代码执行队列最后面, 插入的代码并不能立即执行, 至少也要等到队列前面的代码全部执行完毕(如果队列刚好为空, 则是指定时间立即执行, 否则要等待队列前面的代码顺序执行完毕).</p>
<p>下面我们来通过栗子感受一下setTimeout是怎么排队的.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假如我们要在输入框失去焦点时, 做一些事情, 然后重新获取焦点</span></span><br><span class="line">$(<span class="string">'input'</span>).blur(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//To do something...</span></span><br><span class="line">  $(<span class="keyword">this</span>).focus();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>像上面这种写法在IE下是没有什么问题, 输入框失去焦点后马上就能获取焦点, 然而Firefox就没那么幸运了, 因为Firefox的focus只能出现在blur之后. 利用 setTimeout 的排队特点, 我们可以像下面这样实现:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'input'</span>).blur(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//To do something...</span></span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="keyword">this</span>).focus();</span><br><span class="line">  &#125;,<span class="number">0</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>虽然 setTimeout 延时为0, 但获取焦点的语句并不会立即执行, 原因就在于 setTimeout 只是将获取焦点的语句插入到 js 引擎的代码队列的最后面, 它需要等待整个 blur 完全执行完才能发挥作用, 这样就保证了 focus 事件在 blur 事件之后发生了.</p>
<h4 id="u5145_u5F53_u5B9A_u65F6_u5668"><a href="#u5145_u5F53_u5B9A_u65F6_u5668" class="headerlink" title="充当定时器"></a>充当定时器</h4><p>setTimeout 原本只能延迟一段时间执行一段代码, 如果我们将 setTimeout 写在函数内部, 并在 setTimeout 里调用函数本身, 这样就完成了简单的定时器. 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!i) i = <span class="number">0</span>;</span><br><span class="line">  ++i;</span><br><span class="line">  <span class="keyword">if</span>(i&lt;<span class="number">10</span>) setTimeout(fn,<span class="number">100</span>,i);</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line">fn();<span class="comment">//10, fn每隔100ms执行一次, 直到第10次, 因不符合条件(i=10), 退出定时器, 从而输出10</span></span><br></pre></td></tr></table></figure>
<h4 id="this_u5E26_u6765_u7684_u95EE_u9898"><a href="#this_u5E26_u6765_u7684_u95EE_u9898" class="headerlink" title="this带来的问题"></a>this带来的问题</h4><p>由setTimeout()调用的代码运行在与所在函数完全分离的执行环境上. 这会导致,这些代码中包含的 <code>this</code> 关键字会指向 <code>window</code> (或<code>全局</code>)对象. </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;fruit: <span class="string">"apple"</span>&#125;;</span><br><span class="line">o.shareFruit = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.fruit);</span><br><span class="line">&#125;</span><br><span class="line">o.shareFruit();<span class="comment">//apple</span></span><br><span class="line">setTimeout(o.shareFruit,<span class="number">1000</span>);<span class="comment">//undefined</span></span><br><span class="line">setTimeout.call(o,o.shareFruit,<span class="number">1000</span>);<span class="comment">//Illegal operation on WrappedNative prototype object</span></span><br></pre></td></tr></table></figure>
<p>甚至连 call 方法都没有办法改变当前作用域, 使用中要特别注意避免这个问题. 可参考如下方案: </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(o.shareFruit.bind(o), <span class="number">1000</span>);<span class="comment">//apple</span></span><br></pre></td></tr></table></figure>
<h4 id="u89E3_u51B3_u65B9_u6848"><a href="#u89E3_u51B3_u65B9_u6848" class="headerlink" title="解决方案"></a>解决方案</h4><p>下面我们来使用两个非原生的 setTimeout 和 setInterval 全局函数代替原生的, 使得它们能够借用 call 方法激活正确的作用域.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Enable the passage of the 'this' object through the JavaScript timers</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> __nativeST__ = <span class="built_in">window</span>.setTimeout, __nativeSI__ = <span class="built_in">window</span>.setInterval;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.setTimeout = <span class="function"><span class="keyword">function</span> (<span class="params">vCallback, nDelay <span class="comment">/*, argumentToPass1, argumentToPass2, etc. */</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> oThis = <span class="keyword">this</span>, aArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">return</span> __nativeST__(vCallback <span class="keyword">instanceof</span> <span class="built_in">Function</span> ? <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    vCallback.apply(oThis, aArgs);</span><br><span class="line">  &#125; : vCallback, nDelay);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.setInterval = <span class="function"><span class="keyword">function</span> (<span class="params">vCallback, nDelay <span class="comment">/*, argumentToPass1, argumentToPass2, etc. */</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> oThis = <span class="keyword">this</span>, aArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">return</span> __nativeSI__(vCallback <span class="keyword">instanceof</span> <span class="built_in">Function</span> ? <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    vCallback.apply(oThis, aArgs);</span><br><span class="line">  &#125; : vCallback, nDelay);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//再运行以下代码将能正确执行</span></span><br><span class="line">setTimeout(o.shareFruit,<span class="number">1000</span>);<span class="comment">//apple</span></span><br></pre></td></tr></table></figure>
<h3 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval"></a>setInterval</h3><p>语法1: setInterval(func, millisec, [param1, param2, …])</p>
<p>语法2: setInterval(code, millisec)</p>
<p>setInterval() 方法按照指定的周期(以毫秒为单位)来调用函数或表达式. 可通过 window.clearInterval 函数取消 setInterval 操作.</p>
<h4 id="u57FA_u672C_u7528_u6CD5-1"><a href="#u57FA_u672C_u7528_u6CD5-1" class="headerlink" title="基本用法"></a>基本用法</h4><p>setInterval 与 setTimeout 不同, 它会周期性的去调用函数或者表达式, 直到它本身被取消. 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  ++i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> timer = setInterval(fn,<span class="number">100</span>);<span class="comment">//设置了一个定时器, 每100ms执行一次fn函数</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">window</span>.clearInterval(timer);</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;,<span class="number">2000</span>);<span class="comment">//两秒后清除定时器, 并打印i的值</span></span><br><span class="line"><span class="comment">//20, 可见2s后fn刚好被执行了20次</span></span><br></pre></td></tr></table></figure>
<h4 id="u5B83_u771F_u7684_u53EF_u4EE5_u4F5C_u4E3A_u5B9A_u65F6_u5668_u5417"><a href="#u5B83_u771F_u7684_u53EF_u4EE5_u4F5C_u4E3A_u5B9A_u65F6_u5668_u5417" class="headerlink" title="它真的可以作为定时器吗"></a>它真的可以作为定时器吗</h4><p>实际上 setInterval 真的能作为定时器, 准确无误的在指定间隔时间内执行函数 fn 吗?</p>
<p>答案是 no. 请看下面栗子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  ++i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> timer = setInterval(fn,<span class="number">2</span>);<span class="comment">//设置了一个定时器, 将时间间隔减少至2ms</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">window</span>.clearInterval(timer);</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;,<span class="number">2000</span>);<span class="comment">//两秒后清除定时器, 并打印i的值</span></span><br><span class="line"><span class="comment">//501, 可见2s后fn只是被执行了501次(为什么不是1000次?)</span></span><br></pre></td></tr></table></figure>
<p>以上 fn 应该被执行 2000 次, 实际上才执行501次, 这是为什么呢?</p>
<p>原来, 往 js 引擎在指定时间点插入代码这种技术有个特点, js引擎只允许有一份未执行的process代码(相当于fn), 对上述代码为而言, 每当1ms来临时, js引擎先判断队列中有没有process代码, 如果 fn 函数执行时间大于1ms, 这就意味着fn尚未被执行完, 定时就来了, 然后定时候着, 静静地等待 fn的执行, 这种情况下引擎队列中就可能存在尚未执行的process代码, 如果有则本次插入的时间点就被无情的跳过. </p>
<p>由此可见, 上述代码中, fn 函数被无情的跳过了499次. 我们也可以据此计算出运行一次 fn 函数大致需要2000/501~ = 4ms. 而当我们将上述 timer 的时间间隔设置为4ms时, fn 刚好被执行了 500 次.</p>
<p>因此上面的这段代码并不可靠, 下面我们来看一个更为可靠的版本:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>,timer;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(++i &gt;= <span class="number">1000</span>)&#123;<span class="comment">//fn调用1000次后自动退出</span></span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  timer = setTimeout(<span class="built_in">arguments</span>.callee, <span class="number">2</span>);<span class="comment">//设置延时2ms后执行自身</span></span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i)</span><br><span class="line">  <span class="built_in">window</span>.clearTimeout(timer);</span><br><span class="line">&#125;,<span class="number">2000</span>);<span class="comment">//384</span></span><br></pre></td></tr></table></figure>
<p>可见, 2s之后取消定时器时, fn被执行了384次,如果仅仅希望fn被执行1000次后退出, 删除最后一个setTimeout即可. 此时, 本次fn调用 与 下次调用, 间隔时间将大于或者等于2ms. 这样既保证了调用次数, 又基本保证了调用间隔.</p>
<p>注: IE9 及更早版本的IE 浏览器不支持它们第一个语法中的向回调函数中传参数的功能. 如需支持, 请参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/setTimeout#回调参数" target="_blank" rel="external">兼容写法</a>, 或者借用 Function.prototype.bind 函数, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params">arg1</span>)</span>&#123;&#125;.bind(<span class="literal">undefined</span>, <span class="number">10</span>), <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<hr>
<p>本问就讨论这么多内容,大家有什么问题或好的想法欢迎在下方参与<a href="#respond">留言和评论</a>.</p>
<p>本文作者: <a href="https://github.com/Louiszhai" target="_blank" rel="external">louis</a></p>
<p>本文链接: <a href="http://louiszhai.github.io/2016/01/10/js.timer/">http://louiszhai.github.io/2016/01/10/js.timer/</a></p>
<p>参考文章</p>
<ul>
<li><a href="http://www.jb51.net/article/26679.htm" target="_blank" rel="external">setTimeout和setInterval的区别你真的了解吗?_javascript技巧_脚本之家</a></li>
<li><a href="http://www.jb51.net/article/42971.htm" target="_blank" rel="external">setTimeout和setInterval的深入理解_基础知识_脚本之家</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/setTimeout" target="_blank" rel="external">window.setTimeout - Web API 接口 | MDN</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[JavaScript setTimeout setInterval 轮询]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://louiszhai.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[捋一捋JS的数组]]></title>
    <link href="http://louiszhai.github.io/2015/12/29/array/"/>
    <id>http://louiszhai.github.io/2015/12/29/array/</id>
    <published>2015-12-29T01:00:17.000Z</published>
    <updated>2016-01-12T04:13:37.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u5BFC_u8BFB"><a href="#u5BFC_u8BFB" class="headerlink" title="导读"></a>导读</h3><p>数组是一种非常重要的数据类型, 它语法简单, 灵活,高效, 在多数编程语言中, 数组都充当着至关重要的角色, 以至于很难想象没有数组的编程语言会是什么样子. 这期我们就来侃侃JavaScript的数组, 趴趴它的那点破事儿. 这篇博客从2015年写到了2016年, 权当是跨年的总结吧, 祝大家新年快乐, 2016更好, 未来更好!</p>
<a id="more"></a>
<p>声明: 以下未特别标明的方法均为ES5已实现的方法.</p>
<h3 id="u539F_u578B"><a href="#u539F_u578B" class="headerlink" title="原型"></a>原型</h3><p>js中所有的数组方法均来自于Array.prototype, 和其他构造函数一样, 你可以通过扩展 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Array" target="_blank" rel="external"><code>Array</code></a> 的 <code>prototype</code> 属性上的方法来给所有数组实例增加方法.</p>
<p>值得一说的是, Array.prototype本身就是一个数组.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.isArray(<span class="built_in">Array</span>.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.length);<span class="comment">//0</span></span><br></pre></td></tr></table></figure>
<p>很明显,数组的原型是一个空数组,如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.__proto__;<span class="comment">//[]</span></span><br><span class="line"><span class="built_in">console</span>.log([].__proto__.length);<span class="comment">//0</span></span><br><span class="line"><span class="built_in">console</span>.log([].__proto__);<span class="comment">//[Symbol(Symbol.unscopables): Object]</span></span><br></pre></td></tr></table></figure>
<p>有关Symbol(Symbol.unscopables)的知识, 这里不做详述, 具体请移步后续章节.</p>
<h3 id="u65B9_u6CD5"><a href="#u65B9_u6CD5" class="headerlink" title="方法"></a>方法</h3><p>Array.prototype的方法包含三种, 一种是会改变自身值的, 一种是不会改变自身值的, 另外一种是遍历方法.</p>
<h4 id="u6539_u53D8_u81EA_u8EAB_u503C_u7684_u65B9_u6CD5_289_u4E2A_29"><a href="#u6539_u53D8_u81EA_u8EAB_u503C_u7684_u65B9_u6CD5_289_u4E2A_29" class="headerlink" title="改变自身值的方法(9个)"></a>改变自身值的方法(9个)</h4><p>基于ES6, 改变自身值的方法一共有9个, 分别为pop, push, reverse, shift, sort, splice, unshift, 以及两个ES6新增的方法copyWithin, fill.</p>
<h5 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h5><p>pop() 方法删除一个数组中的最后的一个元素，并且返回这个元素.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">"cat"</span>, <span class="string">"dog"</span>, <span class="string">"cow"</span>, <span class="string">"chicken"</span>, <span class="string">"mouse"</span>];</span><br><span class="line"><span class="keyword">var</span> item = array.pop();</span><br><span class="line"><span class="built_in">console</span>.log(array);<span class="comment">//["cat", "dog", "cow", "chicken"]</span></span><br><span class="line"><span class="built_in">console</span>.log(item);<span class="comment">//mouse</span></span><br></pre></td></tr></table></figure>
<p>由于设计上的巧妙, pop方法可以应用在类数组对象上, 即 <code>鸭式辨型</code>. 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="string">"cat"</span>, <span class="number">1</span>:<span class="string">"dog"</span>, <span class="number">2</span>:<span class="string">"cow"</span>, <span class="number">3</span>:<span class="string">"chicken"</span>, <span class="number">4</span>:<span class="string">"mouse"</span>, length:<span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">var</span> item = <span class="built_in">Array</span>.prototype.pop.call(o);</span><br><span class="line"><span class="built_in">console</span>.log(array);<span class="comment">//Object &#123;0: "cat", 1: "dog", 2: "cow", 3: "chicken", length: 4&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(item);<span class="comment">//mouse</span></span><br></pre></td></tr></table></figure>
<p>但如果类数组对象不具有length属性, 那么该对象将被创建length属性, length值为0, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="string">"cat"</span>, <span class="number">1</span>:<span class="string">"dog"</span>, <span class="number">2</span>:<span class="string">"cow"</span>, <span class="number">3</span>:<span class="string">"chicken"</span>, <span class="number">4</span>:<span class="string">"mouse"</span>&#125;</span><br><span class="line"><span class="keyword">var</span> item = <span class="built_in">Array</span>.prototype.pop.call(o);</span><br><span class="line"><span class="built_in">console</span>.log(array);<span class="comment">//Object &#123;0: "cat", 1: "dog", 2: "cow", 3: "chicken", 4: "mouse", length: 0&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(item);<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<h5 id="push"><a href="#push" class="headerlink" title="push"></a>push</h5><p>push()方法添加一个或者多个元素到数组末尾, 并且返回数组新的长度.</p>
<p>语法: arr.push(element1, …, elementN)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">"football"</span>, <span class="string">"basketball"</span>, <span class="string">"volleyball"</span>, <span class="string">"Table tennis"</span>, <span class="string">"badminton"</span>];</span><br><span class="line"><span class="keyword">var</span> i = array.push(<span class="string">"golfball"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(array);<span class="comment">//["football", "basketball", "volleyball", "Table tennis", "badminton", "golfball"]</span></span><br><span class="line"><span class="built_in">console</span>.log(i);<span class="comment">//6</span></span><br></pre></td></tr></table></figure>
<p>同pop方法一样, push方法也可以应用到类数组对象上, 如果length不能被转成一个数值或者不存在length属性时, 则插入的元素索引为0, 且length属性不存在时, 将会创建它.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="string">"football"</span>, <span class="number">1</span>:<span class="string">"basketball"</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> i = <span class="built_in">Array</span>.prototype.push.call(o, <span class="string">"golfball"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(o);<span class="comment">//Object &#123;0: "golfball", 1: "basketball", length: 1&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(i);<span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<p>实际上, push方法是根据length属性来决定从哪里开始插入给定的值.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="string">"football"</span>, <span class="number">1</span>:<span class="string">"basketball"</span>,length:<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> i = <span class="built_in">Array</span>.prototype.push.call(o,<span class="string">"golfball"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(o);<span class="comment">//Object &#123;0: "football", 1: "golfball", length: 2&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(i);<span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>利用push根据length属性插入元素这个特点, 可以实现数组的合并, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">"football"</span>, <span class="string">"basketball"</span>];</span><br><span class="line"><span class="keyword">var</span> array2 = [<span class="string">"volleyball"</span>, <span class="string">"golfball"</span>];</span><br><span class="line"><span class="keyword">var</span> i = <span class="built_in">Array</span>.prototype.push.apply(array,array2);</span><br><span class="line"><span class="built_in">console</span>.log(array);<span class="comment">//["football", "basketball", "volleyball", "golfball"]</span></span><br><span class="line"><span class="built_in">console</span>.log(i);<span class="comment">//4</span></span><br></pre></td></tr></table></figure>
<h5 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h5><p>reverse()方法颠倒数组中元素的位置, 第一个会成为最后一个, 最后一个会成为第一个, 该方法返回对数组的引用.</p>
<p>语法:arr.reverse()</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> array2 = array.reverse();</span><br><span class="line"><span class="built_in">console</span>.log(array);<span class="comment">//[5,4,3,2,1]</span></span><br><span class="line"><span class="built_in">console</span>.log(array2===array);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>同上, reverse 也是鸭式辨型的受益者, 颠倒元素的范围受length属性制约, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="string">"a"</span>, <span class="number">1</span>:<span class="string">"b"</span>, <span class="number">2</span>:<span class="string">"c"</span>, length:<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="built_in">Array</span>.prototype.reverse.call(o);</span><br><span class="line"><span class="built_in">console</span>.log(o);<span class="comment">//Object &#123;0: "b", 1: "a", 2: "c", length: 2&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(o === o2);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<h5 id="shift"><a href="#shift" class="headerlink" title="shift"></a>shift</h5><p>shift()方法删除数组的第一个元素, 并返回这个元素.</p>
<p>语法: arr.shift()</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> item = array.shift();</span><br><span class="line"><span class="built_in">console</span>.log(array);<span class="comment">//[2,3,4,5]</span></span><br><span class="line"><span class="built_in">console</span>.log(item);<span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<p>同样受益于鸭式辨型, 对于类数组对象, shift仍然能够处理, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="string">"a"</span>, <span class="number">1</span>:<span class="string">"b"</span>, <span class="number">2</span>:<span class="string">"c"</span>, length:<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> item = <span class="built_in">Array</span>.prototype.shift.call(o);</span><br><span class="line"><span class="built_in">console</span>.log(o);<span class="comment">//Object &#123;0: "b", 1: "c", length: 2&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(item);<span class="comment">//a</span></span><br></pre></td></tr></table></figure>
<p>如果类数组对象length属性不存在, 将添加length属性, 并初始化为0,如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="string">"a"</span>, <span class="number">1</span>:<span class="string">"b"</span>, <span class="number">2</span>:<span class="string">"c"</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> item = <span class="built_in">Array</span>.prototype.shift.call(o);</span><br><span class="line"><span class="built_in">console</span>.log(o);<span class="comment">//Object &#123;0: "a", 1: "b", 2:"c" length: 0&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(item);<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<h5 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h5><p>sort()方法对数组元素进行排序, 并返回这个数组.</p>
<p>语法: arr.sort([comparefn]), comparefn是可选的, 如果省略, 数组元素将按照各自转换为字符串的Unicode(万国码)位点顺序排序, 例如”boy”将排到”Apple”之前. 当对数字排序的时候, 25将会排到8之前, 因为转换为字符串后, “25”将比”8”靠前. 例如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">"Apple"</span>,<span class="string">"boy"</span>,<span class="string">"Cat"</span>,<span class="string">"dog"</span>];</span><br><span class="line"><span class="keyword">var</span> array2 = array.sort();</span><br><span class="line"><span class="built_in">console</span>.log(array);<span class="comment">//["Apple", "Cat", "boy", "dog"]</span></span><br><span class="line"><span class="built_in">console</span>.log(array2 == array);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">array = [<span class="number">10</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">20</span>];</span><br><span class="line"><span class="keyword">var</span> array3 = array.sort();</span><br><span class="line"><span class="built_in">console</span>.log(array3);<span class="comment">//[1, 10, 20, 3]</span></span><br></pre></td></tr></table></figure>
<p>如果指明了comparefn, 数组将按照调用该函数的返回值来排序. 若 a 和 b 是两个将要比较的元素:</p>
<ul>
<li>若 comparefn(a, b) &lt; 0 , 那么a 将排到 b 前面;</li>
<li>若 comparefn(a, b) = 0 , 那么a 和 b 相对位置不变;</li>
<li>若 comparefn(a, b) &gt; 0 , 那么a , b 将调换位置;</li>
</ul>
<p>如果数组元素为数字, 则排序函数comparefn格式如下所示:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果数组元素为非ASCII字符的字符串(如包含类似 e, é, è, a, ä 或中文字符等非英文字符的字符串), 则需要使用String.localeCompare. 下面这个函数将排到正确的顺序.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">'互'</span>,<span class="string">'联'</span>,<span class="string">'网'</span>,<span class="string">'改'</span>,<span class="string">'变'</span>,<span class="string">'世'</span>,<span class="string">'界'</span>];</span><br><span class="line"><span class="keyword">var</span> array2 = array.sort();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> array = [<span class="string">'互'</span>,<span class="string">'联'</span>,<span class="string">'网'</span>,<span class="string">'改'</span>,<span class="string">'变'</span>,<span class="string">'世'</span>,<span class="string">'界'</span>];<span class="comment">//重新赋值,避免干扰array2</span></span><br><span class="line"><span class="keyword">var</span> array3 = array.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a.localeCompare(b);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(array2);<span class="comment">//["世", "互", "变", "改", "界", "网", "联"]</span></span><br><span class="line"><span class="built_in">console</span>.log(array3);<span class="comment">//["变", "改", "互", "界", "联", "世", "网"]</span></span><br></pre></td></tr></table></figure>
<p>如上, “互联网改变世界” 这个数组, sort函数默认按照数组元素unicode字符串形式进行排序, 然而实际上, 我们期望的是按照拼音先后顺序进行排序, 显然String.localeCompare 帮助我们达到了这个目的.</p>
<p>为什么上面测试中需要重新给array赋值呢, 这是因为sort每次排序时改变的是数组本身, 并且返回数组引用. 如果不这么做, 经过连续两次排序后, array2 和 array3 将指向同一个数组, 最终影响我们测试. array重新赋值后就断开了对原数组的引用.</p>
<p>同上, sort一样受益于鸭式辨型, 比如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="string">'互'</span>,<span class="number">1</span>:<span class="string">'联'</span>,<span class="number">2</span>:<span class="string">'网'</span>,<span class="number">3</span>:<span class="string">'改'</span>,<span class="number">4</span>:<span class="string">'变'</span>,<span class="number">5</span>:<span class="string">'世'</span>,<span class="number">6</span>:<span class="string">'界'</span>,length:<span class="number">7</span>&#125;;</span><br><span class="line"><span class="built_in">Array</span>.prototype.sort.call(o,<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a.localeCompare(b);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(o);<span class="comment">//Object &#123;0: "变", 1: "改", 2: "互", 3: "界", 4: "联", 5: "世", 6: "网", length: 7&#125;, 可见同上述排序结果一致</span></span><br></pre></td></tr></table></figure>
<p>注意: 使用sort的鸭式辨型特性时, 若类数组对象不具有length属性, 它并不会为其添加length属性.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="string">'互'</span>,<span class="number">1</span>:<span class="string">'联'</span>,<span class="number">2</span>:<span class="string">'网'</span>,<span class="number">3</span>:<span class="string">'改'</span>,<span class="number">4</span>:<span class="string">'变'</span>,<span class="number">5</span>:<span class="string">'世'</span>,<span class="number">6</span>:<span class="string">'界'</span>&#125;;</span><br><span class="line"><span class="built_in">Array</span>.prototype.sort.call(o,<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a.localeCompare(b);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(o);<span class="comment">//Object &#123;0: "互", 1: "联", 2: "网", 3: "改", 4: "变", 5: "世", 6: "界"&#125;, 可见并未添加length属性</span></span><br></pre></td></tr></table></figure>
<h6 id="u4F7F_u7528_u6620_u5C04_u6539_u5584_u6392_u5E8F"><a href="#u4F7F_u7528_u6620_u5C04_u6539_u5584_u6392_u5E8F" class="headerlink" title="使用映射改善排序"></a>使用映射改善排序</h6><p>comparefn 如果需要对数组元素多次转换以实现排序, 那么使用map辅助排序将是个不错的选择. 基本思想就是将数组中的每个元素实际比较的值取出来, 排序后再将数组恢复.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要被排序的数组</span></span><br><span class="line"><span class="keyword">var</span> array = [<span class="string">'dog'</span>, <span class="string">'Cat'</span>, <span class="string">'Boy'</span>, <span class="string">'apple'</span>];</span><br><span class="line"><span class="comment">// 对需要排序的数字和位置的临时存储</span></span><br><span class="line"><span class="keyword">var</span> mapped = array.map(<span class="function"><span class="keyword">function</span>(<span class="params">el, i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; index: i, value: el.toLowerCase() &#125;;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 按照多个值排序数组</span></span><br><span class="line">mapped.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> +(a.value &gt; b.value) || +(a.value === b.value) - <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 根据索引得到排序的结果</span></span><br><span class="line"><span class="keyword">var</span> result = mapped.map(<span class="function"><span class="keyword">function</span>(<span class="params">el</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> array[el.index];</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(result);<span class="comment">//["apple", "Boy", "Cat", "dog"]</span></span><br></pre></td></tr></table></figure>
<h6 id="u5947_u602A_u7684chrome"><a href="#u5947_u602A_u7684chrome" class="headerlink" title="奇怪的chrome"></a>奇怪的chrome</h6><p>实际上, ECMAscript规范中并未规定具体的sort算法, 这就势必导致各个浏览器不尽相同的sort算法, 请看sort方法在Chrome浏览器下表现:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [&#123; n: <span class="string">"a"</span>, v: <span class="number">1</span> &#125;, &#123; n: <span class="string">"b"</span>, v: <span class="number">1</span> &#125;, &#123; n: <span class="string">"c"</span>, v: <span class="number">1</span> &#125;, &#123; n: <span class="string">"d"</span>, v: <span class="number">1</span> &#125;, &#123; n: <span class="string">"e"</span>, v: <span class="number">1</span> &#125;, &#123; n: <span class="string">"f"</span>, v: <span class="number">1</span> &#125;, &#123; n: <span class="string">"g"</span>, v: <span class="number">1</span> &#125;, &#123; n: <span class="string">"h"</span>, v: <span class="number">1</span> &#125;, &#123; n: <span class="string">"i"</span>, v: <span class="number">1</span> &#125;, &#123; n: <span class="string">"j"</span>, v: <span class="number">1</span> &#125;, &#123; n: <span class="string">"k"</span>, v: <span class="number">1</span> &#125;, ];</span><br><span class="line">array.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.v - b.v;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>,len = array.length; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(array[i].n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//f a c d e b g h i j k</span></span><br></pre></td></tr></table></figure>
<p>由于v值相等, array数组排序前后应该不变, 然而Chrome却表现异常, 而其他浏览器(如IE 或 Firefox) 表现正常.</p>
<p>这是因为v8引擎为了高效排序(采用了不稳定排序). 即数组长度超过10条时, 会调用另一种排序方法(快速排序); 而10条及以下采用的是插入算法,此时结果将是稳定的, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [&#123; n: <span class="string">"a"</span>, v: <span class="number">1</span> &#125;, &#123; n: <span class="string">"b"</span>, v: <span class="number">1</span> &#125;, &#123; n: <span class="string">"c"</span>, v: <span class="number">1</span> &#125;, &#123; n: <span class="string">"d"</span>, v: <span class="number">1</span> &#125;, &#123; n: <span class="string">"e"</span>, v: <span class="number">1</span> &#125;, &#123; n: <span class="string">"f"</span>, v: <span class="number">1</span> &#125;, &#123; n: <span class="string">"g"</span>, v: <span class="number">1</span> &#125;, &#123; n: <span class="string">"h"</span>, v: <span class="number">1</span> &#125;, &#123; n: <span class="string">"i"</span>, v: <span class="number">1</span> &#125;, &#123; n: <span class="string">"j"</span>, v: <span class="number">1</span> &#125;,];</span><br><span class="line">array.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.v - b.v;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>,len = array.length; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(array[i].n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//a b c d e f g h i j</span></span><br></pre></td></tr></table></figure>
<p>从a 到 j 刚好10条数据.</p>
<p>那么我们该如何规避Chrome浏览器的这种”bug”呢? 其实很简单, 只需略动手脚, 改变排序方法的返回值即可, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.v - b.v || array.indexOf(a)-array.indexOf(b);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>使用数组的sort方法需要注意一点: 各浏览器的针对sort方法内部算法实现不尽相同, 排序函数尽量只返回-1, 0, 1三种不同的值, 不要尝试返回true或false等其它数值, 因为可能导致不可靠的排序结果.</p>
<h6 id="u95EE_u9898_u5206_u6790"><a href="#u95EE_u9898_u5206_u6790" class="headerlink" title="问题分析"></a>问题分析</h6><p>sort方法传入的排序函数如果返回布尔值会导致什么样的结果呢?</p>
<p>以下是常见的浏览器以及脚本引擎:</p>
<table>
<thead>
<tr>
<th>Browser Name</th>
<th>ECMAScript Engine</th>
</tr>
</thead>
<tbody>
<tr>
<td>Internet Explorer 6 - 8</td>
<td>JScript</td>
</tr>
<tr>
<td>Internet Explorer 9 - 10</td>
<td>Chakra</td>
</tr>
<tr>
<td>Firefox</td>
<td>IonMonkey(Monkey系列引擎), TraceMonkey, Gecko</td>
</tr>
<tr>
<td>Chrome</td>
<td>V8</td>
</tr>
<tr>
<td>Safair</td>
<td>JavaScriptCore(SquirrelFish Extreme)</td>
</tr>
<tr>
<td>Opera</td>
<td>Carakan</td>
</tr>
</tbody>
</table>
<p>分析以下代码，预期将数组元素进行升序排序：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line"><span class="keyword">var</span> comparefn = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x &gt; y;</span><br><span class="line">&#125;;</span><br><span class="line">array.sort(comparefn);</span><br></pre></td></tr></table></figure>
<p>代码中，comparefn 函数返回值为 bool 类型，并非为规范规定的 -1、0、1 值。那么执行此代码，各 JS 脚本引擎实现情况如何？</p>
<table>
<thead>
<tr>
<th></th>
<th>输出结果</th>
<th>是否符合预期</th>
</tr>
</thead>
<tbody>
<tr>
<td>JScript</td>
<td>[2, 3, 5, 1, 4, 6, 7, 0, 8, 9]</td>
<td>否</td>
</tr>
<tr>
<td>Carakan</td>
<td>[0, 1, 3, 8, 2, 4, 9, 5, 6, 7]</td>
<td>否</td>
</tr>
<tr>
<td>Chakra &amp; JavaScriptCore</td>
<td>[7, 6, 5, 4, 3, 2, 1, 0, 8, 9]</td>
<td>否</td>
</tr>
<tr>
<td>IonMonkey</td>
<td>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</td>
<td>是</td>
</tr>
<tr>
<td>V8</td>
<td>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</td>
<td>是</td>
</tr>
</tbody>
</table>
<p><strong>根据表中数据可见，当数组内元素个数小于等于 10 时:</strong></p>
<ul>
<li>JScript &amp; Carakan 排序结果有误</li>
<li>Chakra &amp; JavaScriptCore 看起来没有进行排序</li>
<li>IonMonkey 返回了预期的正确结果</li>
<li>V8 暂时看起来排序正确</li>
</ul>
<p><strong>将数组元素扩大至 11 位:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>];</span><br><span class="line"><span class="keyword">var</span> comparefn = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x &gt; y;</span><br><span class="line">&#125;;</span><br><span class="line">array.sort(comparefn);</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th></th>
<th>输出结果</th>
<th>是否符合预期</th>
</tr>
</thead>
<tbody>
<tr>
<td>JScript</td>
<td>[2, 3, 5, 1, 4, 6, 7, 0, 8, 9, 10]</td>
<td>否</td>
</tr>
<tr>
<td>Carakan</td>
<td>[0, 1, 3, 8, 2, 4, 9, 5, 10, 6, 7]</td>
<td>否</td>
</tr>
<tr>
<td>Chakra &amp; JavaScriptCore</td>
<td>[7, 6, 5, 4, 3, 2, 1, 0, 10, 8, 9]</td>
<td>否</td>
</tr>
<tr>
<td>IonMonkey</td>
<td>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</td>
<td>是</td>
</tr>
<tr>
<td>V8</td>
<td>[5, 0, 1, 2, 3, 4, 6, 7, 8, 9, 10]</td>
<td>否</td>
</tr>
</tbody>
</table>
<p><strong>根据表中数据可见，当数组内元素个数大于 10 时：</strong></p>
<ul>
<li>JScript &amp; Carakan 排序结果有误</li>
<li>Chakra &amp; JavaScriptCore 看起来没有进行排序</li>
<li>IonMonkey 返回了预期的正确结果</li>
<li>V8 <strong>排序结果由正确转为不正确</strong></li>
</ul>
<h5 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h5><p>splice()方法用新元素替换旧元素的方式来修改数组.</p>
<p>语法: arr.splice(start,deleteCount[, item1[, item2[, …]]])</p>
<p>start 指定从哪一位开始修改内容. 如果超过了数组长度, 则从数组末尾开始添加内容; 如果是负值, 则其指定的索引位置等同于length+start(length为数组的长度), 表示从数组末尾开始的第几位.</p>
<p>deleteCount 指定要删除的元素个数, 若等于0 ,则不删除. 这种情况下, 至少应该添加一位新元素. 若大于start之后的元素总和, 则start及之后的元素都将被删除.</p>
<p>itemN 指定新增的元素, 如果缺省, 则该方法只删除数组元素.</p>
<p>返回值 由原数组中被删除元素组成的数组,如果没有删除, 则返回一个空数组.</p>
<p>下面来举栗子说明:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">"apple"</span>,<span class="string">"boy"</span>];</span><br><span class="line"><span class="keyword">var</span> splices = array.splice(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(array);<span class="comment">//["apple"]</span></span><br><span class="line"><span class="built_in">console</span>.log(splices);<span class="comment">//["boy"] ,可见是从数组下标为1的元素开始删除,并且删除一个元素,由于itemN缺省,故此时该方法只删除元素</span></span><br><span class="line"></span><br><span class="line">array = [<span class="string">"apple"</span>,<span class="string">"boy"</span>];</span><br><span class="line">splices = array.splice(<span class="number">2</span>,<span class="number">1</span>,<span class="string">"cat"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(array);<span class="comment">//["apple", "boy", "cat"]</span></span><br><span class="line"><span class="built_in">console</span>.log(splices);<span class="comment">//[], 可见由于start超过数组长度,此时从数组末尾开始添加元素,并且原数组不会发生删除行为</span></span><br><span class="line"></span><br><span class="line">array = [<span class="string">"apple"</span>,<span class="string">"boy"</span>];</span><br><span class="line">splices = array.splice(-<span class="number">3</span>,<span class="number">1</span>,<span class="string">"cat"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(array);<span class="comment">//["cat", "boy"]</span></span><br><span class="line"><span class="built_in">console</span>.log(splices);<span class="comment">//["apple"], 可见当start为负值时,是从数组末尾开始的第-start位开始删除,删除一个元素,并且从此处插入了一个元素</span></span><br><span class="line"></span><br><span class="line">array = [<span class="string">"apple"</span>,<span class="string">"boy"</span>];</span><br><span class="line">splices = array.splice(-<span class="number">3</span>,<span class="number">1</span>,<span class="string">"cat"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(array);<span class="comment">//["cat", "boy"]</span></span><br><span class="line"><span class="built_in">console</span>.log(splices);<span class="comment">//["apple"], 可见即使-start超出数组长度,数组默认从首位开始删除</span></span><br><span class="line"></span><br><span class="line">array = [<span class="string">"apple"</span>,<span class="string">"boy"</span>];</span><br><span class="line">splices = array.splice(<span class="number">0</span>,<span class="number">3</span>,<span class="string">"cat"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(array);<span class="comment">//["cat"]</span></span><br><span class="line"><span class="built_in">console</span>.log(splices);<span class="comment">//["apple", "boy"], 可见当deleteCount大于数组start之后的元素总和时,start及之后的元素都将被删除</span></span><br></pre></td></tr></table></figure>
<p>同上, splice一样受益于鸭式辨型, 比如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="string">"apple"</span>,<span class="number">1</span>:<span class="string">"boy"</span>,length:<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> splices = <span class="built_in">Array</span>.prototype.splice.call(o,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(o);<span class="comment">//Object &#123;0: "apple", length: 1&#125;, 可见对象o删除了一个属性,并且length-1</span></span><br><span class="line"><span class="built_in">console</span>.log(splices);<span class="comment">//["boy"]</span></span><br></pre></td></tr></table></figure>
<p>注: 如果类数组对象没有length属性, splice将为该类数组对象添加length属性,并初始化为0. 此处栗子忽略. 如果需要请在<a href="https://github.com/Louiszhai" target="_blank" rel="external">评论</a>里反馈.</p>
<h5 id="unshift"><a href="#unshift" class="headerlink" title="unshift"></a>unshift</h5><p>unshift() 方法用于在数组开始处插入一些元素(感觉像栈底插入), 并返回数组新的长度.</p>
<p>语法: arr.unshift(element1, …, elementN)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>];</span><br><span class="line"><span class="keyword">var</span> length = array.unshift(<span class="string">"yellow"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(array);<span class="comment">//["yellow", "red", "green", "blue"]</span></span><br><span class="line"><span class="built_in">console</span>.log(length);<span class="comment">//4</span></span><br></pre></td></tr></table></figure>
<p>如果给unshift方法传入一个数组呢?</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>];</span><br><span class="line"><span class="keyword">var</span> length = array.unshift([<span class="string">"yellow"</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(array);<span class="comment">//[["yellow"], "red", "green", "blue"]</span></span><br><span class="line"><span class="built_in">console</span>.log(length);<span class="comment">//4, 可见数组也能成功插入</span></span><br></pre></td></tr></table></figure>
<p>同上, unshift也受益于鸭式辨型, 呈上栗子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="string">"red"</span>, <span class="number">1</span>:<span class="string">"green"</span>, <span class="number">2</span>:<span class="string">"blue"</span>,length:<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> length = <span class="built_in">Array</span>.prototype.unshift.call(o,<span class="string">"gray"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(o);<span class="comment">//Object &#123;0: "gray", 1: "red", 2: "green", 3: "blue", length: 4&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(length);<span class="comment">//4</span></span><br></pre></td></tr></table></figure>
<p>注: 如果类数组对象不指定length属性, 则返回结果是这样的 Object {0: “gray”, 1: “green”, 2: “blue”, length: 1}, shift会认为数组长度为0, 此时将从对象下标为0的位置开始插入, 并且初始化类数组对象的length属性为插入元素个数.</p>
<h5 id="copyWithin"><a href="#copyWithin" class="headerlink" title="copyWithin"></a>copyWithin</h5><p>copyWithin() 方法用于数组内的元素替换, 即替换元素和被替换元素均是数组内的元素.</p>
<p>语法: arr.copyWithin(target, start[, end = this.length])</p>
<p>taget 指定被替换元素的索引, start 指定替换元素起始的索引, end 可选, 指的是替换元素结束位置的索引.</p>
<p>如果start为负，则其指定的索引位置等同于length+start，length为数组的长度。end也是如此.</p>
<p>注: 目前只有Firefox(版本32及其以上版本)实现了该方法.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]; </span><br><span class="line"><span class="keyword">var</span> array2 = array.copyWithin(<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(array===array2,array2);<span class="comment">// true [4, 5, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]; </span><br><span class="line"><span class="built_in">console</span>.log(array.copyWithin(<span class="number">0</span>,<span class="number">3</span>,<span class="number">4</span>));<span class="comment">// [4, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]; </span><br><span class="line"><span class="built_in">console</span>.log(array.copyWithin(<span class="number">0</span>,-<span class="number">2</span>,-<span class="number">1</span>));<span class="comment">// [4, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>
<p>同上, copyWithin一样受益于鸭式辨型, 例如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="number">1</span>, <span class="number">1</span>:<span class="number">2</span>, <span class="number">2</span>:<span class="number">3</span>, <span class="number">3</span>:<span class="number">4</span>, <span class="number">4</span>:<span class="number">5</span>,length:<span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="built_in">Array</span>.prototype.copyWithin.call(o,<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(o===o2,o2);<span class="comment">//true Object &#123; 0=4,  1=5,  2=3,  更多...&#125;</span></span><br></pre></td></tr></table></figure>
<p>如需在Firefox之外的浏览器使用copyWithin方法,请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin#Polyfill" target="_blank" rel="external">Polyfill</a>.</p>
<h5 id="fill"><a href="#fill" class="headerlink" title="fill"></a>fill</h5><p>fill() 方法同样用于数组元素替换, 它可将数组指定区间内的元素替换为某个值.</p>
<p>语法: <em>arr</em>.fill(value, start[, end = this.length])</p>
<p>value 指定被替换的值, start 指定替换元素起始的索引, end 可选, 指的是替换元素结束位置的索引.</p>
<p>如果start为负，则其指定的索引位置等同于length+start，length为数组的长度。end也是如此.</p>
<p>注: 目前只有Firefox(版本31及其以上版本)实现了该方法.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> array2 = array.fill(<span class="number">10</span>,<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(array===array2,array2);<span class="comment">// true [10, 10, 10, 4, 5], 可见数组区间[0,3]的元素全部替换为10</span></span><br><span class="line"><span class="comment">//其他的举例请参考copyWithin</span></span><br></pre></td></tr></table></figure>
<p>同上, fill 一样受益于鸭式辨型, 例如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="number">1</span>, <span class="number">1</span>:<span class="number">2</span>, <span class="number">2</span>:<span class="number">3</span>, <span class="number">3</span>:<span class="number">4</span>, <span class="number">4</span>:<span class="number">5</span>,length:<span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="built_in">Array</span>.prototype.fill.call(o,<span class="number">10</span>,<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(o===o2,o2); <span class="literal">true</span> <span class="built_in">Object</span> &#123; <span class="number">0</span>=<span class="number">10</span>,  <span class="number">1</span>=<span class="number">10</span>,  <span class="number">2</span>=<span class="number">3</span>,  更多...&#125;</span><br></pre></td></tr></table></figure>
<p>如需在Firefox之外的浏览器使用copyWithin方法,请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/fill#Compatibility" target="_blank" rel="external">Polyfill</a>.</p>
<h4 id="u4E0D_u4F1A_u6539_u53D8_u81EA_u8EAB_u7684_u65B9_u6CD5_289_u4E2A_29"><a href="#u4E0D_u4F1A_u6539_u53D8_u81EA_u8EAB_u7684_u65B9_u6CD5_289_u4E2A_29" class="headerlink" title="不会改变自身的方法(9个)"></a>不会改变自身的方法(9个)</h4><p>基于ES7, 不会改变自身的方法一共有9个, 分别为concat, join, slice, toString, toLocateString, indexOf, lastIndexOf, 未标准的toSource, 以及ES7新增的方法includes.z</p>
<h5 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h5><p>concat() 方法将传入的数组或者元素与原数组合并, 组成一个新的数组并返回.</p>
<p>语法: <em>arr</em>.concat(<em>value1</em>, <em>value2</em>, …, <em>valueN</em>)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> array2 = array.concat(<span class="number">4</span>,[<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(array2);<span class="comment">//[1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"><span class="built_in">console</span>.log(array);<span class="comment">//[1, 2, 3], 可见原数组并未被修改</span></span><br></pre></td></tr></table></figure>
<p>同上, concat 一样受益于鸭式辨型, 但其效果可能达不到我们的期望, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="string">"a"</span>, <span class="number">1</span>:<span class="string">"b"</span>, <span class="number">2</span>:<span class="string">"c"</span>,length:<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="built_in">Array</span>.prototype.concat.call(o,<span class="string">'d'</span>,&#123;<span class="number">3</span>:<span class="string">'e'</span>,<span class="number">4</span>:<span class="string">'f'</span>,length:<span class="number">2</span>&#125;,[<span class="string">'g'</span>,<span class="string">'h'</span>,<span class="string">'i'</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(o2);<span class="comment">//[&#123;0:"a", 1:"b", 2:"c", length:3&#125;, 'd', &#123;3:'e', 4:'f', length:2&#125;, 'g', 'h', 'i']</span></span><br></pre></td></tr></table></figure>
<p>可见, 类数组对象合并后返回的是依然是数组, 并不是我们期望的对象.</p>
<h5 id="join"><a href="#join" class="headerlink" title="join"></a>join</h5><p>join() 方法将数组中的所有元素连接成一个字符串.</p>
<p>语法: str = arr.join([separator = ‘,’]) separator可选, 缺省默认为逗号</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">'We'</span>, <span class="string">'are'</span>, <span class="string">'Chinese'</span>];</span><br><span class="line"><span class="built_in">console</span>.log(array.join());<span class="comment">//We,are,Chinese</span></span><br><span class="line"><span class="built_in">console</span>.log(array.join(<span class="string">'+'</span>));<span class="comment">//We+are+Chinese</span></span><br><span class="line"><span class="built_in">console</span>.log(array.join(<span class="string">''</span>));<span class="comment">//WeareChinese</span></span><br></pre></td></tr></table></figure>
<p>同上, join 一样受益于鸭式辨型, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="string">"We"</span>, <span class="number">1</span>:<span class="string">"are"</span>, <span class="number">2</span>:<span class="string">"Chinese"</span>, length:<span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.join.call(o,<span class="string">'+'</span>));<span class="comment">//We+are+Chinese</span></span><br></pre></td></tr></table></figure>
<h5 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h5><p>slice() 方法将数组中一部分元素浅复制存入新的数组对象, 并且返回这个数组对象.</p>
<p>语法: arr.slice(start[, end])</p>
<p>参数 start 指定复制开始位置的索引, end如果有值则表示复制结束位置的索引(不包括此位置).</p>
<p>如果 start 的值为负数, 假如数组长度为 length, 则表示从 length+start 的位置开始复制, 此时参数 end 如果有值, 只能是比 start 大的负数, 否则将返回空数组.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>,<span class="string">"four"</span>, <span class="string">"five"</span>];</span><br><span class="line"><span class="keyword">var</span> array2 = array.slice(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(array2);<span class="comment">//["three"]</span></span><br></pre></td></tr></table></figure>
<p><em>浅复制</em> 是指当对象的被复制时, 只是复制了对象的引用, 指向的依然是同一个对象. 下面来说明slice为什么是浅复制.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [&#123;color:<span class="string">"yellow"</span>&#125;, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> array2 = array.slice(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(array2);<span class="comment">//[&#123;color:"yellow"&#125;]</span></span><br><span class="line">array[<span class="number">0</span>][<span class="string">"color"</span>] = <span class="string">"blue"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(array2);<span class="comment">//[&#123;color:"bule"&#125;]</span></span><br></pre></td></tr></table></figure>
<p>由于slice是浅复制, 复制到的对象只是一个引用, 改变原数组array的值, array2也随之改变.</p>
<p>同上, slice 一样受益于鸭式辨型, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:&#123;<span class="string">"color"</span>:<span class="string">"yellow"</span>&#125;, <span class="number">1</span>:<span class="number">2</span>, <span class="number">2</span>:<span class="number">3</span>, length:<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="built_in">Array</span>.prototype.slice.call(o,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(o2);<span class="comment">//[&#123;color:"yellow"&#125;] ,毫无违和感...</span></span><br></pre></td></tr></table></figure>
<p>鉴于IE9以下版本对于该方法支持性并不是很好, 如需更好的支持低版本IE浏览器, 请参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/slice#更可靠地跨浏览器" target="_blank" rel="external">更可靠地跨浏览器</a></p>
<h5 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h5><p>toString() 方法返回数组的字符串形式, 该字符串由数组中的每个元素的 <code>toString()</code> 返回值经调用 <code>join()</code> 方法连接（由逗号隔开）组成.</p>
<p>语法: <em>arr</em>.toString()</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">'Jan'</span>, <span class="string">'Feb'</span>, <span class="string">'Mar'</span>, <span class="string">'Apr'</span>];</span><br><span class="line"><span class="keyword">var</span> str = array.toString();</span><br><span class="line"><span class="built_in">console</span>.log(str);<span class="comment">//Jan,Feb,Mar,Apr</span></span><br></pre></td></tr></table></figure>
<p>当数组直接和字符串作连接操作时, 将会自动调用其toString() 方法.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = [<span class="string">'Jan'</span>, <span class="string">'Feb'</span>, <span class="string">'Mar'</span>, <span class="string">'Apr'</span>] + <span class="string">',May'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str);<span class="comment">//Jan,Feb,Mar,Apr,May</span></span><br><span class="line"><span class="comment">//下面我们来试试鸭式辨型</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="string">'Jan'</span>, <span class="number">1</span>:<span class="string">'Feb'</span>, <span class="number">2</span>:<span class="string">'Mar'</span>, length:<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="built_in">Array</span>.prototype.toString.call(o);</span><br><span class="line"><span class="built_in">console</span>.log(o2);<span class="comment">//[object Object]</span></span><br><span class="line"><span class="built_in">console</span>.log(o.toString()==o2);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>可见, Array.prototype.toString()方法处理类数组对象时, 跟类数组对象直接调用Object.prototype.toString() 方法结果完全一致, 说好的鸭式辨型呢?</p>
<p>根据ES5语义, toString() 方法是通用的, 可被用于任何对象, 如果对象有一个join() 方法, 将会被调用, 其返回值将被返回, 没有则调用Object.prototype.toString(), 为此, 我们给o对象添加一个join方法, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  <span class="number">0</span>:<span class="string">'Jan'</span>, </span><br><span class="line">  <span class="number">1</span>:<span class="string">'Feb'</span>, </span><br><span class="line">  <span class="number">2</span>:<span class="string">'Mar'</span>, </span><br><span class="line">  length:<span class="number">3</span>, </span><br><span class="line">  join:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.join.call(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.toString.call(o));<span class="comment">//Jan,Feb,Mar</span></span><br></pre></td></tr></table></figure>
<h5 id="toLocaleString-NaN"><a href="#toLocaleString-NaN" class="headerlink" title="toLocaleString"></a>toLocaleString</h5><p>toLocaleString() 类似toString()的变体, 该字符串由数组中的每个元素的 <code>toLocaleString()</code> 返回值经调用 <code>join()</code> 方法连接（由逗号隔开）组成.</p>
<p>语法: <em>arr</em>.toLocaleString()</p>
<p>数组中的元素将调用各自的 toLocaleString 方法:</p>
<ul>
<li><code>Object</code>: <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toLocaleString" target="_blank" rel="external"><code>Object.prototype.toLocaleString()</code></a></li>
<li><code>Number</code>: <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString" target="_blank" rel="external"><code>Number.prototype.toLocaleString()</code></a></li>
<li><code>Date</code>: <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/toLocaleString" target="_blank" rel="external"><code>Date.prototype.toLocaleString()</code></a></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array= [&#123;name:<span class="string">'zz'</span>&#125;, <span class="number">123</span>, <span class="string">"abc"</span>, <span class="keyword">new</span> <span class="built_in">Date</span>()];</span><br><span class="line"><span class="keyword">var</span> str = array.toLocaleString();</span><br><span class="line"><span class="built_in">console</span>.log(str);<span class="comment">//[object Object],123,abc,2016/1/5 下午1:06:23</span></span><br></pre></td></tr></table></figure>
<p>其鸭式辨型的写法也同toString 保持一致, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  <span class="number">0</span>:<span class="number">123</span>, </span><br><span class="line">  <span class="number">1</span>:<span class="string">'abc'</span>, </span><br><span class="line">  <span class="number">2</span>:<span class="keyword">new</span> <span class="built_in">Date</span>(), </span><br><span class="line">  length:<span class="number">3</span>, </span><br><span class="line">  join:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.join.call(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.toLocaleString.call(o));<span class="comment">//123,abc,2016/1/5 下午1:16:50</span></span><br></pre></td></tr></table></figure>
<h5 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h5><p>indexOf() 方法用于查找元素在数组中第一次出现时的索引, 如果没有, 则返回-1.</p>
<p>语法: <em>arr</em>.indexOf(element, fromIndex=0)</p>
<p>element 为需要查找的元素</p>
<p>fromIndex 为开始查找的位置, 缺省默认为0. 如果超出数组长度, 则返回-1. 如果为负值, 假设数组长度为length, 则从数组的第 length + fromIndex项开始往数组末尾查找, 如果length + fromIndex&lt;0 则整个数组都会被查找.</p>
<p>indexOf使用严格相等(即使用 === 去匹配数组中的元素)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">'abc'</span>, <span class="string">'def'</span>, <span class="string">'ghi'</span>,<span class="string">'123'</span>];</span><br><span class="line"><span class="built_in">console</span>.log(array.indexOf(<span class="string">'def'</span>));<span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(array.indexOf(<span class="string">'def'</span>,-<span class="number">1</span>));<span class="comment">//1 此时表示从最后一个元素往后查找,因此查找失败返回-1</span></span><br><span class="line"><span class="built_in">console</span>.log(array.indexOf(<span class="string">'def'</span>,-<span class="number">4</span>));<span class="comment">//1 由于4大于数组长度,此时将查找整个数组,因此返回1</span></span><br><span class="line"><span class="built_in">console</span>.log(array.indexOf(<span class="number">123</span>));<span class="comment">//-1, 由于是严格匹配,因此并不会匹配到字符串'123'</span></span><br></pre></td></tr></table></figure>
<p>得益于鸭式辨型, indexOf 可以处理类数组对象, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="string">'abc'</span>, <span class="number">1</span>:<span class="string">'def'</span>, <span class="number">2</span>:<span class="string">'ghi'</span>, length:<span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.indexOf.call(o,<span class="string">'ghi'</span>,-<span class="number">4</span>));<span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>然而该方法并不支持IE9以下版本, 如需更好的支持低版本IE浏览器(IE6~8), 请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf#Polyfill" target="_blank" rel="external">Polyfill</a>.</p>
<h5 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf"></a>lastIndexOf</h5><p>lastIndexOf() 方法用于查找元素在数组中最后一次出现时的索引, 如果没有, 则返回-1. 并且它是indexOf的逆向查找, 即从数组最后一个往前查找.</p>
<p>语法: <em>arr</em>.lastIndexOf(element, fromIndex=length-1)</p>
<p>element 为需要查找的元素</p>
<p>fromIndex 为开始查找的位置, 缺省默认为数组长度length-1. 如果超出数组长度, 由于是逆向查找, 则查找整个数组. 如果为负值, 则从数组的第 length + fromIndex项开始往数组开头查找, 如果length + fromIndex&lt;0 则数组不会被查找.</p>
<p>同 indexOf 一样, lastIndexOf 也是严格匹配数组元素.</p>
<p>栗子参考 <code>indexOf</code> , 不再详述, 兼容低版本IE浏览器(IE6~8), 请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf#Compatibility" target="_blank" rel="external">Polyfill</a>.</p>
<h5 id="includes"><a href="#includes" class="headerlink" title="includes"></a>includes</h5><p>includes() 方法<strong>目前仍处于 ECMAScript 7 规范提案中</strong>, 它用来判断当前数组是否包含某个指定的值, 如果是, 则返回 true, 否则返回 false.</p>
<p>语法: <em>arr</em>.includes(element, fromIndex=0)</p>
<p>element 为需要查找的元素</p>
<p>fromIndex 表示从该索引位置开始查找 element, 缺省为0, 它是正向查找, 即从索引处往数组末尾查找.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="literal">NaN</span>];</span><br><span class="line"><span class="built_in">console</span>.log(array.includes(<span class="number">1</span>));<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(array.includes(<span class="literal">NaN</span>));<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(array.includes(<span class="number">2</span>,-<span class="number">4</span>));<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>该方法同样受益于鸭式辨型. 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="string">'a'</span>, <span class="number">1</span>:<span class="string">'b'</span>, <span class="number">2</span>:<span class="string">'c'</span>, length:<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> bool = <span class="built_in">Array</span>.prototype.includes.call(o, <span class="string">'a'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(bool);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>处于 ECMAScript 7 规范提案中的该方法只有在Chrome 47, opera 34, Safari 9版本及其更高版本中才予以实现. 如需支持其他浏览器, 请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/includes#Polyfill" target="_blank" rel="external">Polyfill</a>.</p>
<h5 id="toSource"><a href="#toSource" class="headerlink" title="toSource"></a>toSource</h5><p>toSource() 方法是非标准的, 该方法返回数组的源代码, 目前只有 Firefox 实现了它.</p>
<p>语法: <em>arr</em>.toSource()</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="built_in">console</span>.log(array.toSource());<span class="comment">//["a", "b", "c"]</span></span><br><span class="line"><span class="comment">//测试鸭式辨型</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="string">'a'</span>, <span class="number">1</span>:<span class="string">'b'</span>, <span class="number">2</span>:<span class="string">'c'</span>, length:<span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.toSource.call(o));<span class="comment">//["a","b","c"]</span></span><br></pre></td></tr></table></figure>
<h4 id="u904D_u5386_u65B9_u6CD5_2812_u4E2A_29"><a href="#u904D_u5386_u65B9_u6CD5_2812_u4E2A_29" class="headerlink" title="遍历方法(12个)"></a>遍历方法(12个)</h4><p>基于ES6, 不会改变自身的方法一共有12个, 分别为forEach, every, some, filter, map, reduce, reduceRight, 以及ES6新增的方法entries, find, findIndex, keys, values.</p>
<h5 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h5><p>forEach() 方法指定数组的每项元素都执行一次传入的函数, 返回值为undefined.</p>
<p>语法: <em>arr</em>.forEach(fn, thisArg)</p>
<p>fn 表示在数组每一项上执行的函数, 接受三个参数:</p>
<ul>
<li>item 当前正在被处理的元素的值</li>
<li>index 当前元素的数组索引</li>
<li>array 数组本身</li>
</ul>
<p>thisArg 可选, 用来当做fn函数内的this对象(context 上下文).</p>
<p>forEach 将为数组中每一项执行一次 fn 函数, 那些已删除, 新增或者从未赋值的项将被跳过(但不包括值为 undefined 的项). 遍历过程中, fn会被传入上述三个参数.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> obj = &#123;name:<span class="string">'cc'</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> sReturn = array.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>)</span>&#123;</span><br><span class="line">  array[index] = item * item;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);<span class="comment">//cc被打印了三次</span></span><br><span class="line">&#125;,obj);</span><br><span class="line"><span class="built_in">console</span>.log(array);<span class="comment">//[1, 9, 25], 可见原数组改变了</span></span><br><span class="line"><span class="built_in">console</span>.log(sReturn);<span class="comment">//undefined, 可见返回值为undefined</span></span><br></pre></td></tr></table></figure>
<p>得益于鸭式辨型, 虽然forEach不能直接遍历对象, 但它可以通过call方式遍历类数组对象. 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="number">1</span>, <span class="number">1</span>:<span class="number">3</span>, <span class="number">2</span>:<span class="number">5</span>, length:<span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">Array</span>.prototype.forEach.call(o,<span class="function"><span class="keyword">function</span>(<span class="params">item, index, obj</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item,index,obj);</span><br><span class="line">  obj[index] = item * item;</span><br><span class="line">&#125;,o);</span><br><span class="line"><span class="comment">//1 0 Object &#123;0: 1, 1: 3, 2: 5, length: 3&#125;</span></span><br><span class="line"><span class="comment">//3 1 Object &#123;0: 1, 1: 3, 2: 5, length: 3&#125;</span></span><br><span class="line"><span class="comment">//5 2 Object &#123;0: 1, 1: 9, 2: 5, length: 3&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(o);<span class="comment">//Object &#123;0: 1, 1: 9, 2: 25, length: 3&#125;</span></span><br></pre></td></tr></table></figure>
<p>参考前面的文章 <a href="http://louiszhai.github.io/2015/12/18/traverse/#forEach"><code>详解JS遍历</code></a> 中 forEach的讲解, 我们知道, forEach无法直接退出循环, 只能使用return 来达到for循环中continue的效果, 并且forEach不能在低版本IE(6~8)中使用, 兼容写法请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach#兼容旧环境（Polyfill）" target="_blank" rel="external">Polyfill</a> .</p>
<h5 id="every"><a href="#every" class="headerlink" title="every"></a>every</h5><p>every() 方法用于测试数组中所有元素是否都通过了指定函数的测试, 如果全部通过则返回 true, 否则返回false. 语法同上述forEach, 具体请参考 <a href="http://louiszhai.github.io/2015/12/18/traverse/#every"><code>详解JS遍历</code></a> 中every的讲解.</p>
<p>以下是鸭式辨型的写法:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="number">10</span>, <span class="number">1</span>:<span class="number">8</span>, <span class="number">2</span>:<span class="number">25</span>, length:<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> bool = <span class="built_in">Array</span>.prototype.every.call(o,<span class="function"><span class="keyword">function</span>(<span class="params">item, index, obj</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item &gt;= <span class="number">8</span>;</span><br><span class="line">&#125;,o);</span><br><span class="line"><span class="built_in">console</span>.log(bool);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>every 一样不能在低版本IE(6~8)中使用, 兼容写法请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/every#Compatibility" target="_blank" rel="external">Polyfill</a> .</p>
<h5 id="some"><a href="#some" class="headerlink" title="some"></a>some</h5><p>some() 方法几乎同 every() 方法一致, 唯一的区别是, some测试数组元素时, 只要有一个通过, 则返回 true, 若全部不通过, 则返回 false. 其在低版本IE(6~8) 的兼容写法请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/some#Compatibility" target="_blank" rel="external">Polyfill</a> .</p>
<h5 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h5><p>filter() 方法使用传入的函数测试所有元素, 并返回所有通过测试的元素组成的新数组.</p>
<p>语法: <em>arr</em>.filter(fn, thisArg)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">18</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">35</span>, <span class="number">80</span>];</span><br><span class="line"><span class="keyword">var</span> array2 = array.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item &gt; <span class="number">20</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(array2);<span class="comment">//[35, 80]</span></span><br></pre></td></tr></table></figure>
<p>filter一样支持鸭式辨型, 具体请参考every方法鸭式辨型写法. 其在低版本IE(6~8) 的兼容写法请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/filter#Compatibility" target="_blank" rel="external">Polyfill</a> .</p>
<h5 id="map"><a href="#map" class="headerlink" title="map"></a>map</h5><p>map() 方法遍历数组, 使用传入函数处理每个元素, 并返回函数的返回值组成的新数组.</p>
<p>语法: <em>arr</em>.map(fn, thisArg)</p>
<p>参数介绍同 forEach 方法的参数介绍.</p>
<p>具体用法请参考 <a href="http://louiszhai.github.io/2015/12/18/traverse/#map"><code>详解JS遍历</code></a> 中 map 的讲解.</p>
<p>map 一样支持鸭式辨型, 具体请参考every方法鸭式辨型写法.</p>
<p>其在低版本IE(6~8) 的兼容写法请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map#Compatibility" target="_blank" rel="external">Polyfill</a> .</p>
<h5 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h5><p>reduce() 方法接收一个方法作为累加器, 数组中的每个值(从左至右) 开始合并, 最终为一个值.</p>
<p>语法: <em>arr</em>.reduce(fn, initialValue)</p>
<p>fn 表示在数组每一项上执行的函数, 接受四个参数:</p>
<ul>
<li>previousValue 上一次调用回调返回的值, 或者是提供的初始值</li>
<li>item 数组中当前被处理元素的值</li>
<li>index 当前元素在数组中的索引</li>
<li>array 数组自身</li>
</ul>
<p>initialValue 指定第一次调用 fn 的第一个参数.</p>
<p>当 fn 第一次执行时, </p>
<ul>
<li>如果 initialValue 在调用 reduce 时被提供, 那么第一个 previousValue 将等于 initialValue, 此时 item 等于数组中的第一个值;</li>
<li>如果 initialValue 未被提供, 那么 previousVaule 等于数组中的第一个值, item 等于数组中的第二个值. 此时如果数组为空, 那么将抛出 TypeError.</li>
<li>如果数组仅有一个元素, 并且没有提供 initialValue, 或提供了 initialValue 但数组为空, 那么fn不会被执行, 数组的唯一值将被返回.</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> s = array.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">previousValue, item, index, array</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> previousValue * item;</span><br><span class="line">&#125;,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s);<span class="comment">//24</span></span><br></pre></td></tr></table></figure>
<p>以上回调被调用4次, 每次的参数和返回见下表:</p>
<table>
<thead>
<tr>
<th style="text-align:center">callback</th>
<th style="text-align:center">previousValue</th>
<th style="text-align:center">currentValue</th>
<th style="text-align:center">index</th>
<th style="text-align:center">array</th>
<th style="text-align:center">return value</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">第1次</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">[1,2,3,4]</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">第2次</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">[1,2,3,4]</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">第3次</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
<td style="text-align:center">[1,2,3,4]</td>
<td style="text-align:center">6</td>
</tr>
<tr>
<td style="text-align:center">第4次</td>
<td style="text-align:center">6</td>
<td style="text-align:center">4</td>
<td style="text-align:center">4</td>
<td style="text-align:center">[1,2,3,4]</td>
<td style="text-align:center">24</td>
</tr>
</tbody>
</table>
<p>reduce 一样支持鸭式辨型, 具体请参考every方法鸭式辨型写法.</p>
<p>其在低版本IE(6~8) 的兼容写法请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#兼容旧环境（Polyfill）" target="_blank" rel="external">Polyfill</a> .</p>
<h5 id="reduceRight"><a href="#reduceRight" class="headerlink" title="reduceRight"></a>reduceRight</h5><p>reduceRight() 方法接收一个方法作为累加器, 数组中的每个值(从右至左) 开始合并, 最终为一个值. 除了与reduce执行方向相反外, 其他完全与其一致, 请参考上述 reduce 方法介绍.</p>
<p>其在低版本IE(6~8) 的兼容写法请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight#.E5.85.BC.E5.AE.B9.E6.80.A7.E6.97.A7.E7.8E.AF.E5.A2.83.EF.BC.88Polyfill.EF.BC.89" target="_blank" rel="external">Polyfill</a> .</p>
<h5 id="entries"><a href="#entries" class="headerlink" title="entries"></a>entries</h5><p>entries() 方法基于<strong>ECMAScript 2015（ES6）规范</strong>, 返回一个数组迭代器对象, 该对象包含数组中每个索引的键值对.</p>
<p>语法: <em>arr</em>.entries()</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>];</span><br><span class="line"><span class="keyword">var</span> iterator = array.entries();</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value);<span class="comment">//[0, "a"]</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value);<span class="comment">//[1, "b"]</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value);<span class="comment">//[2, "c"]</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value);<span class="comment">//undefined, 迭代器处于数组末尾时, 再迭代就会返回undefined</span></span><br></pre></td></tr></table></figure>
<p>很明显, entries 也受益于鸭式辨型, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="string">"a"</span>, <span class="number">1</span>:<span class="string">"b"</span>, <span class="number">2</span>:<span class="string">"c"</span>, length:<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> iterator = <span class="built_in">Array</span>.prototype.entries.call(o);</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value);<span class="comment">//[0, "a"]</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value);<span class="comment">//[1, "b"]</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value);<span class="comment">//[2, "c"]</span></span><br></pre></td></tr></table></figure>
<p>由于该方法基于ES6, 因此目前并不支持所有浏览器, 以下是各浏览器支持版本:</p>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Chrome</th>
<th>Firefox (Gecko)</th>
<th>Internet Explorer</th>
<th>Opera</th>
<th>Safari</th>
</tr>
</thead>
<tbody>
<tr>
<td>Basic support</td>
<td>38</td>
<td><a href="https://developer.mozilla.org/en-US/Firefox/Releases/28" target="_blank" rel="external">28</a> (28)</td>
<td>未实现</td>
<td>25</td>
<td>7.1</td>
</tr>
</tbody>
</table>
<h5 id="find_26amp_3BfindIndex"><a href="#find_26amp_3BfindIndex" class="headerlink" title="find&amp;findIndex"></a>find&amp;findIndex</h5><p>find() 方法基于<strong>ECMAScript 2015（ES6）规范</strong>, 返回数组中第一个满足条件的元素(如果有的话), 如果没有, 则返回undefined.</p>
<p>findIndex() 方法则返回数组中第一个满足条件的元素的索引(如果有的话), 否则返回-1.</p>
<p>语法: <em>arr</em>.find(fn, thisArg), <em>arr</em>.findIndex(fn, thisArg)</p>
<p>我们发现它们的语法与forEach等十分相似, 其实不光语法, find(或findIndex) 在参数及其使用注意事项上, 均与forEach一致. 因此此处将略去 find(或findIndex) 的参数介绍. 下面我们来看个栗子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">item, index, array</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item%<span class="number">2</span>==<span class="number">0</span>;<span class="comment">//返回偶数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params">item, index, array</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item &gt; <span class="number">20</span>;<span class="comment">//返回大于20的数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(array.find(f));<span class="comment">//8</span></span><br><span class="line"><span class="built_in">console</span>.log(array.find(f2));<span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(array.findIndex(f));<span class="comment">//4</span></span><br><span class="line"><span class="built_in">console</span>.log(array.findIndex(f2));<span class="comment">//-1</span></span><br></pre></td></tr></table></figure>
<p>由于其鸭式辨型写法也与forEach方法一致, 故此处略去. </p>
<p>兼容性上我没有详测, 可以知道的是, 最新版的Chrome(47), 以及Firefox的版本25均实现了它们.</p>
<h5 id="keys"><a href="#keys" class="headerlink" title="keys"></a>keys</h5><p>keys() 方法基于<strong>ECMAScript 2015（ES6）规范</strong>,返回一个数组索引的迭代器. (实际实现可能会有调整)</p>
<p>语法: <em>arr</em>.keys()</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">"abc"</span>, <span class="string">"xyz"</span>];</span><br><span class="line"><span class="keyword">var</span> iterator = array.keys();</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());<span class="comment">//Object &#123;value: 0, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());<span class="comment">//Object &#123;value: 1, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());<span class="comment">//Object &#123;value: undefined, done: false&#125;</span></span><br></pre></td></tr></table></figure>
<p>索引迭代器会包含那些没有对应元素的索引, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">"abc"</span>, , <span class="string">"xyz"</span>];</span><br><span class="line"><span class="keyword">var</span> sparseKeys = <span class="built_in">Object</span>.keys(arr);</span><br><span class="line"><span class="keyword">var</span> denseKeys = [...arr.keys()];</span><br><span class="line"><span class="built_in">console</span>.log(sparseKeys); <span class="comment">// ["0", "2"]</span></span><br><span class="line"><span class="built_in">console</span>.log(denseKeys);  <span class="comment">// [0, 1, 2]</span></span><br></pre></td></tr></table></figure>
<p>其鸭式辨型写法请参考上述 entries 方法.</p>
<p>由于该方法基于ES6, 并未完全支持, 以下是各浏览器支持版本:</p>
<table>
<thead>
<tr>
<th style="text-align:center">Feature</th>
<th style="text-align:center">Chrome</th>
<th style="text-align:center">Firefox (Gecko)</th>
<th style="text-align:center">Internet Explorer</th>
<th style="text-align:center">Opera</th>
<th style="text-align:center">Safari</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Basic support</td>
<td style="text-align:center">38</td>
<td style="text-align:center"><a href="https://developer.mozilla.org/en-US/Firefox/Releases/28" target="_blank" rel="external">28</a> (28)</td>
<td style="text-align:center">未实现</td>
<td style="text-align:center">25</td>
<td style="text-align:center">7.1</td>
</tr>
</tbody>
</table>
<h5 id="values"><a href="#values" class="headerlink" title="values"></a>values</h5><p>values() 方法基于<strong>ECMAScript 2015（ES6）规范</strong>, 返回一个数组迭代器对象, 该对象包含数组中每个索引的值. 其用法基本与上述 entries 方法一致.</p>
<p>语法: <em>arr</em>.values()</p>
<p>遗憾的是, 现在没有浏览器实现了该方法, 因此下面将就着看看吧.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">"abc"</span>, <span class="string">"xyz"</span>];</span><br><span class="line"><span class="keyword">var</span> iterator = array.values();</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value);<span class="comment">//abc</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value);<span class="comment">//xyz</span></span><br></pre></td></tr></table></figure>
<h5 id="Symbol-iterator"><a href="#Symbol-iterator" class="headerlink" title="Symbol.iterator"></a>Symbol.iterator</h5><p>该方法基于<strong>ECMAScript 2015（ES6）规范</strong>, 同 values 方法功能相同.</p>
<p>语法: <em>arr</em>[Symbol.iterator]()</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">"abc"</span>, <span class="string">"xyz"</span>];</span><br><span class="line"><span class="keyword">var</span> iterator = array[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value);<span class="comment">//abc</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value);<span class="comment">//xyz</span></span><br></pre></td></tr></table></figure>
<p>其鸭式辨型写法请参考上述 entries 方法.</p>
<p>由于该方法基于ES6, 并未完全支持, 以下是各浏览器支持版本:</p>
<table>
<thead>
<tr>
<th style="text-align:center">Feature</th>
<th style="text-align:center">Chrome</th>
<th style="text-align:center">Firefox (Gecko)</th>
<th style="text-align:center">Internet Explorer</th>
<th style="text-align:center">Opera</th>
<th style="text-align:center">Safari</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Basic support</td>
<td style="text-align:center">38</td>
<td style="text-align:center"><a href="https://developer.mozilla.org/en-US/Firefox/Releases/36" target="_blank" rel="external">36</a> (36) <a href="#respond">1</a></td>
<td style="text-align:center">未实现</td>
<td style="text-align:center">25</td>
<td style="text-align:center">未实现</td>
</tr>
</tbody>
</table>
<h3 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h3><p>以上, Array.prototype 的各方法 基本介绍完毕, Array.prototype 的所有方法均具有鸭式辨型这种神奇的特性. 它们不止可以用来处理数组对象, 还可以处理类数组对象. </p>
<p>例如 javascript 中一个纯天然的类数组对象字符串(String), 像join 方法就完全适用, 可惜的是 Array.prototype 中很多的方法均会去试图修改当前对象的 length 属性, 比如说 pop 方法, 操作 String 对象时, 它就会报错.</p>
<p>还记得么, Array.prototype本身就是一个数组, 并且它的长度为0.</p>
<p>后续章节我们将继续探索Array的一些事情. 感谢您的阅读! </p>
<p>同时, 以下话题将会逐步去探讨, 敬请关注:</p>
<ul>
<li><code>unicode编码表</code></li>
</ul>
<ul>
<li><code>快速排序</code></li>
</ul>
<ul>
<li><code>插入排序</code></li>
</ul>
<hr>
<p>本问就讨论这么多内容,大家有什么问题或好的想法欢迎在下方参与<a href="#respond">留言和评论</a>.</p>
<p>本文作者: <a href="https://github.com/Louiszhai" target="_blank" rel="external">louis</a></p>
<p>本文链接: <a href="http://louiszhai.github.io/2015/12/29/array/">http://louiszhai.github.io/2015/12/29/array/</a></p>
<p>参考文章</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/prototype" target="_blank" rel="external">Array.prototype - JavaScript | MDN</a></li>
<li><a href="http://www.tuicool.com/articles/YjUBNbN" target="_blank" rel="external">Chrome谷歌浏览器中js代码Array.sort排序的bug乱序解决办法 - yzeng - 推酷</a></li>
<li><a href="http://www.w3help.org/zh-cn/causes/SJ9013" target="_blank" rel="external">SJ9013: Array.prototype.sort当使用了 comparefn 后返回值不为 -1、0、1时，各引擎实现排序结果不一致 - W3Help</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[JavaScript Array]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://louiszhai.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[详解JS作用域链及闭包]]></title>
    <link href="http://louiszhai.github.io/2015/12/22/scopeChain/"/>
    <id>http://louiszhai.github.io/2015/12/22/scopeChain/</id>
    <published>2015-12-22T00:06:13.000Z</published>
    <updated>2015-12-27T02:35:02.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u5BFC_u8BFB"><a href="#u5BFC_u8BFB" class="headerlink" title="导读"></a>导读</h3><p>上一篇我们讲到for和while循环效率之低, 令人发指. 那么本篇我们将揭晓它们低效率的原因, 并给出优化建议. 欢迎阅读本篇<strong><code>详解JS作用域链及闭包</code></strong>.</p>
<a id="more"></a>
<h3 id="u56DE_u987E_u4E0A_u7BC7"><a href="#u56DE_u987E_u4E0A_u7BC7" class="headerlink" title="回顾上篇"></a>回顾上篇</h3><p>请先看上一篇中提到的for循环代码:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [];</span><br><span class="line">array.length = <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t1 = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>,length=array.length;i&lt;length;i++)&#123;</span><br><span class="line">  <span class="comment">//array.push(i);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> t2 = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="built_in">console</span>.log(t2-t1);</span><br><span class="line"><span class="comment">//由于此时CPU空闲较多,此时效率有些许提升,以下是连续5次的运行时间:</span></span><br><span class="line"><span class="comment">//4091+4038+4202+4415+4507 = 21253(ms)</span></span><br></pre></td></tr></table></figure>
<p>我们再看下面一段代码:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t1 = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//闭包</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>,length=array.length;i&lt;length;i++)&#123;</span><br><span class="line">  	<span class="comment">//array.push(i);</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">var</span> t2 = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="built_in">console</span>.log(t2-t1);</span><br><span class="line"><span class="comment">//以下是连续5次的运行时间:</span></span><br><span class="line"><span class="comment">//17+19+17+20+18 = 91(ms)</span></span><br></pre></td></tr></table></figure>
<p>计算一下: 21253/91 = 233 效率提升两百多倍, 为什么呢?</p>
<p>我们注意到两段代码最大的区别就是, 第二段代码使用了匿名函数包裹for循环. 我们将在后面讲到, 请耐心阅读.</p>
<h3 id="u4F5C_u7528_u57DF"><a href="#u4F5C_u7528_u57DF" class="headerlink" title="作用域"></a>作用域</h3><p>所谓作用域, <a href="http://blog.csdn.net/yueguanghaidao" target="_blank" rel="external">Skycrab</a> 有句解释还不错, 指的是, 变量在声明它们的函数体以及这个函数体嵌套的任意函数体内都是有定义的.</p>
<h4 id="js_u4E2D_u53EA_u6709_u51FD_u6570_u4F5C_u7528_u57DF"><a href="#js_u4E2D_u53EA_u6709_u51FD_u6570_u4F5C_u7528_u57DF" class="headerlink" title="js中只有函数作用域"></a>js中只有函数作用域</h4><p>众所周知, JS中并没有块作用域, 只有函数作用域. 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">  ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i);<span class="comment">//10</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line">f();</span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">//a is not defined</span></span><br></pre></td></tr></table></figure>
<p>因此 js 中只有一种局部作用域, 即函数作用域.</p>
<h4 id="u4F7F_u7528_var__u58F0_u660E_u53D8_u91CF"><a href="#u4F7F_u7528_var__u58F0_u660E_u53D8_u91CF" class="headerlink" title="使用 var 声明变量"></a>使用 var 声明变量</h4><p>通常我们知道, js 作为一种弱类型语言, 声明一个变量只需要var保留字, 如果在函数中不使用 var 声明变量, 该变量将提升为全局变量, 进而脱离函数作用域, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  b = <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line">f();</span><br><span class="line"><span class="built_in">console</span>.log(b);<span class="comment">//123</span></span><br></pre></td></tr></table></figure>
<p>此时相对于前面使用var声明的 a 变量, b 变量被提升为全局变量, 在函数作用域外依然可以访问.</p>
<p>既然在函数作用域内不使用 var 声明变量, 会将变量提升为全局变量, 那么在全局下, 不使用var, 会怎么样呢?</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局下不使用var声明,该变量依然是全局变量</span></span><br><span class="line">c = <span class="string">"hello scope"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(c);<span class="comment">//hello scope</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.c);<span class="comment">//hello scope</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查看c变量的属性</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(<span class="built_in">window</span>, <span class="string">'c'</span>));<span class="comment">//Object &#123;value: "hello scope", writable: true, enumerable: true, configurable: true&#125; ,此时c变量可赋值,可列举,可配置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//试着删除c变量</span></span><br><span class="line"><span class="keyword">delete</span> c;<span class="comment">//true 表示c变量被成功删除</span></span><br><span class="line"><span class="built_in">console</span>.log(c);<span class="comment">//c is not defined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.c);<span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用var声明后再删除d变量</span></span><br><span class="line"><span class="keyword">var</span> d = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(<span class="built_in">window</span>, <span class="string">'d'</span>));<span class="comment">//Object &#123;value: 1, writable: true, enumerable: true, configurable: false&#125; ,此时d变量可赋值,可列举,但不可配置</span></span><br><span class="line"><span class="keyword">delete</span> d;<span class="comment">//false 表示d变量删除失败</span></span><br><span class="line"><span class="built_in">console</span>.log(d);<span class="comment">//1 </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.d);<span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<p>综上, 有如下规律:</p>
<ul>
<li>不使用var保留字声明变量, 变量提升为全局变量, 而不论变量处于哪种作用域;</li>
<li>如果不使用var声明,  该变量便可配置, 即可被 delete 保留字删除, 删除后该变量便不可访问; 如果使用var声明, 该变量便不可配置, 即不能被 delete 保留字删除;</li>
<li>只要是全局变量都可以直接访问, 也可使用 “window.变量名” 来访问, 不管该变量是不是通过var来声明的;</li>
</ul>
<h3 id="JS_u4E2D_u7684_u4F5C_u7528_u57DF_u94FE"><a href="#JS_u4E2D_u7684_u4F5C_u7528_u57DF_u94FE" class="headerlink" title="JS中的作用域链"></a>JS中的作用域链</h3><p>函数对象和其它对象一样，拥有可以通过代码访问的属性和一系列仅供JavaScript引擎访问的内部属性。其中一个内部属性是[[Scope]]，由ECMA-262标准第三版定义，该内部属性包含了函数被创建的作用域中对象的集合，这个集合被称为函数的作用域链，它决定了哪些数据能被函数访问。</p>
<p>我们先看一个栗子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> e = <span class="string">"hello"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  e = <span class="string">"scope chain"</span>;</span><br><span class="line">  <span class="keyword">var</span> g = = <span class="string">"good"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上作用域链的图如下所示:</p>
<p><img src="/doc_images/scopeChain01.png" alt=""></p>
<p>函数执行时, 在函数 f 内部会生成一个 active object 和 scope chain. JavaScript引擎内部对象会放入 active object中, 外部的 e 变量处于scope chain的第二层, index=1, 而内部的g变量处于scope chain的顶层, index=0, 因此访问g变量总比访问e变量来的快些.</p>
<h3 id="u95ED_u5305"><a href="#u95ED_u5305" class="headerlink" title="闭包"></a>闭包</h3><p>聊到作用域, 就不得不说闭包, 那么, 什么是闭包?</p>
<p>“官方”的解释是：闭包是一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。</p>
<p>这是什么意思呢, 其实我也不懂.</p>
<p>通俗的讲就是: 闭包是一个函数, 并且这个函数可以访问其他函数内的局部变量.</p>
<p>可是我们都知道函数作用域是局部作用域, 为了做到让另一个函数访问它内部的变量, 恐怕只能将另一个函数放入它的内部, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> h = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  	<span class="keyword">var</span> j = <span class="number">3</span> + i + h;</span><br><span class="line">    <span class="built_in">console</span>.log(j);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ff = f();</span><br><span class="line">ff();<span class="comment">//6</span></span><br></pre></td></tr></table></figure>
<p>由于 f2 处于 f 的内部, 因此 f2 内可以访问到 f 的局部作用域, 这样通过返回 f2 就能保证在 f 函数外部也能访问到 i 变量.</p>
<p>当f2执行时, 变量 j 处于scope chain的 index0的位置上, 变量 i 和变量 h 分别处于 scope chain 的 index1 index2 的位置上. 因此 j 的赋值过程其实就是沿着 scope chain 第二层 第三层 依次找到 i 和 h 的值, 然后将它们和3一起求和, 最终赋值给 j .</p>
<p>浏览器沿着 scope chain 寻找变量总是需要耗费CPU时间, 越是 scope chain 的 外层(或者离f2越远的变量), 浏览器查找起来越是需要时间, 因为 scope chain 需要历经更多次遍历. 因此全局变量(window)总是需要最多的访问时间.</p>
<h4 id="u95ED_u5305_u5185_u7684_u5FAE_u89C2_u4E16_u754C"><a href="#u95ED_u5305_u5185_u7684_u5FAE_u89C2_u4E16_u754C" class="headerlink" title="闭包内的微观世界"></a>闭包内的微观世界</h4><p>　　如果要更加深入的了解闭包以及函数 f 和嵌套函数 f2 的关系，我们需要引入另外几个概念：函数的执行环境(excution context)、活动对象(call object)、作用域(scope)、作用域链(scope chain)。以函数a从定义到执行的过程为例阐述这几个概念。</p>
<ol>
<li>当<strong>定义</strong>函数 f 的时候，js解释器会将函数a的<strong>作用域链(scope chain)</strong>设置为<strong>定义 f 时 a 所在的“环境”</strong>，如果 f 是一个全局函数，则scope chain中只有window对象。</li>
<li>当<strong>执行</strong>函数 f 的时候，f 会进入相应的<strong>执行环境(excution context)</strong>。</li>
<li>在创建执行环境的过程中，首先会为 f 添加一个scope属性，即a的<strong>作用域</strong>，其值就为第1步中的scope chain。即a.scope=f 的作用域链。</li>
<li>然后执行环境会创建一个<strong>活动对象(call object)</strong>。活动对象也是一个拥有属性的对象，但它不具有原型而且不能通过JavaScript代码直接访问。创建完活动对象后，把活动对象添加到 f 的作用域链的最顶端。此时a的作用域链包含了两个对象：f 的活动对象和window对象。</li>
<li>下一步是在活动对象上添加一个arguments属性，它保存着调用函数 f 时所传递的参数。</li>
<li>最后把所有函数 f 的形参和内部的函数 f2 的引用也添加到 f 的活动对象上。在这一步中，完成了函数 f2 的定义，因此如同第3步，函数 f2 的作用域链被设置为 f2 所被定义的环境，即 f 的作用域。</li>
</ol>
<p>到此，整个函数 f 从定义到执行的步骤就完成了。此时 f 返回函数 f2 的引用给 ff，又函数 f2 的作用域链包含了对函数 f 的活动对象的引用，也就是说 f2 可以访问到 f 中定义的所有变量和函数。函数 f2 被 ff 引用，函数 f2又依赖函数 f ，因此函数 f 在返回后不会被GC回收。</p>
<p>当函数 f2 执行的时候亦会像以上步骤一样。因此，执行时 f2 的作用域链包含了3个对象：f2 的活动对象、f 的活动对象和window对象，如下图所示：</p>
<p><img src="/doc_images/scopeChain02.jpg" alt=""></p>
<p>如图所示，当在函数 f2 中访问一个变量的时候，搜索顺序是：</p>
<ol>
<li>先搜索自身的活动对象，如果存在则返回，如果不存在将继续搜索函数 f 的活动对象，依次查找，直到找到为止。</li>
<li>如果函数 f2 存在prototype原型对象，则在查找完自身的活动对象后先查找自身的原型对象，再继续查找。这就是Javascript中的变量查找机制。</li>
<li>如果整个作用域链上都无法找到，则返回undefined。</li>
</ol>
<p>小结，本段中提到了两个重要的词语：函数的<strong>定义</strong>与<strong>执行</strong>。文中提到函数的作用域是在定义函数时候就已经确定，而不是在执行的时候确定（参看步骤1和3）。用一段代码来说明这个问题：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">var</span> g = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">  <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> h = f(<span class="number">1</span>);</span><br><span class="line">alert(h());</span><br></pre></td></tr></table></figure>
<p>这段代码中变量h指向了f中的那个匿名函数(由g返回)。</p>
<ul>
<li>假设函数h的作用域是在执行alert(h())确定的，那么此时h的作用域链是：h的活动对象-&gt;alert的活动对象-&gt;window对象。</li>
<li>假设函数h的作用域是在定义时确定的，就是说h指向的那个匿名函数在定义的时候就已经确定了作用域。那么在执行的时候，h的作用域链为：h的活动对象-&gt;f的活动对象-&gt;window对象。</li>
</ul>
<p>如果第一种假设成立，那输出值就是undefined；如果第二种假设成立，输出值则为1。</p>
<p>运行结果证明了第2个假设是正确的，说明函数的作用域确实是在定义这个函数的时候就已经确定了。</p>
<h4 id="u95ED_u5305_u6709_u53EF_u80FD_u5BFC_u81F4IE_u6D4F_u89C8_u5668_u5185_u5B58_u6CC4_u6F0F"><a href="#u95ED_u5305_u6709_u53EF_u80FD_u5BFC_u81F4IE_u6D4F_u89C8_u5668_u5185_u5B58_u6CC4_u6F0F" class="headerlink" title="闭包有可能导致IE浏览器内存泄漏"></a>闭包有可能导致IE浏览器内存泄漏</h4><p>先看一个栗子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);   </span><br><span class="line">  div.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述div的click事件就是一个闭包, 由于该闭包的存在使得 f 函数内部的 div 变量对DOM元素的引用将一直存在.</p>
<p>而早期IE浏览器( IE9之前 ) js 对象和 DOM 对象使用不同的垃圾收集方法, DOM对象使用计数垃圾回收机制, 只要匿名函数( 比如说onclick事件 )存在, DOM对象的引用便至少为1,因此它所占用的内存就永远不会被销毁.</p>
<p>有趣的是,不同的IE版本将导致不同的现象:</p>
<ul>
<li>如果是IE 6, 内存泄漏，直到关闭IE进程为止;</li>
<li>如果是IE 7，内存泄漏， 直到离开当前页面为止;</li>
<li>如果是IE 8， GC回收器回收他们的内存，无论当前是不是compatibility模式.</li>
</ul>
<p>总结一下, 闭包的优点: 共享函数作用域, 便于开放一些接口或变量供外部使用;</p>
<p>注意事项: 由于闭包可能会使得函数中变量被长期保存在内存中, 从而大量消耗内存, 影响页面性能, 因此不能滥用, 并且在IE浏览中可能导致内存泄露. 解决方法是，在退出函数之前，将不使用的局部变量全部删除.</p>
<h3 id="for_u5FAA_u73AF_u95EE_u9898_u5206_u6790"><a href="#for_u5FAA_u73AF_u95EE_u9898_u5206_u6790" class="headerlink" title="for循环问题分析"></a>for循环问题分析</h3><p>我们再来看看开篇的for循环问题, 增加匿名函数后, for循环内部的变量便处于匿名函数的局部作用域下, 此时访问 length 属性, 或者访问 i 属性, 都只需要在匿名函数作用域内查找即可, 因此查询效率大大提升(测试数据发现提升有两百多倍).</p>
<p>使用匿名函数后, 不止是作用域查询更快, 作用域内的变量还与外部隔离, 避免了像 i , length 这样的变量对后续代码产生影响. 可谓一举两得.</p>
<h3 id="u8E29_u4E2A_u4F5C_u7528_u57DF_u7684_u5751"><a href="#u8E29_u4E2A_u4F5C_u7528_u57DF_u7684_u5751" class="headerlink" title="踩个作用域的坑"></a>踩个作用域的坑</h3><p>下面我们来踩一个作用域经典的坑.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"div"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>,len=div.length;i&lt;len;i++)&#123;</span><br><span class="line">  div[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  	<span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码的本意是每次点击div, 打印div的索引, 实际上打印的却是 len 的值. 我们来分析下原因.</p>
<p>点击div时, 将会执行 console.log(i) 语句, 显然 i 变量不在 click 事件的局部作用域内, 浏览器将沿着 scope chain 寻找 i 变量, 在 index1 的地方, 即 for循环开始的地方, 此处定义了一个 i 变量, 又 js 没有块作用域, 故 i 变量并不会在 for循环块执行完成后被销毁,又 i的最后一次自加使得 i = len, 于是浏览器在scope chain index=1索引的地方停下来了, 返回了i的值, 即len的值.</p>
<p>为了解决这个问题, 我们将根据症结, 对症下药, 从作用域入手, 改变click事件的局部作用域, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"div"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>,len=div.length;i&lt;len;i++)&#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">  	div[n].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(n);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 click 事件被闭包包裹, 并且闭包自执行, 因此闭包内 n 变量的值每次都不一样, 点击div时, 浏览器将沿着 scope chain 寻找 n 变量, 最终会找到闭包内的 n 变量, 并且打印出div 的索引.</p>
<h3 id="this_u4F5C_u7528_u57DF"><a href="#this_u4F5C_u7528_u57DF" class="headerlink" title="this作用域"></a>this作用域</h3><p>前面我们学习了作用域链, 闭包等基础知识, 下面我们来聊聊神秘莫测的this作用域.</p>
<p>熟悉OOP的开发人员都知道, this是对象实例的引用, 始终指向对象实例. 然而 js 的世界里, this随着它的执行环境改变而改变, 并且它总是指向它所在方法的对象. 如下,</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line">o.func = f;</span><br><span class="line">f();<span class="comment">//[object Window]</span></span><br><span class="line">o.func();<span class="comment">//[object Object]</span></span><br><span class="line"><span class="built_in">console</span>.log(f===<span class="built_in">window</span>.f);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>当f单独执行时, 其内部this指向window对象, 但是当f成为o对象的属性func时, this指向的是o对象, 又f === window.f, 故它们实际上指向的都是this所在方法的对象.</p>
<p>下面我们来应用下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.slice.call([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],<span class="number">1</span>);<span class="comment">//[2,3],正确用法</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.slice([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],<span class="number">1</span>);<span class="comment">//[], 错误用法,此时slice内部this仍然指向Array.prototype</span></span><br><span class="line"><span class="keyword">var</span> slice = <span class="built_in">Array</span>.prototype.slice;</span><br><span class="line">slice([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],<span class="number">1</span>);<span class="comment">//Uncaught TypeError: Array.prototype.slice called on null or undefined</span></span><br><span class="line"><span class="comment">//此时slice内部this指向的是window对象,离开了原来的Array.prototype对象作用域,故报错~~</span></span><br></pre></td></tr></table></figure>
<p>总结下, this的使用只需要注意一点:</p>
<blockquote>
<p>this 总是指向它所在方法的对象.</p>
</blockquote>
<h3 id="with_u8BED_u53E5"><a href="#with_u8BED_u53E5" class="headerlink" title="with语句"></a>with语句</h3><p>聊到作用域链就不得不说with语句了, with语句可以用来临时改变作用域, 将语句中的对象添加到作用域的顶部.</p>
<p>语法: with (expression){statement} 例如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> k = &#123;name:<span class="string">"daicy"</span>&#125;;</span><br><span class="line"><span class="keyword">with</span>(k)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name);<span class="comment">//daicy</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(name);<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<p>with 语句用于对象 k, 作用域第一层为 k 对象内部作用域, 故能直接打印出 name 的值, 在with之外的语句不受此影响. </p>
<p>再看一个栗子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> l = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">with</span>(l) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(map(<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">  	<span class="keyword">return</span> i*i;</span><br><span class="line">  &#125;));<span class="comment">//[1,4,9]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，with 语句用于数组，所以在调用 map() 方法时，解释程序将检查该方法是否是本地函数。如果不是，它将检查伪对象 l，看它是否为该对象的方法, 又map是Array对象的方法, 数组l继承了该方法, 故能正确执行.</p>
<p>注意: with语句容易引起歧义, 由于需要强制改变作用域链, 它将带来更多的cpu消耗, 建议慎用 with 语句.</p>
<hr>
<p>本问就讨论这么多内容,大家有什么问题或好的想法欢迎在下方参与<a href="#respond">留言和评论</a>.</p>
<p>本文作者: <a href="https://github.com/Louiszhai" target="_blank" rel="external">louis</a></p>
<p>本文链接: <a href="http://louiszhai.github.io/2015/12/22/scopeChain/">http://louiszhai.github.io/2015/12/22/scopeChain/</a></p>
<p>参考文章</p>
<ul>
<li><a href="http://rainsilence.iteye.com/blog/2012209" target="_blank" rel="external">Jquery的each循环和原生循环及html5foreach循环的效率比较 - rainsilence - ITeye技术网站</a></li>
<li><a href="http://blog.csdn.net/lmj623565791/article/details/25076713" target="_blank" rel="external">Javascript 进阶 作用域 作用域链 - Hongyang - 博客频道 - CSDN.NET</a></li>
<li><a href="http://blog.csdn.net/yueguanghaidao/article/details/9568071" target="_blank" rel="external">Js作用域与作用域链详解 - Skycrab - 博客频道 - CSDN.NET</a></li>
<li><a href="http://www.w3school.com.cn/js/pro_js_statements_with.asp" target="_blank" rel="external">ECMAScript with 语句</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/with" target="_blank" rel="external">with - JavaScript | MDN</a></li>
<li><a href="http://www.cnblogs.com/lufy/archive/2012/05/18/2507536.html" target="_blank" rel="external">Javascript–闭包引起的IE内存泄露 - 船长op - 博客园</a></li>
<li><a href="http://www.jb51.net/article/24101.htm" target="_blank" rel="external">javascript深入理解js闭包_javascript技巧_脚本之家</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[JavaScript scope chain for while 作用域链 闭包 var]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://louiszhai.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[详解JS遍历]]></title>
    <link href="http://louiszhai.github.io/2015/12/18/traverse/"/>
    <id>http://louiszhai.github.io/2015/12/18/traverse/</id>
    <published>2015-12-18T02:54:48.000Z</published>
    <updated>2016-01-06T00:26:46.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u5BFC_u8BFB"><a href="#u5BFC_u8BFB" class="headerlink" title="导读"></a>导读</h3><p>遍历数组或对象是一名程序员的基本素养之一. 然而遍历却不是一件简单的事, 优秀的程序员知道怎么去选择合适的遍历方法, 优化遍历效率. 本篇将带你走进JavaScript遍历的世界, 享受分析JS循环的快感. 本篇所有代码都可以直接运行, 希望您通读本篇后, 不止是浏览, 最好是亲手去实践下.</p>
<a id="more"></a>
<h3 id="u6982_u8FF0"><a href="#u6982_u8FF0" class="headerlink" title="概述"></a>概述</h3><p>js有如下两种数据需要经常遍历</p>
<ul>
<li>数组(Array)</li>
<li>对象(Object)</li>
</ul>
<p>同时又提供了如下8种方法方便我们遍历元素</p>
<ul>
<li>for</li>
<li>while(或do~while)</li>
<li>forEach</li>
<li>for in</li>
<li>$.each</li>
<li>$(selecter).each</li>
<li>map</li>
<li>every</li>
</ul>
<p>最终我们将分析遍历效率选出最佳遍历选手.</p>
<p>本文将针对如下两种数据进行详细的分析和举栗. 下面举栗中如果不加特殊说明将会用到如下数据.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">"囚徒"</span>,<span class="string">"过客"</span>,<span class="string">"领袖"</span>];<span class="comment">//职场3种人</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="string">"linda"</span>,<span class="number">1</span>:<span class="string">"style"</span>,<span class="number">2</span>:<span class="string">"nick"</span>,length:<span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><p>语法: for(初始化; 循环执行条件; 每遍历一个元素后做的事情;){}</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//循环置于闭包之内</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>,length=array.length;i&lt;length;i++)&#123;<span class="comment">//缓存数组长度</span></span><br><span class="line">  	<span class="built_in">console</span>.log(array[i]);<span class="comment">//内部方法若有可能相互影响,也要置于闭包之内</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>for循环只能遍历数组, 不能遍历对象. 写for循环时有两点需要注意.</p>
<ul>
<li>其一, 为了避免遍历时执行多遍计算数组长度的操作, 影响效率,  建议在循环开始以变量的形式缓存下数组长度, 若在循环内部有可能改变数组长度, 请务必慎重处理, 避免数组越界.</li>
<li>JavaScript中并没有类似java的块级作用域, for循环内部定义的变量会直接暴露在外(如 i,循环退出后,i变量将等于数组长度, 后续代码将能访问到 i 变量的值), 因此建议将for循环置于闭包内. 特别要注意的是: <strong>如果在循环内部, 前一个元素的遍历有可能影响到后一个元素的遍历, 那么for循环内部方法也需要置于闭包之内.</strong></li>
</ul>
<h3 id="do/while"><a href="#do/while" class="headerlink" title="do/while"></a>do/while</h3><p>语法: do{…}while(true);</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">do</span> <span class="keyword">while</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span>,</span><br><span class="line">        len = array.length;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 循环被终止, 此处如果是continue就会造成循环无法退出</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'array['</span>+ i +<span class="string">']:'</span> + array[i]);</span><br><span class="line">        i++;<span class="comment">//此句建议放置循环while头部</span></span><br><span class="line">    &#125; <span class="keyword">while</span>(i&lt;len);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>do/while的语法简化了循环的实现, 只保留对循环条件的判断, 所以我们要在循环内部构造出循环退出的条件, 否则有可能造成死循环. 特别要注意的是: <strong>使用 continue 跳出本次遍历时, 要保证循环能够自动进入到下一次遍历, 因此保证循环走到下一次遍历的语句需要放到 continue 前面执行, 建议置于循环头部</strong>.(如上, i++ 语句最好放置循环头部)</p>
<p>do/while 循环与for循环大体差不多,只支持数组遍历, 多用于对循环退出条件不是很明确的场景. 一般来说不建议使用这种方式遍历数组.</p>
<h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><p>语法: array.forEach(function(item){}), 参数item表示数组每一项的元素</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">array.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(item==<span class="string">"囚徒"</span>)</span><br><span class="line">    <span class="keyword">return</span>;<span class="comment">//这里只能使用return跳过当前元素处理</span></span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>forEach的语法特点和 java的for each有些类似, 都丢掉了数组的索引信息.</p>
<p>使用forEach循环有几点需要特别注意:</p>
<ul>
<li>forEach无法遍历对象</li>
<li>forEach无法在IE中使用，只是在firefox和chrome中实现了该方法</li>
<li>forEach无法使用break，continue跳出循环，使用return时，效果和在for循环中使用continue一致</li>
</ul>
<h3 id="for_in"><a href="#for_in" class="headerlink" title="for in"></a>for in</h3><p>语法: for(var item in array){}</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> item <span class="keyword">in</span> array)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;<span class="comment">//0 1 2</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> item <span class="keyword">in</span> o)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;<span class="comment">//0 1 2 length</span></span><br></pre></td></tr></table></figure>
<p>for in 可用于遍历数组和对象, 但它输出的只是数组的索引和对象的key, 我们可以通过索引和key取到对应的值. 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> item <span class="keyword">in</span> array)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(array[item]);</span><br><span class="line">&#125;<span class="comment">//"囚徒" "过客" "领袖"</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> item <span class="keyword">in</span> o)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(o[item]);</span><br><span class="line">&#125;<span class="comment">//"linda" "style" "nick" "length"</span></span><br></pre></td></tr></table></figure>
<h3 id="24-each"><a href="#24-each" class="headerlink" title="$.each"></a>$.each</h3><p>语法: $.each(array|o, function(i, ele){}) 支持数组和对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$.each(array, <span class="function"><span class="keyword">function</span>(<span class="params">i, ele</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i,ele,<span class="keyword">this</span>==ele);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//0 "囚徒" true</span></span><br><span class="line"><span class="comment">//1 "过客" true</span></span><br><span class="line"><span class="comment">//2 "领袖" true</span></span><br><span class="line">$.each(o, <span class="function"><span class="keyword">function</span>(<span class="params">i, ele</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i,ele,<span class="keyword">this</span>==ele);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//0 "linda" true</span></span><br><span class="line"><span class="comment">//1 "style" true</span></span><br><span class="line"><span class="comment">//2 "nick" true</span></span><br></pre></td></tr></table></figure>
<p>这里我们注意到 <strong>this对象 指向当前属性的值</strong>,这是因为:</p>
<p>参考jQuery api:</p>
<blockquote>
<p><code>$.each()</code> 方法会迭代jQuery对象中的每一个DOM元素。每次回调函数执行时，会传递当前循环次数作为参数(从0开始计数)。更重要的是，回调函数是在当前DOM元素为上下文的语境中触发的。因此关键字 <code>this</code> 总是指向这个元素。</p>
</blockquote>
<p>同时,上述遍历时, o 对象的属性中有一个length属性并没有被输出. 这是为什么呢? 请耐心往下看.</p>
<p>首先, 我们来看看遍历对象o时, 当前的this对象到底是什么?</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$.each(o, <span class="function"><span class="keyword">function</span>(<span class="params">i, ele</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>==<span class="string">"linda"</span>)&#123;<span class="comment">//我们随机选取第一个属性</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>,<span class="keyword">this</span>==ele);</span><br><span class="line">    $.each(<span class="keyword">this</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e, ele2</span>) </span>&#123;</span><br><span class="line">    	<span class="built_in">console</span>.log(e, ele2);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//String &#123;0: "l", 1: "i", 2: "n", 3: "d", 4: "a", length: 5, [[PrimitiveValue]]: "linda"&#125; true</span></span><br><span class="line"><span class="comment">//0 "l"</span></span><br><span class="line"><span class="comment">//1 "i"</span></span><br><span class="line"><span class="comment">//2 "n"</span></span><br><span class="line"><span class="comment">//3 "d"</span></span><br><span class="line"><span class="comment">//4 "a"</span></span><br></pre></td></tr></table></figure>
<p>我们发现, this对象等于回调函数的第二个形参, 是一个字符串.且它的 length 属性和 [[PrimitiveValue]] 属性并没有被打印出来, 为此我们来查看下length的内部属性.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$.each(o, <span class="function"><span class="keyword">function</span>(<span class="params">i, ele</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>==<span class="string">"linda"</span>)<span class="comment">//我们还是随机选取第一个属性(这还是随机吗?)</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(<span class="keyword">this</span>, <span class="string">'length'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//Object &#123;value: 5, writable: false, enumerable: false, configurable: false&#125;</span></span><br></pre></td></tr></table></figure>
<p>可见, this对象的length属性的 enumerable 属性被设置成了false, 这表示该对象不能被列举或遍历, 同时还不能被配置(configurable: false), 也不能被赋值(writable: false).</p>
<p>此时, 前面遍历 o 对象时,它的 length 属性没有被打印出来的疑问似乎有解了. 让我们来看看 o.length 的内部属性吧.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(o, <span class="string">'length'</span>));</span><br><span class="line"><span class="comment">//Object &#123;value: 3, writable: true, enumerable: true, configurable: true&#125;</span></span><br></pre></td></tr></table></figure>
<p>o.length 值为3, 可赋值, 可列举, 可配置. 这可不对, 刚刚不是说 enumerable 属性被设置成了false 才不会被遍历吗. 现在该值为 true, 并且还不可遍历. 这不合常理, 自然该有别的原因. 我们接着往下看.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="string">"linda"</span>,<span class="number">1</span>:<span class="string">"style"</span>,<span class="number">2</span>:<span class="string">"nick"</span>,length:<span class="number">1</span>&#125;; <span class="comment">// 试着改变length的值</span></span><br><span class="line">$.each(o, <span class="function"><span class="keyword">function</span>(<span class="params">i, ele</span>)</span>&#123;<span class="comment">//再遍历一次</span></span><br><span class="line">  <span class="built_in">console</span>.log(i,ele);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//0 "linda"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="string">"linda"</span>,<span class="number">1</span>:<span class="string">"style"</span>,<span class="number">2</span>:<span class="string">"nick"</span>,length:<span class="number">5</span>&#125;; <span class="comment">// 坚持改变length的值</span></span><br><span class="line">$.each(o, <span class="function"><span class="keyword">function</span>(<span class="params">i, ele</span>)</span>&#123;<span class="comment">//再遍历一次</span></span><br><span class="line">  <span class="built_in">console</span>.log(i,ele);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 0 linda</span></span><br><span class="line"><span class="comment">// 1 style</span></span><br><span class="line"><span class="comment">// 2 nick</span></span><br><span class="line"><span class="comment">// length 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123;<span class="number">0</span>:<span class="string">"linda"</span>,<span class="number">1</span>:<span class="string">"style"</span>,<span class="number">2</span>:<span class="string">"nick"</span>&#125;; <span class="comment">// 试试去掉length属性</span></span><br><span class="line">$.each(o, <span class="function"><span class="keyword">function</span>(<span class="params">i, ele</span>)</span>&#123;<span class="comment">//再遍历一次</span></span><br><span class="line">  <span class="built_in">console</span>.log(i,ele);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 0 linda</span></span><br><span class="line"><span class="comment">// 1 style</span></span><br><span class="line"><span class="comment">// 2 nick</span></span><br></pre></td></tr></table></figure>
<p>现象明了, 结合jquery源码, 当对象中存在length属性时, $.each 内部使用for循环去遍历对象, 否则它将使用for in循环去遍历, 因此$.each遍历对象遵循如下规律:</p>
<ul>
<li>如果对象中存在 length 属性, 遍历深度以length属性为准, 即length多大, 遍历多少个元素.</li>
<li>如果对象中不存在 length 属性, 遍历深度以实际内部属性个数为准.</li>
</ul>
<p>不仅如此, $.each的具体使用过程中还有以下几点需要注意:</p>
<ul>
<li>使用 <code>return</code> 或者 <code>return true</code> 为跳过一个元素，继续执行后面的循环;</li>
<li>使用 <code>return false</code> 为终止循环的执行，但是并不终止函数执行, 这是因为在 jquery.each 中, 若返回值指定为false, 才跳出循环, 如果感兴趣请翻看 jquery.each 源码;</li>
<li>无法使用 break 与 continue 来跳过循环.</li>
</ul>
<h3 id="24_28selecter_29-each"><a href="#24_28selecter_29-each" class="headerlink" title="$(selecter).each"></a>$(selecter).each</h3><p>语法: $(selecter|array|o).each(function(i, ele){})  支持数组和对象, 该方法基本上与$.each方法相同.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'div'</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params">i,ele</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>,i,<span class="keyword">this</span> == ele);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//dom... 0 dom.... true</span></span><br><span class="line">$(array).each(<span class="function"><span class="keyword">function</span>(<span class="params">i,ele</span>)</span>&#123;<span class="comment">//处理数组</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span> == <span class="string">"领袖"</span>)</span><br><span class="line">  	<span class="built_in">console</span>.log(<span class="keyword">this</span>,i,<span class="keyword">this</span> == ele);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//String &#123;0: "领", 1: "袖", length: 2, [[PrimitiveValue]]: "领袖"&#125; 2 true</span></span><br><span class="line">$(o).each(<span class="function"><span class="keyword">function</span>(<span class="params">i,ele</span>)</span>&#123;<span class="comment">//处理对象</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span> == <span class="string">"nick"</span>)</span><br><span class="line">  	<span class="built_in">console</span>.log(<span class="keyword">this</span>,i,<span class="keyword">this</span> == ele);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//String &#123;0: "n", 1: "i", 2: "c", 3: "k", length: 4, [[PrimitiveValue]]: "nick"&#125; 2 true</span></span><br></pre></td></tr></table></figure>
<p>dom表示div元素, 由于this恒等ele, 说明this也表示div元素, 所以this并不是jquery对象, 而是普通的<a href="https://developer.mozilla.org/en-US/docs/Using_Web_Standards_in_your_Web_Pages/Using_the_W3C_DOM" target="_blank" rel="external"><code>DOM对象</code></a>(可以在this上随意使用DOM方法). 使用$(selecter).each方法,请注意以下几点:</p>
<ul>
<li>i: 即序列值 ele: 表示当前被遍历的DOM元素</li>
<li>this 表示当前被遍历的DOM元素，不能调用jQuery方法, 如需调用jquery方法需要用$符号包裹.如, $(this)</li>
</ul>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>即 Array.prototype.map,该方法只支持数组</p>
<p>语法: array.map(callback[,thisArg]) map方法使用其提供函数的每次返回结果生成一个新的数组.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>];</span><br><span class="line"><span class="keyword">var</span> roots = array.map(<span class="built_in">Math</span>.sqrt);<span class="comment">//map包裹方法名</span></span><br><span class="line"><span class="comment">// roots is now [1, 2, 3], array is still [1, 4, 9]</span></span><br><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>];</span><br><span class="line"><span class="keyword">var</span> doubles = array.map(<span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;<span class="comment">//map包裹方法实体</span></span><br><span class="line">  <span class="keyword">return</span> num * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// doubles is now [2, 8, 18]. array is still [1, 4, 9]</span></span><br></pre></td></tr></table></figure>
<p>实际上,由于map方法被设计成支持 [<code>鸭式辨型</code>][] , 该方法也可以用来处理形似数组的对象, 例如 NodeList.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elems = <span class="built_in">document</span>.querySelectorAll(<span class="string">'select option:checked'</span>);</span><br><span class="line"><span class="keyword">var</span> values = <span class="built_in">Array</span>.prototype.map.call(elems, <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj.value;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>甚至还可以用来处理字符串, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="built_in">Array</span>.prototype.map;</span><br><span class="line"><span class="keyword">var</span> array = map.call(<span class="string">'Hello 中国'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> x.charCodeAt(<span class="number">0</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(array);</span><br><span class="line"><span class="comment">//[72, 101, 108, 108, 111, 32, 20013, 22269]</span></span><br></pre></td></tr></table></figure>
<p>map处理字符串的方式多种多样, 例如 反转等.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'12345'</span>;</span><br><span class="line"><span class="keyword">var</span> output = <span class="built_in">Array</span>.prototype.map.call(str, <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;).reverse().join(<span class="string">''</span>);</span><br><span class="line"><span class="built_in">console</span>.log(output);<span class="comment">//54321</span></span><br></pre></td></tr></table></figure>
<p>例如 将字符串数组转换为数字数组, 只需一条语句, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log([<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>].map(<span class="built_in">Number</span>));<span class="comment">//[1,2,3]</span></span><br></pre></td></tr></table></figure>
<p>目前map方法支持大部分浏览器, 除了IE 6,7,8.</p>
<h3 id="every"><a href="#every" class="headerlink" title="every"></a>every</h3><p>即 Array.prototype.every, 该方法同上述map方法也只支持数组</p>
<p>语法: arr.every(callback[, thisArg]) every 方法用于检验数组中的每一项是否符合某个条件, 若符合则放回true, 反之则返回false.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isBigEnough</span>(<span class="params">element, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> element &gt;= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">[<span class="number">12</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">130</span>, <span class="number">44</span>].every(isBigEnough);   <span class="comment">// false</span></span><br><span class="line">[<span class="number">12</span>, <span class="number">54</span>, <span class="number">18</span>, <span class="number">130</span>, <span class="number">44</span>].every(isBigEnough); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>该方法还有简写方式, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">12</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">130</span>, <span class="number">44</span>].every(elem =&gt; elem &gt;= <span class="number">10</span>); <span class="comment">// false</span></span><br><span class="line">[<span class="number">12</span>, <span class="number">54</span>, <span class="number">18</span>, <span class="number">130</span>, <span class="number">44</span>].every(elem =&gt; elem &gt;= <span class="number">10</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>以上, 遍历数组和对象的8种方法简单的介绍完, 总结如下:</p>
<ul>
<li>for in , $.each , $().each 既支持对象也支持数组遍历;</li>
<li>for , do/while , forEach 只支持数组;</li>
<li>Array.prototype.map, Array.prototype.every 只支持数组和形似数组的对象;</li>
<li>forEach不能退出循环,只能通过return来进入到下一个元素的遍历中(相当于for循环的continue), 且在IE没有实现该方法, 尽量避免使用它;</li>
<li>$.each和$().each循环只能通过return false 来退出循环, 使用return 或 return true 将跳过一个元素, 继续执行后面的循环.</li>
</ul>
<h3 id="u6D4B_u8BD5_u5404_u65B9_u6CD5_u6548_u7387"><a href="#u6D4B_u8BD5_u5404_u65B9_u6CD5_u6548_u7387" class="headerlink" title="测试各方法效率"></a>测试各方法效率</h3><p>下面我们来测试下上述方法的效率.</p>
<p>注: array数组默认为空, 初始长度为100 0000, 每个方法将进行5次测试, 取测试时间总和作为比较对象, 时间单位为ms.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [];</span><br><span class="line">array.length = <span class="number">1000000</span>;<span class="comment">//(一百万)</span></span><br><span class="line"><span class="comment">//-------------------------for</span></span><br><span class="line"><span class="keyword">var</span> t1 = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>,length=array.length;i&lt;length;i++)&#123;</span><br><span class="line">  <span class="comment">//array.push(i);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> t2 = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="built_in">console</span>.log(t2-t1);</span><br><span class="line"><span class="comment">//6677+7025+7356+6948+7246 = 35252(ms)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------do/while</span></span><br><span class="line"><span class="keyword">var</span> t1 = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>,</span><br><span class="line">    length = array.length;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    i++;</span><br><span class="line">&#125; <span class="keyword">while</span>(i&lt;length);</span><br><span class="line"><span class="keyword">var</span> t2 = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="built_in">console</span>.log(t2-t1);</span><br><span class="line"><span class="comment">//8123+8342+8296+8368+8774 = 41903(ms)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------forEach</span></span><br><span class="line"><span class="keyword">var</span> t1 = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">array.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;&#125;);</span><br><span class="line"><span class="keyword">var</span> t2 = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="built_in">console</span>.log(t2-t1);</span><br><span class="line"><span class="comment">//322+273+260+301+285 = 1441(ms)</span></span><br><span class="line"><span class="comment">//2678+2540+2625+2490+2553 = 12886(ms) 基于数组长度为1000 0000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------for in</span></span><br><span class="line"><span class="keyword">var</span> t1 = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> item <span class="keyword">in</span> array)&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> t2 = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="built_in">console</span>.log(t2-t1);</span><br><span class="line"><span class="comment">//6+2+3+3+2 = 16(ms)</span></span><br><span class="line"><span class="comment">//17+17+20+22+19 = 95(ms) 基于数组长度为1000 0000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------- $.each</span></span><br><span class="line"><span class="keyword">var</span> t1 = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">$.each(array, <span class="function"><span class="keyword">function</span>(<span class="params">i, ele</span>)</span>&#123;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> t2 = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="built_in">console</span>.log(t2-t1);</span><br><span class="line"><span class="comment">//29+32+29+29+32 = 151(ms)</span></span><br><span class="line"><span class="comment">//278+294+285+278+300 = 1435(ms) 基于数组长度为1000 0000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------$().each</span></span><br><span class="line"><span class="keyword">var</span> t1 = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">$(array).each(<span class="function"><span class="keyword">function</span>(<span class="params">i,ele</span>)</span>&#123;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> t2 = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="built_in">console</span>.log(t2-t1);</span><br><span class="line"><span class="comment">//96+94+97+87+106 = 480(ms)</span></span><br><span class="line"><span class="comment">//1108+1222+997+858+1007 = 5192(ms) 基于数组长度为1000 0000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------map</span></span><br><span class="line"><span class="keyword">var</span> t1 = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">array.map(<span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> t2 = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="built_in">console</span>.log(t2-t1);</span><br><span class="line"><span class="comment">//284+290+254+271+264 = 1363(ms)</span></span><br><span class="line"><span class="comment">//2549+2513+2493+2441+2468 = 12464(ms) 基于数组长度为1000 0000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------every</span></span><br><span class="line"><span class="keyword">var</span> t1 = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">array.every(<span class="function"><span class="keyword">function</span>(<span class="params">e,i,arr</span>)</span>&#123;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> t2 = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="built_in">console</span>.log(t2-t1);</span><br><span class="line"><span class="comment">//286+264+268+271+295 = 1384(ms)</span></span><br><span class="line"><span class="comment">//2728+2815+2514+2594+2529 = 13180(ms) 基于数组长度为1000 0000</span></span><br></pre></td></tr></table></figure>
<h3 id="u5206_u6790_u603B_u7ED3"><a href="#u5206_u6790_u603B_u7ED3" class="headerlink" title="分析总结"></a>分析总结</h3><p>通过以上测试, 发现在数组长度为100 0000时, 各方法运行五次分别需要的时间排序如下:</p>
<p>for in (16ms) &lt; $().each (151ms) &lt; $.each (480ms) &lt; forEach (1441ms) &lt; map (1363ms) &lt; every (1384ms) &lt;&lt; for (35252ms) &lt; do/while (36665ms)</p>
<p>其中中间3个数据过于接近, 因此将数组长度重新设置为 1000 0000, 重新统计他们的运行时间:</p>
<p>for in (95ms) &lt; $().each (1435ms) &lt; $.each (5129ms) &lt; forEach (12886) ~ map (12464ms) ~ every (13180ms) , 其中for和do/while由于时间太长未做测试</p>
<p>根据统计数据, 可得这8个方法的运行速度排序为:</p>
<ol>
<li>for in</li>
<li>$.each</li>
<li>$().each</li>
<li>forEach map every (这3个不相上下,可认为运行速度差不多)</li>
<li>for</li>
<li>do/while</li>
</ol>
<p>我们翻看jquery代码就会知道, $.each方法内部通过调用for循环来实现 ( for循环自身为啥那么慢? ), 而$().each是先用jquery包裹数组对象, 然后再调用for循环, 因此后者效率略低于前者;</p>
<p>那么问题就来了, 据以上测试结果反映: 作为for循环本身和do/while循环却作为耗时最长的遍历被排在了以上所有方法的末尾. 可以肯定的是: for循环和do/while循环正确的位置应该在 for in之后以及$.each之前, 想知道具体原因, 推荐您阅读下页 <a href="http://louiszhai.github.io/2015/12/22/scopeChain/"><strong>《scope chain》</strong></a>.</p>
<p>综上, 最佳遍历选手是 for in 循环, 推荐大家优先考虑使用它, 一般情况下, 最好不使用forEach. ( Firefox浏览器由于对forEach循环做了底层优化, 效率接近native,不在我们考虑范围内 ).</p>
<p>声明: 本文测试使用的浏览器为<code>Google Chrome</code>的47.0.2526.80 (64-bit)版本. 如果发现本文测试数据不对, 欢迎批评指正.</p>
<hr>
<p>本问就讨论这么多内容,大家有什么问题或好的想法欢迎在下方参与<a href="#respond">留言和评论</a>.</p>
<p>本文作者: <a href="https://github.com/Louiszhai" target="_blank" rel="external">louis</a></p>
<p>本文链接: <a href="http://louiszhai.github.io/2015/12/18/traverse/">http://louiszhai.github.io/2015/12/18/traverse/</a></p>
<p>参考文章</p>
<ul>
<li><a href="http://info.9iphp.com/javascript-loop-functions-detail/" target="_blank" rel="external">JavaScript 各种遍历方式详解，有你不知道的黑科技 | Coder | 程序员资源网</a></li>
<li><a href="http://www.bubuko.com/infodetail-663058.html" target="_blank" rel="external">js,jquery遍历数组,对象-布布扣</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" target="_blank" rel="external">Array.prototype.map() - JavaScript | MDN</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every" target="_blank" rel="external">Array.prototype.every() - JavaScript | MDN</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[JavaScript traverse 遍历 数组 对象 map every forEach forin $.each for while]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://louiszhai.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[详解prototype与__proto__]]></title>
    <link href="http://louiszhai.github.io/2015/12/17/prototype/"/>
    <id>http://louiszhai.github.io/2015/12/17/prototype/</id>
    <published>2015-12-17T01:34:36.000Z</published>
    <updated>2015-12-17T14:09:47.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u6982_u5FF5"><a href="#u6982_u5FF5" class="headerlink" title="概念"></a>概念</h3><ol>
<li><strong>prototype</strong> 是函数(function) 的一个属性, 它指向函数的原型.</li>
<li><strong>__proto__</strong>   是对象的内部属性, 它指向构造器的原型, 对象依赖它进行原型链查询.</li>
</ol>
<p>由上, <strong>prototype</strong> 只有函数才有, 其他(非函数)对象不具有该属性. 而 <strong>__proto__</strong> 是对象的内部属性, 任何对象都拥有该属性. </p>
<a id="more"></a>
<h3 id="u6817_u5B50"><a href="#u6817_u5B50" class="headerlink" title="栗子"></a>栗子</h3><p>下面我们来吃个栗子帮助消化下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'louis'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype);<span class="comment">//Person原型 &#123;constructor: Person(name),__proto__: Object&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.prototype);<span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Person.__proto__);<span class="comment">//空函数, function()&#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.__proto__ == Person.prototype);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>吃栗子时我们发现, Person.prototype(原型) 默认拥有两个属性:</p>
<ul>
<li>constructor 属性, 指向构造器, 即Person本身</li>
<li>__proto__ 属性, 指向一个空的Object 对象</li>
</ul>
<p>而p1作为非函数对象, 自然就没有 prototype 属性; 此处佐证了<code>概念1</code></p>
<p>下面来看看__proto__属性:</p>
<p>Person.__proto__ 属性 指向的是一个空函数( function(){} ), 待会儿我们再来研究这个空函数.</p>
<p>p1.__proto__ 属性 指向的是 构造器(Person) 的原型, 即 Person.prototype. 此处佐证了<code>概念2</code></p>
<p>这里我们发现: 原型链查询时, 正是通过这个属性(__proto__) 链接到构造器的原型, 从而实现查询的层层深入.</p>
<p>对 <code>概念1</code> 不太理解的同学, 说明你们不会吃栗子, 咱们忽略他们. 对 <code>概念2</code> 不太理解的同学, 我们来多吃几个栗子, 边吃边想:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;name: <span class="string">'jack'</span>&#125;,</span><br><span class="line">	arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">	reg = <span class="regexp">/hello/g</span>,</span><br><span class="line">	date = <span class="keyword">new</span> <span class="built_in">Date</span>,</span><br><span class="line">	err = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'exception'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.__proto__  === <span class="built_in">Object</span>.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.__proto__  === <span class="built_in">Array</span>.prototype);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.__proto__  === <span class="built_in">RegExp</span>.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(date.__proto__ === <span class="built_in">Date</span>.prototype);   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(err.__proto__  === <span class="built_in">Error</span>.prototype);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>可见, 以上通过 <code>对象字面量</code> 和 new + JS引擎内置构造器() 创建的对象, 无一例外, 它们的__proto__ 属性全部指向构造器的原型(prototype). 充分佐证了 <code>概念2</code> .</p>
<h3 id="proto"><a href="#proto" class="headerlink" title="__proto__"></a>__proto__</h3><p>刚才留下了一个问题: Person.__proto__ 指向的是一个空函数, 下面我们来看看这个空函数究竟是什么.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Person.__proto__ === <span class="built_in">Function</span>.prototype);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>Person 是构造器也是函数(function), Person的__proto__ 属性自然就指向 函数(function)的原型, 即 Function.prototype.</p>
<p>这说明了什么呢?</p>
<p>我们由 “特殊” 联想到 “通用” , 由Person构造器联想一般的构造器.</p>
<p>这说明 <strong>所有的构造器都继承于Function.prototype</strong> (此处我们只是由特殊总结出了普适规律, 并没有给出证明, 请耐心看到后面) , 甚至包括根构造器Object及Function自身。所有构造器都继承了Function.prototype的属性及方法。如length、call、apply、bind（ES5）等. 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.__proto__   === <span class="built_in">Function</span>.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>.__proto__  === <span class="built_in">Function</span>.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.__proto__   === <span class="built_in">Function</span>.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.__proto__   === <span class="built_in">Function</span>.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.__proto__ === <span class="built_in">Function</span>.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.__proto__    === <span class="built_in">Function</span>.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.__proto__   === <span class="built_in">Function</span>.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Error</span>.__proto__    === <span class="built_in">Function</span>.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Date</span>.__proto__     === <span class="built_in">Function</span>.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>JavaScript中有内置(build-in)构造器/对象共计13个（<a href="http://kangax.github.com/es5-compat-table/" target="_blank" rel="external">ES5</a>中新加了JSON），这里列举了可访问的9个构造器。剩下如Global不能直接访问，Arguments仅在函数调用时由JS引擎创建，Math，JSON是以对象形式存在的，无需new。由于任何对象都拥有 __proto__ 属性指向构造器的原型. 即它们的 __proto__ 指向Object对象的原型(Object.prototype)。如下所示:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.__proto__ === <span class="built_in">Object</span>.prototype);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.__proto__ === <span class="built_in">Object</span>.prototype);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>如上所述, 既然所有的构造器都来自于Function.prototype, 那么Function.prototype 到底是什么呢?</p>
<h3 id="Function-prototype"><a href="#Function-prototype" class="headerlink" title="Function.prototype"></a>Function.prototype</h3><p>我们借用 typeof 运算符来看看它的类型. </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Function</span>.prototype) <span class="comment">// "function"</span></span><br></pre></td></tr></table></figure>
<p>实际上, Function.prototype也是唯一一个typeof XXX.prototype为 “function”的prototype。其它的构造器的prototype都是一个对象。如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Number</span>.prototype)   <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Boolean</span>.prototype)  <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">String</span>.prototype)   <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Object</span>.prototype)   <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Array</span>.prototype)    <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">RegExp</span>.prototype)   <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Error</span>.prototype)    <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Date</span>.prototype)     <span class="comment">// object</span></span><br></pre></td></tr></table></figure>
<h3 id="JS_u4E2D_u51FD_u6570_u662F_u4E00_u7B49_u516C_u6C11"><a href="#JS_u4E2D_u51FD_u6570_u662F_u4E00_u7B49_u516C_u6C11" class="headerlink" title="JS中函数是一等公民"></a>JS中函数是一等公民</h3><p>既然Function.prototype 的类型是函数, 那么它会拥有 __proto__ 属性吗, Function.prototype.__proto__ 会指向哪里呢? 会指向对象的原型吗? 请看下方:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>透过上方代码, 且我们了解到: Function.prototype 的类型是函数, 也就意味着一个函数拥有 __proto__ 属性, 并且该属性指向了对象(Object)构造器的原型. 这意味着啥?</p>
<p>根据我们在 <code>概念2</code> 中了解到的: <strong>__proto__</strong>   是对象的内部属性, 它指向构造器的原型.</p>
<p>这意味着 Function.prototype 函数 拥有了一个对象的内部属性, 并且该属性还恰好指向对象构造器的原型. 它是一个对象吗? 是的, 它一定是对象. 它必须是. </p>
<p>实际上, JavaScript的世界观里, 函数也是对象, 函数是一等公民.</p>
<p>这说明所有的构造器既是<code>函数</code>也是一个普通JS<code>对象</code>，可以给构造器添加/删除属性等。同时它也继承了Object.prototype上的所有方法：toString、valueOf、hasOwnProperty等。</p>
<h3 id="Object-prototype"><a href="#Object-prototype" class="headerlink" title="Object.prototype"></a>Object.prototype</h3><p>函数的 __proto__ 属性指向 Function.prototype, 如: Person.__proto__ —&gt; Function.prototype</p>
<p>Function.prototype 函数的 __proto__ 属性指向 Object.prototype, 如: Function.prototype.__proto__ —&gt; Object.prototype.</p>
<p>那么Object.prototype.__proto__ 指向什么呢? </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>由于已经到顶, JS世界的源头一片荒芜, 竟然什么都没有! 令人嗟叹不已.</p>
<p>都说一图胜千言, 我也不能免俗. 下面附一张 <a href="http://stackoverflow.com/" target="_blank" rel="external">stackoverflow</a> 上的图:</p>
<p><img src="/doc_images/prototype.png" alt=""></p>
<p>这张图也指出: </p>
<ul>
<li>Object.__proto__ == Function.prototype,</li>
</ul>
<ul>
<li>Function.__proto__ == Function.prototype.</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//虽然上面做过测试, 我们还是再次测试下</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.__proto__   == <span class="built_in">Function</span>.prototype);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.__proto__ == <span class="built_in">Function</span>.prototype);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>由于对象构造器 (Object) 也是构造器, 又构造器都是函数, 又函数是一等公民, 函数也是对象.</p>
<p>故, 对象构造器 (Object) 拥有<strong>3</strong>种身份:</p>
<ul>
<li><code>构造器</code></li>
<li><code>函数</code></li>
<li><code>对象</code></li>
</ul>
<p>推而广之, 所有构造器都拥有上述3种身份.</p>
<p>由于构造器是 <code>对象</code> (身份3), 理所当然拥有 __proto__ 属性, 且该属性一定指向其构造器的原型, 也就是指向 <code>函数</code> (身份2) 构造器(Function)的原型, 即 Function.prototype. 于是我们证明了上面那句 <strong>所有的构造器都继承于Function.prototype</strong> (身份1).</p>
<p>注: 上面代码中用到的 __proto__ 目前在IE6/7/8/9中并不支持。IE9中可以使用<a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/GetPrototypeOf" target="_blank" rel="external">Object.getPrototypeOf</a>(ES5)获取对象的内部原型。</p>
<hr>
<p>本问就讨论这么多内容,大家有什么问题或好的想法欢迎在下方参与<a href="#respond">留言和评论</a>.</p>
<p>本文作者: <a href="https://github.com/Louiszhai" target="_blank" rel="external">louis</a></p>
<p>本文链接: <a href="http://louiszhai.github.io/2015/12/17/prototype/">http://louiszhai.github.io/2015/12/17/prototype/</a></p>
<p>参考文章</p>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/prototype" target="_blank" rel="external">Function.prototype - JavaScript | MDN</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/prototype" target="_blank" rel="external">Object.prototype - JavaScript | MDN</a></li>
<li><a href="http://www.cnblogs.com/snandy/archive/2012/09/01/2664134.html" target="_blank" rel="external">JavaScript中__proto__与prototype的关系 - snandy - 博客园</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[JavaScript prototype __proto__ 原型 内部原型 new]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://louiszhai.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Currying]]></title>
    <link href="http://louiszhai.github.io/2015/12/16/currying/"/>
    <id>http://louiszhai.github.io/2015/12/16/currying/</id>
    <published>2015-12-16T00:57:06.000Z</published>
    <updated>2015-12-17T10:08:05.000Z</updated>
    <content type="html"><![CDATA[<p>Currying是函数式编程的一个特性，将多个参数的处理转化成单个参数的处理，类似链式调用。</p>
<h3 id="u67EF_u91CC_u5316_28Currying_29"><a href="#u67EF_u91CC_u5316_28Currying_29" class="headerlink" title="柯里化(Currying)"></a>柯里化(Currying)</h3><p>柯里化有3个常见作用：1. 参数复用；2. 提前返回；3. 延迟计算/运行。</p>
<p>通俗的柯里化函数原型如下:</p>
<a id="more"></a>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> currying = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">var</span> newArgs = args.concat([].slice.call(<span class="built_in">arguments</span>));</span><br><span class="line">          <span class="keyword">return</span> fn.apply(<span class="literal">null</span>, newArgs);</span><br><span class="line">     &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="u67EF_u91CC_u5316_u7684_u901A_u7528_u5B9E_u73B0"><a href="#u67EF_u91CC_u5316_u7684_u901A_u7528_u5B9E_u73B0" class="headerlink" title="柯里化的通用实现"></a>柯里化的通用实现</h4><p>我们来定义一个比较通用的currying函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个参数为要应用的function，第二个参数是需要传入的最少参数个数 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">func, minArgs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minArgs == <span class="literal">undefined</span>) &#123;</span><br><span class="line">        minArgs = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">frozenargs</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 优化处理，如果调用时没有参数，返回该函数本身 </span></span><br><span class="line">	        <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>); </span><br><span class="line">	        <span class="keyword">var</span> newArgs = frozenargs.concat(args); </span><br><span class="line">	        <span class="keyword">if</span> (newArgs.length &gt;= minArgs) &#123; </span><br><span class="line">	        	<span class="keyword">return</span> func.apply(<span class="keyword">this</span>, newArgs); </span><br><span class="line">	        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">	        	<span class="keyword">return</span> A(newArgs); </span><br><span class="line">	        &#125; </span><br><span class="line">	    &#125;; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> A([]); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u67EF_u91CC_u5316_u7684_u6817_u5B50"><a href="#u67EF_u91CC_u5316_u7684_u6817_u5B50" class="headerlink" title="柯里化的栗子"></a>柯里化的栗子</h4><p>这样，我们就可以随意定义我们的业务行为了，比如定义加法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> plus = curry(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; ++i) &#123;</span><br><span class="line">    	result += <span class="built_in">arguments</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;, <span class="number">2</span>);</span><br><span class="line">plus(<span class="number">3</span>, <span class="number">2</span>); <span class="comment">// 正常调用,返回 5</span></span><br><span class="line">plus(<span class="number">3</span>); <span class="comment">// 偏应用，返回一个函数（返回值为3+参数值） </span></span><br><span class="line">plus(<span class="number">3</span>)(<span class="number">2</span>); <span class="comment">// 完整应用（返回5） </span></span><br><span class="line">plus()(<span class="number">3</span>)()()(<span class="number">2</span>); <span class="comment">// 返回 5 </span></span><br><span class="line">plus(<span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>); <span class="comment">// 可以接收多个参数,返回 14</span></span><br><span class="line">plus(<span class="number">3</span>)(<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>); <span class="comment">// 同理,返回13</span></span><br></pre></td></tr></table></figure>
<p>如下是减法的例子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> minus = curry(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="built_in">arguments</span>.length; ++i) &#123;</span><br><span class="line">        result -= <span class="built_in">arguments</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;, <span class="number">2</span>);</span><br><span class="line">minus(<span class="number">5</span>,<span class="number">3</span>);<span class="comment">//正常调用,返回 2</span></span><br><span class="line">minus(<span class="number">5</span>)(<span class="number">3</span>);<span class="comment">//完整应用,返回 2</span></span><br><span class="line">minus()(<span class="number">3</span>)()()(<span class="number">2</span>);<span class="comment">//返回 1</span></span><br><span class="line">minus(<span class="number">8</span>)(<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>);<span class="comment">// 接受多个参数,返回 -2</span></span><br></pre></td></tr></table></figure>
<h4 id="u591A_u6B21_u67EF_u91CC_u5316"><a href="#u591A_u6B21_u67EF_u91CC_u5316" class="headerlink" title="多次柯里化"></a>多次柯里化</h4><p>或者如果你想交换参数的顺序，你可以这样定义:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> flip = curry(<span class="function"><span class="keyword">function</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> curry(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> f(b, a);</span><br><span class="line">    &#125;, <span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> flip_minus = flip()(minus);<span class="comment">//返回一个具有柯里化能力的函数</span></span><br><span class="line">flip_minus(<span class="number">2</span>)(<span class="number">10</span>);<span class="comment">//8</span></span><br><span class="line">flip_minus()(<span class="number">1</span>)()(<span class="number">6</span>);<span class="comment">//5</span></span><br></pre></td></tr></table></figure>
<p>这里为什么要调用两次 curry 呢, 第一次调用是为了固定 func ,返回了curry 内部的A的内部方法,即返回:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;	<span class="comment">//该函数即flip,以下将称作`方法①`</span></span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>); </span><br><span class="line">  <span class="keyword">var</span> newArgs = frozenargs.concat(args); </span><br><span class="line">  <span class="keyword">if</span> (newArgs.length &gt;= minArgs) &#123; </span><br><span class="line">    <span class="keyword">return</span> func.apply(<span class="keyword">this</span>, newArgs);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> A(newArgs); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其中func指的是curry传入的第一个参数,表示一个方法,即如下:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">f</span>) </span>&#123;<span class="comment">//该方法表示上述func,以下将称作`方法②`</span></span><br><span class="line">    <span class="keyword">return</span> curry(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> f(b, a);</span><br><span class="line">    &#125;, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析</p>
<ul>
<li>此时调用 flip(minus) , 实际上是执行了一遍 “方法①” , 由于实参长度等于minArgs(即1), 因此返回 func.apply(this, newArgs); </li>
<li>由于 newArgs=[ minus ], 然后将执行 “方法②” ;</li>
<li>由于 f=minus, 在 “方法②” 中将第二次执行curry, 最终返回交换参数后的minus.</li>
</ul>
<p>因此 flip 是一个柯里化后的方法, 具有柯里化的典型特征: 能够将多个参数的处理转化成单个参数的处理. 不仅如此, flip 可以连续两次柯里化参数.</p>
<p>如上述栗子, 第一次柯里化的参数是方法 minus, 由于长度未做限制, 默认为1, 即至少要向 flip 传递一个方法后才能返回一个柯里化的 flip_minus, 同样, 返回的 flip_minus 也具备柯里化的能力.flip_minus()(1)()(6) 等的执行结果充分说明了这点. </p>
<h3 id="u53CD_u67EF_u91CC_u5316_28unCurrying_29"><a href="#u53CD_u67EF_u91CC_u5316_28unCurrying_29" class="headerlink" title="反柯里化(unCurrying)"></a>反柯里化(unCurrying)</h3><p>函数柯里化，是固定部分参数，返回一个接受剩余参数的函数，也称为部分计算函数，目的是为了固定参数, 延迟计算等。</p>
<p>那么反柯里化函数，从字面讲，意义和用法跟函数柯里化相比正好相反，扩大适用范围，创建一个应用范围更广的函数。使得本来只有特定对象才适用的方法，扩展到更多的对象。</p>
<h4 id="u53CD_u67EF_u91CC_u5316_u7684_u4E09_u79CD_u5B9E_u73B0"><a href="#u53CD_u67EF_u91CC_u5316_u7684_u4E09_u79CD_u5B9E_u73B0" class="headerlink" title="反柯里化的三种实现"></a>反柯里化的三种实现</h4><p>看一下通用函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.unCurrying = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Function</span>.prototype.call.apply(that, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上这段代码做了3件事:</p>
<ul>
<li>在Function原型上增加 unCurrying 方法, 方便所有方法继承;</li>
<li>返回方法, 即暴露方法对外的接口;</li>
<li>借用call, call 的参数由 apply提供;</li>
</ul>
<p>上述代码先后调用了call, apply 方法 来保证参数传递正常. 自然也可以直接调用apply(因arguments类似数组,调用apply较为方便). 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.unCurrying = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> a = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">return</span> that.apply(a[<span class="number">0</span>], [].slice.call(a, <span class="number">1</span>));分割<span class="built_in">arguments</span>,方便apply传参</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当然, 还可以利用<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="external">Function.prototype.bind()</a>方法返回一个新函数.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.unCurrying = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.call.bind(<span class="keyword">this</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>bind() 方法会创建一个新函数, 称为绑定函数, 当调用这个绑定函数时, 绑定函数会以创建它时传入bind() 方法的第一个参数作为this ,也就是说, 传入的this将成为最终的上下文, 从第二个参数开始的参数, 将按照顺序作为原函数的参数来调用原函数. </p>
<p>也就是说, 谁(假设为方法f)调用 unCurrying 方法, 将返回一个如下的方法.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">Function</span>.prototype.call.apply(f, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原理都相同，最终就是把 this.method 转化成 method(this,arg1,arg2….) 以实现方法借用和this的泛化。</p>
<h4 id="u53CD_u67EF_u91CC_u5316_u7684_u524D_u56E0"><a href="#u53CD_u67EF_u91CC_u5316_u7684_u524D_u56E0" class="headerlink" title="反柯里化的前因"></a>反柯里化的前因</h4><p>接下来我们来回顾下前一篇文章&lt;<a href="http://louiszhai.github.io/2015/12/15/arguments/">详解JS之Arguments对象</a>&gt;中所讲到的<a href="http://louiszhai.github.io/2015/12/15/arguments/#u9E2D_u5F0F_u8FA9_u578B">鸭式辩型</a>: 如果一个对象可以像鸭子一样走路,游泳,并且嘎嘎叫,就认为这个对象是鸭子,哪怕它并不是从鸭子对象继承过来的。</p>
<p>Array构造器和String构造器的prototype上的方法就被特意设计成了鸭子类型。这些方法不对this的数据类型做任何校验。这也就是为什么arguments能冒充array调用push方法.</p>
<p>下面我们来看下v8引擎里面 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/push" target="_blank" rel="external">Array.prototype.push</a> 的代码:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ArrayPush</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> n = TO_UINT32(<span class="keyword">this</span>.length);</span><br><span class="line">    <span class="keyword">var</span> m = % _ArgumentsLength();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">this</span>[i + n] = % _Arguments(i); <span class="comment">//属性拷贝 </span></span><br><span class="line">        <span class="keyword">this</span>.length = n + m; <span class="comment">//修正length </span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.length; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Array.prototype.push 方法并没有去判断调用对象是不是数组, 这给对象冒充提供了天然条件, 基于此函数反柯里化(unCurrying) 才具有可行性. </p>
<h4 id="u53CD_u67EF_u91CC_u5316_u7684_u6817_u5B50"><a href="#u53CD_u67EF_u91CC_u5316_u7684_u6817_u5B50" class="headerlink" title="反柯里化的栗子"></a>反柯里化的栗子</h4><p>下面我们让普通对象具有push方法的能力:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> push = <span class="built_in">Array</span>.prototype.push.unCurrying(),</span><br><span class="line">obj = &#123;&#125;;</span><br><span class="line">push(obj, <span class="string">'123'</span>, <span class="string">'456'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">//Object &#123;0: "123", 1: "456", length: 2&#125;</span></span><br></pre></td></tr></table></figure>
<p>obj本来是一个空对象, 它被push了两个元素 “123” 和 “456”, 并且拥有了 length 属性. obj实际上已经变成了一个数组(即[ “123”, “456” ]). </p>
<p>下面我们来看看更多的例子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*反柯里化toUpperCase*/</span></span><br><span class="line"><span class="keyword">var</span> toUpperCase = <span class="built_in">String</span>.prototype.toUpperCase.unCurrying(); <span class="built_in">console</span>.log(toUpperCase(<span class="string">'abc'</span>)); <span class="comment">// ABC</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*反柯里化toLowerCase*/</span></span><br><span class="line"><span class="keyword">var</span> toLowerCase = <span class="built_in">String</span>.prototype.toLowerCase.unCurrying();</span><br><span class="line"><span class="built_in">console</span>.log(toLowerCase(<span class="string">'DEF'</span>)); <span class="comment">// def</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*反柯里化call*/</span></span><br><span class="line"><span class="keyword">var</span> call = <span class="built_in">Function</span>.prototype.call.unCurrying();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">action</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name+<span class="string">" is "</span>+action);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name:<span class="string">'louis'</span></span><br><span class="line">&#125;;</span><br><span class="line">call(f,obj,<span class="string">'working.'</span>);<span class="comment">//call的3个参数分别为 函数, 上下文对象, 形参</span></span><br></pre></td></tr></table></figure>
<p>其中反柯里化 call 可能不大好理解, 它表示 obj 对象借用方法 f , 替换了其中的this(上下文).</p>
<h4 id="u53CD_u67EF_u91CC_u5316_u81EA_u8EAB"><a href="#u53CD_u67EF_u91CC_u5316_u81EA_u8EAB" class="headerlink" title="反柯里化自身"></a>反柯里化自身</h4><p>更有趣的是, unCurrying本身也是方法, 它同样可以被反柯里化, 这就是反柯里化的值得玩味的地方.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> unCurrying = <span class="built_in">Function</span>.prototype.unCurrying.unCurrying();</span><br><span class="line"><span class="keyword">var</span> sort = unCurrying(<span class="built_in">Array</span>.prototype.sort);</span><br><span class="line"><span class="keyword">var</span> array = sort([<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>],<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(array);<span class="comment">//[1,2,3,4,5]</span></span><br></pre></td></tr></table></figure>
<p>以上是关于 <code>javaScript</code> 柯里化与反柯里化的一些理解. </p>
<p>柯里化体现的思想是”归一”, 多个参数化为一个参数, 然后逐个处理, 便于产生偏函数, 实现链式调用; 反柯里化体现的思想是”延伸”, 通过拓展方法的作用域, 使得它变得更通用, 提高了代码的复用性. 它们都提升了代码的优雅性.</p>
<hr>
<p>本问就讨论这么多内容,大家有什么问题或好的想法欢迎在下方参与<a href="#respond">留言和评论</a>.</p>
<p>本文作者: <a href="https://github.com/Louiszhai" target="_blank" rel="external">louis</a></p>
<p>本文链接: <a href="http://louiszhai.github.io/2015/12/16/currying/">http://louiszhai.github.io/2015/12/16/currying/</a></p>
<p>参考文章</p>
<ul>
<li><a href="http://www.cnblogs.com/TomXu/archive/2012/07/23/2580701.html" target="_blank" rel="external">深入理解JavaScript系列（49）：Function模式（上篇） - 汤姆大叔 - 博客园</a></li>
<li><a href="http://www.cnblogs.com/pigtail/p/3450852.html" target="_blank" rel="external">前端开发者进阶之函数反柯里化unCurrying - 穆乙 - 博客园</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[柯里化 反柯里化 Currying unCurrying 固定参数 扩大使用范围]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://louiszhai.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[详解JS之Arguments对象]]></title>
    <link href="http://louiszhai.github.io/2015/12/15/arguments/"/>
    <id>http://louiszhai.github.io/2015/12/15/arguments/</id>
    <published>2015-12-15T12:44:51.000Z</published>
    <updated>2015-12-17T10:07:01.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u6982_u8FF0"><a href="#u6982_u8FF0" class="headerlink" title="概述"></a>概述</h3><p><strong>Arguments</strong> 对象已经不再是函数的属性了, 它是函数内部的本地变量,  包括如下属性：</p>
<ol>
<li>callee — 指向当前函数的引用</li>
<li>length — 真正传递的参数个数</li>
<li>properties-indexes (字符串类型的整数) 属性的值就是函数的参数值(按参数列表从左到右排列)。 properties-indexes内部元素的个数等于arguments.length. properties-indexes 的值和实际传递进来的参数之间是<strong>共享</strong>的。</li>
</ol>
<a id="more"></a>
<h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><h4 id="arguments-callee"><a href="#arguments-callee" class="headerlink" title="arguments.callee"></a>arguments.callee</h4><p>我们可以利用 <strong>callee</strong> 引用来写几个常见的递归, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求阶乘n! 即,1x2x3x4x5x......xn</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">n</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> i &lt; <span class="number">2</span> ? <span class="number">1</span> : i*<span class="built_in">arguments</span>.callee(i-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求1+2+3......+n</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">p</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> i &lt; <span class="number">2</span> ? <span class="number">1</span> : i+<span class="built_in">arguments</span>.callee(i-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//斐波那契数列, 1,1,2,3,5,8,13,......</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _f = <span class="built_in">arguments</span>.callee;</span><br><span class="line">  <span class="keyword">return</span> i &lt; <span class="number">3</span> ? <span class="number">1</span> : _f(i-<span class="number">1</span>) + _f(i-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">n(<span class="number">5</span>);<span class="comment">//120</span></span><br><span class="line">p(<span class="number">5</span>);<span class="comment">//15</span></span><br><span class="line">f(<span class="number">5</span>);<span class="comment">//5</span></span><br></pre></td></tr></table></figure>
<p>遗憾的是: 严格模式(“<em>use</em> <em>strict</em>“)下,  <strong>arguments.callee</strong> 并不可用.</p>
<h4 id="arguments-length"><a href="#arguments-length" class="headerlink" title="arguments.length"></a>arguments.length</h4><p>js方法中形参个数并不能实际反映实参个数, 所幸的是 <strong>arguments.length</strong> 可以取得实参个数, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">a,b,c</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'实参个数:'</span> + <span class="built_in">arguments</span>.length);</span><br><span class="line">&#125;</span><br><span class="line">a(<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//实参个数:2</span></span><br></pre></td></tr></table></figure>
<h4 id="arguments_5B_5D"><a href="#arguments_5B_5D" class="headerlink" title="arguments[]"></a>arguments[]</h4><p>这个共享其实不是真正的共享一个内存地址，而是2个不同的内存地址，使用JavaScript引擎来保证2个值是随时一样的，当然这也有一个前提， 那就是这个索引值要小于你传入的参数个数，也就是说如果你只传入2个参数，而还继续使用arguments[2]赋值的话，就会不一致(索引值从 0 开始)，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">arguments</span>[<span class="number">2</span>] = <span class="number">10</span>;<span class="comment">//参数可以被重新赋值</span></span><br><span class="line">    <span class="built_in">console</span>.log(z);</span><br><span class="line">&#125;</span><br><span class="line">b(<span class="number">1</span>, <span class="number">2</span>);<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<p>这时候因为没传递第三个参数z，所以赋值10以后，console.log(z)的结果依然是undefined，而不是10. </p>
<h4 id="u9E2D_u5F0F_u8FA9_u578B"><a href="#u9E2D_u5F0F_u8FA9_u578B" class="headerlink" title="鸭式辩型"></a>鸭式辩型</h4><p><code>arguments</code> 对象并不是一个真正的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Array" target="_blank" rel="external"><code>Array</code></a>。它类似于数组，但没有数组所特有的属性和方法，除了 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments/length" target="_blank" rel="external">length</a>。例如，它没有 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/pop" target="_blank" rel="external">pop</a> 方法。不过可以将其转换成数组.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);<span class="comment">//args为数组</span></span><br></pre></td></tr></table></figure>
<p>像上面这中arguments虽然不是数组, 但我们把它当做数组处理, 这种现象叫做 <strong><code>鸭式辩型</code></strong> . </p>
<blockquote>
<p>如果一个对象可以像鸭子一样走路,游泳,并且嘎嘎叫,就认为这个对象是鸭子,哪怕它并不是从鸭子对象继承过来的。</p>
</blockquote>
<p>在javascript里面，很多函数都不做对象的类型检测，而是只关心这些对象能做什么. 因此我们尽可利用鸭式辨型的便利, 以下就充分演示了把arguments当做一个数组来处理.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//合并参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myConcat</span>(<span class="params">separator</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);<span class="comment">//相当于arguments调用了Array的slice方法</span></span><br><span class="line">  <span class="keyword">return</span> args.join(separator);</span><br><span class="line">&#125;</span><br><span class="line">myConcat(<span class="string">", "</span>, <span class="string">"red"</span>, <span class="string">"orange"</span>, <span class="string">"blue"</span>);<span class="comment">//"red, orange, blue"</span></span><br></pre></td></tr></table></figure>
<p>警告: 此处不应在 arguments 对象上使用 slice 方法，这会阻碍 JavaScript 引擎的优化 (比如 V8 引擎)。作为替代，应通过遍历 arguments 对象的方式来构建一个新的数组。<a href="https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments" target="_blank" rel="external">更多信息</a>。</p>
<p>如果 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#Array_generic_methods" target="_blank" rel="external">Array generics</a> 可用的话，下面的代码则可以作为替代:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> args = <span class="built_in">Array</span>.slice(<span class="built_in">arguments</span>);<span class="comment">//注意,arguments对象仅在函数内部有效</span></span><br></pre></td></tr></table></figure>
<hr>
<p>本问就讨论这么多内容,大家有什么问题或好的想法欢迎在下方参与<a href="#respond">留言和评论</a>.</p>
<p>本文作者: <a href="https://github.com/Louiszhai" target="_blank" rel="external">louis</a></p>
<p>本文链接: <a href="http://louiszhai.github.io/2015/12/15/arguments/">http://louiszhai.github.io/2015/12/15/arguments/</a></p>
<p>参考文章</p>
<ul>
<li><a href="http://www.cnblogs.com/vnii/archive/2011/12/23/2299636.html" target="_blank" rel="external">几个简单递归js 实现 - 忧郁的匹格 - 博客园</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/arguments" target="_blank" rel="external">arguments - JavaScript | MDN</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u6982_u8FF0"><a href="#u6982_u8FF0" class="headerlink" title="概述"></a>概述</h3><p><strong>Arguments</strong> 对象已经不再是函数的属性了, 它是函数内部的本地变量,  包括如下属性：</p>
<ol>
<li>callee — 指向当前函数的引用</li>
<li>length — 真正传递的参数个数</li>
<li>properties-indexes (字符串类型的整数) 属性的值就是函数的参数值(按参数列表从左到右排列)。 properties-indexes内部元素的个数等于arguments.length. properties-indexes 的值和实际传递进来的参数之间是<strong>共享</strong>的。</li>
</ol>]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://louiszhai.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[详解JS原型链]]></title>
    <link href="http://louiszhai.github.io/2015/12/15/prototypeChain/"/>
    <id>http://louiszhai.github.io/2015/12/15/prototypeChain/</id>
    <published>2015-12-15T01:26:28.000Z</published>
    <updated>2015-12-18T02:42:16.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u6458_u81EAJavaScript_u9AD8_u7EA7_u7A0B_u5E8F_u8BBE_u8BA1_3A"><a href="#u6458_u81EAJavaScript_u9AD8_u7EA7_u7A0B_u5E8F_u8BBE_u8BA1_3A" class="headerlink" title="摘自JavaScript高级程序设计:"></a>摘自JavaScript高级程序设计:</h3><p>继承是OO语言中的一个最为人津津乐道的概念.许多OO语言都支持两种继承方式: <strong>接口继承</strong> 和 <strong>实现继承</strong> .接口继承只继承方法签名,而实现继承则继承实际的方法.由于js中方法没有签名,在ECMAScript中无法实现接口继承.ECMAScript只支持实现继承,而且其 <code>实现继承</code> 主要是依靠原型链来实现的.</p>
<a id="more"></a> 
<h3 id="u6982_u5FF5"><a href="#u6982_u5FF5" class="headerlink" title="概念"></a>概念</h3><p>简单回顾下构造函数,原型和实例的关系:</p>
<blockquote>
<p>每个构造函数(constructor)都有一个原型对象(prototype),原型对象都包含一个指向构造函数的指针,而实例(instance)都包含一个指向原型对象的内部指针.</p>
</blockquote>
<p>JS对象的圈子里有这么个游戏规则:</p>
<blockquote>
<p>如果试图引用对象(实例instance)的某个属性,会首先在对象内部寻找该属性,直至找不到,然后才在该对象的原型(instance.prototype)里去找这个属性.</p>
</blockquote>
<p>如果让原型对象指向另一个类型的实例…..有趣的事情便发生了.</p>
<p>即: constructor1.prototype = instance2</p>
<p>鉴于上述游戏规则生效,如果试图引用constructor1构造的实例instance1的某个属性p1:</p>
<p>1).首先会在instance1内部属性中找一遍;</p>
<p>2).接着会在instance1.constructor1.prototype中找一遍,而instance1.constructor1.prototype 实际上是instance2, 也就是说在instance2中寻找该属性p1;</p>
<p>3).如果instance2中还是没有,此时程序不会灰心,它会继续在instance2.constructor2.prototype中寻找…直至Object的原型对象</p>
<blockquote>
<p>搜索轨迹: instance1–&gt; instance2 –&gt; instance2.constructor2.prototype…Object.prototype</p>
</blockquote>
<p>这种搜索的轨迹,形似一条长链, 又因prototype在这个游戏规则中充当链接的作用,于是我们把这种实例与原型的链条称作 <strong>原型链</strong> . 下面有个例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.getFatherValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.property;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.sonProperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继承 Father</span></span><br><span class="line">Son.prototype = <span class="keyword">new</span> Father();<span class="comment">//Son.prototype被重写,导致Son.prototype.constructor也一同被重写</span></span><br><span class="line">Son.prototype.getSonVaule = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.sonProperty;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> Son();</span><br><span class="line">alert(instance.getFatherValue());<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>instance实例通过原型链找到了Father原型中的getFatherValue方法.</p>
<p>注意: 此时instance.constructor指向的是Father,这是因为Son.prototype中的constructor被重写的缘故.</p>
<p>以上我们弄清楚了何为原型链,如有不清楚请尽量在下方<a href="#respond">给我留言</a></p>
<hr>
<h3 id="u786E_u5B9A_u539F_u578B_u548C_u5B9E_u4F8B_u7684_u5173_u7CFB"><a href="#u786E_u5B9A_u539F_u578B_u548C_u5B9E_u4F8B_u7684_u5173_u7CFB" class="headerlink" title="确定原型和实例的关系"></a>确定原型和实例的关系</h3><p>使用原型链后, 我们怎么去判断原型和实例的这种继承关系呢? 方法一般有两种.</p>
<blockquote>
<p>第一种是使用 <strong>instanceof</strong> 操作符, 只要用这个操作符来测试实例(instance)与原型链中出现过的构造函数,结果就会返回true. 以下几行代码就说明了这点.</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert(instance <span class="keyword">instanceof</span> <span class="built_in">Object</span>);<span class="comment">//true</span></span><br><span class="line">alert(instance <span class="keyword">instanceof</span> Father);<span class="comment">//true</span></span><br><span class="line">alert(instance <span class="keyword">instanceof</span> Son);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>由于原型链的关系, 我们可以说instance 是 Object, Father 或 Son中任何一个类型的实例. 因此, 这三个构造函数的结果都返回了true.</p>
<blockquote>
<p>第二种是使用 <strong>isPrototypeOf()</strong> 方法, 同样只要是原型链中出现过的原型,isPrototypeOf() 方法就会返回true, 如下所示.</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="built_in">Object</span>.prototype.isPrototypeOf(instance));<span class="comment">//true</span></span><br><span class="line">alert(Father.prototype.isPrototypeOf(instance));<span class="comment">//true</span></span><br><span class="line">alert(Son.prototype.isPrototypeOf(instance));<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>原理同上.</p>
<h3 id="u539F_u578B_u94FE_u7684_u95EE_u9898"><a href="#u539F_u578B_u94FE_u7684_u95EE_u9898" class="headerlink" title="原型链的问题"></a>原型链的问题</h3><p>原型链并非十分完美, 它包含如下两个问题.</p>
<blockquote>
<p>问题一: 当原型链中包含引用类型值的原型时,该引用类型值会被所有实例共享;</p>
<p>问题二: 在创建子类型(例如创建Son的实例)时,不能向超类型(例如Father)的构造函数中传递参数. </p>
</blockquote>
<p>有鉴于此, 实践中很少会单独使用原型链.</p>
<p>为此,下面将有一些尝试以弥补原型链的不足.</p>
<h3 id="u501F_u7528_u6784_u9020_u51FD_u6570"><a href="#u501F_u7528_u6784_u9020_u51FD_u6570" class="headerlink" title="借用构造函数"></a>借用构造函数</h3><p>为解决原型链中上述两个问题, 我们开始使用一种叫做<strong>借用构造函数</strong>(constructor stealing)的技术(也叫经典继承).</p>
<blockquote>
<p>基本思想:即在子类型构造函数的内部调用超类型构造函数.</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.colors = [<span class="string">"red"</span>,<span class="string">"blue"</span>,<span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	Father.call(<span class="keyword">this</span>);<span class="comment">//继承了Father,且向父类型传递参数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Son();</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);<span class="comment">//"red,blue,green,black"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> Son();</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors);<span class="comment">//"red,blue,green" 可见引用类型值是独立的</span></span><br></pre></td></tr></table></figure>
<p>很明显,借用构造函数一举解决了原型链的两大问题:</p>
<p>其一, 保证了原型链中引用类型值的独立,不再被所有实例共享;</p>
<p>其二, 子类型创建时也能够向父类型传递参数.</p>
<p>随之而来的是, 如果仅仅借用构造函数,那么将无法避免构造函数模式存在的问题–方法都在构造函数中定义, 因此函数复用也就不可用了.而且超类型(如Father)中定义的方法,对子类型而言也是不可见的. 考虑此,借用构造函数的技术也很少单独使用.</p>
<h3 id="u7EC4_u5408_u7EE7_u627F"><a href="#u7EC4_u5408_u7EE7_u627F" class="headerlink" title="组合继承"></a>组合继承</h3><p>组合继承, 有时候也叫做伪经典继承,指的是将原型链和借用构造函数的技术组合到一块,从而发挥两者之长的一种继承模式.</p>
<blockquote>
<p>基本思路: 使用原型链实现对原型属性和方法的继承,通过借用构造函数来实现对实例属性的继承.</p>
</blockquote>
<p>这样,既通过在原型上定义方法实现了函数复用,又能保证每个实例都有它自己的属性. 如下所示.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.colors = [<span class="string">"red"</span>,<span class="string">"blue"</span>,<span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">	Father.call(<span class="keyword">this</span>,name);<span class="comment">//继承实例属性，第一次调用Father()</span></span><br><span class="line">	<span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Son.prototype = <span class="keyword">new</span> Father();<span class="comment">//继承父类方法,第二次调用Father()</span></span><br><span class="line">Son.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Son(<span class="string">"louis"</span>,<span class="number">5</span>);</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);<span class="comment">//"red,blue,green,black"</span></span><br><span class="line">instance1.sayName();<span class="comment">//louis</span></span><br><span class="line">instance1.sayAge();<span class="comment">//5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Son(<span class="string">"zhai"</span>,<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);<span class="comment">//"red,blue,green"</span></span><br><span class="line">instance1.sayName();<span class="comment">//zhai</span></span><br><span class="line">instance1.sayAge();<span class="comment">//10</span></span><br></pre></td></tr></table></figure>
<p>组合继承避免了原型链和借用构造函数的缺陷,融合了它们的优点,成为 JavaScript 中最常用的继承模式. 而且, instanceof 和 isPrototypeOf( )也能用于识别基于组合继承创建的对象.</p>
<p>同时我们还注意到组合继承其实调用了两次父类构造函数, 造成了不必要的消耗, 那么怎样才能避免这种不必要的消耗呢, 这个我们将在后面讲到.</p>
<h3 id="u539F_u578B_u7EE7_u627F"><a href="#u539F_u578B_u7EE7_u627F" class="headerlink" title="原型继承"></a>原型继承</h3><p>该方法最初由道格拉斯·克罗克福德于2006年在一篇题为 《Prototypal Inheritance in JavaScript》(JavaScript中的原型式继承) 的文章中提出. 他的想法是借助原型可以基于已有的对象创建新对象， 同时还不必因此创建自定义类型. 大意如下:</p>
<blockquote>
<p>在object()函数内部, 先创建一个临时性的构造函数, 然后将传入的对象作为这个构造函数的原型,最后返回了这个临时类型的一个新实例. </p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">	F.prototype = o;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从本质上讲, object() 对传入其中的对象执行了一次浅复制. 下面我们来看看为什么是浅复制.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">	friends : [<span class="string">"Van"</span>,<span class="string">"Louis"</span>,<span class="string">"Nick"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> anotherPerson = object(person);</span><br><span class="line">anotherPerson.friends.push(<span class="string">"Rob"</span>);</span><br><span class="line"><span class="keyword">var</span> yetAnotherPerson = object(person);</span><br><span class="line">yetAnotherPerson.friends.push(<span class="string">"Style"</span>);</span><br><span class="line">alert(person.friends);<span class="comment">//"Van,Louis,Nick,Rob,Style"</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中,可以作为另一个对象基础的是person对象,于是我们把它传入到object()函数中,然后该函数就会返回一个新对象. 这个新对象将person作为原型,因此它的原型中就包含引用类型值属性. 这意味着person.friends不仅属于person所有,而且也会被anotherPerson以及yetAnotherPerson共享.</p>
<p>在 ECMAScript5 中,通过新增 <strong>object.create()</strong> 方法规范化了上面的原型式继承.</p>
<p><strong>object.create()</strong> 接收两个参数:</p>
<ul>
<li>一个用作新对象原型的对象</li>
<li>(可选的)一个为新对象定义额外属性的对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">	friends : [<span class="string">"Van"</span>,<span class="string">"Louis"</span>,<span class="string">"Nick"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> anotherPerson = <span class="built_in">Object</span>.create(person);</span><br><span class="line">anotherPerson.friends.push(<span class="string">"Rob"</span>);</span><br><span class="line"><span class="keyword">var</span> yetAnotherPerson = <span class="built_in">Object</span>.create(person);</span><br><span class="line">yetAnotherPerson.friends.push(<span class="string">"Style"</span>);</span><br><span class="line">alert(person.friends);<span class="comment">//"Van,Louis,Nick,Rob,Style"</span></span><br></pre></td></tr></table></figure>
<p><strong>object.create()</strong> 只有一个参数时功能与上述object方法相同, 它的第二个参数与Object.defineProperties()方法的第二个参数格式相同: 每个属性都是通过自己的描述符定义的.以这种方式指定的任何属性都会覆盖原型对象上的同名属性.例如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">	name : <span class="string">"Van"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> anotherPerson = <span class="built_in">Object</span>.create(person, &#123;</span><br><span class="line">	name : &#123;</span><br><span class="line">		value : <span class="string">"Louis"</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line">alert(anotherPerson.name);<span class="comment">//"Louis"</span></span><br></pre></td></tr></table></figure>
<p>目前支持 <strong>Object.create()</strong> 的浏览器有 IE9+, Firefox 4+, Safari 5+, Opera 12+ 和 Chrome.</p>
<p><strong>提醒:</strong> 原型式继承中, 包含引用类型值的属性始终都会共享相应的值, 就像使用原型模式一样.</p>
<h3 id="u5BC4_u751F_u5F0F_u7EE7_u627F"><a href="#u5BC4_u751F_u5F0F_u7EE7_u627F" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><p>寄生式继承是与原型式继承紧密相关的一种思路， 同样是克罗克福德推而广之.</p>
<blockquote>
<p>寄生式继承的思路与(寄生)构造函数和工厂模式类似, 即创建一个仅用于封装继承过程的函数,该函数在内部以某种方式来增强对象,最后再像真的是它做了所有工作一样返回对象. 如下.</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> clone = object(original);<span class="comment">//通过调用object函数创建一个新对象</span></span><br><span class="line">	clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//以某种方式来增强这个对象</span></span><br><span class="line">		alert(<span class="string">"hi"</span>);</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">return</span> clone;<span class="comment">//返回这个对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子中的代码基于person返回了一个新对象–anotherPerson. 新对象不仅具有 person 的所有属性和方法, 而且还被增强了, 拥有了sayH()方法. </p>
<p><strong>注意:</strong> 使用寄生式继承来为对象添加函数, 会由于不能做到函数复用而降低效率;这一点与构造函数模式类似.</p>
<h3 id="u5BC4_u751F_u7EC4_u5408_u5F0F_u7EE7_u627F"><a href="#u5BC4_u751F_u7EC4_u5408_u5F0F_u7EE7_u627F" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3><p>前面讲过,组合继承是 JavaScript 最常用的继承模式; 不过, 它也有自己的不足. 组合继承最大的问题就是无论什么情况下,都会调用两次父类构造函数: 一次是在创建子类型原型的时候, 另一次是在子类型构造函数内部. <strong>寄生组合式继承就是为了降低调用父类构造函数的开销而出现的</strong> .</p>
<blockquote>
<p>其背后的基本思路是: 不必为了指定子类型的原型而调用超类型的构造函数</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">subClass,superClass</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> prototype = object(superClass.prototype);<span class="comment">//创建对象</span></span><br><span class="line">	prototype.constructor = subClass;<span class="comment">//增强对象</span></span><br><span class="line">	subClass.prototype = prototype;<span class="comment">//指定对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>extend的高效率体现在它没有调用superClass构造函数,因此避免了在subClass.prototype上面创建不必要,多余的属性. 于此同时,原型链还能保持不变; 因此还能正常使用 instanceof 和 isPrototypeOf() 方法.</p>
<p>以上,寄生组合式继承,集寄生式继承和组合继承的优点于一身,是实现基于类型继承的最有效方法.</p>
<hr>
<p>下面我们来看下extend的另一种更为有效的扩展.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">subClass, superClass</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  F.prototype = superClass.prototype;</span><br><span class="line">  subClass.prototype = <span class="keyword">new</span> F(); </span><br><span class="line">  subClass.prototype.constructor = subClass;</span><br><span class="line"></span><br><span class="line">  subClass.superclass = superClass.prototype;</span><br><span class="line">  <span class="keyword">if</span>(superClass.prototype.constructor == <span class="built_in">Object</span>.prototype.constructor) &#123;</span><br><span class="line">    superClass.prototype.constructor = superClass;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我一直不太明白的是为什么要 “<strong>new F()</strong>“, 既然extend的目的是将子类型的 prototype 指向超类型的 prototype,为什么不直接做如下操作呢?</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subClass.prototype = superClass.prototype;<span class="comment">//直接指向超类型prototype</span></span><br></pre></td></tr></table></figure>
<p>于是便有了下面这个插曲.</p>
<hr>
<p>我仔细研究了new运算符具体干了什么?发现其实很简单，就干了三件事情。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj  = &#123;&#125;;</span><br><span class="line">obj.__proto__ = F.prototype;</span><br><span class="line">F.call(obj);</span><br></pre></td></tr></table></figure>
<p>第一行，我们创建了一个空对象obj;</p>
<p>第二行，我们将这个空对象的<strong>proto</strong>成员指向了F函数对象prototype成员对象;</p>
<p>第三行，我们将F函数对象的this指针替换成obj，然后再调用F函数.</p>
<p>我们可以这么理解: 以 new 操作符调用构造函数的时候，函数内部实际上发生以下变化：</p>
<p>  1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。</p>
<p>  2、属性和方法被加入到 this 引用的对象中。</p>
<p>  3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。</p>
<p>以上new操作符的作用大体是继承原型并返回this, 即便如此 new F()依然没有做更多的事情,故我认为可以使用以下代码替换掉new F()那段.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subClass.prototype = superClass.prototype;<span class="comment">//直接指向超类型prototype</span></span><br></pre></td></tr></table></figure>
<p>于是最终extend代码应该为</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">subClass, superClass</span>) </span>&#123;</span><br><span class="line">  subClass.prototype = superClass.prototype;</span><br><span class="line"></span><br><span class="line">  subClass.superclass = superClass.prototype;</span><br><span class="line">  <span class="keyword">if</span>(superClass.prototype.constructor == <span class="built_in">Object</span>.prototype.constructor) &#123;</span><br><span class="line">    superClass.prototype.constructor = superClass;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么最终,原型链继承可以这么实现,例如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.colors = [<span class="string">"red"</span>,<span class="string">"blue"</span>,<span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">	Father.call(<span class="keyword">this</span>,name);<span class="comment">//继承实例属性，第一次调用Father()</span></span><br><span class="line">	<span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">extend(Son,Father)<span class="comment">//继承父类方法,此处并不会第二次调用Father()</span></span><br><span class="line">Son.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Son(<span class="string">"louis"</span>,<span class="number">5</span>);</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);<span class="comment">//"red,blue,green,black"</span></span><br><span class="line">instance1.sayName();<span class="comment">//louis</span></span><br><span class="line">instance1.sayAge();<span class="comment">//5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Son(<span class="string">"zhai"</span>,<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);<span class="comment">//"red,blue,green"</span></span><br><span class="line">instance1.sayName();<span class="comment">//zhai</span></span><br><span class="line">instance1.sayAge();<span class="comment">//10</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="u6269_u5C55_3A"><a href="#u6269_u5C55_3A" class="headerlink" title="扩展:"></a>扩展:</h3><h4 id="u5C5E_u6027_u67E5_u627E"><a href="#u5C5E_u6027_u67E5_u627E" class="headerlink" title="属性查找"></a>属性查找</h4><p>​    使用了原型链后, 当查找一个对象的属性时，JavaScript 会向上遍历原型链，直到找到给定名称的属性为止，到查找到达原型链的顶部 - 也就是 Object.prototype - 但是仍然没有找到指定的属性，就会返回 undefined. 此时若想避免原型链查找, 建议使用 <strong>hasOwnProperty</strong> 方法. 因为 <strong>hasOwnProperty</strong> 是 JavaScript 中唯一一个处理属性但是不查找原型链的函数. 如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(instance1.hasOwnProperty(<span class="string">'age'</span>));<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>对比: <strong>isPrototypeOf</strong> 则是用来判断该方法所属的对象是不是参数的原型对象，是则返回true，否则返回false。如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Father.prototype.isPrototypeOf(instance1));<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<h4 id="instanceof__26amp_3B_26amp_3B_typeof"><a href="#instanceof__26amp_3B_26amp_3B_typeof" class="headerlink" title="instanceof &amp;&amp; typeof"></a>instanceof &amp;&amp; typeof</h4><p>上面提到几次提到 instanceof 运算符. 那么到底它是怎么玩的呢? 下面让我们来趴一趴它的使用场景.</p>
<p><strong>instanceof</strong> 运算符是用来在运行时指出对象是否是构造器的一个实例, 例如漏写了new运算符去调用某个构造器, 此时构造器内部可以通过 instanceof 来判断.(java中功能类似)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span> <span class="keyword">instanceof</span> <span class="built_in">arguments</span>.callee)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'此处作为构造函数被调用'</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'此处作为普通函数被调用'</span>);</span><br><span class="line">&#125;</span><br><span class="line">f();<span class="comment">//此处作为构造函数被调用</span></span><br><span class="line"><span class="keyword">new</span> f();<span class="comment">//此处作为普通函数被调用</span></span><br></pre></td></tr></table></figure>
<p>以上, this instanceof <a href="http://louiszhai.github.io/2015/12/15/arguments/"><code>arguments</code></a>.callee 的值如果为 true 表示是作为构造函数被调用的,如果为 false 则表示是作为普通函数被调用的。</p>
<p>对比: <strong>typeof</strong> 则用以获取一个变量或者表达式的类型, 一般只能返回如下几个结果:</p>
<p>number,boolean,string,function（函数）,object（NULL,数组，对象）,undefined。</p>
<h4 id="new_u8FD0_u7B97_u7B26"><a href="#new_u8FD0_u7B97_u7B26" class="headerlink" title="new运算符"></a>new运算符</h4><p>此处引用 艾伦的 <a href="http://www.cnblogs.com/aaronjs/archive/2012/07/04/2575570.html" target="_blank" rel="external">JS 对象机制深剖——new 运算符</a></p>
<p>接着上述对new运算符的研究, 我们来考察 ECMAScript 语言规范中 <strong>new</strong> 运算符的定义：</p>
<p>The new Operator</p>
<blockquote>
<p>The production <em>NewExpression : new NewExpression</em> is evaluated as follows:Evaluate NewExpression.Call GetValue(Result(1)).If Type(Result(2)) is not Object, throw a TypeError exception.If Result(2) does not implement the internal <a href="http://www.pushiming.com/blog/2009/10/the-new-operator/#appendix" target="_blank" rel="external">[[Construc]]</a> method, throw a TypeError exception.Call the [[Construct]] method on Result(2), providing no arguments (that is, an empty list of arguments).Return Result(5).</p>
</blockquote>
<p>其大意是，new 后必须跟一个对象并且此对象必须有一个名为 [[Construct]] 的内部方法（其实这种对象就是构造器），否则会抛出异常</p>
<p>根据这些内容，我们完全可以构造一个伪 [[Construct]] 方法来模拟此流程</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyObject</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyObject.construct = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = &#123;&#125;, Constructor = MyObject;</span><br><span class="line">    o.__proto__ = Constructor.prototype;</span><br><span class="line">    <span class="comment">// FF 支持用户引用内部属性 [[Prototype]]</span></span><br><span class="line">    Constructor.apply(o, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = <span class="keyword">new</span> MyObject(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">var</span> obj2 = MyObject.construct(<span class="number">10</span>);</span><br><span class="line">alert(obj2 <span class="keyword">instanceof</span> MyObject);<span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<hr>
<p>不知不觉本文已经写了3天, 其实还有很多引申的东西没有讲出来, 大家有什么问题或好的想法欢迎在下方参与<a href="#respond">留言和评论</a>.</p>
<p>本文作者: <a href="https://github.com/Louiszhai" target="_blank" rel="external">louis</a></p>
<p>本文链接: <a href="http://louiszhai.github.io/2015/12/15/prototypeChain/">http://louiszhai.github.io/2015/12/15/prototypeChain/</a></p>
<p>参考:</p>
<ul>
<li>《JavaScript高级程序设计》</li>
<li><a href="http://www.infoq.com/cn/articles/javascript-instantiation-and-inheritance/" target="_blank" rel="external">JavaScript的实例化与继承：请停止使用new关键字</a></li>
<li><a href="http://www.cnblogs.com/TomXu/archive/2012/01/05/2305453.html" target="_blank" rel="external">深入理解JavaScript系列（5）：强大的原型和原型链 - 汤姆大叔 - 博客园</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[JavaScript 原型链 prototype instanceof typeof  hasOwnProperty new  借用构造函数 组合继承 寄生式继承 寄生组合式继承]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://louiszhai.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JS布尔值(Boolean)转换规则]]></title>
    <link href="http://louiszhai.github.io/2015/12/11/js.boolean/"/>
    <id>http://louiszhai.github.io/2015/12/11/js.boolean/</id>
    <published>2015-12-11T03:37:00.000Z</published>
    <updated>2015-12-15T15:06:11.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u8BED_u6CD5"><a href="#u8BED_u6CD5" class="headerlink" title="语法"></a>语法</h3><p>众所周知, JavaScript有五个基本的值类型：<strong>number</strong>、<strong>string</strong>、<strong>boolean</strong>、<strong>null</strong>和<strong>undefined。</strong>除了null和undefined以外，其他三个具有所谓的基本包装对象。可以使用内置构造函数Number()、String()、Boolean()创建包装对象。</p>
<blockquote>
<p>boolean是JS的6种数据类型(number,string,object,boolean,null,undefined)之一,有且只有两种值:true和false</p>
</blockquote>
<a id="more"></a>
<p>1.使用Boolean(value)方法可以强制转换任意值为boolean类型,除了以下六个值，其他都是自动转为true：</p>
<ul>
<li>undefined</li>
<li>null</li>
<li>-0</li>
<li>+0</li>
<li>NaN</li>
<li>‘’（空字符串）</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>(<span class="literal">undefined</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">null</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="number">0</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">NaN</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="string">''</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>2.对象的转换规则</p>
<blockquote>
<p>所有对象的布尔值都是true，甚至连false对应的布尔对象也是true。</p>
<p>请注意，空对象{}和空数组[]也会被转成true。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>(<span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>))<span class="comment">// Boolean对象会转成true</span></span><br><span class="line"><span class="built_in">Boolean</span>([]) <span class="comment">// 空数组会转成true</span></span><br><span class="line"><span class="built_in">Boolean</span>(&#123;&#125;) <span class="comment">// 空对象会转成true</span></span><br></pre></td></tr></table></figure>
<p>3.其中有一些让人困惑的地方</p>
<blockquote>
<p><strong>&amp;&amp;</strong> 表达式从第一个开始,遇到值为false的表达式,则返回表达式本身,否则返回最后一个表达式</p>
<p><strong>||</strong> 和 <strong>!</strong> 逻辑运算符原理类似</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj &amp;&amp; <span class="literal">true</span>);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> &amp;&amp; obj);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>因此,第二个console实际上打印的是obj对象的值,即false</p>
<hr>
<p>本问就讨论这么多内容,大家有什么问题或好的想法欢迎在下方参与<a href="#respond">留言和评论</a>.</p>
<p>本文作者: <a href="https://github.com/Louiszhai" target="_blank" rel="external">louis</a></p>
<p>本文链接: <a href="http://louiszhai.github.io/2015/12/11/js.boolean/">http://louiszhai.github.io/2015/12/11/js.boolean/</a></p>
<p>参考文章</p>
<ul>
<li><a href="http://blog.csdn.net/gudanyehai/article/details/6089255" target="_blank" rel="external">js中的boolean原始类型和Boolean引用类型 - 孤单夜海 - 博客频道 - CSDN.NET</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[JavaScript boolean]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://louiszhai.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[详解ECMAScript String.replace]]></title>
    <link href="http://louiszhai.github.io/2015/12/11/js.replace/"/>
    <id>http://louiszhai.github.io/2015/12/11/js.replace/</id>
    <published>2015-12-11T02:02:47.000Z</published>
    <updated>2015-12-15T14:13:54.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u8BED_u6CD5"><a href="#u8BED_u6CD5" class="headerlink" title="语法"></a>语法</h3><blockquote>
<p><strong>str.replace( regexp | substr, newSubStr | function[, flags] )</strong></p>
</blockquote>
<a id="more"></a>
<h3 id="u53C2_u6570"><a href="#u53C2_u6570" class="headerlink" title="参数"></a>参数</h3><ul>
<li><strong>regexp:</strong> 一个 RegExp 对象。该正则所匹配的内容会被第二个参数的返回值替换掉。</li>
<li><strong>substr:</strong> 一个要被 newSubStr 替换的字符串。</li>
<li><strong>newSubStr:</strong> 替换掉第一个参数在原字符串中的匹配部分。该字符串中可以内插一些特殊的变量名。</li>
<li><strong>function:</strong> 一个用来创建新子字符串的函数，该函数的返回值将替换掉第一个参数匹配到的结果。该函数的参数描述请参考 指定一个函数作为参数 小节。</li>
<li><strong>flags:</strong> 注意：flags 参数在 v8 内核（Chrome and NodeJs）中不起作用。方法中使用 flags 参数不是符合标准的并且不赞成这样做。</li>
</ul>
<blockquote>
<p>简单概括,replace拥有两个参数,第一个是需要替换的字符串或者正则表达式;<br> 第二个是新的字符串或者一个function,这样参数便有四种组合</p>
</blockquote>
<h3 id="u63CF_u8FF0"><a href="#u63CF_u8FF0" class="headerlink" title="描述"></a>描述</h3><p>该方法并不改变调用它的字符串本身，而只是返回替换后的字符串。</p>
<h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p>1.一般来说我们使用JS String对象的replace方法的姿势是这个样子:</p>
<blockquote>
<p>match1:    String–&gt;String</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">"what is this? before"</span>;</span><br><span class="line"><span class="keyword">var</span> b = a.replace(<span class="string">"before"</span>,<span class="string">"after"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(b);	<span class="comment">// "what is this? after"</span></span><br></pre></td></tr></table></figure>
<p>仅仅用到了文本替换为文本的功能.</p>
<p>2.更高级些还可以摆出这样的姿势,如果第一个参数是正则表达式,新的字符串中可以用$符号取正则中匹配的子串(也就是正则中被括号包裹的部分):</p>
<blockquote>
<p>match2:    Regexp–&gt;String</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">"what is this? before"</span>;</span><br><span class="line"><span class="keyword">var</span> b = a.replace(<span class="regexp">/(^\w+).*?(\w+)$/</span>,<span class="string">"$2 $1"</span>);<span class="comment">//括号分割的部分依次为子串1....n</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// "before what"</span></span><br></pre></td></tr></table></figure>
<p>3.依照语法,第二个参数其实可为一个function,最终字符串将以function的返回值作为replace的返回值,以下是该function的形参:<br>function(match,p1…,offset,string),可见至少包含三个形参(即arguments.length&gt;=3)</p>
<blockquote>
<p>match3:    Regexp–&gt;Function</p>
</blockquote>
<ul>
<li>match表示第一个参数(整个正则表达式)匹配的字符串</li>
<li>p1至pn表示第1..n个括号匹配的字符串,如果没有括号则不存在该项</li>
<li>offset表示匹配的起点在原字符串中的偏移</li>
<li>string表示原字符串</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">replacer</span>(<span class="params">match,p1,p2,offset,string</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//此时p1=" is",p2=" this"</span></span><br><span class="line">    <span class="keyword">return</span> p1+<span class="string">" that"</span>;<span class="comment">//如果返回为空串,则匹配内容替换为空,如果不返回,则匹配内容替换为undefined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">"what is this? before"</span>;</span><br><span class="line"><span class="keyword">var</span> b = a.replace(<span class="regexp">/(\s\w+)(\s\w+)/</span>,replacer);</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// "what is that? before"</span></span><br></pre></td></tr></table></figure>
<p>4.这里还有一种搭配,str.replace( substr, function[, flags] )</p>
<blockquote>
<p>match4:    String–&gt;Function</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">replacer</span>(<span class="params">match,offset,string</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//由于字符串中不会有括号进行分组,此时没有子串</span></span><br><span class="line">    <span class="keyword">return</span> offset+<span class="string">" that"</span>;<span class="comment">//偏移为4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">"what is this? before"</span>;</span><br><span class="line"><span class="keyword">var</span> b = a.replace(<span class="string">" is this"</span>,replacer);</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// "what4 that? before"</span></span><br></pre></td></tr></table></figure>
<p>以上4种replace使用方法可以满足大部分的操作字符串场景,特别是function的引入,极大的增强了replace的实力,从而使得我们操作字符游刃有余.</p>
<hr>
<p>本问就讨论这么多内容,大家有什么问题或好的想法欢迎在下方参与<a href="http://louiszhai.github.io/2015/12/11/js.replace/#respond">留言和评论</a>.<br>本文作者: <a href="https://github.com/Louiszhai" target="_blank" rel="external">louis</a><br>本文链接: <a href="http://louiszhai.github.io/2015/12/11/js.replace/">http://louiszhai.github.io/2015/12/11/js.replace/</a></p>
<p>参考文章</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace" target="_blank" rel="external">String.prototype.replace() - JavaScript | MDN</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[JavaScript string replace]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://louiszhai.github.io/tags/JavaScript/"/>
    
  </entry>
  
</feed>
