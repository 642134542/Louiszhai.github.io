<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>webpack与browser-sync热更新原理深度讲解 | louis blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="EventSource 热更新 webpack热更新延迟 websocket 心跳连接 Frame Socket.IO browser-sync webpack-hot-middleware">
<meta property="og:type" content="article">
<meta property="og:title" content="webpack与browser-sync热更新原理深度讲解">
<meta property="og:url" content="http://louiszhai.github.io/2017/04/19/hmr/index.html">
<meta property="og:site_name" content="louis blog">
<meta property="og:description" content="EventSource 热更新 webpack热更新延迟 websocket 心跳连接 Frame Socket.IO browser-sync webpack-hot-middleware">
<meta property="og:image" content="http://louiszhai.github.io/docImages/hmr11.png">
<meta property="og:image" content="http://louiszhai.github.io/docImages/hmr12.png">
<meta property="og:image" content="http://louiszhai.github.io/docImages/hot-replace01.gif">
<meta property="og:image" content="http://louiszhai.github.io/docImages/hot-replace02.gif">
<meta property="og:image" content="http://louiszhai.github.io/docImages/hot-replace04.png">
<meta property="og:image" content="http://louiszhai.github.io/docImages/hot-replace03.gif">
<meta property="og:image" content="http://louiszhai.github.io/docImages/hot-replace09.png">
<meta property="og:image" content="http://louiszhai.github.io/docImages/hot-replace05.png">
<meta property="og:image" content="http://louiszhai.github.io/docImages/hot-replace07.png">
<meta property="og:image" content="http://louiszhai.github.io/docImages/hot-replace06.png">
<meta property="og:image" content="http://louiszhai.github.io/docImages/hot-replace08.png">
<meta property="og:image" content="http://louiszhai.github.io/docImages/hot-replace10.png">
<meta property="og:updated_time" content="2017-04-19T11:02:31.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="webpack与browser-sync热更新原理深度讲解">
<meta name="twitter:description" content="EventSource 热更新 webpack热更新延迟 websocket 心跳连接 Frame Socket.IO browser-sync webpack-hot-middleware">
<meta name="twitter:image" content="http://louiszhai.github.io/docImages/hmr11.png">
  
    <link rel="alternative" href="/atom.xml" title="louis blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
<div id="container">
    <div class="left-col">
        <div class="overlay">
	<!--<input type="text" class="st-default-search-input" style="position:absolute;top: 50px;left: 35px;">-->
</div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="https://avatars2.githubusercontent.com/u/8412301?v=3&amp;s=320" class="js-avatar" style="width: 100%;height: 100%;opacity: 1;">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">路易斯</a></h1>
		</hgroup>

		
		<p class="header-subtitle">坚持原著, 深度思考, 力求简单通俗叙事</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>Tags</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives/">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/Louiszhai" title="github">github</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/CSS/" style="font-size: 16.67px;">CSS</a> <a href="/tags/JavaScript/" style="font-size: 20px;">JavaScript</a> <a href="/tags/Web/" style="font-size: 16.67px;">Web</a> <a href="/tags/XSS/" style="font-size: 10px;">XSS</a> <a href="/tags/css/" style="font-size: 13.33px;">css</a> <a href="/tags/javascript/" style="font-size: 10px;">javascript</a>
					</div>
				</section>
				
				
				

				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
        <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">路易斯</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img src="https://avatars2.githubusercontent.com/u/8412301?v=3&amp;s=320" class="js-avatar" style="width: 100%;height: 100%;opacity: 1;">
			
			</div>
			<hgroup>
			  <h1 class="header-author">路易斯</h1>
			</hgroup>
			
			<p class="header-subtitle">坚持原著, 深度思考, 力求简单通俗叙事</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives/">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Louiszhai" title="github">github</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

        <div class="body-wrap"><article id="post-hmr" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/04/19/hmr/" class="article-date">
  	<time datetime="2017-04-19T02:10:00.000Z" itemprop="datePublished">2017-04-19</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      webpack与browser-sync热更新原理深度讲解
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Web/">Web</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          <span class="toc-arrow"></span>
<div id="toc" class="toc-article">
    <div class="toc-title">目录</div>
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#webpack-hot-middleware"><span class="toc-text">webpack-hot-middleware</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EventSource"><span class="toc-text">EventSource</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CORS"><span class="toc-text">CORS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nginx配置"><span class="toc-text">nginx配置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#browser-sync"><span class="toc-text">browser-sync</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WebSocket"><span class="toc-text">WebSocket</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#支持性"><span class="toc-text">支持性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Frame"><span class="toc-text">Frame</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#建立连接"><span class="toc-text">建立连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#服务端实现"><span class="toc-text">服务端实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#发送和监听消息"><span class="toc-text">发送和监听消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#关闭连接"><span class="toc-text">关闭连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#拥有的属性"><span class="toc-text">拥有的属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#文件上传"><span class="toc-text">文件上传</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#心跳连接"><span class="toc-text">心跳连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Socket-IO"><span class="toc-text">Socket.IO</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小结"><span class="toc-text">小结</span></a></li></ol>
</div>
      
        <p>开发环境页面热更新早已是主流，我们不光要吃着火锅唱着歌，享受热更新高效率的快感，更要深入下去探求其原理。</p>
<p>要知道，触类则旁通，常见的需求如赛事网页推送比赛结果、网页实时展示投票或点赞数据、在线评论或弹幕、在线聊天室等，都需要借助热更新功能，才能达到实时的端对端的极致体验。</p>
<p>刚好，最近解决<code>webpack-hot-middleware</code>热更新延迟问题的过程中，我深入接触了EventSource技术。遂本文由此开篇，进一步讲解<code>webpack-hot-middleware</code>，<code>browser-sync</code>背后的技术。</p>
<a id="more"></a>
<h3 id="webpack-hot-middleware"><a href="#webpack-hot-middleware" class="headerlink" title="webpack-hot-middleware"></a><strong>webpack-hot-middleware</strong></h3><p><code>webpack-hot-middleware</code>中间件是webpack的一个plugin，通常结合<code>webpack-dev-middleware</code>一起使用。借助它可以实现浏览器的无刷新更新（热更新），即webpack里的HMR（Hot Module Replacement）。如何配置请参考 <a href="https://github.com/glenjamin/webpack-hot-middleware" target="_blank" rel="external">webpack-hot-middleware</a>，如何理解其相关插件请参考 <a href="https://segmentfault.com/a/1190000005614604?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">手把手深入理解 webpack dev middleware 原理與相關 plugins</a>。</p>
<p>webpack加入<code>webpack-hot-middleware</code>后，内存中的页面将包含HMR相关js，加载页面后，Network栏可以看到如下请求：</p>
<p><img src="http://louiszhai.github.io/docImages/hmr11.png" alt="__webpack_hmr"></p>
<p>__webpack_hmr是一个<code>type</code>为EventSource的请求, 从<code>Time</code>栏可以看出：默认情况下，服务器每十秒推送一条信息到浏览器。</p>
<p><img src="http://louiszhai.github.io/docImages/hmr12.png" alt="hmr每10秒推送一条信息"></p>
<p>如果此时关闭开发服务器，浏览器由于重连机制，将持续抛出类似<code>GET http://www.test.com/__webpack_hmr 502 (Bad Gateway)</code> 这样的错误。重新启动开发服务器后，重连将会成功，此时便会刷新页面。</p>
<p>以上这些便是我们使用时感受到的最初的印象。当然，停留在使用层面不是我们的目标，接下来我们将跳出该中间件，讲解其所使用到的<code>EventSource</code>技术。</p>
<h3 id="EventSource"><a href="#EventSource" class="headerlink" title="EventSource"></a><strong>EventSource</strong></h3><p>EventSource 不是一个新鲜的技术，它早就随着H5规范提出了，正式一点应该叫<code>Server-sent events</code>，即<code>SSE</code>。</p>
<p>鉴于传统的通过ajax轮训获取服务器信息的技术方案已经过时，我们迫切需要一个高效的节省资源的方式去获取服务器信息，一旦服务器资源有更新，能够及时地通知到客户端，从而实时地反馈到用户界面上。EventSource就是这样的技术，它本质上还是HTTP，通过response流实时推送服务器信息到客户端。</p>
<p>新建一个EventSource对象非常简单。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> es = <span class="keyword">new</span> EventSource(<span class="string">'/message'</span>);<span class="comment">// /message是服务端支持EventSource的接口</span></div></pre></td></tr></table></figure>
<p>新创建的EventSource对象拥有如下属性：</p>
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">url(只读)</td>
<td style="text-align:center">es对象请求的服务器url</td>
</tr>
<tr>
<td style="text-align:center">readyState(只读)</td>
<td style="text-align:center">es对象的状态，初始为0，包含CONNECTING (0)，OPEN (1)，CLOSED (2)三种状态</td>
</tr>
<tr>
<td style="text-align:center">withCredentials</td>
<td style="text-align:center">是否允许带凭证等，默认为false，即不支持发送cookie</td>
</tr>
</tbody>
</table>
<p>服务端实现<code>/message</code>接口，需要返回类型为 <code>text/event-stream</code>的响应头。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req，res</span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span>(req.url === <span class="string">'/message'</span>)&#123;</div><div class="line">    res.writeHead(<span class="number">200</span>，&#123;</div><div class="line">      <span class="string">'Content-Type'</span>: <span class="string">'text/event-stream'</span>,</div><div class="line">      <span class="string">'Cache-Control'</span>: <span class="string">'no-cache'</span>,</div><div class="line">      <span class="string">'Connection'</span>: <span class="string">'keep-alive'</span></div><div class="line">    &#125;);</div><div class="line">    setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      res.write(<span class="string">'data: '</span> + +<span class="keyword">new</span> <span class="built_in">Date</span>() + <span class="string">'\n\n'</span>);</div><div class="line">    &#125;, <span class="number">1000</span>);</div><div class="line">  &#125;</div><div class="line">&#125;).listen(<span class="number">8888</span>);</div></pre></td></tr></table></figure>
<p>我们注意到，为了避免缓存，Cache-Control 特别设置成了 no-cache，为了能够发送多个response， Connection被设置成了keep-alive.。发送数据时，请务必保证服务器推送的数据以 <code>data:</code>开始，以<code>\n\n</code>结束，否则推送将会失败(原因就不说了，这是约定的)。</p>
<p>以上，服务器每隔1s主动向客户端发送当前时间戳，为了接受这个信息，客户端需要监听服务器。如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">es.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(e.data); <span class="comment">// 打印服务器推送的信息</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如下是消息推送的过程：</p>
<p><img src="http://louiszhai.github.io/docImages/hot-replace01.gif" alt="response size不断增加"></p>
<p><img src="http://louiszhai.github.io/docImages/hot-replace02.gif" alt="接收消息"></p>
<p>你以为es只能监听message事件吗？并不是，message只是缺省的事件类型。实际上，它可以监听任何指定类型的事件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">es.addEventListener(<span class="string">"####"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;<span class="comment">// 事件类型可以随你定义</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'####:'</span>, e.data);</div><div class="line">&#125;，<span class="literal">false</span>);</div></pre></td></tr></table></figure>
<p>服务器发送不同类型的事件时，需要指定event字段。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">res.write(<span class="string">'event: ####\n'</span>);</div><div class="line">res.write(<span class="string">'data: 这是一个自定义的####类型事件\n'</span>);</div><div class="line">res.write(<span class="string">'data: 多个data字段将被解析成一个字段\n\n'</span>);</div></pre></td></tr></table></figure>
<p>如下所示：</p>
<p><img src="http://louiszhai.github.io/docImages/hot-replace04.png" alt="####消息"></p>
<p>可以看到，服务端指定event事件名为”####”后，客户端触发了对应的事件回调，同时服务端设置的多个data字段，客户端使用换行符连接成了一个字符串。</p>
<p>不仅如此，事件流中还可以混合多种事件，请看我们是怎么收到消息的，如下：</p>
<p><img src="http://louiszhai.github.io/docImages/hot-replace03.gif" alt="混合消息"></p>
<p>除此之外，es对象还拥有另外3个方法: <code>onopen()</code>、<code>onerror()</code>、<code>close()</code>，请参考如下实现。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">es.onopen = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="comment">// 链接打开时的回调</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'当前状态readyState:'</span>, es.readyState);<span class="comment">// open时readyState===1</span></div><div class="line">&#125;</div><div class="line">es.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="comment">// 出错时的回调(网络问题,或者服务下线等都有可能导致出错)</span></div><div class="line">  <span class="built_in">console</span>.log(es.readyState);<span class="comment">// 出错时readyState===0</span></div><div class="line">  es.close();<span class="comment">// 出错时，chrome浏览器会每隔3秒向服务器重发原请求,直到成功. 因此出错时，可主动断开原连接.</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用EventSource技术实时更新网页信息十分高效。实际使用中，我们几乎不用担心兼容性问题，主流浏览器都了支持EventSource，当然，除了掉队的IE系。对于不支持的浏览器，其PolyFill方案请参考<a href="https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-Browser-Polyfills#eventsource" target="_blank" rel="external">HTML5 Cross Browser Polyfills</a>。</p>
<h4 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a><strong>CORS</strong></h4><p>另外，如果需要支持跨域调用，请设置响应头<code>Access-Control-Allow-Origin&#39;: &#39;*&#39;</code>。</p>
<p>如需支持发送cookie，请设置响应头<code>Access-Control-Allow-Origin&#39;: req.headers.origin</code> 和 <code>Access-Control-Allow-Credentials:true</code>，并且创建es对象时，需要明确指定是否发送凭证。如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> es = <span class="keyword">new</span> EventSource(<span class="string">'/message'</span>, &#123;</div><div class="line">  <span class="attr">withCredentials</span>: <span class="literal">true</span></div><div class="line">&#125;); <span class="comment">// 创建时指定配置才是有效的</span></div><div class="line">es.withCredentials = <span class="literal">true</span>; <span class="comment">// 与ajax不同，这样设置是无效的</span></div></pre></td></tr></table></figure>
<p>以下是主流浏览器对EventSource的CORS的支持：</p>
<table>
<thead>
<tr>
<th style="text-align:center">Firefox</th>
<th style="text-align:center">Opera</th>
<th style="text-align:center">Chrome</th>
<th style="text-align:center">Safari</th>
<th style="text-align:center">iOS</th>
<th style="text-align:center">Android</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">10+</td>
<td style="text-align:center">12+</td>
<td style="text-align:center">26+</td>
<td style="text-align:center">7.0+</td>
<td style="text-align:center">7.0+</td>
<td style="text-align:center">4.4+</td>
</tr>
</tbody>
</table>
<h4 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置"></a><strong>nginx配置</strong></h4><p>既然说到了EventSource，便有必要谈谈遇到的坑，接下来，就说说我遇到的webpack热更新延迟问题。</p>
<p>如我们所知，webpack借助webpack-hot-middleware插件，实现了网页热更新机制，正常情况下，浏览器打开 <a href="http://localhost:8080" target="_blank" rel="external">http://localhost:8080</a> 这样的网页即可开始调试。然而实际开发中，由于远程服务器需要种cookie登录态到特定的域名上等原因，因此本地往往会用nginx做一层反向代理。即把 <a href="http://www.test.com" target="_blank" rel="external">http://www.test.com</a> 的请求转发到 <a href="http://localhost:8080" target="_blank" rel="external">http://localhost:8080</a> 上(配置过程这里不详述，具体请参考<a href="http://louiszhai.github.io/2016/11/02/ajax/ajax调试技巧">Ajax知识体系大梳理-ajax调试技巧</a>)。转发过后，发现热更新便延迟了。</p>
<p>原因是nginx默认开启的buffer机制缓存了服务器推送的片段信息，缓存达到一定的量才会返回响应内容。只要关闭proxy_buffering即可。配置如下所示：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="section">server</span> &#123;</div><div class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</div><div class="line">    <span class="attribute">server_name</span>  www.test.company.com;</div><div class="line">    <span class="attribute">location</span> / &#123;</div><div class="line">        <span class="attribute">proxy_pass</span> http://localhost:8080;</div><div class="line">        <span class="attribute">proxy_buffering</span> <span class="literal">off</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至此，EventSource部分便告一段落。学习讲究由浅入深，循序渐进。后面我将重点讲解的<code>browser-sync</code>热更新机制，请耐心细读。</p>
<h3 id="browser-sync"><a href="#browser-sync" class="headerlink" title="browser-sync"></a><strong>browser-sync</strong></h3><p>开发中使用<code>browser-sync</code>插件调试，一个网页里的所有交互动作（包括滚动，输入，点击等等），可以实时地同步到其他所有打开该网页的设备，能够节省大量的手工操作时间，从而带来流畅的开发调试体验。目前<code>browser-sync</code>可以结合<code>Gulp</code>或<code>Grunt</code>一起使用，其API请参考：<a href="http://www.browsersync.cn/docs/api/" target="_blank" rel="external">Browsersync API</a>。</p>
<p>通过上面的了解，我们知道<code>EventSouce</code>的使用是比较便捷的，那为什么<code>browser-sync</code>不使用EventSource技术进行代码推送呢？这是因为<code>browser-sync</code>插件共做了两件事：</p>
<ul>
<li>开发更新了一段新的逻辑，服务器实时推送代码改动信息。数据流：服务器 —&gt; 浏览器，使用EventSource技术同样能够实现。</li>
<li>用户操作网页，滚动、输入或点击等，操作信息实时发送给服务器，然后再由服务器将操作同步给其他已打开的网页。数据流：浏览器 —&gt; 服务器 —&gt; 浏览器，该部分功能EventSource技术已无能为力。</li>
</ul>
<p>以上，<code>browser-sync</code>使用WebSocket技术达到实时推送代码改动和用户操作两个目的。至于它是如何计算推送内容，根据不同推送内容采取何种响应策略，不在本次讨论范围之内。下面我们将讲解其核心的WebSocket技术。</p>
<h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a><strong>WebSocket</strong></h3><p>WebSocket是基于TCP的全双工通讯的协议，它与EventSource有着本质上的不同.(前者基于TCP，后者依然基于HTTP) 该协议于2011年被IETF定为标准RFC6455，后被RFC7936补充. WebSocket api也被W3C定为标准。</p>
<p>WebSocket使用和HTTP相同的TCP端口，默认为80， 统一资源标志符为ws，运行在TLS之上时，默认使用443，统一资源标志符为wss。它通过<code>101 switch protocol</code>进行一次TCP握手，即从HTTP协议切换成WebSocket通信协议。</p>
<p>相对于HTTP协议，WebSocket拥有如下优点：</p>
<ul>
<li>全双工，实时性更强。</li>
<li>相对于http携带完整的头部，WebSocket请求头部明显减少。</li>
<li>保持连接状态，不用再验权了。</li>
<li>二进制支持更强，Websocket定义了二进制帧，处理更轻松。</li>
<li>Websocket协议支持扩展，可以自定义的子协议，如 <code>permessage-deflate</code> 扩展。</li>
</ul>
<h4 id="支持性"><a href="#支持性" class="headerlink" title="支持性"></a><strong>支持性</strong></h4><p>优秀技术的落地，调研兼容性是必不可少的环节。所幸的是，现代浏览器对WebSocket的支持比较友好，如下是PC端兼容性：</p>
<table>
<thead>
<tr>
<th style="text-align:center">IE/Edge</th>
<th style="text-align:center">Firefox</th>
<th style="text-align:center">Chrome</th>
<th style="text-align:center">Safari</th>
<th style="text-align:center">Opera</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">10+</td>
<td style="text-align:center">11+</td>
<td style="text-align:center">16+</td>
<td style="text-align:center">7+</td>
<td style="text-align:center">12.1+</td>
</tr>
</tbody>
</table>
<p>如下是mobile端兼容性：</p>
<table>
<thead>
<tr>
<th style="text-align:center">iOS Safari</th>
<th style="text-align:center">Android</th>
<th style="text-align:center">Android Chrome</th>
<th style="text-align:center">Android UC</th>
<th style="text-align:center">QQ Browser</th>
<th style="text-align:center">Opera Mini</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">7.1+</td>
<td style="text-align:center">4.4+</td>
<td style="text-align:center">57+</td>
<td style="text-align:center">11.4+</td>
<td style="text-align:center">1.2+</td>
<td style="text-align:center">-</td>
</tr>
</tbody>
</table>
<h4 id="Frame"><a href="#Frame" class="headerlink" title="Frame"></a><strong>Frame</strong></h4><p>根据RFC6455文档，WebSocket协议基于Frame而非Stream（EventSource是基于Stream的）。因此其传输的数据都是Frame（帧）。想要了解数据的往返，弄懂协议处理过程，Frame的解读是必不可少。如下便是Frame的结构：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"> 0                   1                   2                   3</div><div class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</div><div class="line">+-+-+-+-+-------+-+-------------+-------------------------------+</div><div class="line">|<span class="string">F</span>|<span class="string">R</span>|<span class="string">R</span>|<span class="string">R</span>|<span class="string"> opcode</span>|<span class="string">M</span>|<span class="string"> Payload len </span>|<span class="string">    Extended payload length    </span>|</div><div class="line">|<span class="string">I</span>|<span class="string">S</span>|<span class="string">S</span>|<span class="string">S</span>|<span class="string">  (4)  </span>|<span class="string">A</span>|<span class="string">     (7)     </span>|<span class="string">             (16/64)           </span>|</div><div class="line">|<span class="string">N</span>|<span class="string">V</span>|<span class="string">V</span>|<span class="string">V</span>|<span class="string">       </span>|<span class="string">S</span>|<span class="string">             </span>|<span class="string">   (if payload len==126/127)   </span>|</div><div class="line">|<span class="string"> </span>|<span class="string">1</span>|<span class="string">2</span>|<span class="string">3</span>|<span class="string">       </span>|<span class="string">K</span>|<span class="string">             </span>|<span class="string">                               </span>|</div><div class="line">+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +</div><div class="line">|<span class="string">     Extended payload length continued，if payload len == 127  </span>|</div><div class="line">+ - - - - - - - - - - - - - - - +-------------------------------+</div><div class="line">|<span class="string">                               </span>|<span class="string">Masking-key，if MASK set to 1  </span>|</div><div class="line">+-------------------------------+-------------------------------+</div><div class="line">|<span class="string"> Masking-key (continued)       </span>|<span class="string">          Payload Data         </span>|</div><div class="line">+-------------------------------- - - - - - - - - - - - - - - - +</div><div class="line">:                     Payload Data continued ...                :</div><div class="line">+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +</div><div class="line">|<span class="string">                     Payload Data continued ...                </span>|</div><div class="line">+---------------------------------------------------------------+</div></pre></td></tr></table></figure>
<p>第一个字节包含FIN、RSV、Opcode。</p>
<ul>
<li><p>FIN：size为1bit，标示是否最后一帧。<code>%x0</code>表示还有后续帧，<code>%x1</code>表示这是最后一帧。</p>
</li>
<li><p>RSV1、2、3，每个size都是1bit，默认值都是0，如果没有定义非零值的含义，却出现了非零值，则WebSocket链接将失败。</p>
</li>
<li><p>Opcode，size为4bits，表示『payload data』的类型。如果收到未知的opcode，连接将会断开。已定义的opcode值如下：</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">%<span class="selector-tag">x0</span></span>:	代表连续的帧</div><div class="line"><span class="tag">%<span class="selector-tag">x1</span></span>:	文本帧</div><div class="line"><span class="tag">%<span class="selector-tag">x2</span></span>:	二进制帧</div><div class="line"><span class="tag">%<span class="selector-tag">x3</span></span>~7:	预留的非控制帧</div><div class="line"><span class="tag">%<span class="selector-tag">x8</span></span>:	关闭握手帧</div><div class="line"><span class="tag">%<span class="selector-tag">x9</span></span>:	ping帧，后续心跳连接会讲到</div><div class="line"><span class="tag">%<span class="selector-tag">xA</span></span>:	pong帧，后续心跳连接会讲到</div><div class="line"><span class="tag">%<span class="selector-tag">xB</span></span>~F:	预留的非控制帧</div></pre></td></tr></table></figure>
</li>
</ul>
<p>第二个字节包含Mask、Payload len。</p>
<ul>
<li><p>Mask：size为1bit，标示『payload data』是否添加掩码。所有从客户端发送到服务端的帧都会被置为1，如果置1，<code>Masking-key</code>便会赋值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//若server是一个WebSocket服务端实例</span></div><div class="line"><span class="comment">//监听客户端消息</span></div><div class="line">server.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">msg, flags</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'client say: %s'</span>, msg);</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'mask value:'</span>, flags.masked);<span class="comment">// true，进一步佐证了客户端发送到服务端的Mask帧都会被置为1</span></div><div class="line">&#125;);</div><div class="line"><span class="comment">//监听客户端pong帧响应</span></div><div class="line">server.on(<span class="string">'pong'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">msg, flags</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'pong data: %s'</span>, msg);</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'mask value:'</span>, flags.masked);<span class="comment">// true，进一步佐证了客户端发送到服务端的Mask帧都会被置为1</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>Payload len：size为7bits，即使是当做无符号整型也只能表示0~127的值，所以它不能表示更大的值，因此规定”Payload data”长度小于或等于125的时候才用来描述数据长度。如果<code>Payload len==126</code>，则使用随后的2bytes（16bits）来存储数据长度。如果<code>Payload len==127</code>，则使用随后的8bytes（64bits）来存储数据长度。</p>
</li>
</ul>
<p>以上，扩展的Payload len可能占据第三至第四个或第三至第十个字节。紧随其后的是”Mask-key”。</p>
<ul>
<li>Mask-key：size为0或4bytes（32bits），默认为0，与前面Mask呼应，从客户端发送到服务端的帧都包含4bytes（32bits）的掩码，一旦掩码被设置，所有接收到的”payload data”都必须与该值以一种算法做异或运算来获取真实值。</li>
<li>Payload data：size为”Extension data” 和 “Application data” 的总和，一般”Extension data”数据为空。</li>
<li>Extension data：默认为0，如果扩展被定义，扩展必须指定”Extension data”的长度。</li>
<li>Application data：占据”Extension data”之后剩余帧的空间。</li>
</ul>
<p>关于Frame的更多理论介绍不妨读读 <a href="https://github.com/abbshr/abbshr.github.io/issues/22" target="_blank" rel="external">学习WebSocket协议—从顶层到底层的实现原理（修订版）</a>。</p>
<p>关于Frame的数据帧解析不妨读读 <a href="https://www.web-tinker.com/article/20306.html" target="_blank" rel="external">WebSocket(贰) 解析数据帧</a> 及其后续文章。</p>
<h4 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a><strong>建立连接</strong></h4><p>了解了Frame的数据结构后，我们来实际练习下。浏览器上，新建一个ws对象十分简单。如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">'ws://127.0.0.1:10103/'</span>);<span class="comment">// 本地使用10103端口进行测试</span></div></pre></td></tr></table></figure>
<p>新建的WebSocket对象如下所示：</p>
<p><img src="http://louiszhai.github.io/docImages/hot-replace09.png" alt="Websocket对象"></p>
<p>这中间包含了一次Websocket握手的过程，我们分两步来理解。</p>
<p>第一步，客户端请求。</p>
<p><img src="http://louiszhai.github.io/docImages/hot-replace05.png" alt="Websocket Request"></p>
<p>这是一个GET请求，主要字段如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Connection: Upgrade</div><div class="line">Upgrade: websocket</div><div class="line">Sec-WebSocket-Key:61x6lFN92sJHgzXzCHfBJQ==</div><div class="line">Sec-WebSocket-Version:13</div></pre></td></tr></table></figure>
<p>Connection字段指定为Upgrade，表示客户端希望连接升级。</p>
<p>Upgrade字段设置为websocket，表示希望升级至Websocket协议。</p>
<p>Sec-WebSocket-Key字段是随机字符串，服务器根据它来构造一个SHA-1的信息摘要。</p>
<p>Sec-WebSocket-Version表示支持的Websocket版本。RFC6455要求使用的版本是13。</p>
<p>甚至我们可以从请求截图里看出，Origin是<code>file://</code>，而Host是<code>127.0.0.1:10103</code>，明显不是同一个域下，但依然可以请求成功，说明Websocket协议是不受同源策略限制的(同源策略限制的是http协议)。</p>
<p>第二步，服务端响应。</p>
<p><img src="http://louiszhai.github.io/docImages/hot-replace07.png" alt="Websocket Response"></p>
<p>Status Code: 101 Switching Protocols 表示Websocket协议通过101状态码进行握手。</p>
<p>Sec-WebSocket-Accept字段是由Sec-WebSocket-Key字段加上特定字符串”258EAFA5-E914-47DA-95CA-C5AB0DC85B11”，计算SHA-1摘要，然后再base64编码之后生成的. 该操作可避免普通http请求，被误认为Websocket协议。</p>
<p>Sec-WebSocket-Extensions字段表示服务端对Websocket协议的扩展。</p>
<p>以上，WebSocket构造器不止可以传入url，还能传入一个可选的协议名称字符串或数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ws = <span class="keyword">new</span> WebSocket(<span class="string">'ws://127.0.0.1:10103/'</span>, [<span class="string">'abc'</span>,<span class="string">'son_protocols'</span>]);</div></pre></td></tr></table></figure>
<h4 id="服务端实现"><a href="#服务端实现" class="headerlink" title="服务端实现"></a><strong>服务端实现</strong></h4><p>等等，我们慢一点，上面好像漏掉了一步，似乎没有提到服务端是怎么实现的。请继续往下看：</p>
<p>先做一些准备。ws是一个nodejs版的WebSocketServer实现。使用 <code>npm install ws</code> 即可安装。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> WebSocketServer = <span class="built_in">require</span>(<span class="string">'ws'</span>).Server，</div><div class="line">    server = <span class="keyword">new</span> WebSocketServer(&#123;<span class="attr">port</span>: <span class="number">10103</span>&#125;);</div><div class="line">server.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</div><div class="line">  s.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123; <span class="comment">//监听客户端消息</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'client say: %s'</span>, msg);</div><div class="line">  &#125;);</div><div class="line">  s.send(<span class="string">'server ready!'</span>);<span class="comment">// 连接建立好后，向客户端发送一条消息</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>以上，<code>new WebSocketServer()</code>创建服务器时如需权限验证，请指定<code>verifyClient</code>为验权的函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">server = <span class="keyword">new</span> WebSocketServer(&#123;</div><div class="line">  <span class="attr">port</span>: <span class="number">10103</span>,</div><div class="line">  <span class="attr">verifyClient</span>: verify</div><div class="line">&#125;);</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">verify</span>(<span class="params">info</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(info));<span class="comment">// [ 'origin', 'secure', 'req' ]</span></div><div class="line">  <span class="built_in">console</span>.log(info.orgin);<span class="comment">// "file://"</span></div><div class="line">  <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">// 返回true时表示验权通过，否则客户端将抛出"HTTP Authentication failed"错误</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上，<code>verifyClient</code>指定的函数只有一个形参，若为它显式指定两个形参，那么第一个参数同上info，第二个参数将是一个<code>cb</code>回调函数。该函数用于显式指定拒绝时的HTTP状态码等，它默认拥有3个形参，依次为：</p>
<ul>
<li>result，布尔值类型，表示是否通过权限验证。</li>
<li>code，数值类型，若result值为false时，表示HTTP的错误状态码。</li>
<li>name，字符串类型，若result值为false时，表示HTTP状态码的错误信息。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 若verify定义如下</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">verify</span>(<span class="params">info, cb</span>)</span>&#123;</div><div class="line">  <span class="comment">//一旦拥有第二个形参，如果不调用，默认将通过验权</span></div><div class="line">  cb(<span class="literal">false</span>, <span class="number">401</span>, <span class="string">'权限不够'</span>);<span class="comment">// 此时表示验权失败，HTTP状态码为401，错误信息为"权限不够"</span></div><div class="line">  <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">// 一旦拥有第二个形参，响应就被cb接管了，返回什么值都不会影响前面的处理结果</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除了<code>port</code> 和 <code>verifyClient</code>设置外，其它设置项及更多API，请参考文档 <a href="https://github.com/websockets/ws/blob/master/doc/ws.md" target="_blank" rel="external">ws-doc</a>。</p>
<h4 id="发送和监听消息"><a href="#发送和监听消息" class="headerlink" title="发送和监听消息"></a><strong>发送和监听消息</strong></h4><p>接下来，我们来实现消息收发。如下是客户端发送消息。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ws.onopen = function(e)&#123;</div><div class="line">  // 可发送字符串，ArrayBuffer 或者 Blob数据</div><div class="line">  ws.send('client ready!);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>客户端监听信息。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'server say:'</span>, e.data);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>如下是浏览器的运行截图。</p>
<p><img src="http://louiszhai.github.io/docImages/hot-replace06.png" alt="message"></p>
<p>消息的内容都在Frames栏，第一条彩色背景的信息是客户端发送的，第二条是服务端发送的。两条消息的长度都是13。</p>
<p>如下是Timing栏，不止是WebSocket，包括EventSource，都有这样的黄色高亮警告。</p>
<p><img src="http://louiszhai.github.io/docImages/hot-replace08.png" alt="Websocket Request"></p>
<p>该警告说明：请求还没完成。实际上，直到一方连接close掉，请求才会完成。</p>
<h4 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a><strong>关闭连接</strong></h4><p>说到close，ws的close方法比es的略复杂。</p>
<p>语法：<em>close(short code，string reason);</em></p>
<p>close默认可传入两个参数。code是数字，表示关闭连接的状态号，默认是1000，即正常关闭。（code取值范围从0到4999，其中有些是保留状态号，正常关闭时只能指定为1000或者3000~4999之间的值，具体请参考<a href="https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes" target="_blank" rel="external">CloseEvent - Web APIs</a>）。reason是UTF-8文本，表示关闭的原因（文本长度需小于或等于123字节）。</p>
<p>由于code 和 reason都有限制，因此该方法可能抛出异常，建议catch下.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">  ws.close(<span class="number">1001</span>, <span class="string">'CLOSE_GOING_AWAY'</span>);</div><div class="line">&#125;<span class="keyword">catch</span>(e)&#123;</div><div class="line">  <span class="built_in">console</span>.log(e);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ws对象还拥有onclose和onerror监听器，分别监听关闭和错误事件。（注：EventSource没有onclose监听）</p>
<h4 id="拥有的属性"><a href="#拥有的属性" class="headerlink" title="拥有的属性"></a><strong>拥有的属性</strong></h4><p>ws的readyState属性拥有4个值，比es的readyState的多一个CLOSING的状态。</p>
<table>
<thead>
<tr>
<th style="text-align:center">常量</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">EventSource(值)</th>
<th style="text-align:center">WebSocket(值)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">CONNECTING</td>
<td style="text-align:center">连接未初始化</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">OPEN</td>
<td style="text-align:center">连接已就绪</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">CLOSING</td>
<td style="text-align:center">连接正在关闭</td>
<td style="text-align:center">-</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">CLOSED</td>
<td style="text-align:center">连接已关闭</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
</tr>
</tbody>
</table>
<p>另外，除了两种都有的url属性外，WebSocket对象还拥有更多的属性。</p>
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">binaryType</td>
<td style="text-align:center">被传输二进制内容的类型，有blob，arraybuffer两种</td>
</tr>
<tr>
<td style="text-align:center">bufferedAmount</td>
<td style="text-align:center">待传输的数据的长度</td>
</tr>
<tr>
<td style="text-align:center">extensions</td>
<td style="text-align:center">表示服务器选用的扩展</td>
</tr>
<tr>
<td style="text-align:center">protocol</td>
<td style="text-align:center">指的是构造器第二个参数传入的子协议名称</td>
</tr>
</tbody>
</table>
<h4 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a><strong>文件上传</strong></h4><p>以前一直是使用ajax做文件上传，实际上，Websocket上传文件也是一把好刀. 其send方法可以发送String，ArrayBuffer，Blob共三种数据类型，发送二进制文件完全不在话下。</p>
<p>由于各个浏览器对Websocket单次发送的数据有限制，所以我们需要将待上传文件切成片段去发送。如下是实现。</p>
<p>1) html。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">id</span>=<span class="string">"file"</span>/&gt;</span></div></pre></td></tr></table></figure>
<p>2) js。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">'ws://127.0.0.1:10103/'</span>);<span class="comment">// 连接服务器</span></div><div class="line"><span class="keyword">const</span> fileSelect = <span class="built_in">document</span>.getElementById(<span class="string">'file'</span>);</div><div class="line"><span class="keyword">const</span> size = <span class="number">1024</span> * <span class="number">128</span>;<span class="comment">// 分段发送的文件大小(字节)</span></div><div class="line"><span class="keyword">let</span> curSize, total, file, fileReader;</div><div class="line"></div><div class="line">fileSelect.onchange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  file = <span class="keyword">this</span>.files[<span class="number">0</span>];<span class="comment">// 选中的待上传文件</span></div><div class="line">  curSize = <span class="number">0</span>;<span class="comment">// 当前已发送的文件大小</span></div><div class="line">  total = file.size;<span class="comment">// 文件大小</span></div><div class="line">  ws.send(file.name);<span class="comment">// 先发送待上传文件的名称</span></div><div class="line">  fileReader = <span class="keyword">new</span> FileReader();<span class="comment">// 准备读取文件</span></div><div class="line">  fileReader.onload = loadAndSend;</div><div class="line">  readFragment();<span class="comment">// 读取文件片段</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadAndSend</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span>(ws.bufferedAmount &gt; size * <span class="number">5</span>)&#123;<span class="comment">// 若发送队列中的数据太多,先等一等</span></div><div class="line">    setTimeout(loadAndSend，<span class="number">4</span>);</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  ws.send(fileReader.result);<span class="comment">// 发送本次读取的片段内容</span></div><div class="line">  curSize += size;<span class="comment">// 更新已发送文件大小</span></div><div class="line">  curSize &lt; total ? readFragment() : <span class="built_in">console</span>.log(<span class="string">'upload successed!'</span>);<span class="comment">// 下一步操作</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFragment</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">const</span> blob = file.slice(curSize, curSize + size);<span class="comment">// 获取文件指定片段</span></div><div class="line">  fileReader.readAsArrayBuffer(blob);<span class="comment">// 读取文件为ArrayBuffer对象</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>3) server(node)。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> WebSocketServer = <span class="built_in">require</span>(<span class="string">'ws'</span>).Server,</div><div class="line">    server = <span class="keyword">new</span> WebSocketServer(&#123;<span class="attr">port</span>: <span class="number">10103</span>&#125;),<span class="comment">// 启动服务器</span></div><div class="line">    fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line">server.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">wsServer</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> fileName, i = <span class="number">0</span>;<span class="comment">// 变量定义不可放在全局,因每个连接都不一样,这里才是私有作用域</span></div><div class="line">  server.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data, flags</span>)</span>&#123;<span class="comment">// 监听客户端消息</span></div><div class="line">    <span class="keyword">if</span>(flags.binary)&#123;<span class="comment">// 判断是否二进制数据</span></div><div class="line">      <span class="keyword">var</span> method = i++ ? <span class="string">'appendFileSync'</span> : <span class="string">'writeFileSync'</span>;</div><div class="line">      <span class="comment">// 当前目录下写入或者追加写入文件(建议加上try语句捕获可能的错误)</span></div><div class="line">      fs[method](<span class="string">'./'</span> + fileName, data，<span class="string">'utf-8'</span>);</div><div class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">// 非二进制数据则认为是文件名称</span></div><div class="line">      fileName = data;</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">  wsServer.send(<span class="string">'server ready!'</span>);<span class="comment">// 告知客户端服务器已就绪</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>运行效果如下：</p>
<p><img src="http://louiszhai.github.io/docImages/hot-replace10.png" alt="Websocket upload"></p>
<p>上述测试代码中没有过多涉及服务器的存储过程。通常，服务器也会有缓存区上限，如果客户端单次发送的数据量超过服务端缓存区上限，那么服务端也需要多次读取。</p>
<h4 id="心跳连接"><a href="#心跳连接" class="headerlink" title="心跳连接"></a><strong>心跳连接</strong></h4><p>生产环境下上传一个文件远比本地测试来得复杂。实际上，从客户端到服务端，中间存在着大量的网络链路，如路由器，防火墙等等。一份文件的上传要经过中间的层层路由转发，过滤。这些中间链路可能会认为一段时间没有数据发送，就自发切断两端的连接。这个时候，由于TCP并不定时检测连接是否中断，而通信的双方又相互没有数据发送，客户端和服务端依然会一厢情愿的信任之前的连接，长此以往，将使得大量的服务端资源被WebSocket连接占用。</p>
<p>正常情况下，TCP的四次挥手完全可以通知两端去释放连接。但是上述这种普遍存在的异常场景，将使得连接的释放成为梦幻。</p>
<p>为此，早在websocket协议实现时，设计者们便提供了一种 Ping/Pong Frame的心跳机制。一端发送Ping Frame，另一端以 Pong Frame响应。这种Frame是一种特殊的数据包，它只包含一些元数据，能够在不影响原通信的情况下维持住连接。</p>
<p>根据规范<a href="https://tools.ietf.org/html/rfc6455#section-5.5.2" target="_blank" rel="external">RFC 6455</a>，Ping Frame包含一个值为9的opcode，它可能携带数据。收到Ping Frame后，Pong Frame必须被作为响应发出。Pong Frame包含一个值为10的opcode，它将包含与Ping Frame中相同的数据。</p>
<p>借助ws包，服务端可以这么来发送Ping Frame。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wsServer.ping();</div></pre></td></tr></table></figure>
<p>同时，需要监听客户端响应的pong Frame.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">wsServer.on(<span class="string">'pong'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data, flags</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(data);<span class="comment">// ""</span></div><div class="line">  <span class="built_in">console</span>.log(flags);<span class="comment">// &#123; masked: true，binary: true &#125;</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>以上，由于Ping Frame 不带数据，因此作为响应的Pong Frame的data值为空串。遗憾的是，目前浏览器只能被动发送Pong Frame作为响应（<a href="http://stackoverflow.com/questions/10585355/sending-websocket-ping-pong-frame-from-browser" target="_blank" rel="external">Sending websocket ping/pong frame from browser</a>），无法通过JS API主动向服务端发送Ping Frame。因此对于web服务，可以采取服务端主动ping的方式，来保持住链接。实际应用中，服务端还需要设置心跳的周期，以保证心跳连接可以一直持续。同时，还应该有重发机制，若连续几次没有收到心跳连接的回复，则认为连接已经断开，此时便可以关闭Websocket连接了。</p>
<h4 id="Socket-IO"><a href="#Socket-IO" class="headerlink" title="Socket.IO"></a><strong>Socket.IO</strong></h4><p>WebSocket出世已久，很多优秀的大神基于此开发出了各式各样的库。其中<a href="http://Socket.IO" target="_blank" rel="external">Socket.IO</a>是一个非常不错的开源WebSocke库，旨在抹平浏览器之间的兼容性问题。它基于Node.js，支持以下方式优雅降级：</p>
<ul>
<li>Websocket</li>
<li>Adobe® Flash® Socket</li>
<li>AJAX long polling</li>
<li>AJAX multipart streaming</li>
<li>Forever Iframe</li>
<li>JSONP Polling</li>
</ul>
<p>如何在项目中使用Socket.IO，请参考<a href="https://github.com/nswbmw/N-chat/wiki/%E7%AC%AC%E4%B8%80%E7%AB%A0-socket.io-%E7%AE%80%E4%BB%8B%E5%8F%8A%E4%BD%BF%E7%94%A8" target="_blank" rel="external">第一章 socket.io 简介及使用</a>。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h3><p>EventSource，本质依然是HTTP，它仅提供服务端到客户端的单向文本数据传输，不需要心跳连接，连接断开会持续触发重连。</p>
<p>WebSocket协议，基于TCP协议，它提供双向数据传输，支持二进制，需要心跳连接，连接断开不会重连。</p>
<p>EventSource更轻量和简单，WebSocket支持性更好（因其支持IE10+）。通常来说，使用EventSource能够完成的功能，使用WebSocket一样能够做到，反之却不行，使用时若遇到连接断开或抛错，请及时调用各自的<code>close</code>方法主动释放资源。</p>
<hr>
<p>本问就讨论这么多内容,大家有什么问题或好的想法欢迎在下方参与<a href="#respond">留言和评论</a>。</p>
<p>本文作者： <a href="https://github.com/Louiszhai" target="_blank" rel="external">louis</a></p>
<p>本文链接： <a href="http://louiszhai.github.io/2017/04/19/hmr/">http://louiszhai.github.io/2017/04/19/hmr/</a></p>
<p>参考文章</p>
<ul>
<li><a href="https://tools.ietf.org/html/rfc6455#section-5.5.2" target="_blank" rel="external">RFC 6455 - The WebSocket Protocol</a></li>
<li><a href="https://cnodejs.org/topic/5463840472f405c829029f62" target="_blank" rel="external">用node.js实现HTML5原生的comet(长连接) </a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Server-sent_events/Using_server-sent_events" target="_blank" rel="external">使用服务器发送事件 - Server-sent events</a></li>
<li><a href="http://www.cnblogs.com/tianma3798/p/5852475.html" target="_blank" rel="external">HTML5 文件域+FileReader 分段读取文件并上传(七)-WebSocket</a></li>
<li><a href="http://www.cnblogs.com/axes/p/4514199.html?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">nodejs实现Websocket的数据接收发送</a></li>
</ul>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2017/04/07/http-cache/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">浏览器缓存机制剖析</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">Share to: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
    <a class="jiathis_button_twitter"></a>
    <a class="jiathis_button_plus"></a> 
    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>






<div class="duoshuo">
	<div class="ds-thread" data-thread-key="hmr" data-title="webpack与browser-sync热更新原理深度讲解" data-url="http://louiszhai.github.io/2017/04/19/hmr/"></div>
	<style>
		#ds-reset .ds-avatar img{width:54px;height:54px;border-radius:27px;-webkit-border-radius:27px;-moz-border-radius:27px;box-shadow:inset 0 -1px 0 #3333sf;-webkit-box-shadow:inset 0 -1px 0 #3333sf;-webkit-transition:0.4s;-webkit-transition:-webkit-transform 0.4s ease-out;transition:transform 0.4s ease-out;-moz-transition:-moz-transform 0.4s ease-out;}
		#ds-reset .ds-avatar img:hover{box-shadow:0 0 10px #fff;rgba(255,255,255,.6),inset 0 0 20px rgba(255,255,255,1);-webkit-box-shadow:0 0 10px #fff;rgba(255,255,255,.6),inset 0 0 20px rgba(255,255,255,1);transform:rotateZ(360deg);-webkit-transform:rotateZ(360deg);-moz-transform:rotateZ(360deg);}
		p.ds-powered-by,#ds-sync-checkbox,.ds-sync label{display:none!important;}
		#ds-reset .ds-rounded-top{-webkit-border-top-right-radius:0px;-webkit-border-top-left-radius:0px;border-top-right-radius:0px;border-top-left-radius:0px;}
		#ds-thread #ds-reset .ds-textarea-wrapper{background:#fff;border:0;margin-bottom:20px;padding-right:0px;}
		#ds-thread #ds-reset .ds-textarea-wrapper textarea{min-height:80px;border:1px solid #ccc;padding:10px;-webkit-appearance:none;border-radius:0;background-color:#FFFFFF;border-color:#cccccc;box-shadow:inset 0 1px 2px rgba(0,0,0,0.1);color:rgba(0,0,0,0.75);-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-transition:border-color 0.15s linear,background 0.15s linear;-moz-transition:border-color 0.15s linear,background 0.15s linear;-ms-transition:border-color 0.15s linear,background 0.15s linear;-o-transition:border-color 0.15s linear,background 0.15s linear;transition:border-color 0.15s linear,background 0.15s linear;}
		/*#ds-thread #ds-reset .ds-textarea-wrapper textarea:focus{border-color:#999999;background:#fafafa;outline:none;}*/
		#ds-thread #ds-reset .ds-post-options{border-bottom-left-radius:0px;-webkit-border-bottom-left-radius:0px;border:none;background:none!important;}
		#ds-reset .ds-textarea-wrapper textarea:focus{border-color:#66afe9;outline:0;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 8px rgba(102,175,233,.6);box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 8px rgba(102,175,233,.6);}
		#ds-thread #ds-reset .ds-post-button:hover,#ds-thread #ds-reset .ds-post-button:focus{
		    background-color: #51a351;
		    background-position: 0 -32px;
		    color:white;
		}
		#ds-thread #ds-reset .ds-post-toolbar,#ds-reset .ds-avatar{box-shadow:none;}
		#ds-thread #ds-reset .ds-textarea-wrapper textarea:focus{
	    	/*background: none repeat scroll 0 0 #F4FAFF;*/
	    	border-color:#9DD4FD;
	    	border-width:1px;
	    	box-shadow:0 1px 1px rgba(0,0,0,0.075) inset, 0 0 8px rgba(82, 168, 236, 0.6);
	    	outline:0 none;
    	}
		#ds-thread #ds-reset .ds-textarea-wrapper textarea:active{
	    	/*background: none repeat scroll 0 0 #F4FAFF;*/
	    	border-width:1px;
	    	border-color:#9DD4FD;
	    	box-shadow:0 1px 1px rgba(0,0,0,0.075) inset, 0 0 8px rgba(82, 168, 236, 0.6);
	    	outline:0 none;
    	}
    	#ds-thread #ds-reset .ds-post-button{
    		box-shadow: 0 1px 0 rgba(255, 255, 255, 0.2) inset, 0 1px 2px rgba(0, 0, 0, 0.05);
		    border-color: rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.25);
		    border-width: 1px;
		    border-style: solid;
		    border-radius: 3px;
		    background: #5bb75b;
		    color:white;
		    text-shadow:none;
		    transition:background-color 300ms ease-out;
    	}
    	#ds-reset .ds-avatar{
    		background-color:initial;
    	}

	</style>
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"true"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
</div>



</div>
        <link rel="stylesheet" href="/css/content.css" type="text/css">
<footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <img src="/img/top_arrow.png" class="top_arrow" id="top_arrow">
    	<div class="footer-left">
    		&copy; 2017 路易斯

        <span style="position:relative;top:2px" id="cnzz_stat_icon_1256923583"></span>
        <script type="text/javascript">
          var s = document.createElement('script');
          var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");
          s.src = cnzz_protocol + "s11.cnzz.com/z_stat.php?id=1256923583&show=pic";
          document.body.appendChild(s);
        </script>

    	</div>
      	<div class="footer-right">
      		<a href="https://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
<script type="text/javascript">
  //swifty
  /*(function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');
  
  _st('install','4AmBuvmx4Cy-3hvyxeh8','2.0.0');*/
</script>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: false,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="/js/jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/content.js"></script>







</div>
<script src="/js/screenfull.js"></script>
<a href="https://github.com/Louiszhai" style="position: fixed; top: 0; right: 0; border: 0;z-index:9999"><img
            source="https://camo.githubusercontent.com/a6677b08c955af8400f44c6298f40e7d19cc5b2d/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f677261795f3664366436642e706e67"
            src="/img/fork_me_on_github.png" alt="Fork me on GitHub"
            data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_gray_6d6d6d.png"></a>
</body>
</html>